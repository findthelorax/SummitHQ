
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Area
 * 
 */
export type Area = $Result.DefaultSelection<Prisma.$AreaPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Hours
 * 
 */
export type Hours = $Result.DefaultSelection<Prisma.$HoursPayload>
/**
 * Model Mountain
 * 
 */
export type Mountain = $Result.DefaultSelection<Prisma.$MountainPayload>
/**
 * Model Weather
 * 
 */
export type Weather = $Result.DefaultSelection<Prisma.$WeatherPayload>
/**
 * Model EmployeeMountainAssignment
 * 
 */
export type EmployeeMountainAssignment = $Result.DefaultSelection<Prisma.$EmployeeMountainAssignmentPayload>
/**
 * Model DispatcherAssignment
 * 
 */
export type DispatcherAssignment = $Result.DefaultSelection<Prisma.$DispatcherAssignmentPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model EmployeeRole
 * 
 */
export type EmployeeRole = $Result.DefaultSelection<Prisma.$EmployeeRolePayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Lift
 * 
 */
export type Lift = $Result.DefaultSelection<Prisma.$LiftPayload>
/**
 * Model Trail
 * 
 */
export type Trail = $Result.DefaultSelection<Prisma.$TrailPayload>
/**
 * Model Lodge
 * 
 */
export type Lodge = $Result.DefaultSelection<Prisma.$LodgePayload>
/**
 * Model Hut
 * 
 */
export type Hut = $Result.DefaultSelection<Prisma.$HutPayload>
/**
 * Model AidRoom
 * 
 */
export type AidRoom = $Result.DefaultSelection<Prisma.$AidRoomPayload>
/**
 * Model EquipmentServiceLog
 * 
 */
export type EquipmentServiceLog = $Result.DefaultSelection<Prisma.$EquipmentServiceLogPayload>
/**
 * Model Equipment
 * 
 */
export type Equipment = $Result.DefaultSelection<Prisma.$EquipmentPayload>
/**
 * Model Incident
 * 
 */
export type Incident = $Result.DefaultSelection<Prisma.$IncidentPayload>
/**
 * Model IncidentEquipmentUsageLog
 * 
 */
export type IncidentEquipmentUsageLog = $Result.DefaultSelection<Prisma.$IncidentEquipmentUsageLogPayload>
/**
 * Model LiftCheck
 * 
 */
export type LiftCheck = $Result.DefaultSelection<Prisma.$LiftCheckPayload>
/**
 * Model TrailCheck
 * 
 */
export type TrailCheck = $Result.DefaultSelection<Prisma.$TrailCheckPayload>
/**
 * Model HutCheck
 * 
 */
export type HutCheck = $Result.DefaultSelection<Prisma.$HutCheckPayload>
/**
 * Model AidRoomCheck
 * 
 */
export type AidRoomCheck = $Result.DefaultSelection<Prisma.$AidRoomCheckPayload>
/**
 * Model EquipmentCheck
 * 
 */
export type EquipmentCheck = $Result.DefaultSelection<Prisma.$EquipmentCheckPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const LOCATION_TYPE: {
  AIDROOM: 'AIDROOM',
  HUT: 'HUT',
  LODGE: 'LODGE',
  LIFT: 'LIFT',
  TRAIL: 'TRAIL',
  MOUNTAIN: 'MOUNTAIN',
  OTHER: 'OTHER'
};

export type LOCATION_TYPE = (typeof LOCATION_TYPE)[keyof typeof LOCATION_TYPE]


export const STATUS: {
  OPEN: 'OPEN',
  CLOSED: 'CLOSED',
  ON_HOLD: 'ON_HOLD',
  UNKNOWN: 'UNKNOWN'
};

export type STATUS = (typeof STATUS)[keyof typeof STATUS]


export const INCIDENT_STATUS: {
  STANDBY: 'STANDBY',
  REPORTED: 'REPORTED',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  UNKNOWN: 'UNKNOWN'
};

export type INCIDENT_STATUS = (typeof INCIDENT_STATUS)[keyof typeof INCIDENT_STATUS]


export const EQUIPMENT_STATUS: {
  OPERATIONAL: 'OPERATIONAL',
  IN_SERVICE: 'IN_SERVICE',
  OUT_OF_SERVICE: 'OUT_OF_SERVICE',
  IN_USE: 'IN_USE',
  CLEANING: 'CLEANING',
  NEEDS_INSPECTION: 'NEEDS_INSPECTION',
  PENDING_REPAIR: 'PENDING_REPAIR',
  UNDER_MAINTENANCE: 'UNDER_MAINTENANCE',
  LOST: 'LOST',
  DAMAGED: 'DAMAGED',
  RETIRED: 'RETIRED',
  STANDBY: 'STANDBY'
};

export type EQUIPMENT_STATUS = (typeof EQUIPMENT_STATUS)[keyof typeof EQUIPMENT_STATUS]


export const LIFT_TYPE: {
  CHAIR: 'CHAIR',
  GONDOLA: 'GONDOLA',
  T_BAR: 'T_BAR',
  MAGIC_CARPET: 'MAGIC_CARPET',
  ROPE_TOW: 'ROPE_TOW',
  OTHER: 'OTHER'
};

export type LIFT_TYPE = (typeof LIFT_TYPE)[keyof typeof LIFT_TYPE]


export const TRAIL_CONDITION: {
  MACHINE_GROOMED: 'MACHINE_GROOMED',
  HARD_PACK: 'HARD_PACK',
  PACKED_POWDER: 'PACKED_POWDER',
  POWDER: 'POWDER',
  MOGULS: 'MOGULS',
  NATURAL: 'NATURAL',
  GLADES: 'GLADES',
  CLOSED: 'CLOSED'
};

export type TRAIL_CONDITION = (typeof TRAIL_CONDITION)[keyof typeof TRAIL_CONDITION]


export const TRAIL_DIFFICULTY: {
  GREEN_CIRCLE: 'GREEN_CIRCLE',
  BLUE_SQUARE: 'BLUE_SQUARE',
  BLACK_DIAMOND: 'BLACK_DIAMOND',
  DOUBLE_BLACK_DIAMOND: 'DOUBLE_BLACK_DIAMOND',
  TERRAIN_PARK: 'TERRAIN_PARK',
  RACE_COURSE: 'RACE_COURSE',
  OTHER: 'OTHER'
};

export type TRAIL_DIFFICULTY = (typeof TRAIL_DIFFICULTY)[keyof typeof TRAIL_DIFFICULTY]


export const DEPARTMENT: {
  PATROL: 'PATROL',
  LIFT_OPERATIONS: 'LIFT_OPERATIONS',
  DISPATCH: 'DISPATCH',
  MAINTENANCE: 'MAINTENANCE',
  ADMINISTRATION: 'ADMINISTRATION',
  OTHER: 'OTHER'
};

export type DEPARTMENT = (typeof DEPARTMENT)[keyof typeof DEPARTMENT]


export const AREA_TYPE: {
  BASE_AREA: 'BASE_AREA',
  MOUNTAIN_AREA: 'MOUNTAIN_AREA',
  SUMMIT: 'SUMMIT',
  OTHER: 'OTHER'
};

export type AREA_TYPE = (typeof AREA_TYPE)[keyof typeof AREA_TYPE]


export const EMPLOYEE_ROLES: {
  SUPERVISOR: 'SUPERVISOR',
  ADVANCED_PATROLLER: 'ADVANCED_PATROLLER',
  HILL_CHIEF: 'HILL_CHIEF',
  SPECIALIST: 'SPECIALIST',
  TRAINER: 'TRAINER',
  DIRECTOR: 'DIRECTOR'
};

export type EMPLOYEE_ROLES = (typeof EMPLOYEE_ROLES)[keyof typeof EMPLOYEE_ROLES]

}

export type LOCATION_TYPE = $Enums.LOCATION_TYPE

export const LOCATION_TYPE: typeof $Enums.LOCATION_TYPE

export type STATUS = $Enums.STATUS

export const STATUS: typeof $Enums.STATUS

export type INCIDENT_STATUS = $Enums.INCIDENT_STATUS

export const INCIDENT_STATUS: typeof $Enums.INCIDENT_STATUS

export type EQUIPMENT_STATUS = $Enums.EQUIPMENT_STATUS

export const EQUIPMENT_STATUS: typeof $Enums.EQUIPMENT_STATUS

export type LIFT_TYPE = $Enums.LIFT_TYPE

export const LIFT_TYPE: typeof $Enums.LIFT_TYPE

export type TRAIL_CONDITION = $Enums.TRAIL_CONDITION

export const TRAIL_CONDITION: typeof $Enums.TRAIL_CONDITION

export type TRAIL_DIFFICULTY = $Enums.TRAIL_DIFFICULTY

export const TRAIL_DIFFICULTY: typeof $Enums.TRAIL_DIFFICULTY

export type DEPARTMENT = $Enums.DEPARTMENT

export const DEPARTMENT: typeof $Enums.DEPARTMENT

export type AREA_TYPE = $Enums.AREA_TYPE

export const AREA_TYPE: typeof $Enums.AREA_TYPE

export type EMPLOYEE_ROLES = $Enums.EMPLOYEE_ROLES

export const EMPLOYEE_ROLES: typeof $Enums.EMPLOYEE_ROLES

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Areas
 * const areas = await prisma.area.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Areas
   * const areas = await prisma.area.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.area`: Exposes CRUD operations for the **Area** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Areas
    * const areas = await prisma.area.findMany()
    * ```
    */
  get area(): Prisma.AreaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hours`: Exposes CRUD operations for the **Hours** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hours
    * const hours = await prisma.hours.findMany()
    * ```
    */
  get hours(): Prisma.HoursDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mountain`: Exposes CRUD operations for the **Mountain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mountains
    * const mountains = await prisma.mountain.findMany()
    * ```
    */
  get mountain(): Prisma.MountainDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weather`: Exposes CRUD operations for the **Weather** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weathers
    * const weathers = await prisma.weather.findMany()
    * ```
    */
  get weather(): Prisma.WeatherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeMountainAssignment`: Exposes CRUD operations for the **EmployeeMountainAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeMountainAssignments
    * const employeeMountainAssignments = await prisma.employeeMountainAssignment.findMany()
    * ```
    */
  get employeeMountainAssignment(): Prisma.EmployeeMountainAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dispatcherAssignment`: Exposes CRUD operations for the **DispatcherAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DispatcherAssignments
    * const dispatcherAssignments = await prisma.dispatcherAssignment.findMany()
    * ```
    */
  get dispatcherAssignment(): Prisma.DispatcherAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeRole`: Exposes CRUD operations for the **EmployeeRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeRoles
    * const employeeRoles = await prisma.employeeRole.findMany()
    * ```
    */
  get employeeRole(): Prisma.EmployeeRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lift`: Exposes CRUD operations for the **Lift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lifts
    * const lifts = await prisma.lift.findMany()
    * ```
    */
  get lift(): Prisma.LiftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trail`: Exposes CRUD operations for the **Trail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trails
    * const trails = await prisma.trail.findMany()
    * ```
    */
  get trail(): Prisma.TrailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lodge`: Exposes CRUD operations for the **Lodge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lodges
    * const lodges = await prisma.lodge.findMany()
    * ```
    */
  get lodge(): Prisma.LodgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hut`: Exposes CRUD operations for the **Hut** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Huts
    * const huts = await prisma.hut.findMany()
    * ```
    */
  get hut(): Prisma.HutDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aidRoom`: Exposes CRUD operations for the **AidRoom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AidRooms
    * const aidRooms = await prisma.aidRoom.findMany()
    * ```
    */
  get aidRoom(): Prisma.AidRoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipmentServiceLog`: Exposes CRUD operations for the **EquipmentServiceLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipmentServiceLogs
    * const equipmentServiceLogs = await prisma.equipmentServiceLog.findMany()
    * ```
    */
  get equipmentServiceLog(): Prisma.EquipmentServiceLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipment`: Exposes CRUD operations for the **Equipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment
    * const equipment = await prisma.equipment.findMany()
    * ```
    */
  get equipment(): Prisma.EquipmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.incident`: Exposes CRUD operations for the **Incident** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Incidents
    * const incidents = await prisma.incident.findMany()
    * ```
    */
  get incident(): Prisma.IncidentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.incidentEquipmentUsageLog`: Exposes CRUD operations for the **IncidentEquipmentUsageLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IncidentEquipmentUsageLogs
    * const incidentEquipmentUsageLogs = await prisma.incidentEquipmentUsageLog.findMany()
    * ```
    */
  get incidentEquipmentUsageLog(): Prisma.IncidentEquipmentUsageLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.liftCheck`: Exposes CRUD operations for the **LiftCheck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LiftChecks
    * const liftChecks = await prisma.liftCheck.findMany()
    * ```
    */
  get liftCheck(): Prisma.LiftCheckDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trailCheck`: Exposes CRUD operations for the **TrailCheck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrailChecks
    * const trailChecks = await prisma.trailCheck.findMany()
    * ```
    */
  get trailCheck(): Prisma.TrailCheckDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hutCheck`: Exposes CRUD operations for the **HutCheck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HutChecks
    * const hutChecks = await prisma.hutCheck.findMany()
    * ```
    */
  get hutCheck(): Prisma.HutCheckDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aidRoomCheck`: Exposes CRUD operations for the **AidRoomCheck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AidRoomChecks
    * const aidRoomChecks = await prisma.aidRoomCheck.findMany()
    * ```
    */
  get aidRoomCheck(): Prisma.AidRoomCheckDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipmentCheck`: Exposes CRUD operations for the **EquipmentCheck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipmentChecks
    * const equipmentChecks = await prisma.equipmentCheck.findMany()
    * ```
    */
  get equipmentCheck(): Prisma.EquipmentCheckDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Area: 'Area',
    Location: 'Location',
    Hours: 'Hours',
    Mountain: 'Mountain',
    Weather: 'Weather',
    EmployeeMountainAssignment: 'EmployeeMountainAssignment',
    DispatcherAssignment: 'DispatcherAssignment',
    Role: 'Role',
    EmployeeRole: 'EmployeeRole',
    Employee: 'Employee',
    Lift: 'Lift',
    Trail: 'Trail',
    Lodge: 'Lodge',
    Hut: 'Hut',
    AidRoom: 'AidRoom',
    EquipmentServiceLog: 'EquipmentServiceLog',
    Equipment: 'Equipment',
    Incident: 'Incident',
    IncidentEquipmentUsageLog: 'IncidentEquipmentUsageLog',
    LiftCheck: 'LiftCheck',
    TrailCheck: 'TrailCheck',
    HutCheck: 'HutCheck',
    AidRoomCheck: 'AidRoomCheck',
    EquipmentCheck: 'EquipmentCheck'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "area" | "location" | "hours" | "mountain" | "weather" | "employeeMountainAssignment" | "dispatcherAssignment" | "role" | "employeeRole" | "employee" | "lift" | "trail" | "lodge" | "hut" | "aidRoom" | "equipmentServiceLog" | "equipment" | "incident" | "incidentEquipmentUsageLog" | "liftCheck" | "trailCheck" | "hutCheck" | "aidRoomCheck" | "equipmentCheck"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Area: {
        payload: Prisma.$AreaPayload<ExtArgs>
        fields: Prisma.AreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AreaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AreaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          findFirst: {
            args: Prisma.AreaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AreaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          findMany: {
            args: Prisma.AreaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>[]
          }
          create: {
            args: Prisma.AreaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          createMany: {
            args: Prisma.AreaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AreaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>[]
          }
          delete: {
            args: Prisma.AreaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          update: {
            args: Prisma.AreaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          deleteMany: {
            args: Prisma.AreaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AreaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AreaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>[]
          }
          upsert: {
            args: Prisma.AreaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          aggregate: {
            args: Prisma.AreaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArea>
          }
          groupBy: {
            args: Prisma.AreaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AreaCountArgs<ExtArgs>
            result: $Utils.Optional<AreaCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Hours: {
        payload: Prisma.$HoursPayload<ExtArgs>
        fields: Prisma.HoursFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HoursFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoursPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HoursFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoursPayload>
          }
          findFirst: {
            args: Prisma.HoursFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoursPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HoursFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoursPayload>
          }
          findMany: {
            args: Prisma.HoursFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoursPayload>[]
          }
          create: {
            args: Prisma.HoursCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoursPayload>
          }
          createMany: {
            args: Prisma.HoursCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HoursCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoursPayload>[]
          }
          delete: {
            args: Prisma.HoursDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoursPayload>
          }
          update: {
            args: Prisma.HoursUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoursPayload>
          }
          deleteMany: {
            args: Prisma.HoursDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HoursUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HoursUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoursPayload>[]
          }
          upsert: {
            args: Prisma.HoursUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoursPayload>
          }
          aggregate: {
            args: Prisma.HoursAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHours>
          }
          groupBy: {
            args: Prisma.HoursGroupByArgs<ExtArgs>
            result: $Utils.Optional<HoursGroupByOutputType>[]
          }
          count: {
            args: Prisma.HoursCountArgs<ExtArgs>
            result: $Utils.Optional<HoursCountAggregateOutputType> | number
          }
        }
      }
      Mountain: {
        payload: Prisma.$MountainPayload<ExtArgs>
        fields: Prisma.MountainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MountainFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MountainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MountainFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MountainPayload>
          }
          findFirst: {
            args: Prisma.MountainFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MountainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MountainFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MountainPayload>
          }
          findMany: {
            args: Prisma.MountainFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MountainPayload>[]
          }
          create: {
            args: Prisma.MountainCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MountainPayload>
          }
          createMany: {
            args: Prisma.MountainCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MountainCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MountainPayload>[]
          }
          delete: {
            args: Prisma.MountainDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MountainPayload>
          }
          update: {
            args: Prisma.MountainUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MountainPayload>
          }
          deleteMany: {
            args: Prisma.MountainDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MountainUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MountainUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MountainPayload>[]
          }
          upsert: {
            args: Prisma.MountainUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MountainPayload>
          }
          aggregate: {
            args: Prisma.MountainAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMountain>
          }
          groupBy: {
            args: Prisma.MountainGroupByArgs<ExtArgs>
            result: $Utils.Optional<MountainGroupByOutputType>[]
          }
          count: {
            args: Prisma.MountainCountArgs<ExtArgs>
            result: $Utils.Optional<MountainCountAggregateOutputType> | number
          }
        }
      }
      Weather: {
        payload: Prisma.$WeatherPayload<ExtArgs>
        fields: Prisma.WeatherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeatherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeatherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          findFirst: {
            args: Prisma.WeatherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeatherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          findMany: {
            args: Prisma.WeatherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>[]
          }
          create: {
            args: Prisma.WeatherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          createMany: {
            args: Prisma.WeatherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeatherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>[]
          }
          delete: {
            args: Prisma.WeatherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          update: {
            args: Prisma.WeatherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          deleteMany: {
            args: Prisma.WeatherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeatherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeatherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>[]
          }
          upsert: {
            args: Prisma.WeatherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          aggregate: {
            args: Prisma.WeatherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeather>
          }
          groupBy: {
            args: Prisma.WeatherGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeatherGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeatherCountArgs<ExtArgs>
            result: $Utils.Optional<WeatherCountAggregateOutputType> | number
          }
        }
      }
      EmployeeMountainAssignment: {
        payload: Prisma.$EmployeeMountainAssignmentPayload<ExtArgs>
        fields: Prisma.EmployeeMountainAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeMountainAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeMountainAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeMountainAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeMountainAssignmentPayload>
          }
          findFirst: {
            args: Prisma.EmployeeMountainAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeMountainAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeMountainAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeMountainAssignmentPayload>
          }
          findMany: {
            args: Prisma.EmployeeMountainAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeMountainAssignmentPayload>[]
          }
          create: {
            args: Prisma.EmployeeMountainAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeMountainAssignmentPayload>
          }
          createMany: {
            args: Prisma.EmployeeMountainAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeMountainAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeMountainAssignmentPayload>[]
          }
          delete: {
            args: Prisma.EmployeeMountainAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeMountainAssignmentPayload>
          }
          update: {
            args: Prisma.EmployeeMountainAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeMountainAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeMountainAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeMountainAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeMountainAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeMountainAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.EmployeeMountainAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeMountainAssignmentPayload>
          }
          aggregate: {
            args: Prisma.EmployeeMountainAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeMountainAssignment>
          }
          groupBy: {
            args: Prisma.EmployeeMountainAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeMountainAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeMountainAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeMountainAssignmentCountAggregateOutputType> | number
          }
        }
      }
      DispatcherAssignment: {
        payload: Prisma.$DispatcherAssignmentPayload<ExtArgs>
        fields: Prisma.DispatcherAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DispatcherAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatcherAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DispatcherAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatcherAssignmentPayload>
          }
          findFirst: {
            args: Prisma.DispatcherAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatcherAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DispatcherAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatcherAssignmentPayload>
          }
          findMany: {
            args: Prisma.DispatcherAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatcherAssignmentPayload>[]
          }
          create: {
            args: Prisma.DispatcherAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatcherAssignmentPayload>
          }
          createMany: {
            args: Prisma.DispatcherAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DispatcherAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatcherAssignmentPayload>[]
          }
          delete: {
            args: Prisma.DispatcherAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatcherAssignmentPayload>
          }
          update: {
            args: Prisma.DispatcherAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatcherAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.DispatcherAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DispatcherAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DispatcherAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatcherAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.DispatcherAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatcherAssignmentPayload>
          }
          aggregate: {
            args: Prisma.DispatcherAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDispatcherAssignment>
          }
          groupBy: {
            args: Prisma.DispatcherAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DispatcherAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DispatcherAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<DispatcherAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      EmployeeRole: {
        payload: Prisma.$EmployeeRolePayload<ExtArgs>
        fields: Prisma.EmployeeRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRolePayload>
          }
          findFirst: {
            args: Prisma.EmployeeRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRolePayload>
          }
          findMany: {
            args: Prisma.EmployeeRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRolePayload>[]
          }
          create: {
            args: Prisma.EmployeeRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRolePayload>
          }
          createMany: {
            args: Prisma.EmployeeRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRolePayload>[]
          }
          delete: {
            args: Prisma.EmployeeRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRolePayload>
          }
          update: {
            args: Prisma.EmployeeRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRolePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRolePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRolePayload>
          }
          aggregate: {
            args: Prisma.EmployeeRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeRole>
          }
          groupBy: {
            args: Prisma.EmployeeRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeRoleCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeRoleCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Lift: {
        payload: Prisma.$LiftPayload<ExtArgs>
        fields: Prisma.LiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftPayload>
          }
          findFirst: {
            args: Prisma.LiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftPayload>
          }
          findMany: {
            args: Prisma.LiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftPayload>[]
          }
          create: {
            args: Prisma.LiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftPayload>
          }
          createMany: {
            args: Prisma.LiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LiftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftPayload>[]
          }
          delete: {
            args: Prisma.LiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftPayload>
          }
          update: {
            args: Prisma.LiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftPayload>
          }
          deleteMany: {
            args: Prisma.LiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LiftUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftPayload>[]
          }
          upsert: {
            args: Prisma.LiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftPayload>
          }
          aggregate: {
            args: Prisma.LiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLift>
          }
          groupBy: {
            args: Prisma.LiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<LiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.LiftCountArgs<ExtArgs>
            result: $Utils.Optional<LiftCountAggregateOutputType> | number
          }
        }
      }
      Trail: {
        payload: Prisma.$TrailPayload<ExtArgs>
        fields: Prisma.TrailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailPayload>
          }
          findFirst: {
            args: Prisma.TrailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailPayload>
          }
          findMany: {
            args: Prisma.TrailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailPayload>[]
          }
          create: {
            args: Prisma.TrailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailPayload>
          }
          createMany: {
            args: Prisma.TrailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailPayload>[]
          }
          delete: {
            args: Prisma.TrailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailPayload>
          }
          update: {
            args: Prisma.TrailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailPayload>
          }
          deleteMany: {
            args: Prisma.TrailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailPayload>[]
          }
          upsert: {
            args: Prisma.TrailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailPayload>
          }
          aggregate: {
            args: Prisma.TrailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrail>
          }
          groupBy: {
            args: Prisma.TrailGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrailGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrailCountArgs<ExtArgs>
            result: $Utils.Optional<TrailCountAggregateOutputType> | number
          }
        }
      }
      Lodge: {
        payload: Prisma.$LodgePayload<ExtArgs>
        fields: Prisma.LodgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LodgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LodgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LodgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LodgePayload>
          }
          findFirst: {
            args: Prisma.LodgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LodgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LodgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LodgePayload>
          }
          findMany: {
            args: Prisma.LodgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LodgePayload>[]
          }
          create: {
            args: Prisma.LodgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LodgePayload>
          }
          createMany: {
            args: Prisma.LodgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LodgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LodgePayload>[]
          }
          delete: {
            args: Prisma.LodgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LodgePayload>
          }
          update: {
            args: Prisma.LodgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LodgePayload>
          }
          deleteMany: {
            args: Prisma.LodgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LodgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LodgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LodgePayload>[]
          }
          upsert: {
            args: Prisma.LodgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LodgePayload>
          }
          aggregate: {
            args: Prisma.LodgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLodge>
          }
          groupBy: {
            args: Prisma.LodgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LodgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LodgeCountArgs<ExtArgs>
            result: $Utils.Optional<LodgeCountAggregateOutputType> | number
          }
        }
      }
      Hut: {
        payload: Prisma.$HutPayload<ExtArgs>
        fields: Prisma.HutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutPayload>
          }
          findFirst: {
            args: Prisma.HutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutPayload>
          }
          findMany: {
            args: Prisma.HutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutPayload>[]
          }
          create: {
            args: Prisma.HutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutPayload>
          }
          createMany: {
            args: Prisma.HutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HutCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutPayload>[]
          }
          delete: {
            args: Prisma.HutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutPayload>
          }
          update: {
            args: Prisma.HutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutPayload>
          }
          deleteMany: {
            args: Prisma.HutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HutUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutPayload>[]
          }
          upsert: {
            args: Prisma.HutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutPayload>
          }
          aggregate: {
            args: Prisma.HutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHut>
          }
          groupBy: {
            args: Prisma.HutGroupByArgs<ExtArgs>
            result: $Utils.Optional<HutGroupByOutputType>[]
          }
          count: {
            args: Prisma.HutCountArgs<ExtArgs>
            result: $Utils.Optional<HutCountAggregateOutputType> | number
          }
        }
      }
      AidRoom: {
        payload: Prisma.$AidRoomPayload<ExtArgs>
        fields: Prisma.AidRoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AidRoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AidRoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomPayload>
          }
          findFirst: {
            args: Prisma.AidRoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AidRoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomPayload>
          }
          findMany: {
            args: Prisma.AidRoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomPayload>[]
          }
          create: {
            args: Prisma.AidRoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomPayload>
          }
          createMany: {
            args: Prisma.AidRoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AidRoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomPayload>[]
          }
          delete: {
            args: Prisma.AidRoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomPayload>
          }
          update: {
            args: Prisma.AidRoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomPayload>
          }
          deleteMany: {
            args: Prisma.AidRoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AidRoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AidRoomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomPayload>[]
          }
          upsert: {
            args: Prisma.AidRoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomPayload>
          }
          aggregate: {
            args: Prisma.AidRoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAidRoom>
          }
          groupBy: {
            args: Prisma.AidRoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<AidRoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.AidRoomCountArgs<ExtArgs>
            result: $Utils.Optional<AidRoomCountAggregateOutputType> | number
          }
        }
      }
      EquipmentServiceLog: {
        payload: Prisma.$EquipmentServiceLogPayload<ExtArgs>
        fields: Prisma.EquipmentServiceLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentServiceLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentServiceLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentServiceLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentServiceLogPayload>
          }
          findFirst: {
            args: Prisma.EquipmentServiceLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentServiceLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentServiceLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentServiceLogPayload>
          }
          findMany: {
            args: Prisma.EquipmentServiceLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentServiceLogPayload>[]
          }
          create: {
            args: Prisma.EquipmentServiceLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentServiceLogPayload>
          }
          createMany: {
            args: Prisma.EquipmentServiceLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipmentServiceLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentServiceLogPayload>[]
          }
          delete: {
            args: Prisma.EquipmentServiceLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentServiceLogPayload>
          }
          update: {
            args: Prisma.EquipmentServiceLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentServiceLogPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentServiceLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentServiceLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EquipmentServiceLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentServiceLogPayload>[]
          }
          upsert: {
            args: Prisma.EquipmentServiceLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentServiceLogPayload>
          }
          aggregate: {
            args: Prisma.EquipmentServiceLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipmentServiceLog>
          }
          groupBy: {
            args: Prisma.EquipmentServiceLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentServiceLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentServiceLogCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentServiceLogCountAggregateOutputType> | number
          }
        }
      }
      Equipment: {
        payload: Prisma.$EquipmentPayload<ExtArgs>
        fields: Prisma.EquipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findFirst: {
            args: Prisma.EquipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findMany: {
            args: Prisma.EquipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          create: {
            args: Prisma.EquipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          createMany: {
            args: Prisma.EquipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          delete: {
            args: Prisma.EquipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          update: {
            args: Prisma.EquipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EquipmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          upsert: {
            args: Prisma.EquipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          aggregate: {
            args: Prisma.EquipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipment>
          }
          groupBy: {
            args: Prisma.EquipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentCountAggregateOutputType> | number
          }
        }
      }
      Incident: {
        payload: Prisma.$IncidentPayload<ExtArgs>
        fields: Prisma.IncidentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncidentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncidentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          findFirst: {
            args: Prisma.IncidentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncidentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          findMany: {
            args: Prisma.IncidentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>[]
          }
          create: {
            args: Prisma.IncidentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          createMany: {
            args: Prisma.IncidentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncidentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>[]
          }
          delete: {
            args: Prisma.IncidentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          update: {
            args: Prisma.IncidentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          deleteMany: {
            args: Prisma.IncidentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncidentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IncidentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>[]
          }
          upsert: {
            args: Prisma.IncidentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          aggregate: {
            args: Prisma.IncidentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncident>
          }
          groupBy: {
            args: Prisma.IncidentGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncidentGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncidentCountArgs<ExtArgs>
            result: $Utils.Optional<IncidentCountAggregateOutputType> | number
          }
        }
      }
      IncidentEquipmentUsageLog: {
        payload: Prisma.$IncidentEquipmentUsageLogPayload<ExtArgs>
        fields: Prisma.IncidentEquipmentUsageLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncidentEquipmentUsageLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentEquipmentUsageLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncidentEquipmentUsageLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentEquipmentUsageLogPayload>
          }
          findFirst: {
            args: Prisma.IncidentEquipmentUsageLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentEquipmentUsageLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncidentEquipmentUsageLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentEquipmentUsageLogPayload>
          }
          findMany: {
            args: Prisma.IncidentEquipmentUsageLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentEquipmentUsageLogPayload>[]
          }
          create: {
            args: Prisma.IncidentEquipmentUsageLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentEquipmentUsageLogPayload>
          }
          createMany: {
            args: Prisma.IncidentEquipmentUsageLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncidentEquipmentUsageLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentEquipmentUsageLogPayload>[]
          }
          delete: {
            args: Prisma.IncidentEquipmentUsageLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentEquipmentUsageLogPayload>
          }
          update: {
            args: Prisma.IncidentEquipmentUsageLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentEquipmentUsageLogPayload>
          }
          deleteMany: {
            args: Prisma.IncidentEquipmentUsageLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncidentEquipmentUsageLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IncidentEquipmentUsageLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentEquipmentUsageLogPayload>[]
          }
          upsert: {
            args: Prisma.IncidentEquipmentUsageLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentEquipmentUsageLogPayload>
          }
          aggregate: {
            args: Prisma.IncidentEquipmentUsageLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncidentEquipmentUsageLog>
          }
          groupBy: {
            args: Prisma.IncidentEquipmentUsageLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncidentEquipmentUsageLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncidentEquipmentUsageLogCountArgs<ExtArgs>
            result: $Utils.Optional<IncidentEquipmentUsageLogCountAggregateOutputType> | number
          }
        }
      }
      LiftCheck: {
        payload: Prisma.$LiftCheckPayload<ExtArgs>
        fields: Prisma.LiftCheckFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LiftCheckFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftCheckPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LiftCheckFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftCheckPayload>
          }
          findFirst: {
            args: Prisma.LiftCheckFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftCheckPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LiftCheckFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftCheckPayload>
          }
          findMany: {
            args: Prisma.LiftCheckFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftCheckPayload>[]
          }
          create: {
            args: Prisma.LiftCheckCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftCheckPayload>
          }
          createMany: {
            args: Prisma.LiftCheckCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LiftCheckCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftCheckPayload>[]
          }
          delete: {
            args: Prisma.LiftCheckDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftCheckPayload>
          }
          update: {
            args: Prisma.LiftCheckUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftCheckPayload>
          }
          deleteMany: {
            args: Prisma.LiftCheckDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LiftCheckUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LiftCheckUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftCheckPayload>[]
          }
          upsert: {
            args: Prisma.LiftCheckUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftCheckPayload>
          }
          aggregate: {
            args: Prisma.LiftCheckAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLiftCheck>
          }
          groupBy: {
            args: Prisma.LiftCheckGroupByArgs<ExtArgs>
            result: $Utils.Optional<LiftCheckGroupByOutputType>[]
          }
          count: {
            args: Prisma.LiftCheckCountArgs<ExtArgs>
            result: $Utils.Optional<LiftCheckCountAggregateOutputType> | number
          }
        }
      }
      TrailCheck: {
        payload: Prisma.$TrailCheckPayload<ExtArgs>
        fields: Prisma.TrailCheckFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrailCheckFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailCheckPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrailCheckFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailCheckPayload>
          }
          findFirst: {
            args: Prisma.TrailCheckFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailCheckPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrailCheckFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailCheckPayload>
          }
          findMany: {
            args: Prisma.TrailCheckFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailCheckPayload>[]
          }
          create: {
            args: Prisma.TrailCheckCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailCheckPayload>
          }
          createMany: {
            args: Prisma.TrailCheckCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrailCheckCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailCheckPayload>[]
          }
          delete: {
            args: Prisma.TrailCheckDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailCheckPayload>
          }
          update: {
            args: Prisma.TrailCheckUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailCheckPayload>
          }
          deleteMany: {
            args: Prisma.TrailCheckDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrailCheckUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrailCheckUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailCheckPayload>[]
          }
          upsert: {
            args: Prisma.TrailCheckUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailCheckPayload>
          }
          aggregate: {
            args: Prisma.TrailCheckAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrailCheck>
          }
          groupBy: {
            args: Prisma.TrailCheckGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrailCheckGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrailCheckCountArgs<ExtArgs>
            result: $Utils.Optional<TrailCheckCountAggregateOutputType> | number
          }
        }
      }
      HutCheck: {
        payload: Prisma.$HutCheckPayload<ExtArgs>
        fields: Prisma.HutCheckFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HutCheckFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutCheckPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HutCheckFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutCheckPayload>
          }
          findFirst: {
            args: Prisma.HutCheckFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutCheckPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HutCheckFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutCheckPayload>
          }
          findMany: {
            args: Prisma.HutCheckFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutCheckPayload>[]
          }
          create: {
            args: Prisma.HutCheckCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutCheckPayload>
          }
          createMany: {
            args: Prisma.HutCheckCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HutCheckCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutCheckPayload>[]
          }
          delete: {
            args: Prisma.HutCheckDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutCheckPayload>
          }
          update: {
            args: Prisma.HutCheckUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutCheckPayload>
          }
          deleteMany: {
            args: Prisma.HutCheckDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HutCheckUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HutCheckUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutCheckPayload>[]
          }
          upsert: {
            args: Prisma.HutCheckUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutCheckPayload>
          }
          aggregate: {
            args: Prisma.HutCheckAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHutCheck>
          }
          groupBy: {
            args: Prisma.HutCheckGroupByArgs<ExtArgs>
            result: $Utils.Optional<HutCheckGroupByOutputType>[]
          }
          count: {
            args: Prisma.HutCheckCountArgs<ExtArgs>
            result: $Utils.Optional<HutCheckCountAggregateOutputType> | number
          }
        }
      }
      AidRoomCheck: {
        payload: Prisma.$AidRoomCheckPayload<ExtArgs>
        fields: Prisma.AidRoomCheckFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AidRoomCheckFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomCheckPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AidRoomCheckFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomCheckPayload>
          }
          findFirst: {
            args: Prisma.AidRoomCheckFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomCheckPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AidRoomCheckFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomCheckPayload>
          }
          findMany: {
            args: Prisma.AidRoomCheckFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomCheckPayload>[]
          }
          create: {
            args: Prisma.AidRoomCheckCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomCheckPayload>
          }
          createMany: {
            args: Prisma.AidRoomCheckCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AidRoomCheckCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomCheckPayload>[]
          }
          delete: {
            args: Prisma.AidRoomCheckDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomCheckPayload>
          }
          update: {
            args: Prisma.AidRoomCheckUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomCheckPayload>
          }
          deleteMany: {
            args: Prisma.AidRoomCheckDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AidRoomCheckUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AidRoomCheckUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomCheckPayload>[]
          }
          upsert: {
            args: Prisma.AidRoomCheckUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomCheckPayload>
          }
          aggregate: {
            args: Prisma.AidRoomCheckAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAidRoomCheck>
          }
          groupBy: {
            args: Prisma.AidRoomCheckGroupByArgs<ExtArgs>
            result: $Utils.Optional<AidRoomCheckGroupByOutputType>[]
          }
          count: {
            args: Prisma.AidRoomCheckCountArgs<ExtArgs>
            result: $Utils.Optional<AidRoomCheckCountAggregateOutputType> | number
          }
        }
      }
      EquipmentCheck: {
        payload: Prisma.$EquipmentCheckPayload<ExtArgs>
        fields: Prisma.EquipmentCheckFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentCheckFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCheckPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentCheckFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCheckPayload>
          }
          findFirst: {
            args: Prisma.EquipmentCheckFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCheckPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentCheckFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCheckPayload>
          }
          findMany: {
            args: Prisma.EquipmentCheckFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCheckPayload>[]
          }
          create: {
            args: Prisma.EquipmentCheckCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCheckPayload>
          }
          createMany: {
            args: Prisma.EquipmentCheckCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipmentCheckCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCheckPayload>[]
          }
          delete: {
            args: Prisma.EquipmentCheckDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCheckPayload>
          }
          update: {
            args: Prisma.EquipmentCheckUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCheckPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentCheckDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentCheckUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EquipmentCheckUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCheckPayload>[]
          }
          upsert: {
            args: Prisma.EquipmentCheckUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCheckPayload>
          }
          aggregate: {
            args: Prisma.EquipmentCheckAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipmentCheck>
          }
          groupBy: {
            args: Prisma.EquipmentCheckGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentCheckGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentCheckCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentCheckCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    area?: AreaOmit
    location?: LocationOmit
    hours?: HoursOmit
    mountain?: MountainOmit
    weather?: WeatherOmit
    employeeMountainAssignment?: EmployeeMountainAssignmentOmit
    dispatcherAssignment?: DispatcherAssignmentOmit
    role?: RoleOmit
    employeeRole?: EmployeeRoleOmit
    employee?: EmployeeOmit
    lift?: LiftOmit
    trail?: TrailOmit
    lodge?: LodgeOmit
    hut?: HutOmit
    aidRoom?: AidRoomOmit
    equipmentServiceLog?: EquipmentServiceLogOmit
    equipment?: EquipmentOmit
    incident?: IncidentOmit
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogOmit
    liftCheck?: LiftCheckOmit
    trailCheck?: TrailCheckOmit
    hutCheck?: HutCheckOmit
    aidRoomCheck?: AidRoomCheckOmit
    equipmentCheck?: EquipmentCheckOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AreaCountOutputType
   */

  export type AreaCountOutputType = {
    locations: number
  }

  export type AreaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | AreaCountOutputTypeCountLocationsArgs
  }

  // Custom InputTypes
  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaCountOutputType
     */
    select?: AreaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    hours: number
    equipment: number
    incidents: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hours?: boolean | LocationCountOutputTypeCountHoursArgs
    equipment?: boolean | LocationCountOutputTypeCountEquipmentArgs
    incidents?: boolean | LocationCountOutputTypeCountIncidentsArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HoursWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
  }


  /**
   * Count Type MountainCountOutputType
   */

  export type MountainCountOutputType = {
    weather: number
    locations: number
    areas: number
    aidRooms: number
    huts: number
    lodges: number
    lifts: number
    trails: number
    aidRoomChecks: number
    hutChecks: number
    liftChecks: number
    trailChecks: number
    equipmentChecks: number
    incidents: number
    equipment: number
    employeeAssignments: number
    dispatcherAssignments: number
    incidentEquipmentUsageLog: number
    equipmentServiceLogs: number
  }

  export type MountainCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weather?: boolean | MountainCountOutputTypeCountWeatherArgs
    locations?: boolean | MountainCountOutputTypeCountLocationsArgs
    areas?: boolean | MountainCountOutputTypeCountAreasArgs
    aidRooms?: boolean | MountainCountOutputTypeCountAidRoomsArgs
    huts?: boolean | MountainCountOutputTypeCountHutsArgs
    lodges?: boolean | MountainCountOutputTypeCountLodgesArgs
    lifts?: boolean | MountainCountOutputTypeCountLiftsArgs
    trails?: boolean | MountainCountOutputTypeCountTrailsArgs
    aidRoomChecks?: boolean | MountainCountOutputTypeCountAidRoomChecksArgs
    hutChecks?: boolean | MountainCountOutputTypeCountHutChecksArgs
    liftChecks?: boolean | MountainCountOutputTypeCountLiftChecksArgs
    trailChecks?: boolean | MountainCountOutputTypeCountTrailChecksArgs
    equipmentChecks?: boolean | MountainCountOutputTypeCountEquipmentChecksArgs
    incidents?: boolean | MountainCountOutputTypeCountIncidentsArgs
    equipment?: boolean | MountainCountOutputTypeCountEquipmentArgs
    employeeAssignments?: boolean | MountainCountOutputTypeCountEmployeeAssignmentsArgs
    dispatcherAssignments?: boolean | MountainCountOutputTypeCountDispatcherAssignmentsArgs
    incidentEquipmentUsageLog?: boolean | MountainCountOutputTypeCountIncidentEquipmentUsageLogArgs
    equipmentServiceLogs?: boolean | MountainCountOutputTypeCountEquipmentServiceLogsArgs
  }

  // Custom InputTypes
  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MountainCountOutputType
     */
    select?: MountainCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountWeatherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeatherWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountAreasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AreaWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountAidRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AidRoomWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountHutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HutWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountLodgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LodgeWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountLiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiftWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountTrailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrailWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountAidRoomChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AidRoomCheckWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountHutChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HutCheckWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountLiftChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiftCheckWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountTrailChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrailCheckWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountEquipmentChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentCheckWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountEmployeeAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeMountainAssignmentWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountDispatcherAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispatcherAssignmentWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountIncidentEquipmentUsageLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentEquipmentUsageLogWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountEquipmentServiceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentServiceLogWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    employees: number
    employeeRole: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | RoleCountOutputTypeCountEmployeesArgs
    employeeRole?: boolean | RoleCountOutputTypeCountEmployeeRoleArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountEmployeeRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeRoleWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    additionalRoles: number
    mountainAssignments: number
    dispatcherAssignments: number
    incidents: number
    aidRoomChecks: number
    hutChecks: number
    liftChecks: number
    trailChecks: number
    equipmentChecks: number
    equipmentServiceLogs: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    additionalRoles?: boolean | EmployeeCountOutputTypeCountAdditionalRolesArgs
    mountainAssignments?: boolean | EmployeeCountOutputTypeCountMountainAssignmentsArgs
    dispatcherAssignments?: boolean | EmployeeCountOutputTypeCountDispatcherAssignmentsArgs
    incidents?: boolean | EmployeeCountOutputTypeCountIncidentsArgs
    aidRoomChecks?: boolean | EmployeeCountOutputTypeCountAidRoomChecksArgs
    hutChecks?: boolean | EmployeeCountOutputTypeCountHutChecksArgs
    liftChecks?: boolean | EmployeeCountOutputTypeCountLiftChecksArgs
    trailChecks?: boolean | EmployeeCountOutputTypeCountTrailChecksArgs
    equipmentChecks?: boolean | EmployeeCountOutputTypeCountEquipmentChecksArgs
    equipmentServiceLogs?: boolean | EmployeeCountOutputTypeCountEquipmentServiceLogsArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAdditionalRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeRoleWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountMountainAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeMountainAssignmentWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountDispatcherAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispatcherAssignmentWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAidRoomChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AidRoomCheckWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountHutChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HutCheckWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountLiftChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiftCheckWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountTrailChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrailCheckWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountEquipmentChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentCheckWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountEquipmentServiceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentServiceLogWhereInput
  }


  /**
   * Count Type LiftCountOutputType
   */

  export type LiftCountOutputType = {
    liftChecks: number
  }

  export type LiftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    liftChecks?: boolean | LiftCountOutputTypeCountLiftChecksArgs
  }

  // Custom InputTypes
  /**
   * LiftCountOutputType without action
   */
  export type LiftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCountOutputType
     */
    select?: LiftCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LiftCountOutputType without action
   */
  export type LiftCountOutputTypeCountLiftChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiftCheckWhereInput
  }


  /**
   * Count Type TrailCountOutputType
   */

  export type TrailCountOutputType = {
    trailChecks: number
  }

  export type TrailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trailChecks?: boolean | TrailCountOutputTypeCountTrailChecksArgs
  }

  // Custom InputTypes
  /**
   * TrailCountOutputType without action
   */
  export type TrailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCountOutputType
     */
    select?: TrailCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrailCountOutputType without action
   */
  export type TrailCountOutputTypeCountTrailChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrailCheckWhereInput
  }


  /**
   * Count Type HutCountOutputType
   */

  export type HutCountOutputType = {
    hutChecks: number
  }

  export type HutCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hutChecks?: boolean | HutCountOutputTypeCountHutChecksArgs
  }

  // Custom InputTypes
  /**
   * HutCountOutputType without action
   */
  export type HutCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCountOutputType
     */
    select?: HutCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HutCountOutputType without action
   */
  export type HutCountOutputTypeCountHutChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HutCheckWhereInput
  }


  /**
   * Count Type AidRoomCountOutputType
   */

  export type AidRoomCountOutputType = {
    aidRoomChecks: number
  }

  export type AidRoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aidRoomChecks?: boolean | AidRoomCountOutputTypeCountAidRoomChecksArgs
  }

  // Custom InputTypes
  /**
   * AidRoomCountOutputType without action
   */
  export type AidRoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCountOutputType
     */
    select?: AidRoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AidRoomCountOutputType without action
   */
  export type AidRoomCountOutputTypeCountAidRoomChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AidRoomCheckWhereInput
  }


  /**
   * Count Type EquipmentCountOutputType
   */

  export type EquipmentCountOutputType = {
    incidentEquipmentUsageLogs: number
    equipmentChecks: number
    equipmentServiceLogs: number
  }

  export type EquipmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incidentEquipmentUsageLogs?: boolean | EquipmentCountOutputTypeCountIncidentEquipmentUsageLogsArgs
    equipmentChecks?: boolean | EquipmentCountOutputTypeCountEquipmentChecksArgs
    equipmentServiceLogs?: boolean | EquipmentCountOutputTypeCountEquipmentServiceLogsArgs
  }

  // Custom InputTypes
  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCountOutputType
     */
    select?: EquipmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountIncidentEquipmentUsageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentEquipmentUsageLogWhereInput
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountEquipmentChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentCheckWhereInput
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountEquipmentServiceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentServiceLogWhereInput
  }


  /**
   * Count Type IncidentCountOutputType
   */

  export type IncidentCountOutputType = {
    incidentEquipmentUsageLog: number
    employees: number
  }

  export type IncidentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incidentEquipmentUsageLog?: boolean | IncidentCountOutputTypeCountIncidentEquipmentUsageLogArgs
    employees?: boolean | IncidentCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * IncidentCountOutputType without action
   */
  export type IncidentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentCountOutputType
     */
    select?: IncidentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IncidentCountOutputType without action
   */
  export type IncidentCountOutputTypeCountIncidentEquipmentUsageLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentEquipmentUsageLogWhereInput
  }

  /**
   * IncidentCountOutputType without action
   */
  export type IncidentCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Area
   */

  export type AggregateArea = {
    _count: AreaCountAggregateOutputType | null
    _min: AreaMinAggregateOutputType | null
    _max: AreaMaxAggregateOutputType | null
  }

  export type AreaMinAggregateOutputType = {
    id: string | null
    mountainId: string | null
    name: string | null
    type: $Enums.AREA_TYPE | null
    description: string | null
  }

  export type AreaMaxAggregateOutputType = {
    id: string | null
    mountainId: string | null
    name: string | null
    type: $Enums.AREA_TYPE | null
    description: string | null
  }

  export type AreaCountAggregateOutputType = {
    id: number
    mountainId: number
    name: number
    type: number
    description: number
    _all: number
  }


  export type AreaMinAggregateInputType = {
    id?: true
    mountainId?: true
    name?: true
    type?: true
    description?: true
  }

  export type AreaMaxAggregateInputType = {
    id?: true
    mountainId?: true
    name?: true
    type?: true
    description?: true
  }

  export type AreaCountAggregateInputType = {
    id?: true
    mountainId?: true
    name?: true
    type?: true
    description?: true
    _all?: true
  }

  export type AreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Area to aggregate.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Areas
    **/
    _count?: true | AreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AreaMaxAggregateInputType
  }

  export type GetAreaAggregateType<T extends AreaAggregateArgs> = {
        [P in keyof T & keyof AggregateArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArea[P]>
      : GetScalarType<T[P], AggregateArea[P]>
  }




  export type AreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AreaWhereInput
    orderBy?: AreaOrderByWithAggregationInput | AreaOrderByWithAggregationInput[]
    by: AreaScalarFieldEnum[] | AreaScalarFieldEnum
    having?: AreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AreaCountAggregateInputType | true
    _min?: AreaMinAggregateInputType
    _max?: AreaMaxAggregateInputType
  }

  export type AreaGroupByOutputType = {
    id: string
    mountainId: string
    name: string
    type: $Enums.AREA_TYPE
    description: string | null
    _count: AreaCountAggregateOutputType | null
    _min: AreaMinAggregateOutputType | null
    _max: AreaMaxAggregateOutputType | null
  }

  type GetAreaGroupByPayload<T extends AreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AreaGroupByOutputType[P]>
            : GetScalarType<T[P], AreaGroupByOutputType[P]>
        }
      >
    >


  export type AreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    locations?: boolean | Area$locationsArgs<ExtArgs>
    _count?: boolean | AreaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["area"]>

  export type AreaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["area"]>

  export type AreaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["area"]>

  export type AreaSelectScalar = {
    id?: boolean
    mountainId?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
  }

  export type AreaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mountainId" | "name" | "type" | "description", ExtArgs["result"]["area"]>
  export type AreaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    locations?: boolean | Area$locationsArgs<ExtArgs>
    _count?: boolean | AreaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AreaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }
  export type AreaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }

  export type $AreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Area"
    objects: {
      mountain: Prisma.$MountainPayload<ExtArgs>
      locations: Prisma.$LocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mountainId: string
      name: string
      type: $Enums.AREA_TYPE
      description: string | null
    }, ExtArgs["result"]["area"]>
    composites: {}
  }

  type AreaGetPayload<S extends boolean | null | undefined | AreaDefaultArgs> = $Result.GetResult<Prisma.$AreaPayload, S>

  type AreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AreaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AreaCountAggregateInputType | true
    }

  export interface AreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Area'], meta: { name: 'Area' } }
    /**
     * Find zero or one Area that matches the filter.
     * @param {AreaFindUniqueArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AreaFindUniqueArgs>(args: SelectSubset<T, AreaFindUniqueArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Area that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AreaFindUniqueOrThrowArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AreaFindUniqueOrThrowArgs>(args: SelectSubset<T, AreaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Area that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindFirstArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AreaFindFirstArgs>(args?: SelectSubset<T, AreaFindFirstArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Area that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindFirstOrThrowArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AreaFindFirstOrThrowArgs>(args?: SelectSubset<T, AreaFindFirstOrThrowArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Areas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Areas
     * const areas = await prisma.area.findMany()
     * 
     * // Get first 10 Areas
     * const areas = await prisma.area.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const areaWithIdOnly = await prisma.area.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AreaFindManyArgs>(args?: SelectSubset<T, AreaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Area.
     * @param {AreaCreateArgs} args - Arguments to create a Area.
     * @example
     * // Create one Area
     * const Area = await prisma.area.create({
     *   data: {
     *     // ... data to create a Area
     *   }
     * })
     * 
     */
    create<T extends AreaCreateArgs>(args: SelectSubset<T, AreaCreateArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Areas.
     * @param {AreaCreateManyArgs} args - Arguments to create many Areas.
     * @example
     * // Create many Areas
     * const area = await prisma.area.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AreaCreateManyArgs>(args?: SelectSubset<T, AreaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Areas and returns the data saved in the database.
     * @param {AreaCreateManyAndReturnArgs} args - Arguments to create many Areas.
     * @example
     * // Create many Areas
     * const area = await prisma.area.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Areas and only return the `id`
     * const areaWithIdOnly = await prisma.area.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AreaCreateManyAndReturnArgs>(args?: SelectSubset<T, AreaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Area.
     * @param {AreaDeleteArgs} args - Arguments to delete one Area.
     * @example
     * // Delete one Area
     * const Area = await prisma.area.delete({
     *   where: {
     *     // ... filter to delete one Area
     *   }
     * })
     * 
     */
    delete<T extends AreaDeleteArgs>(args: SelectSubset<T, AreaDeleteArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Area.
     * @param {AreaUpdateArgs} args - Arguments to update one Area.
     * @example
     * // Update one Area
     * const area = await prisma.area.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AreaUpdateArgs>(args: SelectSubset<T, AreaUpdateArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Areas.
     * @param {AreaDeleteManyArgs} args - Arguments to filter Areas to delete.
     * @example
     * // Delete a few Areas
     * const { count } = await prisma.area.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AreaDeleteManyArgs>(args?: SelectSubset<T, AreaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Areas
     * const area = await prisma.area.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AreaUpdateManyArgs>(args: SelectSubset<T, AreaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Areas and returns the data updated in the database.
     * @param {AreaUpdateManyAndReturnArgs} args - Arguments to update many Areas.
     * @example
     * // Update many Areas
     * const area = await prisma.area.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Areas and only return the `id`
     * const areaWithIdOnly = await prisma.area.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AreaUpdateManyAndReturnArgs>(args: SelectSubset<T, AreaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Area.
     * @param {AreaUpsertArgs} args - Arguments to update or create a Area.
     * @example
     * // Update or create a Area
     * const area = await prisma.area.upsert({
     *   create: {
     *     // ... data to create a Area
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Area we want to update
     *   }
     * })
     */
    upsert<T extends AreaUpsertArgs>(args: SelectSubset<T, AreaUpsertArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaCountArgs} args - Arguments to filter Areas to count.
     * @example
     * // Count the number of Areas
     * const count = await prisma.area.count({
     *   where: {
     *     // ... the filter for the Areas we want to count
     *   }
     * })
    **/
    count<T extends AreaCountArgs>(
      args?: Subset<T, AreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AreaAggregateArgs>(args: Subset<T, AreaAggregateArgs>): Prisma.PrismaPromise<GetAreaAggregateType<T>>

    /**
     * Group by Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AreaGroupByArgs['orderBy'] }
        : { orderBy?: AreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Area model
   */
  readonly fields: AreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Area.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    locations<T extends Area$locationsArgs<ExtArgs> = {}>(args?: Subset<T, Area$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Area model
   */
  interface AreaFieldRefs {
    readonly id: FieldRef<"Area", 'String'>
    readonly mountainId: FieldRef<"Area", 'String'>
    readonly name: FieldRef<"Area", 'String'>
    readonly type: FieldRef<"Area", 'AREA_TYPE'>
    readonly description: FieldRef<"Area", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Area findUnique
   */
  export type AreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area findUniqueOrThrow
   */
  export type AreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area findFirst
   */
  export type AreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Areas.
     */
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area findFirstOrThrow
   */
  export type AreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Areas.
     */
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area findMany
   */
  export type AreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Areas to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area create
   */
  export type AreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The data needed to create a Area.
     */
    data: XOR<AreaCreateInput, AreaUncheckedCreateInput>
  }

  /**
   * Area createMany
   */
  export type AreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Areas.
     */
    data: AreaCreateManyInput | AreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Area createManyAndReturn
   */
  export type AreaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * The data used to create many Areas.
     */
    data: AreaCreateManyInput | AreaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Area update
   */
  export type AreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The data needed to update a Area.
     */
    data: XOR<AreaUpdateInput, AreaUncheckedUpdateInput>
    /**
     * Choose, which Area to update.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area updateMany
   */
  export type AreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Areas.
     */
    data: XOR<AreaUpdateManyMutationInput, AreaUncheckedUpdateManyInput>
    /**
     * Filter which Areas to update
     */
    where?: AreaWhereInput
    /**
     * Limit how many Areas to update.
     */
    limit?: number
  }

  /**
   * Area updateManyAndReturn
   */
  export type AreaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * The data used to update Areas.
     */
    data: XOR<AreaUpdateManyMutationInput, AreaUncheckedUpdateManyInput>
    /**
     * Filter which Areas to update
     */
    where?: AreaWhereInput
    /**
     * Limit how many Areas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Area upsert
   */
  export type AreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The filter to search for the Area to update in case it exists.
     */
    where: AreaWhereUniqueInput
    /**
     * In case the Area found by the `where` argument doesn't exist, create a new Area with this data.
     */
    create: XOR<AreaCreateInput, AreaUncheckedCreateInput>
    /**
     * In case the Area was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AreaUpdateInput, AreaUncheckedUpdateInput>
  }

  /**
   * Area delete
   */
  export type AreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter which Area to delete.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area deleteMany
   */
  export type AreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Areas to delete
     */
    where?: AreaWhereInput
    /**
     * Limit how many Areas to delete.
     */
    limit?: number
  }

  /**
   * Area.locations
   */
  export type Area$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Area without action
   */
  export type AreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    mountainId: string | null
    name: string | null
    areaId: string | null
    entityId: string | null
    entityType: $Enums.LOCATION_TYPE | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    mountainId: string | null
    name: string | null
    areaId: string | null
    entityId: string | null
    entityType: $Enums.LOCATION_TYPE | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    mountainId: number
    name: number
    areaId: number
    entityId: number
    entityType: number
    _all: number
  }


  export type LocationMinAggregateInputType = {
    id?: true
    mountainId?: true
    name?: true
    areaId?: true
    entityId?: true
    entityType?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    mountainId?: true
    name?: true
    areaId?: true
    entityId?: true
    entityType?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    mountainId?: true
    name?: true
    areaId?: true
    entityId?: true
    entityType?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    mountainId: string
    name: string
    areaId: string | null
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    name?: boolean
    areaId?: boolean
    entityId?: boolean
    entityType?: boolean
    area?: boolean | Location$areaArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    lift?: boolean | Location$liftArgs<ExtArgs>
    trail?: boolean | Location$trailArgs<ExtArgs>
    hut?: boolean | Location$hutArgs<ExtArgs>
    lodge?: boolean | Location$lodgeArgs<ExtArgs>
    aidRoom?: boolean | Location$aidRoomArgs<ExtArgs>
    hours?: boolean | Location$hoursArgs<ExtArgs>
    equipment?: boolean | Location$equipmentArgs<ExtArgs>
    incidents?: boolean | Location$incidentsArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    name?: boolean
    areaId?: boolean
    entityId?: boolean
    entityType?: boolean
    area?: boolean | Location$areaArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    name?: boolean
    areaId?: boolean
    entityId?: boolean
    entityType?: boolean
    area?: boolean | Location$areaArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    mountainId?: boolean
    name?: boolean
    areaId?: boolean
    entityId?: boolean
    entityType?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mountainId" | "name" | "areaId" | "entityId" | "entityType", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | Location$areaArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    lift?: boolean | Location$liftArgs<ExtArgs>
    trail?: boolean | Location$trailArgs<ExtArgs>
    hut?: boolean | Location$hutArgs<ExtArgs>
    lodge?: boolean | Location$lodgeArgs<ExtArgs>
    aidRoom?: boolean | Location$aidRoomArgs<ExtArgs>
    hours?: boolean | Location$hoursArgs<ExtArgs>
    equipment?: boolean | Location$equipmentArgs<ExtArgs>
    incidents?: boolean | Location$incidentsArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | Location$areaArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | Location$areaArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      area: Prisma.$AreaPayload<ExtArgs> | null
      mountain: Prisma.$MountainPayload<ExtArgs>
      lift: Prisma.$LiftPayload<ExtArgs> | null
      trail: Prisma.$TrailPayload<ExtArgs> | null
      hut: Prisma.$HutPayload<ExtArgs> | null
      lodge: Prisma.$LodgePayload<ExtArgs> | null
      aidRoom: Prisma.$AidRoomPayload<ExtArgs> | null
      hours: Prisma.$HoursPayload<ExtArgs>[]
      equipment: Prisma.$EquipmentPayload<ExtArgs>[]
      incidents: Prisma.$IncidentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mountainId: string
      name: string
      areaId: string | null
      entityId: string
      entityType: $Enums.LOCATION_TYPE
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    area<T extends Location$areaArgs<ExtArgs> = {}>(args?: Subset<T, Location$areaArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lift<T extends Location$liftArgs<ExtArgs> = {}>(args?: Subset<T, Location$liftArgs<ExtArgs>>): Prisma__LiftClient<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    trail<T extends Location$trailArgs<ExtArgs> = {}>(args?: Subset<T, Location$trailArgs<ExtArgs>>): Prisma__TrailClient<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    hut<T extends Location$hutArgs<ExtArgs> = {}>(args?: Subset<T, Location$hutArgs<ExtArgs>>): Prisma__HutClient<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lodge<T extends Location$lodgeArgs<ExtArgs> = {}>(args?: Subset<T, Location$lodgeArgs<ExtArgs>>): Prisma__LodgeClient<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    aidRoom<T extends Location$aidRoomArgs<ExtArgs> = {}>(args?: Subset<T, Location$aidRoomArgs<ExtArgs>>): Prisma__AidRoomClient<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    hours<T extends Location$hoursArgs<ExtArgs> = {}>(args?: Subset<T, Location$hoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoursPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipment<T extends Location$equipmentArgs<ExtArgs> = {}>(args?: Subset<T, Location$equipmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    incidents<T extends Location$incidentsArgs<ExtArgs> = {}>(args?: Subset<T, Location$incidentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly mountainId: FieldRef<"Location", 'String'>
    readonly name: FieldRef<"Location", 'String'>
    readonly areaId: FieldRef<"Location", 'String'>
    readonly entityId: FieldRef<"Location", 'String'>
    readonly entityType: FieldRef<"Location", 'LOCATION_TYPE'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location.area
   */
  export type Location$areaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    where?: AreaWhereInput
  }

  /**
   * Location.lift
   */
  export type Location$liftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
    where?: LiftWhereInput
  }

  /**
   * Location.trail
   */
  export type Location$trailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
    where?: TrailWhereInput
  }

  /**
   * Location.hut
   */
  export type Location$hutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
    where?: HutWhereInput
  }

  /**
   * Location.lodge
   */
  export type Location$lodgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
    where?: LodgeWhereInput
  }

  /**
   * Location.aidRoom
   */
  export type Location$aidRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
    where?: AidRoomWhereInput
  }

  /**
   * Location.hours
   */
  export type Location$hoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hours
     */
    select?: HoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hours
     */
    omit?: HoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoursInclude<ExtArgs> | null
    where?: HoursWhereInput
    orderBy?: HoursOrderByWithRelationInput | HoursOrderByWithRelationInput[]
    cursor?: HoursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HoursScalarFieldEnum | HoursScalarFieldEnum[]
  }

  /**
   * Location.equipment
   */
  export type Location$equipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    cursor?: EquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Location.incidents
   */
  export type Location$incidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    cursor?: IncidentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Hours
   */

  export type AggregateHours = {
    _count: HoursCountAggregateOutputType | null
    _avg: HoursAvgAggregateOutputType | null
    _sum: HoursSumAggregateOutputType | null
    _min: HoursMinAggregateOutputType | null
    _max: HoursMaxAggregateOutputType | null
  }

  export type HoursAvgAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type HoursSumAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type HoursMinAggregateOutputType = {
    id: string | null
    locationId: string | null
    dayOfWeek: number | null
    date: Date | null
    openTime: Date | null
    closeTime: Date | null
    status: $Enums.STATUS | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HoursMaxAggregateOutputType = {
    id: string | null
    locationId: string | null
    dayOfWeek: number | null
    date: Date | null
    openTime: Date | null
    closeTime: Date | null
    status: $Enums.STATUS | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HoursCountAggregateOutputType = {
    id: number
    locationId: number
    dayOfWeek: number
    date: number
    openTime: number
    closeTime: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HoursAvgAggregateInputType = {
    dayOfWeek?: true
  }

  export type HoursSumAggregateInputType = {
    dayOfWeek?: true
  }

  export type HoursMinAggregateInputType = {
    id?: true
    locationId?: true
    dayOfWeek?: true
    date?: true
    openTime?: true
    closeTime?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HoursMaxAggregateInputType = {
    id?: true
    locationId?: true
    dayOfWeek?: true
    date?: true
    openTime?: true
    closeTime?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HoursCountAggregateInputType = {
    id?: true
    locationId?: true
    dayOfWeek?: true
    date?: true
    openTime?: true
    closeTime?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HoursAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hours to aggregate.
     */
    where?: HoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hours to fetch.
     */
    orderBy?: HoursOrderByWithRelationInput | HoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hours
    **/
    _count?: true | HoursCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HoursAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HoursSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HoursMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HoursMaxAggregateInputType
  }

  export type GetHoursAggregateType<T extends HoursAggregateArgs> = {
        [P in keyof T & keyof AggregateHours]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHours[P]>
      : GetScalarType<T[P], AggregateHours[P]>
  }




  export type HoursGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HoursWhereInput
    orderBy?: HoursOrderByWithAggregationInput | HoursOrderByWithAggregationInput[]
    by: HoursScalarFieldEnum[] | HoursScalarFieldEnum
    having?: HoursScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HoursCountAggregateInputType | true
    _avg?: HoursAvgAggregateInputType
    _sum?: HoursSumAggregateInputType
    _min?: HoursMinAggregateInputType
    _max?: HoursMaxAggregateInputType
  }

  export type HoursGroupByOutputType = {
    id: string
    locationId: string
    dayOfWeek: number | null
    date: Date | null
    openTime: Date | null
    closeTime: Date | null
    status: $Enums.STATUS
    createdAt: Date
    updatedAt: Date
    _count: HoursCountAggregateOutputType | null
    _avg: HoursAvgAggregateOutputType | null
    _sum: HoursSumAggregateOutputType | null
    _min: HoursMinAggregateOutputType | null
    _max: HoursMaxAggregateOutputType | null
  }

  type GetHoursGroupByPayload<T extends HoursGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HoursGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HoursGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HoursGroupByOutputType[P]>
            : GetScalarType<T[P], HoursGroupByOutputType[P]>
        }
      >
    >


  export type HoursSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    dayOfWeek?: boolean
    date?: boolean
    openTime?: boolean
    closeTime?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hours"]>

  export type HoursSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    dayOfWeek?: boolean
    date?: boolean
    openTime?: boolean
    closeTime?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hours"]>

  export type HoursSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    dayOfWeek?: boolean
    date?: boolean
    openTime?: boolean
    closeTime?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hours"]>

  export type HoursSelectScalar = {
    id?: boolean
    locationId?: boolean
    dayOfWeek?: boolean
    date?: boolean
    openTime?: boolean
    closeTime?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HoursOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "locationId" | "dayOfWeek" | "date" | "openTime" | "closeTime" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["hours"]>
  export type HoursInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type HoursIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type HoursIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $HoursPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hours"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationId: string
      dayOfWeek: number | null
      date: Date | null
      openTime: Date | null
      closeTime: Date | null
      status: $Enums.STATUS
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hours"]>
    composites: {}
  }

  type HoursGetPayload<S extends boolean | null | undefined | HoursDefaultArgs> = $Result.GetResult<Prisma.$HoursPayload, S>

  type HoursCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HoursFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HoursCountAggregateInputType | true
    }

  export interface HoursDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hours'], meta: { name: 'Hours' } }
    /**
     * Find zero or one Hours that matches the filter.
     * @param {HoursFindUniqueArgs} args - Arguments to find a Hours
     * @example
     * // Get one Hours
     * const hours = await prisma.hours.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HoursFindUniqueArgs>(args: SelectSubset<T, HoursFindUniqueArgs<ExtArgs>>): Prisma__HoursClient<$Result.GetResult<Prisma.$HoursPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hours that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HoursFindUniqueOrThrowArgs} args - Arguments to find a Hours
     * @example
     * // Get one Hours
     * const hours = await prisma.hours.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HoursFindUniqueOrThrowArgs>(args: SelectSubset<T, HoursFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HoursClient<$Result.GetResult<Prisma.$HoursPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoursFindFirstArgs} args - Arguments to find a Hours
     * @example
     * // Get one Hours
     * const hours = await prisma.hours.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HoursFindFirstArgs>(args?: SelectSubset<T, HoursFindFirstArgs<ExtArgs>>): Prisma__HoursClient<$Result.GetResult<Prisma.$HoursPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hours that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoursFindFirstOrThrowArgs} args - Arguments to find a Hours
     * @example
     * // Get one Hours
     * const hours = await prisma.hours.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HoursFindFirstOrThrowArgs>(args?: SelectSubset<T, HoursFindFirstOrThrowArgs<ExtArgs>>): Prisma__HoursClient<$Result.GetResult<Prisma.$HoursPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoursFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hours
     * const hours = await prisma.hours.findMany()
     * 
     * // Get first 10 Hours
     * const hours = await prisma.hours.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hoursWithIdOnly = await prisma.hours.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HoursFindManyArgs>(args?: SelectSubset<T, HoursFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoursPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hours.
     * @param {HoursCreateArgs} args - Arguments to create a Hours.
     * @example
     * // Create one Hours
     * const Hours = await prisma.hours.create({
     *   data: {
     *     // ... data to create a Hours
     *   }
     * })
     * 
     */
    create<T extends HoursCreateArgs>(args: SelectSubset<T, HoursCreateArgs<ExtArgs>>): Prisma__HoursClient<$Result.GetResult<Prisma.$HoursPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hours.
     * @param {HoursCreateManyArgs} args - Arguments to create many Hours.
     * @example
     * // Create many Hours
     * const hours = await prisma.hours.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HoursCreateManyArgs>(args?: SelectSubset<T, HoursCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hours and returns the data saved in the database.
     * @param {HoursCreateManyAndReturnArgs} args - Arguments to create many Hours.
     * @example
     * // Create many Hours
     * const hours = await prisma.hours.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hours and only return the `id`
     * const hoursWithIdOnly = await prisma.hours.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HoursCreateManyAndReturnArgs>(args?: SelectSubset<T, HoursCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoursPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Hours.
     * @param {HoursDeleteArgs} args - Arguments to delete one Hours.
     * @example
     * // Delete one Hours
     * const Hours = await prisma.hours.delete({
     *   where: {
     *     // ... filter to delete one Hours
     *   }
     * })
     * 
     */
    delete<T extends HoursDeleteArgs>(args: SelectSubset<T, HoursDeleteArgs<ExtArgs>>): Prisma__HoursClient<$Result.GetResult<Prisma.$HoursPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hours.
     * @param {HoursUpdateArgs} args - Arguments to update one Hours.
     * @example
     * // Update one Hours
     * const hours = await prisma.hours.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HoursUpdateArgs>(args: SelectSubset<T, HoursUpdateArgs<ExtArgs>>): Prisma__HoursClient<$Result.GetResult<Prisma.$HoursPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hours.
     * @param {HoursDeleteManyArgs} args - Arguments to filter Hours to delete.
     * @example
     * // Delete a few Hours
     * const { count } = await prisma.hours.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HoursDeleteManyArgs>(args?: SelectSubset<T, HoursDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoursUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hours
     * const hours = await prisma.hours.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HoursUpdateManyArgs>(args: SelectSubset<T, HoursUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hours and returns the data updated in the database.
     * @param {HoursUpdateManyAndReturnArgs} args - Arguments to update many Hours.
     * @example
     * // Update many Hours
     * const hours = await prisma.hours.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Hours and only return the `id`
     * const hoursWithIdOnly = await prisma.hours.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HoursUpdateManyAndReturnArgs>(args: SelectSubset<T, HoursUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoursPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Hours.
     * @param {HoursUpsertArgs} args - Arguments to update or create a Hours.
     * @example
     * // Update or create a Hours
     * const hours = await prisma.hours.upsert({
     *   create: {
     *     // ... data to create a Hours
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hours we want to update
     *   }
     * })
     */
    upsert<T extends HoursUpsertArgs>(args: SelectSubset<T, HoursUpsertArgs<ExtArgs>>): Prisma__HoursClient<$Result.GetResult<Prisma.$HoursPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoursCountArgs} args - Arguments to filter Hours to count.
     * @example
     * // Count the number of Hours
     * const count = await prisma.hours.count({
     *   where: {
     *     // ... the filter for the Hours we want to count
     *   }
     * })
    **/
    count<T extends HoursCountArgs>(
      args?: Subset<T, HoursCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HoursCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoursAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HoursAggregateArgs>(args: Subset<T, HoursAggregateArgs>): Prisma.PrismaPromise<GetHoursAggregateType<T>>

    /**
     * Group by Hours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoursGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HoursGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HoursGroupByArgs['orderBy'] }
        : { orderBy?: HoursGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HoursGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHoursGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hours model
   */
  readonly fields: HoursFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hours.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HoursClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hours model
   */
  interface HoursFieldRefs {
    readonly id: FieldRef<"Hours", 'String'>
    readonly locationId: FieldRef<"Hours", 'String'>
    readonly dayOfWeek: FieldRef<"Hours", 'Int'>
    readonly date: FieldRef<"Hours", 'DateTime'>
    readonly openTime: FieldRef<"Hours", 'DateTime'>
    readonly closeTime: FieldRef<"Hours", 'DateTime'>
    readonly status: FieldRef<"Hours", 'STATUS'>
    readonly createdAt: FieldRef<"Hours", 'DateTime'>
    readonly updatedAt: FieldRef<"Hours", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Hours findUnique
   */
  export type HoursFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hours
     */
    select?: HoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hours
     */
    omit?: HoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoursInclude<ExtArgs> | null
    /**
     * Filter, which Hours to fetch.
     */
    where: HoursWhereUniqueInput
  }

  /**
   * Hours findUniqueOrThrow
   */
  export type HoursFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hours
     */
    select?: HoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hours
     */
    omit?: HoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoursInclude<ExtArgs> | null
    /**
     * Filter, which Hours to fetch.
     */
    where: HoursWhereUniqueInput
  }

  /**
   * Hours findFirst
   */
  export type HoursFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hours
     */
    select?: HoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hours
     */
    omit?: HoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoursInclude<ExtArgs> | null
    /**
     * Filter, which Hours to fetch.
     */
    where?: HoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hours to fetch.
     */
    orderBy?: HoursOrderByWithRelationInput | HoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hours.
     */
    cursor?: HoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hours.
     */
    distinct?: HoursScalarFieldEnum | HoursScalarFieldEnum[]
  }

  /**
   * Hours findFirstOrThrow
   */
  export type HoursFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hours
     */
    select?: HoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hours
     */
    omit?: HoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoursInclude<ExtArgs> | null
    /**
     * Filter, which Hours to fetch.
     */
    where?: HoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hours to fetch.
     */
    orderBy?: HoursOrderByWithRelationInput | HoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hours.
     */
    cursor?: HoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hours.
     */
    distinct?: HoursScalarFieldEnum | HoursScalarFieldEnum[]
  }

  /**
   * Hours findMany
   */
  export type HoursFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hours
     */
    select?: HoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hours
     */
    omit?: HoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoursInclude<ExtArgs> | null
    /**
     * Filter, which Hours to fetch.
     */
    where?: HoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hours to fetch.
     */
    orderBy?: HoursOrderByWithRelationInput | HoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hours.
     */
    cursor?: HoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hours.
     */
    skip?: number
    distinct?: HoursScalarFieldEnum | HoursScalarFieldEnum[]
  }

  /**
   * Hours create
   */
  export type HoursCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hours
     */
    select?: HoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hours
     */
    omit?: HoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoursInclude<ExtArgs> | null
    /**
     * The data needed to create a Hours.
     */
    data: XOR<HoursCreateInput, HoursUncheckedCreateInput>
  }

  /**
   * Hours createMany
   */
  export type HoursCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hours.
     */
    data: HoursCreateManyInput | HoursCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hours createManyAndReturn
   */
  export type HoursCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hours
     */
    select?: HoursSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hours
     */
    omit?: HoursOmit<ExtArgs> | null
    /**
     * The data used to create many Hours.
     */
    data: HoursCreateManyInput | HoursCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoursIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hours update
   */
  export type HoursUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hours
     */
    select?: HoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hours
     */
    omit?: HoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoursInclude<ExtArgs> | null
    /**
     * The data needed to update a Hours.
     */
    data: XOR<HoursUpdateInput, HoursUncheckedUpdateInput>
    /**
     * Choose, which Hours to update.
     */
    where: HoursWhereUniqueInput
  }

  /**
   * Hours updateMany
   */
  export type HoursUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hours.
     */
    data: XOR<HoursUpdateManyMutationInput, HoursUncheckedUpdateManyInput>
    /**
     * Filter which Hours to update
     */
    where?: HoursWhereInput
    /**
     * Limit how many Hours to update.
     */
    limit?: number
  }

  /**
   * Hours updateManyAndReturn
   */
  export type HoursUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hours
     */
    select?: HoursSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hours
     */
    omit?: HoursOmit<ExtArgs> | null
    /**
     * The data used to update Hours.
     */
    data: XOR<HoursUpdateManyMutationInput, HoursUncheckedUpdateManyInput>
    /**
     * Filter which Hours to update
     */
    where?: HoursWhereInput
    /**
     * Limit how many Hours to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoursIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hours upsert
   */
  export type HoursUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hours
     */
    select?: HoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hours
     */
    omit?: HoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoursInclude<ExtArgs> | null
    /**
     * The filter to search for the Hours to update in case it exists.
     */
    where: HoursWhereUniqueInput
    /**
     * In case the Hours found by the `where` argument doesn't exist, create a new Hours with this data.
     */
    create: XOR<HoursCreateInput, HoursUncheckedCreateInput>
    /**
     * In case the Hours was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HoursUpdateInput, HoursUncheckedUpdateInput>
  }

  /**
   * Hours delete
   */
  export type HoursDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hours
     */
    select?: HoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hours
     */
    omit?: HoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoursInclude<ExtArgs> | null
    /**
     * Filter which Hours to delete.
     */
    where: HoursWhereUniqueInput
  }

  /**
   * Hours deleteMany
   */
  export type HoursDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hours to delete
     */
    where?: HoursWhereInput
    /**
     * Limit how many Hours to delete.
     */
    limit?: number
  }

  /**
   * Hours without action
   */
  export type HoursDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hours
     */
    select?: HoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hours
     */
    omit?: HoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoursInclude<ExtArgs> | null
  }


  /**
   * Model Mountain
   */

  export type AggregateMountain = {
    _count: MountainCountAggregateOutputType | null
    _avg: MountainAvgAggregateOutputType | null
    _sum: MountainSumAggregateOutputType | null
    _min: MountainMinAggregateOutputType | null
    _max: MountainMaxAggregateOutputType | null
  }

  export type MountainAvgAggregateOutputType = {
    latitude: Decimal | null
    longitude: Decimal | null
    height: number | null
  }

  export type MountainSumAggregateOutputType = {
    latitude: Decimal | null
    longitude: Decimal | null
    height: number | null
  }

  export type MountainMinAggregateOutputType = {
    id: string | null
    name: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    height: number | null
    phoneNumber: string | null
    address: string | null
    city: string | null
    state: string | null
    zipcode: string | null
    openingDate: Date | null
    closingDate: Date | null
  }

  export type MountainMaxAggregateOutputType = {
    id: string | null
    name: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    height: number | null
    phoneNumber: string | null
    address: string | null
    city: string | null
    state: string | null
    zipcode: string | null
    openingDate: Date | null
    closingDate: Date | null
  }

  export type MountainCountAggregateOutputType = {
    id: number
    name: number
    latitude: number
    longitude: number
    height: number
    phoneNumber: number
    address: number
    city: number
    state: number
    zipcode: number
    openingDate: number
    closingDate: number
    _all: number
  }


  export type MountainAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    height?: true
  }

  export type MountainSumAggregateInputType = {
    latitude?: true
    longitude?: true
    height?: true
  }

  export type MountainMinAggregateInputType = {
    id?: true
    name?: true
    latitude?: true
    longitude?: true
    height?: true
    phoneNumber?: true
    address?: true
    city?: true
    state?: true
    zipcode?: true
    openingDate?: true
    closingDate?: true
  }

  export type MountainMaxAggregateInputType = {
    id?: true
    name?: true
    latitude?: true
    longitude?: true
    height?: true
    phoneNumber?: true
    address?: true
    city?: true
    state?: true
    zipcode?: true
    openingDate?: true
    closingDate?: true
  }

  export type MountainCountAggregateInputType = {
    id?: true
    name?: true
    latitude?: true
    longitude?: true
    height?: true
    phoneNumber?: true
    address?: true
    city?: true
    state?: true
    zipcode?: true
    openingDate?: true
    closingDate?: true
    _all?: true
  }

  export type MountainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mountain to aggregate.
     */
    where?: MountainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mountains to fetch.
     */
    orderBy?: MountainOrderByWithRelationInput | MountainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MountainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mountains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mountains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mountains
    **/
    _count?: true | MountainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MountainAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MountainSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MountainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MountainMaxAggregateInputType
  }

  export type GetMountainAggregateType<T extends MountainAggregateArgs> = {
        [P in keyof T & keyof AggregateMountain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMountain[P]>
      : GetScalarType<T[P], AggregateMountain[P]>
  }




  export type MountainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MountainWhereInput
    orderBy?: MountainOrderByWithAggregationInput | MountainOrderByWithAggregationInput[]
    by: MountainScalarFieldEnum[] | MountainScalarFieldEnum
    having?: MountainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MountainCountAggregateInputType | true
    _avg?: MountainAvgAggregateInputType
    _sum?: MountainSumAggregateInputType
    _min?: MountainMinAggregateInputType
    _max?: MountainMaxAggregateInputType
  }

  export type MountainGroupByOutputType = {
    id: string
    name: string
    latitude: Decimal | null
    longitude: Decimal | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate: Date | null
    closingDate: Date | null
    _count: MountainCountAggregateOutputType | null
    _avg: MountainAvgAggregateOutputType | null
    _sum: MountainSumAggregateOutputType | null
    _min: MountainMinAggregateOutputType | null
    _max: MountainMaxAggregateOutputType | null
  }

  type GetMountainGroupByPayload<T extends MountainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MountainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MountainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MountainGroupByOutputType[P]>
            : GetScalarType<T[P], MountainGroupByOutputType[P]>
        }
      >
    >


  export type MountainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    latitude?: boolean
    longitude?: boolean
    height?: boolean
    phoneNumber?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipcode?: boolean
    openingDate?: boolean
    closingDate?: boolean
    weather?: boolean | Mountain$weatherArgs<ExtArgs>
    locations?: boolean | Mountain$locationsArgs<ExtArgs>
    areas?: boolean | Mountain$areasArgs<ExtArgs>
    aidRooms?: boolean | Mountain$aidRoomsArgs<ExtArgs>
    huts?: boolean | Mountain$hutsArgs<ExtArgs>
    lodges?: boolean | Mountain$lodgesArgs<ExtArgs>
    lifts?: boolean | Mountain$liftsArgs<ExtArgs>
    trails?: boolean | Mountain$trailsArgs<ExtArgs>
    aidRoomChecks?: boolean | Mountain$aidRoomChecksArgs<ExtArgs>
    hutChecks?: boolean | Mountain$hutChecksArgs<ExtArgs>
    liftChecks?: boolean | Mountain$liftChecksArgs<ExtArgs>
    trailChecks?: boolean | Mountain$trailChecksArgs<ExtArgs>
    equipmentChecks?: boolean | Mountain$equipmentChecksArgs<ExtArgs>
    incidents?: boolean | Mountain$incidentsArgs<ExtArgs>
    equipment?: boolean | Mountain$equipmentArgs<ExtArgs>
    employeeAssignments?: boolean | Mountain$employeeAssignmentsArgs<ExtArgs>
    dispatcherAssignments?: boolean | Mountain$dispatcherAssignmentsArgs<ExtArgs>
    incidentEquipmentUsageLog?: boolean | Mountain$incidentEquipmentUsageLogArgs<ExtArgs>
    equipmentServiceLogs?: boolean | Mountain$equipmentServiceLogsArgs<ExtArgs>
    _count?: boolean | MountainCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mountain"]>

  export type MountainSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    latitude?: boolean
    longitude?: boolean
    height?: boolean
    phoneNumber?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipcode?: boolean
    openingDate?: boolean
    closingDate?: boolean
  }, ExtArgs["result"]["mountain"]>

  export type MountainSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    latitude?: boolean
    longitude?: boolean
    height?: boolean
    phoneNumber?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipcode?: boolean
    openingDate?: boolean
    closingDate?: boolean
  }, ExtArgs["result"]["mountain"]>

  export type MountainSelectScalar = {
    id?: boolean
    name?: boolean
    latitude?: boolean
    longitude?: boolean
    height?: boolean
    phoneNumber?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipcode?: boolean
    openingDate?: boolean
    closingDate?: boolean
  }

  export type MountainOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "latitude" | "longitude" | "height" | "phoneNumber" | "address" | "city" | "state" | "zipcode" | "openingDate" | "closingDate", ExtArgs["result"]["mountain"]>
  export type MountainInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weather?: boolean | Mountain$weatherArgs<ExtArgs>
    locations?: boolean | Mountain$locationsArgs<ExtArgs>
    areas?: boolean | Mountain$areasArgs<ExtArgs>
    aidRooms?: boolean | Mountain$aidRoomsArgs<ExtArgs>
    huts?: boolean | Mountain$hutsArgs<ExtArgs>
    lodges?: boolean | Mountain$lodgesArgs<ExtArgs>
    lifts?: boolean | Mountain$liftsArgs<ExtArgs>
    trails?: boolean | Mountain$trailsArgs<ExtArgs>
    aidRoomChecks?: boolean | Mountain$aidRoomChecksArgs<ExtArgs>
    hutChecks?: boolean | Mountain$hutChecksArgs<ExtArgs>
    liftChecks?: boolean | Mountain$liftChecksArgs<ExtArgs>
    trailChecks?: boolean | Mountain$trailChecksArgs<ExtArgs>
    equipmentChecks?: boolean | Mountain$equipmentChecksArgs<ExtArgs>
    incidents?: boolean | Mountain$incidentsArgs<ExtArgs>
    equipment?: boolean | Mountain$equipmentArgs<ExtArgs>
    employeeAssignments?: boolean | Mountain$employeeAssignmentsArgs<ExtArgs>
    dispatcherAssignments?: boolean | Mountain$dispatcherAssignmentsArgs<ExtArgs>
    incidentEquipmentUsageLog?: boolean | Mountain$incidentEquipmentUsageLogArgs<ExtArgs>
    equipmentServiceLogs?: boolean | Mountain$equipmentServiceLogsArgs<ExtArgs>
    _count?: boolean | MountainCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MountainIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MountainIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MountainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mountain"
    objects: {
      weather: Prisma.$WeatherPayload<ExtArgs>[]
      locations: Prisma.$LocationPayload<ExtArgs>[]
      areas: Prisma.$AreaPayload<ExtArgs>[]
      aidRooms: Prisma.$AidRoomPayload<ExtArgs>[]
      huts: Prisma.$HutPayload<ExtArgs>[]
      lodges: Prisma.$LodgePayload<ExtArgs>[]
      lifts: Prisma.$LiftPayload<ExtArgs>[]
      trails: Prisma.$TrailPayload<ExtArgs>[]
      aidRoomChecks: Prisma.$AidRoomCheckPayload<ExtArgs>[]
      hutChecks: Prisma.$HutCheckPayload<ExtArgs>[]
      liftChecks: Prisma.$LiftCheckPayload<ExtArgs>[]
      trailChecks: Prisma.$TrailCheckPayload<ExtArgs>[]
      equipmentChecks: Prisma.$EquipmentCheckPayload<ExtArgs>[]
      incidents: Prisma.$IncidentPayload<ExtArgs>[]
      equipment: Prisma.$EquipmentPayload<ExtArgs>[]
      employeeAssignments: Prisma.$EmployeeMountainAssignmentPayload<ExtArgs>[]
      dispatcherAssignments: Prisma.$DispatcherAssignmentPayload<ExtArgs>[]
      incidentEquipmentUsageLog: Prisma.$IncidentEquipmentUsageLogPayload<ExtArgs>[]
      equipmentServiceLogs: Prisma.$EquipmentServiceLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      latitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      height: number
      phoneNumber: string
      address: string
      city: string
      state: string
      zipcode: string
      openingDate: Date | null
      closingDate: Date | null
    }, ExtArgs["result"]["mountain"]>
    composites: {}
  }

  type MountainGetPayload<S extends boolean | null | undefined | MountainDefaultArgs> = $Result.GetResult<Prisma.$MountainPayload, S>

  type MountainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MountainFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MountainCountAggregateInputType | true
    }

  export interface MountainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mountain'], meta: { name: 'Mountain' } }
    /**
     * Find zero or one Mountain that matches the filter.
     * @param {MountainFindUniqueArgs} args - Arguments to find a Mountain
     * @example
     * // Get one Mountain
     * const mountain = await prisma.mountain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MountainFindUniqueArgs>(args: SelectSubset<T, MountainFindUniqueArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mountain that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MountainFindUniqueOrThrowArgs} args - Arguments to find a Mountain
     * @example
     * // Get one Mountain
     * const mountain = await prisma.mountain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MountainFindUniqueOrThrowArgs>(args: SelectSubset<T, MountainFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mountain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MountainFindFirstArgs} args - Arguments to find a Mountain
     * @example
     * // Get one Mountain
     * const mountain = await prisma.mountain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MountainFindFirstArgs>(args?: SelectSubset<T, MountainFindFirstArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mountain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MountainFindFirstOrThrowArgs} args - Arguments to find a Mountain
     * @example
     * // Get one Mountain
     * const mountain = await prisma.mountain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MountainFindFirstOrThrowArgs>(args?: SelectSubset<T, MountainFindFirstOrThrowArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mountains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MountainFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mountains
     * const mountains = await prisma.mountain.findMany()
     * 
     * // Get first 10 Mountains
     * const mountains = await prisma.mountain.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mountainWithIdOnly = await prisma.mountain.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MountainFindManyArgs>(args?: SelectSubset<T, MountainFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mountain.
     * @param {MountainCreateArgs} args - Arguments to create a Mountain.
     * @example
     * // Create one Mountain
     * const Mountain = await prisma.mountain.create({
     *   data: {
     *     // ... data to create a Mountain
     *   }
     * })
     * 
     */
    create<T extends MountainCreateArgs>(args: SelectSubset<T, MountainCreateArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mountains.
     * @param {MountainCreateManyArgs} args - Arguments to create many Mountains.
     * @example
     * // Create many Mountains
     * const mountain = await prisma.mountain.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MountainCreateManyArgs>(args?: SelectSubset<T, MountainCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mountains and returns the data saved in the database.
     * @param {MountainCreateManyAndReturnArgs} args - Arguments to create many Mountains.
     * @example
     * // Create many Mountains
     * const mountain = await prisma.mountain.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mountains and only return the `id`
     * const mountainWithIdOnly = await prisma.mountain.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MountainCreateManyAndReturnArgs>(args?: SelectSubset<T, MountainCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mountain.
     * @param {MountainDeleteArgs} args - Arguments to delete one Mountain.
     * @example
     * // Delete one Mountain
     * const Mountain = await prisma.mountain.delete({
     *   where: {
     *     // ... filter to delete one Mountain
     *   }
     * })
     * 
     */
    delete<T extends MountainDeleteArgs>(args: SelectSubset<T, MountainDeleteArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mountain.
     * @param {MountainUpdateArgs} args - Arguments to update one Mountain.
     * @example
     * // Update one Mountain
     * const mountain = await prisma.mountain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MountainUpdateArgs>(args: SelectSubset<T, MountainUpdateArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mountains.
     * @param {MountainDeleteManyArgs} args - Arguments to filter Mountains to delete.
     * @example
     * // Delete a few Mountains
     * const { count } = await prisma.mountain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MountainDeleteManyArgs>(args?: SelectSubset<T, MountainDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mountains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MountainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mountains
     * const mountain = await prisma.mountain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MountainUpdateManyArgs>(args: SelectSubset<T, MountainUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mountains and returns the data updated in the database.
     * @param {MountainUpdateManyAndReturnArgs} args - Arguments to update many Mountains.
     * @example
     * // Update many Mountains
     * const mountain = await prisma.mountain.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mountains and only return the `id`
     * const mountainWithIdOnly = await prisma.mountain.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MountainUpdateManyAndReturnArgs>(args: SelectSubset<T, MountainUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mountain.
     * @param {MountainUpsertArgs} args - Arguments to update or create a Mountain.
     * @example
     * // Update or create a Mountain
     * const mountain = await prisma.mountain.upsert({
     *   create: {
     *     // ... data to create a Mountain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mountain we want to update
     *   }
     * })
     */
    upsert<T extends MountainUpsertArgs>(args: SelectSubset<T, MountainUpsertArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mountains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MountainCountArgs} args - Arguments to filter Mountains to count.
     * @example
     * // Count the number of Mountains
     * const count = await prisma.mountain.count({
     *   where: {
     *     // ... the filter for the Mountains we want to count
     *   }
     * })
    **/
    count<T extends MountainCountArgs>(
      args?: Subset<T, MountainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MountainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mountain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MountainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MountainAggregateArgs>(args: Subset<T, MountainAggregateArgs>): Prisma.PrismaPromise<GetMountainAggregateType<T>>

    /**
     * Group by Mountain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MountainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MountainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MountainGroupByArgs['orderBy'] }
        : { orderBy?: MountainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MountainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMountainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mountain model
   */
  readonly fields: MountainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mountain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MountainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    weather<T extends Mountain$weatherArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$weatherArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    locations<T extends Mountain$locationsArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    areas<T extends Mountain$areasArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$areasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aidRooms<T extends Mountain$aidRoomsArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$aidRoomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    huts<T extends Mountain$hutsArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$hutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lodges<T extends Mountain$lodgesArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$lodgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lifts<T extends Mountain$liftsArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$liftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trails<T extends Mountain$trailsArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$trailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aidRoomChecks<T extends Mountain$aidRoomChecksArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$aidRoomChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hutChecks<T extends Mountain$hutChecksArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$hutChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    liftChecks<T extends Mountain$liftChecksArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$liftChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trailChecks<T extends Mountain$trailChecksArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$trailChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipmentChecks<T extends Mountain$equipmentChecksArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$equipmentChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    incidents<T extends Mountain$incidentsArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$incidentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipment<T extends Mountain$equipmentArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$equipmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employeeAssignments<T extends Mountain$employeeAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$employeeAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeMountainAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dispatcherAssignments<T extends Mountain$dispatcherAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$dispatcherAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    incidentEquipmentUsageLog<T extends Mountain$incidentEquipmentUsageLogArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$incidentEquipmentUsageLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentEquipmentUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipmentServiceLogs<T extends Mountain$equipmentServiceLogsArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$equipmentServiceLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentServiceLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mountain model
   */
  interface MountainFieldRefs {
    readonly id: FieldRef<"Mountain", 'String'>
    readonly name: FieldRef<"Mountain", 'String'>
    readonly latitude: FieldRef<"Mountain", 'Decimal'>
    readonly longitude: FieldRef<"Mountain", 'Decimal'>
    readonly height: FieldRef<"Mountain", 'Int'>
    readonly phoneNumber: FieldRef<"Mountain", 'String'>
    readonly address: FieldRef<"Mountain", 'String'>
    readonly city: FieldRef<"Mountain", 'String'>
    readonly state: FieldRef<"Mountain", 'String'>
    readonly zipcode: FieldRef<"Mountain", 'String'>
    readonly openingDate: FieldRef<"Mountain", 'DateTime'>
    readonly closingDate: FieldRef<"Mountain", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Mountain findUnique
   */
  export type MountainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MountainInclude<ExtArgs> | null
    /**
     * Filter, which Mountain to fetch.
     */
    where: MountainWhereUniqueInput
  }

  /**
   * Mountain findUniqueOrThrow
   */
  export type MountainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MountainInclude<ExtArgs> | null
    /**
     * Filter, which Mountain to fetch.
     */
    where: MountainWhereUniqueInput
  }

  /**
   * Mountain findFirst
   */
  export type MountainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MountainInclude<ExtArgs> | null
    /**
     * Filter, which Mountain to fetch.
     */
    where?: MountainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mountains to fetch.
     */
    orderBy?: MountainOrderByWithRelationInput | MountainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mountains.
     */
    cursor?: MountainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mountains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mountains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mountains.
     */
    distinct?: MountainScalarFieldEnum | MountainScalarFieldEnum[]
  }

  /**
   * Mountain findFirstOrThrow
   */
  export type MountainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MountainInclude<ExtArgs> | null
    /**
     * Filter, which Mountain to fetch.
     */
    where?: MountainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mountains to fetch.
     */
    orderBy?: MountainOrderByWithRelationInput | MountainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mountains.
     */
    cursor?: MountainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mountains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mountains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mountains.
     */
    distinct?: MountainScalarFieldEnum | MountainScalarFieldEnum[]
  }

  /**
   * Mountain findMany
   */
  export type MountainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MountainInclude<ExtArgs> | null
    /**
     * Filter, which Mountains to fetch.
     */
    where?: MountainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mountains to fetch.
     */
    orderBy?: MountainOrderByWithRelationInput | MountainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mountains.
     */
    cursor?: MountainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mountains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mountains.
     */
    skip?: number
    distinct?: MountainScalarFieldEnum | MountainScalarFieldEnum[]
  }

  /**
   * Mountain create
   */
  export type MountainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MountainInclude<ExtArgs> | null
    /**
     * The data needed to create a Mountain.
     */
    data: XOR<MountainCreateInput, MountainUncheckedCreateInput>
  }

  /**
   * Mountain createMany
   */
  export type MountainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mountains.
     */
    data: MountainCreateManyInput | MountainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mountain createManyAndReturn
   */
  export type MountainCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * The data used to create many Mountains.
     */
    data: MountainCreateManyInput | MountainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mountain update
   */
  export type MountainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MountainInclude<ExtArgs> | null
    /**
     * The data needed to update a Mountain.
     */
    data: XOR<MountainUpdateInput, MountainUncheckedUpdateInput>
    /**
     * Choose, which Mountain to update.
     */
    where: MountainWhereUniqueInput
  }

  /**
   * Mountain updateMany
   */
  export type MountainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mountains.
     */
    data: XOR<MountainUpdateManyMutationInput, MountainUncheckedUpdateManyInput>
    /**
     * Filter which Mountains to update
     */
    where?: MountainWhereInput
    /**
     * Limit how many Mountains to update.
     */
    limit?: number
  }

  /**
   * Mountain updateManyAndReturn
   */
  export type MountainUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * The data used to update Mountains.
     */
    data: XOR<MountainUpdateManyMutationInput, MountainUncheckedUpdateManyInput>
    /**
     * Filter which Mountains to update
     */
    where?: MountainWhereInput
    /**
     * Limit how many Mountains to update.
     */
    limit?: number
  }

  /**
   * Mountain upsert
   */
  export type MountainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MountainInclude<ExtArgs> | null
    /**
     * The filter to search for the Mountain to update in case it exists.
     */
    where: MountainWhereUniqueInput
    /**
     * In case the Mountain found by the `where` argument doesn't exist, create a new Mountain with this data.
     */
    create: XOR<MountainCreateInput, MountainUncheckedCreateInput>
    /**
     * In case the Mountain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MountainUpdateInput, MountainUncheckedUpdateInput>
  }

  /**
   * Mountain delete
   */
  export type MountainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MountainInclude<ExtArgs> | null
    /**
     * Filter which Mountain to delete.
     */
    where: MountainWhereUniqueInput
  }

  /**
   * Mountain deleteMany
   */
  export type MountainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mountains to delete
     */
    where?: MountainWhereInput
    /**
     * Limit how many Mountains to delete.
     */
    limit?: number
  }

  /**
   * Mountain.weather
   */
  export type Mountain$weatherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    where?: WeatherWhereInput
    orderBy?: WeatherOrderByWithRelationInput | WeatherOrderByWithRelationInput[]
    cursor?: WeatherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeatherScalarFieldEnum | WeatherScalarFieldEnum[]
  }

  /**
   * Mountain.locations
   */
  export type Mountain$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Mountain.areas
   */
  export type Mountain$areasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    where?: AreaWhereInput
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    cursor?: AreaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Mountain.aidRooms
   */
  export type Mountain$aidRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
    where?: AidRoomWhereInput
    orderBy?: AidRoomOrderByWithRelationInput | AidRoomOrderByWithRelationInput[]
    cursor?: AidRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AidRoomScalarFieldEnum | AidRoomScalarFieldEnum[]
  }

  /**
   * Mountain.huts
   */
  export type Mountain$hutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
    where?: HutWhereInput
    orderBy?: HutOrderByWithRelationInput | HutOrderByWithRelationInput[]
    cursor?: HutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HutScalarFieldEnum | HutScalarFieldEnum[]
  }

  /**
   * Mountain.lodges
   */
  export type Mountain$lodgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
    where?: LodgeWhereInput
    orderBy?: LodgeOrderByWithRelationInput | LodgeOrderByWithRelationInput[]
    cursor?: LodgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LodgeScalarFieldEnum | LodgeScalarFieldEnum[]
  }

  /**
   * Mountain.lifts
   */
  export type Mountain$liftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
    where?: LiftWhereInput
    orderBy?: LiftOrderByWithRelationInput | LiftOrderByWithRelationInput[]
    cursor?: LiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiftScalarFieldEnum | LiftScalarFieldEnum[]
  }

  /**
   * Mountain.trails
   */
  export type Mountain$trailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
    where?: TrailWhereInput
    orderBy?: TrailOrderByWithRelationInput | TrailOrderByWithRelationInput[]
    cursor?: TrailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrailScalarFieldEnum | TrailScalarFieldEnum[]
  }

  /**
   * Mountain.aidRoomChecks
   */
  export type Mountain$aidRoomChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    where?: AidRoomCheckWhereInput
    orderBy?: AidRoomCheckOrderByWithRelationInput | AidRoomCheckOrderByWithRelationInput[]
    cursor?: AidRoomCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AidRoomCheckScalarFieldEnum | AidRoomCheckScalarFieldEnum[]
  }

  /**
   * Mountain.hutChecks
   */
  export type Mountain$hutChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    where?: HutCheckWhereInput
    orderBy?: HutCheckOrderByWithRelationInput | HutCheckOrderByWithRelationInput[]
    cursor?: HutCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HutCheckScalarFieldEnum | HutCheckScalarFieldEnum[]
  }

  /**
   * Mountain.liftChecks
   */
  export type Mountain$liftChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    where?: LiftCheckWhereInput
    orderBy?: LiftCheckOrderByWithRelationInput | LiftCheckOrderByWithRelationInput[]
    cursor?: LiftCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiftCheckScalarFieldEnum | LiftCheckScalarFieldEnum[]
  }

  /**
   * Mountain.trailChecks
   */
  export type Mountain$trailChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    where?: TrailCheckWhereInput
    orderBy?: TrailCheckOrderByWithRelationInput | TrailCheckOrderByWithRelationInput[]
    cursor?: TrailCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrailCheckScalarFieldEnum | TrailCheckScalarFieldEnum[]
  }

  /**
   * Mountain.equipmentChecks
   */
  export type Mountain$equipmentChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    where?: EquipmentCheckWhereInput
    orderBy?: EquipmentCheckOrderByWithRelationInput | EquipmentCheckOrderByWithRelationInput[]
    cursor?: EquipmentCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentCheckScalarFieldEnum | EquipmentCheckScalarFieldEnum[]
  }

  /**
   * Mountain.incidents
   */
  export type Mountain$incidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    cursor?: IncidentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Mountain.equipment
   */
  export type Mountain$equipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    cursor?: EquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Mountain.employeeAssignments
   */
  export type Mountain$employeeAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeMountainAssignment
     */
    select?: EmployeeMountainAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeMountainAssignment
     */
    omit?: EmployeeMountainAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeMountainAssignmentInclude<ExtArgs> | null
    where?: EmployeeMountainAssignmentWhereInput
    orderBy?: EmployeeMountainAssignmentOrderByWithRelationInput | EmployeeMountainAssignmentOrderByWithRelationInput[]
    cursor?: EmployeeMountainAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeMountainAssignmentScalarFieldEnum | EmployeeMountainAssignmentScalarFieldEnum[]
  }

  /**
   * Mountain.dispatcherAssignments
   */
  export type Mountain$dispatcherAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
    where?: DispatcherAssignmentWhereInput
    orderBy?: DispatcherAssignmentOrderByWithRelationInput | DispatcherAssignmentOrderByWithRelationInput[]
    cursor?: DispatcherAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DispatcherAssignmentScalarFieldEnum | DispatcherAssignmentScalarFieldEnum[]
  }

  /**
   * Mountain.incidentEquipmentUsageLog
   */
  export type Mountain$incidentEquipmentUsageLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentEquipmentUsageLog
     */
    select?: IncidentEquipmentUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentEquipmentUsageLog
     */
    omit?: IncidentEquipmentUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentEquipmentUsageLogInclude<ExtArgs> | null
    where?: IncidentEquipmentUsageLogWhereInput
    orderBy?: IncidentEquipmentUsageLogOrderByWithRelationInput | IncidentEquipmentUsageLogOrderByWithRelationInput[]
    cursor?: IncidentEquipmentUsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentEquipmentUsageLogScalarFieldEnum | IncidentEquipmentUsageLogScalarFieldEnum[]
  }

  /**
   * Mountain.equipmentServiceLogs
   */
  export type Mountain$equipmentServiceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentServiceLog
     */
    select?: EquipmentServiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentServiceLog
     */
    omit?: EquipmentServiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentServiceLogInclude<ExtArgs> | null
    where?: EquipmentServiceLogWhereInput
    orderBy?: EquipmentServiceLogOrderByWithRelationInput | EquipmentServiceLogOrderByWithRelationInput[]
    cursor?: EquipmentServiceLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentServiceLogScalarFieldEnum | EquipmentServiceLogScalarFieldEnum[]
  }

  /**
   * Mountain without action
   */
  export type MountainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MountainInclude<ExtArgs> | null
  }


  /**
   * Model Weather
   */

  export type AggregateWeather = {
    _count: WeatherCountAggregateOutputType | null
    _avg: WeatherAvgAggregateOutputType | null
    _sum: WeatherSumAggregateOutputType | null
    _min: WeatherMinAggregateOutputType | null
    _max: WeatherMaxAggregateOutputType | null
  }

  export type WeatherAvgAggregateOutputType = {
    temperature: number | null
    windSpeed: number | null
    visibility: number | null
    snowfallRecent: number | null
    snowfall24h: number | null
    snowfall7d: number | null
  }

  export type WeatherSumAggregateOutputType = {
    temperature: number | null
    windSpeed: number | null
    visibility: number | null
    snowfallRecent: number | null
    snowfall24h: number | null
    snowfall7d: number | null
  }

  export type WeatherMinAggregateOutputType = {
    id: string | null
    mountainId: string | null
    date: Date | null
    temperature: number | null
    windSpeed: number | null
    windDirection: string | null
    visibility: number | null
    conditions: string | null
    snowfallRecent: number | null
    snowfall24h: number | null
    snowfall7d: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WeatherMaxAggregateOutputType = {
    id: string | null
    mountainId: string | null
    date: Date | null
    temperature: number | null
    windSpeed: number | null
    windDirection: string | null
    visibility: number | null
    conditions: string | null
    snowfallRecent: number | null
    snowfall24h: number | null
    snowfall7d: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WeatherCountAggregateOutputType = {
    id: number
    mountainId: number
    date: number
    temperature: number
    windSpeed: number
    windDirection: number
    visibility: number
    conditions: number
    snowfallRecent: number
    snowfall24h: number
    snowfall7d: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WeatherAvgAggregateInputType = {
    temperature?: true
    windSpeed?: true
    visibility?: true
    snowfallRecent?: true
    snowfall24h?: true
    snowfall7d?: true
  }

  export type WeatherSumAggregateInputType = {
    temperature?: true
    windSpeed?: true
    visibility?: true
    snowfallRecent?: true
    snowfall24h?: true
    snowfall7d?: true
  }

  export type WeatherMinAggregateInputType = {
    id?: true
    mountainId?: true
    date?: true
    temperature?: true
    windSpeed?: true
    windDirection?: true
    visibility?: true
    conditions?: true
    snowfallRecent?: true
    snowfall24h?: true
    snowfall7d?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WeatherMaxAggregateInputType = {
    id?: true
    mountainId?: true
    date?: true
    temperature?: true
    windSpeed?: true
    windDirection?: true
    visibility?: true
    conditions?: true
    snowfallRecent?: true
    snowfall24h?: true
    snowfall7d?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WeatherCountAggregateInputType = {
    id?: true
    mountainId?: true
    date?: true
    temperature?: true
    windSpeed?: true
    windDirection?: true
    visibility?: true
    conditions?: true
    snowfallRecent?: true
    snowfall24h?: true
    snowfall7d?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WeatherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weather to aggregate.
     */
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     */
    orderBy?: WeatherOrderByWithRelationInput | WeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Weathers
    **/
    _count?: true | WeatherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeatherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeatherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeatherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeatherMaxAggregateInputType
  }

  export type GetWeatherAggregateType<T extends WeatherAggregateArgs> = {
        [P in keyof T & keyof AggregateWeather]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeather[P]>
      : GetScalarType<T[P], AggregateWeather[P]>
  }




  export type WeatherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeatherWhereInput
    orderBy?: WeatherOrderByWithAggregationInput | WeatherOrderByWithAggregationInput[]
    by: WeatherScalarFieldEnum[] | WeatherScalarFieldEnum
    having?: WeatherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeatherCountAggregateInputType | true
    _avg?: WeatherAvgAggregateInputType
    _sum?: WeatherSumAggregateInputType
    _min?: WeatherMinAggregateInputType
    _max?: WeatherMaxAggregateInputType
  }

  export type WeatherGroupByOutputType = {
    id: string
    mountainId: string
    date: Date
    temperature: number
    windSpeed: number
    windDirection: string | null
    visibility: number | null
    conditions: string
    snowfallRecent: number | null
    snowfall24h: number | null
    snowfall7d: number | null
    createdAt: Date
    updatedAt: Date
    _count: WeatherCountAggregateOutputType | null
    _avg: WeatherAvgAggregateOutputType | null
    _sum: WeatherSumAggregateOutputType | null
    _min: WeatherMinAggregateOutputType | null
    _max: WeatherMaxAggregateOutputType | null
  }

  type GetWeatherGroupByPayload<T extends WeatherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeatherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeatherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeatherGroupByOutputType[P]>
            : GetScalarType<T[P], WeatherGroupByOutputType[P]>
        }
      >
    >


  export type WeatherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    date?: boolean
    temperature?: boolean
    windSpeed?: boolean
    windDirection?: boolean
    visibility?: boolean
    conditions?: boolean
    snowfallRecent?: boolean
    snowfall24h?: boolean
    snowfall7d?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weather"]>

  export type WeatherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    date?: boolean
    temperature?: boolean
    windSpeed?: boolean
    windDirection?: boolean
    visibility?: boolean
    conditions?: boolean
    snowfallRecent?: boolean
    snowfall24h?: boolean
    snowfall7d?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weather"]>

  export type WeatherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    date?: boolean
    temperature?: boolean
    windSpeed?: boolean
    windDirection?: boolean
    visibility?: boolean
    conditions?: boolean
    snowfallRecent?: boolean
    snowfall24h?: boolean
    snowfall7d?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weather"]>

  export type WeatherSelectScalar = {
    id?: boolean
    mountainId?: boolean
    date?: boolean
    temperature?: boolean
    windSpeed?: boolean
    windDirection?: boolean
    visibility?: boolean
    conditions?: boolean
    snowfallRecent?: boolean
    snowfall24h?: boolean
    snowfall7d?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WeatherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mountainId" | "date" | "temperature" | "windSpeed" | "windDirection" | "visibility" | "conditions" | "snowfallRecent" | "snowfall24h" | "snowfall7d" | "createdAt" | "updatedAt", ExtArgs["result"]["weather"]>
  export type WeatherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }
  export type WeatherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }
  export type WeatherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }

  export type $WeatherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Weather"
    objects: {
      mountain: Prisma.$MountainPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mountainId: string
      date: Date
      temperature: number
      windSpeed: number
      windDirection: string | null
      visibility: number | null
      conditions: string
      snowfallRecent: number | null
      snowfall24h: number | null
      snowfall7d: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["weather"]>
    composites: {}
  }

  type WeatherGetPayload<S extends boolean | null | undefined | WeatherDefaultArgs> = $Result.GetResult<Prisma.$WeatherPayload, S>

  type WeatherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeatherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeatherCountAggregateInputType | true
    }

  export interface WeatherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Weather'], meta: { name: 'Weather' } }
    /**
     * Find zero or one Weather that matches the filter.
     * @param {WeatherFindUniqueArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeatherFindUniqueArgs>(args: SelectSubset<T, WeatherFindUniqueArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Weather that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeatherFindUniqueOrThrowArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeatherFindUniqueOrThrowArgs>(args: SelectSubset<T, WeatherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weather that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherFindFirstArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeatherFindFirstArgs>(args?: SelectSubset<T, WeatherFindFirstArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weather that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherFindFirstOrThrowArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeatherFindFirstOrThrowArgs>(args?: SelectSubset<T, WeatherFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Weathers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weathers
     * const weathers = await prisma.weather.findMany()
     * 
     * // Get first 10 Weathers
     * const weathers = await prisma.weather.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weatherWithIdOnly = await prisma.weather.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeatherFindManyArgs>(args?: SelectSubset<T, WeatherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Weather.
     * @param {WeatherCreateArgs} args - Arguments to create a Weather.
     * @example
     * // Create one Weather
     * const Weather = await prisma.weather.create({
     *   data: {
     *     // ... data to create a Weather
     *   }
     * })
     * 
     */
    create<T extends WeatherCreateArgs>(args: SelectSubset<T, WeatherCreateArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Weathers.
     * @param {WeatherCreateManyArgs} args - Arguments to create many Weathers.
     * @example
     * // Create many Weathers
     * const weather = await prisma.weather.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeatherCreateManyArgs>(args?: SelectSubset<T, WeatherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Weathers and returns the data saved in the database.
     * @param {WeatherCreateManyAndReturnArgs} args - Arguments to create many Weathers.
     * @example
     * // Create many Weathers
     * const weather = await prisma.weather.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Weathers and only return the `id`
     * const weatherWithIdOnly = await prisma.weather.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeatherCreateManyAndReturnArgs>(args?: SelectSubset<T, WeatherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Weather.
     * @param {WeatherDeleteArgs} args - Arguments to delete one Weather.
     * @example
     * // Delete one Weather
     * const Weather = await prisma.weather.delete({
     *   where: {
     *     // ... filter to delete one Weather
     *   }
     * })
     * 
     */
    delete<T extends WeatherDeleteArgs>(args: SelectSubset<T, WeatherDeleteArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Weather.
     * @param {WeatherUpdateArgs} args - Arguments to update one Weather.
     * @example
     * // Update one Weather
     * const weather = await prisma.weather.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeatherUpdateArgs>(args: SelectSubset<T, WeatherUpdateArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Weathers.
     * @param {WeatherDeleteManyArgs} args - Arguments to filter Weathers to delete.
     * @example
     * // Delete a few Weathers
     * const { count } = await prisma.weather.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeatherDeleteManyArgs>(args?: SelectSubset<T, WeatherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weathers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weathers
     * const weather = await prisma.weather.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeatherUpdateManyArgs>(args: SelectSubset<T, WeatherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weathers and returns the data updated in the database.
     * @param {WeatherUpdateManyAndReturnArgs} args - Arguments to update many Weathers.
     * @example
     * // Update many Weathers
     * const weather = await prisma.weather.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Weathers and only return the `id`
     * const weatherWithIdOnly = await prisma.weather.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeatherUpdateManyAndReturnArgs>(args: SelectSubset<T, WeatherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Weather.
     * @param {WeatherUpsertArgs} args - Arguments to update or create a Weather.
     * @example
     * // Update or create a Weather
     * const weather = await prisma.weather.upsert({
     *   create: {
     *     // ... data to create a Weather
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weather we want to update
     *   }
     * })
     */
    upsert<T extends WeatherUpsertArgs>(args: SelectSubset<T, WeatherUpsertArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Weathers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherCountArgs} args - Arguments to filter Weathers to count.
     * @example
     * // Count the number of Weathers
     * const count = await prisma.weather.count({
     *   where: {
     *     // ... the filter for the Weathers we want to count
     *   }
     * })
    **/
    count<T extends WeatherCountArgs>(
      args?: Subset<T, WeatherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeatherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weather.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeatherAggregateArgs>(args: Subset<T, WeatherAggregateArgs>): Prisma.PrismaPromise<GetWeatherAggregateType<T>>

    /**
     * Group by Weather.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeatherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeatherGroupByArgs['orderBy'] }
        : { orderBy?: WeatherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeatherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeatherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Weather model
   */
  readonly fields: WeatherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Weather.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeatherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Weather model
   */
  interface WeatherFieldRefs {
    readonly id: FieldRef<"Weather", 'String'>
    readonly mountainId: FieldRef<"Weather", 'String'>
    readonly date: FieldRef<"Weather", 'DateTime'>
    readonly temperature: FieldRef<"Weather", 'Float'>
    readonly windSpeed: FieldRef<"Weather", 'Float'>
    readonly windDirection: FieldRef<"Weather", 'String'>
    readonly visibility: FieldRef<"Weather", 'Float'>
    readonly conditions: FieldRef<"Weather", 'String'>
    readonly snowfallRecent: FieldRef<"Weather", 'Float'>
    readonly snowfall24h: FieldRef<"Weather", 'Float'>
    readonly snowfall7d: FieldRef<"Weather", 'Float'>
    readonly createdAt: FieldRef<"Weather", 'DateTime'>
    readonly updatedAt: FieldRef<"Weather", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Weather findUnique
   */
  export type WeatherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * Filter, which Weather to fetch.
     */
    where: WeatherWhereUniqueInput
  }

  /**
   * Weather findUniqueOrThrow
   */
  export type WeatherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * Filter, which Weather to fetch.
     */
    where: WeatherWhereUniqueInput
  }

  /**
   * Weather findFirst
   */
  export type WeatherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * Filter, which Weather to fetch.
     */
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     */
    orderBy?: WeatherOrderByWithRelationInput | WeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weathers.
     */
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weathers.
     */
    distinct?: WeatherScalarFieldEnum | WeatherScalarFieldEnum[]
  }

  /**
   * Weather findFirstOrThrow
   */
  export type WeatherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * Filter, which Weather to fetch.
     */
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     */
    orderBy?: WeatherOrderByWithRelationInput | WeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weathers.
     */
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weathers.
     */
    distinct?: WeatherScalarFieldEnum | WeatherScalarFieldEnum[]
  }

  /**
   * Weather findMany
   */
  export type WeatherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * Filter, which Weathers to fetch.
     */
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     */
    orderBy?: WeatherOrderByWithRelationInput | WeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Weathers.
     */
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     */
    skip?: number
    distinct?: WeatherScalarFieldEnum | WeatherScalarFieldEnum[]
  }

  /**
   * Weather create
   */
  export type WeatherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * The data needed to create a Weather.
     */
    data: XOR<WeatherCreateInput, WeatherUncheckedCreateInput>
  }

  /**
   * Weather createMany
   */
  export type WeatherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Weathers.
     */
    data: WeatherCreateManyInput | WeatherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Weather createManyAndReturn
   */
  export type WeatherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * The data used to create many Weathers.
     */
    data: WeatherCreateManyInput | WeatherCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Weather update
   */
  export type WeatherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * The data needed to update a Weather.
     */
    data: XOR<WeatherUpdateInput, WeatherUncheckedUpdateInput>
    /**
     * Choose, which Weather to update.
     */
    where: WeatherWhereUniqueInput
  }

  /**
   * Weather updateMany
   */
  export type WeatherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Weathers.
     */
    data: XOR<WeatherUpdateManyMutationInput, WeatherUncheckedUpdateManyInput>
    /**
     * Filter which Weathers to update
     */
    where?: WeatherWhereInput
    /**
     * Limit how many Weathers to update.
     */
    limit?: number
  }

  /**
   * Weather updateManyAndReturn
   */
  export type WeatherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * The data used to update Weathers.
     */
    data: XOR<WeatherUpdateManyMutationInput, WeatherUncheckedUpdateManyInput>
    /**
     * Filter which Weathers to update
     */
    where?: WeatherWhereInput
    /**
     * Limit how many Weathers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Weather upsert
   */
  export type WeatherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * The filter to search for the Weather to update in case it exists.
     */
    where: WeatherWhereUniqueInput
    /**
     * In case the Weather found by the `where` argument doesn't exist, create a new Weather with this data.
     */
    create: XOR<WeatherCreateInput, WeatherUncheckedCreateInput>
    /**
     * In case the Weather was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeatherUpdateInput, WeatherUncheckedUpdateInput>
  }

  /**
   * Weather delete
   */
  export type WeatherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * Filter which Weather to delete.
     */
    where: WeatherWhereUniqueInput
  }

  /**
   * Weather deleteMany
   */
  export type WeatherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weathers to delete
     */
    where?: WeatherWhereInput
    /**
     * Limit how many Weathers to delete.
     */
    limit?: number
  }

  /**
   * Weather without action
   */
  export type WeatherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeMountainAssignment
   */

  export type AggregateEmployeeMountainAssignment = {
    _count: EmployeeMountainAssignmentCountAggregateOutputType | null
    _min: EmployeeMountainAssignmentMinAggregateOutputType | null
    _max: EmployeeMountainAssignmentMaxAggregateOutputType | null
  }

  export type EmployeeMountainAssignmentMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    mountainId: string | null
    assignedAt: Date | null
  }

  export type EmployeeMountainAssignmentMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    mountainId: string | null
    assignedAt: Date | null
  }

  export type EmployeeMountainAssignmentCountAggregateOutputType = {
    id: number
    employeeId: number
    mountainId: number
    assignedAt: number
    _all: number
  }


  export type EmployeeMountainAssignmentMinAggregateInputType = {
    id?: true
    employeeId?: true
    mountainId?: true
    assignedAt?: true
  }

  export type EmployeeMountainAssignmentMaxAggregateInputType = {
    id?: true
    employeeId?: true
    mountainId?: true
    assignedAt?: true
  }

  export type EmployeeMountainAssignmentCountAggregateInputType = {
    id?: true
    employeeId?: true
    mountainId?: true
    assignedAt?: true
    _all?: true
  }

  export type EmployeeMountainAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeMountainAssignment to aggregate.
     */
    where?: EmployeeMountainAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeMountainAssignments to fetch.
     */
    orderBy?: EmployeeMountainAssignmentOrderByWithRelationInput | EmployeeMountainAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeMountainAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeMountainAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeMountainAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeMountainAssignments
    **/
    _count?: true | EmployeeMountainAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMountainAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMountainAssignmentMaxAggregateInputType
  }

  export type GetEmployeeMountainAssignmentAggregateType<T extends EmployeeMountainAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeMountainAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeMountainAssignment[P]>
      : GetScalarType<T[P], AggregateEmployeeMountainAssignment[P]>
  }




  export type EmployeeMountainAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeMountainAssignmentWhereInput
    orderBy?: EmployeeMountainAssignmentOrderByWithAggregationInput | EmployeeMountainAssignmentOrderByWithAggregationInput[]
    by: EmployeeMountainAssignmentScalarFieldEnum[] | EmployeeMountainAssignmentScalarFieldEnum
    having?: EmployeeMountainAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeMountainAssignmentCountAggregateInputType | true
    _min?: EmployeeMountainAssignmentMinAggregateInputType
    _max?: EmployeeMountainAssignmentMaxAggregateInputType
  }

  export type EmployeeMountainAssignmentGroupByOutputType = {
    id: string
    employeeId: string
    mountainId: string
    assignedAt: Date
    _count: EmployeeMountainAssignmentCountAggregateOutputType | null
    _min: EmployeeMountainAssignmentMinAggregateOutputType | null
    _max: EmployeeMountainAssignmentMaxAggregateOutputType | null
  }

  type GetEmployeeMountainAssignmentGroupByPayload<T extends EmployeeMountainAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeMountainAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeMountainAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeMountainAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeMountainAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeMountainAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    mountainId?: boolean
    assignedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeMountainAssignment"]>

  export type EmployeeMountainAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    mountainId?: boolean
    assignedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeMountainAssignment"]>

  export type EmployeeMountainAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    mountainId?: boolean
    assignedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeMountainAssignment"]>

  export type EmployeeMountainAssignmentSelectScalar = {
    id?: boolean
    employeeId?: boolean
    mountainId?: boolean
    assignedAt?: boolean
  }

  export type EmployeeMountainAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "mountainId" | "assignedAt", ExtArgs["result"]["employeeMountainAssignment"]>
  export type EmployeeMountainAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }
  export type EmployeeMountainAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }
  export type EmployeeMountainAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }

  export type $EmployeeMountainAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeMountainAssignment"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      mountain: Prisma.$MountainPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      mountainId: string
      assignedAt: Date
    }, ExtArgs["result"]["employeeMountainAssignment"]>
    composites: {}
  }

  type EmployeeMountainAssignmentGetPayload<S extends boolean | null | undefined | EmployeeMountainAssignmentDefaultArgs> = $Result.GetResult<Prisma.$EmployeeMountainAssignmentPayload, S>

  type EmployeeMountainAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeMountainAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeMountainAssignmentCountAggregateInputType | true
    }

  export interface EmployeeMountainAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeMountainAssignment'], meta: { name: 'EmployeeMountainAssignment' } }
    /**
     * Find zero or one EmployeeMountainAssignment that matches the filter.
     * @param {EmployeeMountainAssignmentFindUniqueArgs} args - Arguments to find a EmployeeMountainAssignment
     * @example
     * // Get one EmployeeMountainAssignment
     * const employeeMountainAssignment = await prisma.employeeMountainAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeMountainAssignmentFindUniqueArgs>(args: SelectSubset<T, EmployeeMountainAssignmentFindUniqueArgs<ExtArgs>>): Prisma__EmployeeMountainAssignmentClient<$Result.GetResult<Prisma.$EmployeeMountainAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeeMountainAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeMountainAssignmentFindUniqueOrThrowArgs} args - Arguments to find a EmployeeMountainAssignment
     * @example
     * // Get one EmployeeMountainAssignment
     * const employeeMountainAssignment = await prisma.employeeMountainAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeMountainAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeMountainAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeMountainAssignmentClient<$Result.GetResult<Prisma.$EmployeeMountainAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeMountainAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeMountainAssignmentFindFirstArgs} args - Arguments to find a EmployeeMountainAssignment
     * @example
     * // Get one EmployeeMountainAssignment
     * const employeeMountainAssignment = await prisma.employeeMountainAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeMountainAssignmentFindFirstArgs>(args?: SelectSubset<T, EmployeeMountainAssignmentFindFirstArgs<ExtArgs>>): Prisma__EmployeeMountainAssignmentClient<$Result.GetResult<Prisma.$EmployeeMountainAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeMountainAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeMountainAssignmentFindFirstOrThrowArgs} args - Arguments to find a EmployeeMountainAssignment
     * @example
     * // Get one EmployeeMountainAssignment
     * const employeeMountainAssignment = await prisma.employeeMountainAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeMountainAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeMountainAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeMountainAssignmentClient<$Result.GetResult<Prisma.$EmployeeMountainAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeeMountainAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeMountainAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeMountainAssignments
     * const employeeMountainAssignments = await prisma.employeeMountainAssignment.findMany()
     * 
     * // Get first 10 EmployeeMountainAssignments
     * const employeeMountainAssignments = await prisma.employeeMountainAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeMountainAssignmentWithIdOnly = await prisma.employeeMountainAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeMountainAssignmentFindManyArgs>(args?: SelectSubset<T, EmployeeMountainAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeMountainAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeeMountainAssignment.
     * @param {EmployeeMountainAssignmentCreateArgs} args - Arguments to create a EmployeeMountainAssignment.
     * @example
     * // Create one EmployeeMountainAssignment
     * const EmployeeMountainAssignment = await prisma.employeeMountainAssignment.create({
     *   data: {
     *     // ... data to create a EmployeeMountainAssignment
     *   }
     * })
     * 
     */
    create<T extends EmployeeMountainAssignmentCreateArgs>(args: SelectSubset<T, EmployeeMountainAssignmentCreateArgs<ExtArgs>>): Prisma__EmployeeMountainAssignmentClient<$Result.GetResult<Prisma.$EmployeeMountainAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeeMountainAssignments.
     * @param {EmployeeMountainAssignmentCreateManyArgs} args - Arguments to create many EmployeeMountainAssignments.
     * @example
     * // Create many EmployeeMountainAssignments
     * const employeeMountainAssignment = await prisma.employeeMountainAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeMountainAssignmentCreateManyArgs>(args?: SelectSubset<T, EmployeeMountainAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeMountainAssignments and returns the data saved in the database.
     * @param {EmployeeMountainAssignmentCreateManyAndReturnArgs} args - Arguments to create many EmployeeMountainAssignments.
     * @example
     * // Create many EmployeeMountainAssignments
     * const employeeMountainAssignment = await prisma.employeeMountainAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeMountainAssignments and only return the `id`
     * const employeeMountainAssignmentWithIdOnly = await prisma.employeeMountainAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeMountainAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeMountainAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeMountainAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmployeeMountainAssignment.
     * @param {EmployeeMountainAssignmentDeleteArgs} args - Arguments to delete one EmployeeMountainAssignment.
     * @example
     * // Delete one EmployeeMountainAssignment
     * const EmployeeMountainAssignment = await prisma.employeeMountainAssignment.delete({
     *   where: {
     *     // ... filter to delete one EmployeeMountainAssignment
     *   }
     * })
     * 
     */
    delete<T extends EmployeeMountainAssignmentDeleteArgs>(args: SelectSubset<T, EmployeeMountainAssignmentDeleteArgs<ExtArgs>>): Prisma__EmployeeMountainAssignmentClient<$Result.GetResult<Prisma.$EmployeeMountainAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeeMountainAssignment.
     * @param {EmployeeMountainAssignmentUpdateArgs} args - Arguments to update one EmployeeMountainAssignment.
     * @example
     * // Update one EmployeeMountainAssignment
     * const employeeMountainAssignment = await prisma.employeeMountainAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeMountainAssignmentUpdateArgs>(args: SelectSubset<T, EmployeeMountainAssignmentUpdateArgs<ExtArgs>>): Prisma__EmployeeMountainAssignmentClient<$Result.GetResult<Prisma.$EmployeeMountainAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeeMountainAssignments.
     * @param {EmployeeMountainAssignmentDeleteManyArgs} args - Arguments to filter EmployeeMountainAssignments to delete.
     * @example
     * // Delete a few EmployeeMountainAssignments
     * const { count } = await prisma.employeeMountainAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeMountainAssignmentDeleteManyArgs>(args?: SelectSubset<T, EmployeeMountainAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeMountainAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeMountainAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeMountainAssignments
     * const employeeMountainAssignment = await prisma.employeeMountainAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeMountainAssignmentUpdateManyArgs>(args: SelectSubset<T, EmployeeMountainAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeMountainAssignments and returns the data updated in the database.
     * @param {EmployeeMountainAssignmentUpdateManyAndReturnArgs} args - Arguments to update many EmployeeMountainAssignments.
     * @example
     * // Update many EmployeeMountainAssignments
     * const employeeMountainAssignment = await prisma.employeeMountainAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmployeeMountainAssignments and only return the `id`
     * const employeeMountainAssignmentWithIdOnly = await prisma.employeeMountainAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeMountainAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeMountainAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeMountainAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmployeeMountainAssignment.
     * @param {EmployeeMountainAssignmentUpsertArgs} args - Arguments to update or create a EmployeeMountainAssignment.
     * @example
     * // Update or create a EmployeeMountainAssignment
     * const employeeMountainAssignment = await prisma.employeeMountainAssignment.upsert({
     *   create: {
     *     // ... data to create a EmployeeMountainAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeMountainAssignment we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeMountainAssignmentUpsertArgs>(args: SelectSubset<T, EmployeeMountainAssignmentUpsertArgs<ExtArgs>>): Prisma__EmployeeMountainAssignmentClient<$Result.GetResult<Prisma.$EmployeeMountainAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeeMountainAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeMountainAssignmentCountArgs} args - Arguments to filter EmployeeMountainAssignments to count.
     * @example
     * // Count the number of EmployeeMountainAssignments
     * const count = await prisma.employeeMountainAssignment.count({
     *   where: {
     *     // ... the filter for the EmployeeMountainAssignments we want to count
     *   }
     * })
    **/
    count<T extends EmployeeMountainAssignmentCountArgs>(
      args?: Subset<T, EmployeeMountainAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeMountainAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeMountainAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeMountainAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeMountainAssignmentAggregateArgs>(args: Subset<T, EmployeeMountainAssignmentAggregateArgs>): Prisma.PrismaPromise<GetEmployeeMountainAssignmentAggregateType<T>>

    /**
     * Group by EmployeeMountainAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeMountainAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeMountainAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeMountainAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeMountainAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeMountainAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeMountainAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeMountainAssignment model
   */
  readonly fields: EmployeeMountainAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeMountainAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeMountainAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeMountainAssignment model
   */
  interface EmployeeMountainAssignmentFieldRefs {
    readonly id: FieldRef<"EmployeeMountainAssignment", 'String'>
    readonly employeeId: FieldRef<"EmployeeMountainAssignment", 'String'>
    readonly mountainId: FieldRef<"EmployeeMountainAssignment", 'String'>
    readonly assignedAt: FieldRef<"EmployeeMountainAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeMountainAssignment findUnique
   */
  export type EmployeeMountainAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeMountainAssignment
     */
    select?: EmployeeMountainAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeMountainAssignment
     */
    omit?: EmployeeMountainAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeMountainAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeMountainAssignment to fetch.
     */
    where: EmployeeMountainAssignmentWhereUniqueInput
  }

  /**
   * EmployeeMountainAssignment findUniqueOrThrow
   */
  export type EmployeeMountainAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeMountainAssignment
     */
    select?: EmployeeMountainAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeMountainAssignment
     */
    omit?: EmployeeMountainAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeMountainAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeMountainAssignment to fetch.
     */
    where: EmployeeMountainAssignmentWhereUniqueInput
  }

  /**
   * EmployeeMountainAssignment findFirst
   */
  export type EmployeeMountainAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeMountainAssignment
     */
    select?: EmployeeMountainAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeMountainAssignment
     */
    omit?: EmployeeMountainAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeMountainAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeMountainAssignment to fetch.
     */
    where?: EmployeeMountainAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeMountainAssignments to fetch.
     */
    orderBy?: EmployeeMountainAssignmentOrderByWithRelationInput | EmployeeMountainAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeMountainAssignments.
     */
    cursor?: EmployeeMountainAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeMountainAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeMountainAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeMountainAssignments.
     */
    distinct?: EmployeeMountainAssignmentScalarFieldEnum | EmployeeMountainAssignmentScalarFieldEnum[]
  }

  /**
   * EmployeeMountainAssignment findFirstOrThrow
   */
  export type EmployeeMountainAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeMountainAssignment
     */
    select?: EmployeeMountainAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeMountainAssignment
     */
    omit?: EmployeeMountainAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeMountainAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeMountainAssignment to fetch.
     */
    where?: EmployeeMountainAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeMountainAssignments to fetch.
     */
    orderBy?: EmployeeMountainAssignmentOrderByWithRelationInput | EmployeeMountainAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeMountainAssignments.
     */
    cursor?: EmployeeMountainAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeMountainAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeMountainAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeMountainAssignments.
     */
    distinct?: EmployeeMountainAssignmentScalarFieldEnum | EmployeeMountainAssignmentScalarFieldEnum[]
  }

  /**
   * EmployeeMountainAssignment findMany
   */
  export type EmployeeMountainAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeMountainAssignment
     */
    select?: EmployeeMountainAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeMountainAssignment
     */
    omit?: EmployeeMountainAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeMountainAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeMountainAssignments to fetch.
     */
    where?: EmployeeMountainAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeMountainAssignments to fetch.
     */
    orderBy?: EmployeeMountainAssignmentOrderByWithRelationInput | EmployeeMountainAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeMountainAssignments.
     */
    cursor?: EmployeeMountainAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeMountainAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeMountainAssignments.
     */
    skip?: number
    distinct?: EmployeeMountainAssignmentScalarFieldEnum | EmployeeMountainAssignmentScalarFieldEnum[]
  }

  /**
   * EmployeeMountainAssignment create
   */
  export type EmployeeMountainAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeMountainAssignment
     */
    select?: EmployeeMountainAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeMountainAssignment
     */
    omit?: EmployeeMountainAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeMountainAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeMountainAssignment.
     */
    data: XOR<EmployeeMountainAssignmentCreateInput, EmployeeMountainAssignmentUncheckedCreateInput>
  }

  /**
   * EmployeeMountainAssignment createMany
   */
  export type EmployeeMountainAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeMountainAssignments.
     */
    data: EmployeeMountainAssignmentCreateManyInput | EmployeeMountainAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeMountainAssignment createManyAndReturn
   */
  export type EmployeeMountainAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeMountainAssignment
     */
    select?: EmployeeMountainAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeMountainAssignment
     */
    omit?: EmployeeMountainAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many EmployeeMountainAssignments.
     */
    data: EmployeeMountainAssignmentCreateManyInput | EmployeeMountainAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeMountainAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeMountainAssignment update
   */
  export type EmployeeMountainAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeMountainAssignment
     */
    select?: EmployeeMountainAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeMountainAssignment
     */
    omit?: EmployeeMountainAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeMountainAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeMountainAssignment.
     */
    data: XOR<EmployeeMountainAssignmentUpdateInput, EmployeeMountainAssignmentUncheckedUpdateInput>
    /**
     * Choose, which EmployeeMountainAssignment to update.
     */
    where: EmployeeMountainAssignmentWhereUniqueInput
  }

  /**
   * EmployeeMountainAssignment updateMany
   */
  export type EmployeeMountainAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeMountainAssignments.
     */
    data: XOR<EmployeeMountainAssignmentUpdateManyMutationInput, EmployeeMountainAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeMountainAssignments to update
     */
    where?: EmployeeMountainAssignmentWhereInput
    /**
     * Limit how many EmployeeMountainAssignments to update.
     */
    limit?: number
  }

  /**
   * EmployeeMountainAssignment updateManyAndReturn
   */
  export type EmployeeMountainAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeMountainAssignment
     */
    select?: EmployeeMountainAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeMountainAssignment
     */
    omit?: EmployeeMountainAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update EmployeeMountainAssignments.
     */
    data: XOR<EmployeeMountainAssignmentUpdateManyMutationInput, EmployeeMountainAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeMountainAssignments to update
     */
    where?: EmployeeMountainAssignmentWhereInput
    /**
     * Limit how many EmployeeMountainAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeMountainAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeMountainAssignment upsert
   */
  export type EmployeeMountainAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeMountainAssignment
     */
    select?: EmployeeMountainAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeMountainAssignment
     */
    omit?: EmployeeMountainAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeMountainAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeMountainAssignment to update in case it exists.
     */
    where: EmployeeMountainAssignmentWhereUniqueInput
    /**
     * In case the EmployeeMountainAssignment found by the `where` argument doesn't exist, create a new EmployeeMountainAssignment with this data.
     */
    create: XOR<EmployeeMountainAssignmentCreateInput, EmployeeMountainAssignmentUncheckedCreateInput>
    /**
     * In case the EmployeeMountainAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeMountainAssignmentUpdateInput, EmployeeMountainAssignmentUncheckedUpdateInput>
  }

  /**
   * EmployeeMountainAssignment delete
   */
  export type EmployeeMountainAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeMountainAssignment
     */
    select?: EmployeeMountainAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeMountainAssignment
     */
    omit?: EmployeeMountainAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeMountainAssignmentInclude<ExtArgs> | null
    /**
     * Filter which EmployeeMountainAssignment to delete.
     */
    where: EmployeeMountainAssignmentWhereUniqueInput
  }

  /**
   * EmployeeMountainAssignment deleteMany
   */
  export type EmployeeMountainAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeMountainAssignments to delete
     */
    where?: EmployeeMountainAssignmentWhereInput
    /**
     * Limit how many EmployeeMountainAssignments to delete.
     */
    limit?: number
  }

  /**
   * EmployeeMountainAssignment without action
   */
  export type EmployeeMountainAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeMountainAssignment
     */
    select?: EmployeeMountainAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeMountainAssignment
     */
    omit?: EmployeeMountainAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeMountainAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model DispatcherAssignment
   */

  export type AggregateDispatcherAssignment = {
    _count: DispatcherAssignmentCountAggregateOutputType | null
    _min: DispatcherAssignmentMinAggregateOutputType | null
    _max: DispatcherAssignmentMaxAggregateOutputType | null
  }

  export type DispatcherAssignmentMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    mountainId: string | null
    assignedAt: Date | null
  }

  export type DispatcherAssignmentMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    mountainId: string | null
    assignedAt: Date | null
  }

  export type DispatcherAssignmentCountAggregateOutputType = {
    id: number
    employeeId: number
    mountainId: number
    assignedAt: number
    _all: number
  }


  export type DispatcherAssignmentMinAggregateInputType = {
    id?: true
    employeeId?: true
    mountainId?: true
    assignedAt?: true
  }

  export type DispatcherAssignmentMaxAggregateInputType = {
    id?: true
    employeeId?: true
    mountainId?: true
    assignedAt?: true
  }

  export type DispatcherAssignmentCountAggregateInputType = {
    id?: true
    employeeId?: true
    mountainId?: true
    assignedAt?: true
    _all?: true
  }

  export type DispatcherAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DispatcherAssignment to aggregate.
     */
    where?: DispatcherAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispatcherAssignments to fetch.
     */
    orderBy?: DispatcherAssignmentOrderByWithRelationInput | DispatcherAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DispatcherAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispatcherAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispatcherAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DispatcherAssignments
    **/
    _count?: true | DispatcherAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DispatcherAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DispatcherAssignmentMaxAggregateInputType
  }

  export type GetDispatcherAssignmentAggregateType<T extends DispatcherAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDispatcherAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDispatcherAssignment[P]>
      : GetScalarType<T[P], AggregateDispatcherAssignment[P]>
  }




  export type DispatcherAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispatcherAssignmentWhereInput
    orderBy?: DispatcherAssignmentOrderByWithAggregationInput | DispatcherAssignmentOrderByWithAggregationInput[]
    by: DispatcherAssignmentScalarFieldEnum[] | DispatcherAssignmentScalarFieldEnum
    having?: DispatcherAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DispatcherAssignmentCountAggregateInputType | true
    _min?: DispatcherAssignmentMinAggregateInputType
    _max?: DispatcherAssignmentMaxAggregateInputType
  }

  export type DispatcherAssignmentGroupByOutputType = {
    id: string
    employeeId: string
    mountainId: string
    assignedAt: Date
    _count: DispatcherAssignmentCountAggregateOutputType | null
    _min: DispatcherAssignmentMinAggregateOutputType | null
    _max: DispatcherAssignmentMaxAggregateOutputType | null
  }

  type GetDispatcherAssignmentGroupByPayload<T extends DispatcherAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DispatcherAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DispatcherAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DispatcherAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], DispatcherAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type DispatcherAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    mountainId?: boolean
    assignedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispatcherAssignment"]>

  export type DispatcherAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    mountainId?: boolean
    assignedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispatcherAssignment"]>

  export type DispatcherAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    mountainId?: boolean
    assignedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispatcherAssignment"]>

  export type DispatcherAssignmentSelectScalar = {
    id?: boolean
    employeeId?: boolean
    mountainId?: boolean
    assignedAt?: boolean
  }

  export type DispatcherAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "mountainId" | "assignedAt", ExtArgs["result"]["dispatcherAssignment"]>
  export type DispatcherAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }
  export type DispatcherAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }
  export type DispatcherAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }

  export type $DispatcherAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DispatcherAssignment"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      mountain: Prisma.$MountainPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      mountainId: string
      assignedAt: Date
    }, ExtArgs["result"]["dispatcherAssignment"]>
    composites: {}
  }

  type DispatcherAssignmentGetPayload<S extends boolean | null | undefined | DispatcherAssignmentDefaultArgs> = $Result.GetResult<Prisma.$DispatcherAssignmentPayload, S>

  type DispatcherAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DispatcherAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DispatcherAssignmentCountAggregateInputType | true
    }

  export interface DispatcherAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DispatcherAssignment'], meta: { name: 'DispatcherAssignment' } }
    /**
     * Find zero or one DispatcherAssignment that matches the filter.
     * @param {DispatcherAssignmentFindUniqueArgs} args - Arguments to find a DispatcherAssignment
     * @example
     * // Get one DispatcherAssignment
     * const dispatcherAssignment = await prisma.dispatcherAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DispatcherAssignmentFindUniqueArgs>(args: SelectSubset<T, DispatcherAssignmentFindUniqueArgs<ExtArgs>>): Prisma__DispatcherAssignmentClient<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DispatcherAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DispatcherAssignmentFindUniqueOrThrowArgs} args - Arguments to find a DispatcherAssignment
     * @example
     * // Get one DispatcherAssignment
     * const dispatcherAssignment = await prisma.dispatcherAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DispatcherAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DispatcherAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DispatcherAssignmentClient<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DispatcherAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatcherAssignmentFindFirstArgs} args - Arguments to find a DispatcherAssignment
     * @example
     * // Get one DispatcherAssignment
     * const dispatcherAssignment = await prisma.dispatcherAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DispatcherAssignmentFindFirstArgs>(args?: SelectSubset<T, DispatcherAssignmentFindFirstArgs<ExtArgs>>): Prisma__DispatcherAssignmentClient<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DispatcherAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatcherAssignmentFindFirstOrThrowArgs} args - Arguments to find a DispatcherAssignment
     * @example
     * // Get one DispatcherAssignment
     * const dispatcherAssignment = await prisma.dispatcherAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DispatcherAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DispatcherAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DispatcherAssignmentClient<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DispatcherAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatcherAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DispatcherAssignments
     * const dispatcherAssignments = await prisma.dispatcherAssignment.findMany()
     * 
     * // Get first 10 DispatcherAssignments
     * const dispatcherAssignments = await prisma.dispatcherAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dispatcherAssignmentWithIdOnly = await prisma.dispatcherAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DispatcherAssignmentFindManyArgs>(args?: SelectSubset<T, DispatcherAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DispatcherAssignment.
     * @param {DispatcherAssignmentCreateArgs} args - Arguments to create a DispatcherAssignment.
     * @example
     * // Create one DispatcherAssignment
     * const DispatcherAssignment = await prisma.dispatcherAssignment.create({
     *   data: {
     *     // ... data to create a DispatcherAssignment
     *   }
     * })
     * 
     */
    create<T extends DispatcherAssignmentCreateArgs>(args: SelectSubset<T, DispatcherAssignmentCreateArgs<ExtArgs>>): Prisma__DispatcherAssignmentClient<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DispatcherAssignments.
     * @param {DispatcherAssignmentCreateManyArgs} args - Arguments to create many DispatcherAssignments.
     * @example
     * // Create many DispatcherAssignments
     * const dispatcherAssignment = await prisma.dispatcherAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DispatcherAssignmentCreateManyArgs>(args?: SelectSubset<T, DispatcherAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DispatcherAssignments and returns the data saved in the database.
     * @param {DispatcherAssignmentCreateManyAndReturnArgs} args - Arguments to create many DispatcherAssignments.
     * @example
     * // Create many DispatcherAssignments
     * const dispatcherAssignment = await prisma.dispatcherAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DispatcherAssignments and only return the `id`
     * const dispatcherAssignmentWithIdOnly = await prisma.dispatcherAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DispatcherAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DispatcherAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DispatcherAssignment.
     * @param {DispatcherAssignmentDeleteArgs} args - Arguments to delete one DispatcherAssignment.
     * @example
     * // Delete one DispatcherAssignment
     * const DispatcherAssignment = await prisma.dispatcherAssignment.delete({
     *   where: {
     *     // ... filter to delete one DispatcherAssignment
     *   }
     * })
     * 
     */
    delete<T extends DispatcherAssignmentDeleteArgs>(args: SelectSubset<T, DispatcherAssignmentDeleteArgs<ExtArgs>>): Prisma__DispatcherAssignmentClient<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DispatcherAssignment.
     * @param {DispatcherAssignmentUpdateArgs} args - Arguments to update one DispatcherAssignment.
     * @example
     * // Update one DispatcherAssignment
     * const dispatcherAssignment = await prisma.dispatcherAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DispatcherAssignmentUpdateArgs>(args: SelectSubset<T, DispatcherAssignmentUpdateArgs<ExtArgs>>): Prisma__DispatcherAssignmentClient<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DispatcherAssignments.
     * @param {DispatcherAssignmentDeleteManyArgs} args - Arguments to filter DispatcherAssignments to delete.
     * @example
     * // Delete a few DispatcherAssignments
     * const { count } = await prisma.dispatcherAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DispatcherAssignmentDeleteManyArgs>(args?: SelectSubset<T, DispatcherAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DispatcherAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatcherAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DispatcherAssignments
     * const dispatcherAssignment = await prisma.dispatcherAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DispatcherAssignmentUpdateManyArgs>(args: SelectSubset<T, DispatcherAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DispatcherAssignments and returns the data updated in the database.
     * @param {DispatcherAssignmentUpdateManyAndReturnArgs} args - Arguments to update many DispatcherAssignments.
     * @example
     * // Update many DispatcherAssignments
     * const dispatcherAssignment = await prisma.dispatcherAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DispatcherAssignments and only return the `id`
     * const dispatcherAssignmentWithIdOnly = await prisma.dispatcherAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DispatcherAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DispatcherAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DispatcherAssignment.
     * @param {DispatcherAssignmentUpsertArgs} args - Arguments to update or create a DispatcherAssignment.
     * @example
     * // Update or create a DispatcherAssignment
     * const dispatcherAssignment = await prisma.dispatcherAssignment.upsert({
     *   create: {
     *     // ... data to create a DispatcherAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DispatcherAssignment we want to update
     *   }
     * })
     */
    upsert<T extends DispatcherAssignmentUpsertArgs>(args: SelectSubset<T, DispatcherAssignmentUpsertArgs<ExtArgs>>): Prisma__DispatcherAssignmentClient<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DispatcherAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatcherAssignmentCountArgs} args - Arguments to filter DispatcherAssignments to count.
     * @example
     * // Count the number of DispatcherAssignments
     * const count = await prisma.dispatcherAssignment.count({
     *   where: {
     *     // ... the filter for the DispatcherAssignments we want to count
     *   }
     * })
    **/
    count<T extends DispatcherAssignmentCountArgs>(
      args?: Subset<T, DispatcherAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DispatcherAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DispatcherAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatcherAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DispatcherAssignmentAggregateArgs>(args: Subset<T, DispatcherAssignmentAggregateArgs>): Prisma.PrismaPromise<GetDispatcherAssignmentAggregateType<T>>

    /**
     * Group by DispatcherAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatcherAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DispatcherAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DispatcherAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: DispatcherAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DispatcherAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDispatcherAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DispatcherAssignment model
   */
  readonly fields: DispatcherAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DispatcherAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DispatcherAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DispatcherAssignment model
   */
  interface DispatcherAssignmentFieldRefs {
    readonly id: FieldRef<"DispatcherAssignment", 'String'>
    readonly employeeId: FieldRef<"DispatcherAssignment", 'String'>
    readonly mountainId: FieldRef<"DispatcherAssignment", 'String'>
    readonly assignedAt: FieldRef<"DispatcherAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DispatcherAssignment findUnique
   */
  export type DispatcherAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DispatcherAssignment to fetch.
     */
    where: DispatcherAssignmentWhereUniqueInput
  }

  /**
   * DispatcherAssignment findUniqueOrThrow
   */
  export type DispatcherAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DispatcherAssignment to fetch.
     */
    where: DispatcherAssignmentWhereUniqueInput
  }

  /**
   * DispatcherAssignment findFirst
   */
  export type DispatcherAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DispatcherAssignment to fetch.
     */
    where?: DispatcherAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispatcherAssignments to fetch.
     */
    orderBy?: DispatcherAssignmentOrderByWithRelationInput | DispatcherAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DispatcherAssignments.
     */
    cursor?: DispatcherAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispatcherAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispatcherAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DispatcherAssignments.
     */
    distinct?: DispatcherAssignmentScalarFieldEnum | DispatcherAssignmentScalarFieldEnum[]
  }

  /**
   * DispatcherAssignment findFirstOrThrow
   */
  export type DispatcherAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DispatcherAssignment to fetch.
     */
    where?: DispatcherAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispatcherAssignments to fetch.
     */
    orderBy?: DispatcherAssignmentOrderByWithRelationInput | DispatcherAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DispatcherAssignments.
     */
    cursor?: DispatcherAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispatcherAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispatcherAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DispatcherAssignments.
     */
    distinct?: DispatcherAssignmentScalarFieldEnum | DispatcherAssignmentScalarFieldEnum[]
  }

  /**
   * DispatcherAssignment findMany
   */
  export type DispatcherAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DispatcherAssignments to fetch.
     */
    where?: DispatcherAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispatcherAssignments to fetch.
     */
    orderBy?: DispatcherAssignmentOrderByWithRelationInput | DispatcherAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DispatcherAssignments.
     */
    cursor?: DispatcherAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispatcherAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispatcherAssignments.
     */
    skip?: number
    distinct?: DispatcherAssignmentScalarFieldEnum | DispatcherAssignmentScalarFieldEnum[]
  }

  /**
   * DispatcherAssignment create
   */
  export type DispatcherAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a DispatcherAssignment.
     */
    data: XOR<DispatcherAssignmentCreateInput, DispatcherAssignmentUncheckedCreateInput>
  }

  /**
   * DispatcherAssignment createMany
   */
  export type DispatcherAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DispatcherAssignments.
     */
    data: DispatcherAssignmentCreateManyInput | DispatcherAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DispatcherAssignment createManyAndReturn
   */
  export type DispatcherAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many DispatcherAssignments.
     */
    data: DispatcherAssignmentCreateManyInput | DispatcherAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DispatcherAssignment update
   */
  export type DispatcherAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a DispatcherAssignment.
     */
    data: XOR<DispatcherAssignmentUpdateInput, DispatcherAssignmentUncheckedUpdateInput>
    /**
     * Choose, which DispatcherAssignment to update.
     */
    where: DispatcherAssignmentWhereUniqueInput
  }

  /**
   * DispatcherAssignment updateMany
   */
  export type DispatcherAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DispatcherAssignments.
     */
    data: XOR<DispatcherAssignmentUpdateManyMutationInput, DispatcherAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which DispatcherAssignments to update
     */
    where?: DispatcherAssignmentWhereInput
    /**
     * Limit how many DispatcherAssignments to update.
     */
    limit?: number
  }

  /**
   * DispatcherAssignment updateManyAndReturn
   */
  export type DispatcherAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update DispatcherAssignments.
     */
    data: XOR<DispatcherAssignmentUpdateManyMutationInput, DispatcherAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which DispatcherAssignments to update
     */
    where?: DispatcherAssignmentWhereInput
    /**
     * Limit how many DispatcherAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DispatcherAssignment upsert
   */
  export type DispatcherAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the DispatcherAssignment to update in case it exists.
     */
    where: DispatcherAssignmentWhereUniqueInput
    /**
     * In case the DispatcherAssignment found by the `where` argument doesn't exist, create a new DispatcherAssignment with this data.
     */
    create: XOR<DispatcherAssignmentCreateInput, DispatcherAssignmentUncheckedCreateInput>
    /**
     * In case the DispatcherAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DispatcherAssignmentUpdateInput, DispatcherAssignmentUncheckedUpdateInput>
  }

  /**
   * DispatcherAssignment delete
   */
  export type DispatcherAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
    /**
     * Filter which DispatcherAssignment to delete.
     */
    where: DispatcherAssignmentWhereUniqueInput
  }

  /**
   * DispatcherAssignment deleteMany
   */
  export type DispatcherAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DispatcherAssignments to delete
     */
    where?: DispatcherAssignmentWhereInput
    /**
     * Limit how many DispatcherAssignments to delete.
     */
    limit?: number
  }

  /**
   * DispatcherAssignment without action
   */
  export type DispatcherAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    level: number | null
  }

  export type RoleSumAggregateOutputType = {
    level: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    department: $Enums.DEPARTMENT | null
    name: string | null
    title: string | null
    position: string | null
    level: number | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    department: $Enums.DEPARTMENT | null
    name: string | null
    title: string | null
    position: string | null
    level: number | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    department: number
    name: number
    title: number
    position: number
    level: number
    permissions: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    level?: true
  }

  export type RoleSumAggregateInputType = {
    level?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    department?: true
    name?: true
    title?: true
    position?: true
    level?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    department?: true
    name?: true
    title?: true
    position?: true
    level?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    department?: true
    name?: true
    title?: true
    position?: true
    level?: true
    permissions?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    department: $Enums.DEPARTMENT
    name: string
    title: string
    position: string
    level: number | null
    permissions: string[]
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    department?: boolean
    name?: boolean
    title?: boolean
    position?: boolean
    level?: boolean
    permissions?: boolean
    employees?: boolean | Role$employeesArgs<ExtArgs>
    employeeRole?: boolean | Role$employeeRoleArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    department?: boolean
    name?: boolean
    title?: boolean
    position?: boolean
    level?: boolean
    permissions?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    department?: boolean
    name?: boolean
    title?: boolean
    position?: boolean
    level?: boolean
    permissions?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    department?: boolean
    name?: boolean
    title?: boolean
    position?: boolean
    level?: boolean
    permissions?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "department" | "name" | "title" | "position" | "level" | "permissions", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | Role$employeesArgs<ExtArgs>
    employeeRole?: boolean | Role$employeeRoleArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      employeeRole: Prisma.$EmployeeRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      department: $Enums.DEPARTMENT
      name: string
      title: string
      position: string
      level: number | null
      permissions: string[]
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends Role$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Role$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employeeRole<T extends Role$employeeRoleArgs<ExtArgs> = {}>(args?: Subset<T, Role$employeeRoleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly department: FieldRef<"Role", 'DEPARTMENT'>
    readonly name: FieldRef<"Role", 'String'>
    readonly title: FieldRef<"Role", 'String'>
    readonly position: FieldRef<"Role", 'String'>
    readonly level: FieldRef<"Role", 'Int'>
    readonly permissions: FieldRef<"Role", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.employees
   */
  export type Role$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Role.employeeRole
   */
  export type Role$employeeRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
    where?: EmployeeRoleWhereInput
    orderBy?: EmployeeRoleOrderByWithRelationInput | EmployeeRoleOrderByWithRelationInput[]
    cursor?: EmployeeRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeRoleScalarFieldEnum | EmployeeRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeRole
   */

  export type AggregateEmployeeRole = {
    _count: EmployeeRoleCountAggregateOutputType | null
    _min: EmployeeRoleMinAggregateOutputType | null
    _max: EmployeeRoleMaxAggregateOutputType | null
  }

  export type EmployeeRoleMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    roleId: string | null
  }

  export type EmployeeRoleMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    roleId: string | null
  }

  export type EmployeeRoleCountAggregateOutputType = {
    id: number
    employeeId: number
    roleId: number
    _all: number
  }


  export type EmployeeRoleMinAggregateInputType = {
    id?: true
    employeeId?: true
    roleId?: true
  }

  export type EmployeeRoleMaxAggregateInputType = {
    id?: true
    employeeId?: true
    roleId?: true
  }

  export type EmployeeRoleCountAggregateInputType = {
    id?: true
    employeeId?: true
    roleId?: true
    _all?: true
  }

  export type EmployeeRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeRole to aggregate.
     */
    where?: EmployeeRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeRoles to fetch.
     */
    orderBy?: EmployeeRoleOrderByWithRelationInput | EmployeeRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeRoles
    **/
    _count?: true | EmployeeRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeRoleMaxAggregateInputType
  }

  export type GetEmployeeRoleAggregateType<T extends EmployeeRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeRole[P]>
      : GetScalarType<T[P], AggregateEmployeeRole[P]>
  }




  export type EmployeeRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeRoleWhereInput
    orderBy?: EmployeeRoleOrderByWithAggregationInput | EmployeeRoleOrderByWithAggregationInput[]
    by: EmployeeRoleScalarFieldEnum[] | EmployeeRoleScalarFieldEnum
    having?: EmployeeRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeRoleCountAggregateInputType | true
    _min?: EmployeeRoleMinAggregateInputType
    _max?: EmployeeRoleMaxAggregateInputType
  }

  export type EmployeeRoleGroupByOutputType = {
    id: string
    employeeId: string
    roleId: string
    _count: EmployeeRoleCountAggregateOutputType | null
    _min: EmployeeRoleMinAggregateOutputType | null
    _max: EmployeeRoleMaxAggregateOutputType | null
  }

  type GetEmployeeRoleGroupByPayload<T extends EmployeeRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeRoleGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeRoleGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    roleId?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeRole"]>

  export type EmployeeRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    roleId?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeRole"]>

  export type EmployeeRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    roleId?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeRole"]>

  export type EmployeeRoleSelectScalar = {
    id?: boolean
    employeeId?: boolean
    roleId?: boolean
  }

  export type EmployeeRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "roleId", ExtArgs["result"]["employeeRole"]>
  export type EmployeeRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type EmployeeRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type EmployeeRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $EmployeeRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeRole"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      roleId: string
    }, ExtArgs["result"]["employeeRole"]>
    composites: {}
  }

  type EmployeeRoleGetPayload<S extends boolean | null | undefined | EmployeeRoleDefaultArgs> = $Result.GetResult<Prisma.$EmployeeRolePayload, S>

  type EmployeeRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeRoleCountAggregateInputType | true
    }

  export interface EmployeeRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeRole'], meta: { name: 'EmployeeRole' } }
    /**
     * Find zero or one EmployeeRole that matches the filter.
     * @param {EmployeeRoleFindUniqueArgs} args - Arguments to find a EmployeeRole
     * @example
     * // Get one EmployeeRole
     * const employeeRole = await prisma.employeeRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeRoleFindUniqueArgs>(args: SelectSubset<T, EmployeeRoleFindUniqueArgs<ExtArgs>>): Prisma__EmployeeRoleClient<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeeRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeRoleFindUniqueOrThrowArgs} args - Arguments to find a EmployeeRole
     * @example
     * // Get one EmployeeRole
     * const employeeRole = await prisma.employeeRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeRoleClient<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeRoleFindFirstArgs} args - Arguments to find a EmployeeRole
     * @example
     * // Get one EmployeeRole
     * const employeeRole = await prisma.employeeRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeRoleFindFirstArgs>(args?: SelectSubset<T, EmployeeRoleFindFirstArgs<ExtArgs>>): Prisma__EmployeeRoleClient<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeRoleFindFirstOrThrowArgs} args - Arguments to find a EmployeeRole
     * @example
     * // Get one EmployeeRole
     * const employeeRole = await prisma.employeeRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeRoleClient<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeeRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeRoles
     * const employeeRoles = await prisma.employeeRole.findMany()
     * 
     * // Get first 10 EmployeeRoles
     * const employeeRoles = await prisma.employeeRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeRoleWithIdOnly = await prisma.employeeRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeRoleFindManyArgs>(args?: SelectSubset<T, EmployeeRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeeRole.
     * @param {EmployeeRoleCreateArgs} args - Arguments to create a EmployeeRole.
     * @example
     * // Create one EmployeeRole
     * const EmployeeRole = await prisma.employeeRole.create({
     *   data: {
     *     // ... data to create a EmployeeRole
     *   }
     * })
     * 
     */
    create<T extends EmployeeRoleCreateArgs>(args: SelectSubset<T, EmployeeRoleCreateArgs<ExtArgs>>): Prisma__EmployeeRoleClient<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeeRoles.
     * @param {EmployeeRoleCreateManyArgs} args - Arguments to create many EmployeeRoles.
     * @example
     * // Create many EmployeeRoles
     * const employeeRole = await prisma.employeeRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeRoleCreateManyArgs>(args?: SelectSubset<T, EmployeeRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeRoles and returns the data saved in the database.
     * @param {EmployeeRoleCreateManyAndReturnArgs} args - Arguments to create many EmployeeRoles.
     * @example
     * // Create many EmployeeRoles
     * const employeeRole = await prisma.employeeRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeRoles and only return the `id`
     * const employeeRoleWithIdOnly = await prisma.employeeRole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmployeeRole.
     * @param {EmployeeRoleDeleteArgs} args - Arguments to delete one EmployeeRole.
     * @example
     * // Delete one EmployeeRole
     * const EmployeeRole = await prisma.employeeRole.delete({
     *   where: {
     *     // ... filter to delete one EmployeeRole
     *   }
     * })
     * 
     */
    delete<T extends EmployeeRoleDeleteArgs>(args: SelectSubset<T, EmployeeRoleDeleteArgs<ExtArgs>>): Prisma__EmployeeRoleClient<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeeRole.
     * @param {EmployeeRoleUpdateArgs} args - Arguments to update one EmployeeRole.
     * @example
     * // Update one EmployeeRole
     * const employeeRole = await prisma.employeeRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeRoleUpdateArgs>(args: SelectSubset<T, EmployeeRoleUpdateArgs<ExtArgs>>): Prisma__EmployeeRoleClient<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeeRoles.
     * @param {EmployeeRoleDeleteManyArgs} args - Arguments to filter EmployeeRoles to delete.
     * @example
     * // Delete a few EmployeeRoles
     * const { count } = await prisma.employeeRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeRoleDeleteManyArgs>(args?: SelectSubset<T, EmployeeRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeRoles
     * const employeeRole = await prisma.employeeRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeRoleUpdateManyArgs>(args: SelectSubset<T, EmployeeRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeRoles and returns the data updated in the database.
     * @param {EmployeeRoleUpdateManyAndReturnArgs} args - Arguments to update many EmployeeRoles.
     * @example
     * // Update many EmployeeRoles
     * const employeeRole = await prisma.employeeRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmployeeRoles and only return the `id`
     * const employeeRoleWithIdOnly = await prisma.employeeRole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmployeeRole.
     * @param {EmployeeRoleUpsertArgs} args - Arguments to update or create a EmployeeRole.
     * @example
     * // Update or create a EmployeeRole
     * const employeeRole = await prisma.employeeRole.upsert({
     *   create: {
     *     // ... data to create a EmployeeRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeRole we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeRoleUpsertArgs>(args: SelectSubset<T, EmployeeRoleUpsertArgs<ExtArgs>>): Prisma__EmployeeRoleClient<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeeRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeRoleCountArgs} args - Arguments to filter EmployeeRoles to count.
     * @example
     * // Count the number of EmployeeRoles
     * const count = await prisma.employeeRole.count({
     *   where: {
     *     // ... the filter for the EmployeeRoles we want to count
     *   }
     * })
    **/
    count<T extends EmployeeRoleCountArgs>(
      args?: Subset<T, EmployeeRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeRoleAggregateArgs>(args: Subset<T, EmployeeRoleAggregateArgs>): Prisma.PrismaPromise<GetEmployeeRoleAggregateType<T>>

    /**
     * Group by EmployeeRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeRoleGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeRole model
   */
  readonly fields: EmployeeRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeRole model
   */
  interface EmployeeRoleFieldRefs {
    readonly id: FieldRef<"EmployeeRole", 'String'>
    readonly employeeId: FieldRef<"EmployeeRole", 'String'>
    readonly roleId: FieldRef<"EmployeeRole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeRole findUnique
   */
  export type EmployeeRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeRole to fetch.
     */
    where: EmployeeRoleWhereUniqueInput
  }

  /**
   * EmployeeRole findUniqueOrThrow
   */
  export type EmployeeRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeRole to fetch.
     */
    where: EmployeeRoleWhereUniqueInput
  }

  /**
   * EmployeeRole findFirst
   */
  export type EmployeeRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeRole to fetch.
     */
    where?: EmployeeRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeRoles to fetch.
     */
    orderBy?: EmployeeRoleOrderByWithRelationInput | EmployeeRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeRoles.
     */
    cursor?: EmployeeRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeRoles.
     */
    distinct?: EmployeeRoleScalarFieldEnum | EmployeeRoleScalarFieldEnum[]
  }

  /**
   * EmployeeRole findFirstOrThrow
   */
  export type EmployeeRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeRole to fetch.
     */
    where?: EmployeeRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeRoles to fetch.
     */
    orderBy?: EmployeeRoleOrderByWithRelationInput | EmployeeRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeRoles.
     */
    cursor?: EmployeeRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeRoles.
     */
    distinct?: EmployeeRoleScalarFieldEnum | EmployeeRoleScalarFieldEnum[]
  }

  /**
   * EmployeeRole findMany
   */
  export type EmployeeRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeRoles to fetch.
     */
    where?: EmployeeRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeRoles to fetch.
     */
    orderBy?: EmployeeRoleOrderByWithRelationInput | EmployeeRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeRoles.
     */
    cursor?: EmployeeRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeRoles.
     */
    skip?: number
    distinct?: EmployeeRoleScalarFieldEnum | EmployeeRoleScalarFieldEnum[]
  }

  /**
   * EmployeeRole create
   */
  export type EmployeeRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeRole.
     */
    data: XOR<EmployeeRoleCreateInput, EmployeeRoleUncheckedCreateInput>
  }

  /**
   * EmployeeRole createMany
   */
  export type EmployeeRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeRoles.
     */
    data: EmployeeRoleCreateManyInput | EmployeeRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeRole createManyAndReturn
   */
  export type EmployeeRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * The data used to create many EmployeeRoles.
     */
    data: EmployeeRoleCreateManyInput | EmployeeRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeRole update
   */
  export type EmployeeRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeRole.
     */
    data: XOR<EmployeeRoleUpdateInput, EmployeeRoleUncheckedUpdateInput>
    /**
     * Choose, which EmployeeRole to update.
     */
    where: EmployeeRoleWhereUniqueInput
  }

  /**
   * EmployeeRole updateMany
   */
  export type EmployeeRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeRoles.
     */
    data: XOR<EmployeeRoleUpdateManyMutationInput, EmployeeRoleUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeRoles to update
     */
    where?: EmployeeRoleWhereInput
    /**
     * Limit how many EmployeeRoles to update.
     */
    limit?: number
  }

  /**
   * EmployeeRole updateManyAndReturn
   */
  export type EmployeeRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * The data used to update EmployeeRoles.
     */
    data: XOR<EmployeeRoleUpdateManyMutationInput, EmployeeRoleUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeRoles to update
     */
    where?: EmployeeRoleWhereInput
    /**
     * Limit how many EmployeeRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeRole upsert
   */
  export type EmployeeRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeRole to update in case it exists.
     */
    where: EmployeeRoleWhereUniqueInput
    /**
     * In case the EmployeeRole found by the `where` argument doesn't exist, create a new EmployeeRole with this data.
     */
    create: XOR<EmployeeRoleCreateInput, EmployeeRoleUncheckedCreateInput>
    /**
     * In case the EmployeeRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeRoleUpdateInput, EmployeeRoleUncheckedUpdateInput>
  }

  /**
   * EmployeeRole delete
   */
  export type EmployeeRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
    /**
     * Filter which EmployeeRole to delete.
     */
    where: EmployeeRoleWhereUniqueInput
  }

  /**
   * EmployeeRole deleteMany
   */
  export type EmployeeRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeRoles to delete
     */
    where?: EmployeeRoleWhereInput
    /**
     * Limit how many EmployeeRoles to delete.
     */
    limit?: number
  }

  /**
   * EmployeeRole without action
   */
  export type EmployeeRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    employeeIdNumber: number | null
  }

  export type EmployeeSumAggregateOutputType = {
    employeeIdNumber: number | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    employeeIdNumber: number | null
    email: string | null
    phoneNumber: string | null
    name: string | null
    roleId: string | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    employeeIdNumber: number | null
    email: string | null
    phoneNumber: string | null
    name: string | null
    roleId: string | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    employeeIdNumber: number
    email: number
    phoneNumber: number
    name: number
    roleId: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    employeeIdNumber?: true
  }

  export type EmployeeSumAggregateInputType = {
    employeeIdNumber?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    employeeIdNumber?: true
    email?: true
    phoneNumber?: true
    name?: true
    roleId?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    employeeIdNumber?: true
    email?: true
    phoneNumber?: true
    name?: true
    roleId?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    employeeIdNumber?: true
    email?: true
    phoneNumber?: true
    name?: true
    roleId?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    roleId: string | null
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeIdNumber?: boolean
    email?: boolean
    phoneNumber?: boolean
    name?: boolean
    roleId?: boolean
    role?: boolean | Employee$roleArgs<ExtArgs>
    additionalRoles?: boolean | Employee$additionalRolesArgs<ExtArgs>
    mountainAssignments?: boolean | Employee$mountainAssignmentsArgs<ExtArgs>
    dispatcherAssignments?: boolean | Employee$dispatcherAssignmentsArgs<ExtArgs>
    incidents?: boolean | Employee$incidentsArgs<ExtArgs>
    aidRoomChecks?: boolean | Employee$aidRoomChecksArgs<ExtArgs>
    hutChecks?: boolean | Employee$hutChecksArgs<ExtArgs>
    liftChecks?: boolean | Employee$liftChecksArgs<ExtArgs>
    trailChecks?: boolean | Employee$trailChecksArgs<ExtArgs>
    equipmentChecks?: boolean | Employee$equipmentChecksArgs<ExtArgs>
    equipmentServiceLogs?: boolean | Employee$equipmentServiceLogsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeIdNumber?: boolean
    email?: boolean
    phoneNumber?: boolean
    name?: boolean
    roleId?: boolean
    role?: boolean | Employee$roleArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeIdNumber?: boolean
    email?: boolean
    phoneNumber?: boolean
    name?: boolean
    roleId?: boolean
    role?: boolean | Employee$roleArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    employeeIdNumber?: boolean
    email?: boolean
    phoneNumber?: boolean
    name?: boolean
    roleId?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeIdNumber" | "email" | "phoneNumber" | "name" | "roleId", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | Employee$roleArgs<ExtArgs>
    additionalRoles?: boolean | Employee$additionalRolesArgs<ExtArgs>
    mountainAssignments?: boolean | Employee$mountainAssignmentsArgs<ExtArgs>
    dispatcherAssignments?: boolean | Employee$dispatcherAssignmentsArgs<ExtArgs>
    incidents?: boolean | Employee$incidentsArgs<ExtArgs>
    aidRoomChecks?: boolean | Employee$aidRoomChecksArgs<ExtArgs>
    hutChecks?: boolean | Employee$hutChecksArgs<ExtArgs>
    liftChecks?: boolean | Employee$liftChecksArgs<ExtArgs>
    trailChecks?: boolean | Employee$trailChecksArgs<ExtArgs>
    equipmentChecks?: boolean | Employee$equipmentChecksArgs<ExtArgs>
    equipmentServiceLogs?: boolean | Employee$equipmentServiceLogsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | Employee$roleArgs<ExtArgs>
  }
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | Employee$roleArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      role: Prisma.$RolePayload<ExtArgs> | null
      additionalRoles: Prisma.$EmployeeRolePayload<ExtArgs>[]
      mountainAssignments: Prisma.$EmployeeMountainAssignmentPayload<ExtArgs>[]
      dispatcherAssignments: Prisma.$DispatcherAssignmentPayload<ExtArgs>[]
      incidents: Prisma.$IncidentPayload<ExtArgs>[]
      aidRoomChecks: Prisma.$AidRoomCheckPayload<ExtArgs>[]
      hutChecks: Prisma.$HutCheckPayload<ExtArgs>[]
      liftChecks: Prisma.$LiftCheckPayload<ExtArgs>[]
      trailChecks: Prisma.$TrailCheckPayload<ExtArgs>[]
      equipmentChecks: Prisma.$EquipmentCheckPayload<ExtArgs>[]
      equipmentServiceLogs: Prisma.$EquipmentServiceLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeIdNumber: number
      email: string
      phoneNumber: string
      name: string
      roleId: string | null
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends Employee$roleArgs<ExtArgs> = {}>(args?: Subset<T, Employee$roleArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    additionalRoles<T extends Employee$additionalRolesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$additionalRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mountainAssignments<T extends Employee$mountainAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$mountainAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeMountainAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dispatcherAssignments<T extends Employee$dispatcherAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$dispatcherAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    incidents<T extends Employee$incidentsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$incidentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aidRoomChecks<T extends Employee$aidRoomChecksArgs<ExtArgs> = {}>(args?: Subset<T, Employee$aidRoomChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hutChecks<T extends Employee$hutChecksArgs<ExtArgs> = {}>(args?: Subset<T, Employee$hutChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    liftChecks<T extends Employee$liftChecksArgs<ExtArgs> = {}>(args?: Subset<T, Employee$liftChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trailChecks<T extends Employee$trailChecksArgs<ExtArgs> = {}>(args?: Subset<T, Employee$trailChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipmentChecks<T extends Employee$equipmentChecksArgs<ExtArgs> = {}>(args?: Subset<T, Employee$equipmentChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipmentServiceLogs<T extends Employee$equipmentServiceLogsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$equipmentServiceLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentServiceLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'String'>
    readonly employeeIdNumber: FieldRef<"Employee", 'Int'>
    readonly email: FieldRef<"Employee", 'String'>
    readonly phoneNumber: FieldRef<"Employee", 'String'>
    readonly name: FieldRef<"Employee", 'String'>
    readonly roleId: FieldRef<"Employee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.role
   */
  export type Employee$roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
  }

  /**
   * Employee.additionalRoles
   */
  export type Employee$additionalRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRole
     */
    select?: EmployeeRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeRole
     */
    omit?: EmployeeRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRoleInclude<ExtArgs> | null
    where?: EmployeeRoleWhereInput
    orderBy?: EmployeeRoleOrderByWithRelationInput | EmployeeRoleOrderByWithRelationInput[]
    cursor?: EmployeeRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeRoleScalarFieldEnum | EmployeeRoleScalarFieldEnum[]
  }

  /**
   * Employee.mountainAssignments
   */
  export type Employee$mountainAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeMountainAssignment
     */
    select?: EmployeeMountainAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeMountainAssignment
     */
    omit?: EmployeeMountainAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeMountainAssignmentInclude<ExtArgs> | null
    where?: EmployeeMountainAssignmentWhereInput
    orderBy?: EmployeeMountainAssignmentOrderByWithRelationInput | EmployeeMountainAssignmentOrderByWithRelationInput[]
    cursor?: EmployeeMountainAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeMountainAssignmentScalarFieldEnum | EmployeeMountainAssignmentScalarFieldEnum[]
  }

  /**
   * Employee.dispatcherAssignments
   */
  export type Employee$dispatcherAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
    where?: DispatcherAssignmentWhereInput
    orderBy?: DispatcherAssignmentOrderByWithRelationInput | DispatcherAssignmentOrderByWithRelationInput[]
    cursor?: DispatcherAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DispatcherAssignmentScalarFieldEnum | DispatcherAssignmentScalarFieldEnum[]
  }

  /**
   * Employee.incidents
   */
  export type Employee$incidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    cursor?: IncidentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Employee.aidRoomChecks
   */
  export type Employee$aidRoomChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    where?: AidRoomCheckWhereInput
    orderBy?: AidRoomCheckOrderByWithRelationInput | AidRoomCheckOrderByWithRelationInput[]
    cursor?: AidRoomCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AidRoomCheckScalarFieldEnum | AidRoomCheckScalarFieldEnum[]
  }

  /**
   * Employee.hutChecks
   */
  export type Employee$hutChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    where?: HutCheckWhereInput
    orderBy?: HutCheckOrderByWithRelationInput | HutCheckOrderByWithRelationInput[]
    cursor?: HutCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HutCheckScalarFieldEnum | HutCheckScalarFieldEnum[]
  }

  /**
   * Employee.liftChecks
   */
  export type Employee$liftChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    where?: LiftCheckWhereInput
    orderBy?: LiftCheckOrderByWithRelationInput | LiftCheckOrderByWithRelationInput[]
    cursor?: LiftCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiftCheckScalarFieldEnum | LiftCheckScalarFieldEnum[]
  }

  /**
   * Employee.trailChecks
   */
  export type Employee$trailChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    where?: TrailCheckWhereInput
    orderBy?: TrailCheckOrderByWithRelationInput | TrailCheckOrderByWithRelationInput[]
    cursor?: TrailCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrailCheckScalarFieldEnum | TrailCheckScalarFieldEnum[]
  }

  /**
   * Employee.equipmentChecks
   */
  export type Employee$equipmentChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    where?: EquipmentCheckWhereInput
    orderBy?: EquipmentCheckOrderByWithRelationInput | EquipmentCheckOrderByWithRelationInput[]
    cursor?: EquipmentCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentCheckScalarFieldEnum | EquipmentCheckScalarFieldEnum[]
  }

  /**
   * Employee.equipmentServiceLogs
   */
  export type Employee$equipmentServiceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentServiceLog
     */
    select?: EquipmentServiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentServiceLog
     */
    omit?: EquipmentServiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentServiceLogInclude<ExtArgs> | null
    where?: EquipmentServiceLogWhereInput
    orderBy?: EquipmentServiceLogOrderByWithRelationInput | EquipmentServiceLogOrderByWithRelationInput[]
    cursor?: EquipmentServiceLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentServiceLogScalarFieldEnum | EquipmentServiceLogScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Lift
   */

  export type AggregateLift = {
    _count: LiftCountAggregateOutputType | null
    _avg: LiftAvgAggregateOutputType | null
    _sum: LiftSumAggregateOutputType | null
    _min: LiftMinAggregateOutputType | null
    _max: LiftMaxAggregateOutputType | null
  }

  export type LiftAvgAggregateOutputType = {
    capacity: number | null
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type LiftSumAggregateOutputType = {
    capacity: number | null
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type LiftMinAggregateOutputType = {
    id: string | null
    mountainId: string | null
    name: string | null
    type: $Enums.LIFT_TYPE | null
    status: $Enums.STATUS | null
    capacity: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    locationId: string | null
  }

  export type LiftMaxAggregateOutputType = {
    id: string | null
    mountainId: string | null
    name: string | null
    type: $Enums.LIFT_TYPE | null
    status: $Enums.STATUS | null
    capacity: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    locationId: string | null
  }

  export type LiftCountAggregateOutputType = {
    id: number
    mountainId: number
    name: number
    type: number
    status: number
    capacity: number
    latitude: number
    longitude: number
    locationId: number
    _all: number
  }


  export type LiftAvgAggregateInputType = {
    capacity?: true
    latitude?: true
    longitude?: true
  }

  export type LiftSumAggregateInputType = {
    capacity?: true
    latitude?: true
    longitude?: true
  }

  export type LiftMinAggregateInputType = {
    id?: true
    mountainId?: true
    name?: true
    type?: true
    status?: true
    capacity?: true
    latitude?: true
    longitude?: true
    locationId?: true
  }

  export type LiftMaxAggregateInputType = {
    id?: true
    mountainId?: true
    name?: true
    type?: true
    status?: true
    capacity?: true
    latitude?: true
    longitude?: true
    locationId?: true
  }

  export type LiftCountAggregateInputType = {
    id?: true
    mountainId?: true
    name?: true
    type?: true
    status?: true
    capacity?: true
    latitude?: true
    longitude?: true
    locationId?: true
    _all?: true
  }

  export type LiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lift to aggregate.
     */
    where?: LiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lifts to fetch.
     */
    orderBy?: LiftOrderByWithRelationInput | LiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lifts
    **/
    _count?: true | LiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LiftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LiftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiftMaxAggregateInputType
  }

  export type GetLiftAggregateType<T extends LiftAggregateArgs> = {
        [P in keyof T & keyof AggregateLift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLift[P]>
      : GetScalarType<T[P], AggregateLift[P]>
  }




  export type LiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiftWhereInput
    orderBy?: LiftOrderByWithAggregationInput | LiftOrderByWithAggregationInput[]
    by: LiftScalarFieldEnum[] | LiftScalarFieldEnum
    having?: LiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiftCountAggregateInputType | true
    _avg?: LiftAvgAggregateInputType
    _sum?: LiftSumAggregateInputType
    _min?: LiftMinAggregateInputType
    _max?: LiftMaxAggregateInputType
  }

  export type LiftGroupByOutputType = {
    id: string
    mountainId: string
    name: string
    type: $Enums.LIFT_TYPE
    status: $Enums.STATUS
    capacity: number
    latitude: Decimal | null
    longitude: Decimal | null
    locationId: string | null
    _count: LiftCountAggregateOutputType | null
    _avg: LiftAvgAggregateOutputType | null
    _sum: LiftSumAggregateOutputType | null
    _min: LiftMinAggregateOutputType | null
    _max: LiftMaxAggregateOutputType | null
  }

  type GetLiftGroupByPayload<T extends LiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LiftGroupByOutputType[P]>
            : GetScalarType<T[P], LiftGroupByOutputType[P]>
        }
      >
    >


  export type LiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    capacity?: boolean
    latitude?: boolean
    longitude?: boolean
    locationId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    liftChecks?: boolean | Lift$liftChecksArgs<ExtArgs>
    location?: boolean | Lift$locationArgs<ExtArgs>
    _count?: boolean | LiftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lift"]>

  export type LiftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    capacity?: boolean
    latitude?: boolean
    longitude?: boolean
    locationId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | Lift$locationArgs<ExtArgs>
  }, ExtArgs["result"]["lift"]>

  export type LiftSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    capacity?: boolean
    latitude?: boolean
    longitude?: boolean
    locationId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | Lift$locationArgs<ExtArgs>
  }, ExtArgs["result"]["lift"]>

  export type LiftSelectScalar = {
    id?: boolean
    mountainId?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    capacity?: boolean
    latitude?: boolean
    longitude?: boolean
    locationId?: boolean
  }

  export type LiftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mountainId" | "name" | "type" | "status" | "capacity" | "latitude" | "longitude" | "locationId", ExtArgs["result"]["lift"]>
  export type LiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    liftChecks?: boolean | Lift$liftChecksArgs<ExtArgs>
    location?: boolean | Lift$locationArgs<ExtArgs>
    _count?: boolean | LiftCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LiftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | Lift$locationArgs<ExtArgs>
  }
  export type LiftIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | Lift$locationArgs<ExtArgs>
  }

  export type $LiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lift"
    objects: {
      mountain: Prisma.$MountainPayload<ExtArgs>
      liftChecks: Prisma.$LiftCheckPayload<ExtArgs>[]
      location: Prisma.$LocationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mountainId: string
      name: string
      type: $Enums.LIFT_TYPE
      status: $Enums.STATUS
      capacity: number
      latitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      locationId: string | null
    }, ExtArgs["result"]["lift"]>
    composites: {}
  }

  type LiftGetPayload<S extends boolean | null | undefined | LiftDefaultArgs> = $Result.GetResult<Prisma.$LiftPayload, S>

  type LiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LiftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LiftCountAggregateInputType | true
    }

  export interface LiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lift'], meta: { name: 'Lift' } }
    /**
     * Find zero or one Lift that matches the filter.
     * @param {LiftFindUniqueArgs} args - Arguments to find a Lift
     * @example
     * // Get one Lift
     * const lift = await prisma.lift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LiftFindUniqueArgs>(args: SelectSubset<T, LiftFindUniqueArgs<ExtArgs>>): Prisma__LiftClient<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lift that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LiftFindUniqueOrThrowArgs} args - Arguments to find a Lift
     * @example
     * // Get one Lift
     * const lift = await prisma.lift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LiftFindUniqueOrThrowArgs>(args: SelectSubset<T, LiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LiftClient<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftFindFirstArgs} args - Arguments to find a Lift
     * @example
     * // Get one Lift
     * const lift = await prisma.lift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LiftFindFirstArgs>(args?: SelectSubset<T, LiftFindFirstArgs<ExtArgs>>): Prisma__LiftClient<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftFindFirstOrThrowArgs} args - Arguments to find a Lift
     * @example
     * // Get one Lift
     * const lift = await prisma.lift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LiftFindFirstOrThrowArgs>(args?: SelectSubset<T, LiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__LiftClient<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lifts
     * const lifts = await prisma.lift.findMany()
     * 
     * // Get first 10 Lifts
     * const lifts = await prisma.lift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const liftWithIdOnly = await prisma.lift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LiftFindManyArgs>(args?: SelectSubset<T, LiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lift.
     * @param {LiftCreateArgs} args - Arguments to create a Lift.
     * @example
     * // Create one Lift
     * const Lift = await prisma.lift.create({
     *   data: {
     *     // ... data to create a Lift
     *   }
     * })
     * 
     */
    create<T extends LiftCreateArgs>(args: SelectSubset<T, LiftCreateArgs<ExtArgs>>): Prisma__LiftClient<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lifts.
     * @param {LiftCreateManyArgs} args - Arguments to create many Lifts.
     * @example
     * // Create many Lifts
     * const lift = await prisma.lift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LiftCreateManyArgs>(args?: SelectSubset<T, LiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lifts and returns the data saved in the database.
     * @param {LiftCreateManyAndReturnArgs} args - Arguments to create many Lifts.
     * @example
     * // Create many Lifts
     * const lift = await prisma.lift.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lifts and only return the `id`
     * const liftWithIdOnly = await prisma.lift.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LiftCreateManyAndReturnArgs>(args?: SelectSubset<T, LiftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lift.
     * @param {LiftDeleteArgs} args - Arguments to delete one Lift.
     * @example
     * // Delete one Lift
     * const Lift = await prisma.lift.delete({
     *   where: {
     *     // ... filter to delete one Lift
     *   }
     * })
     * 
     */
    delete<T extends LiftDeleteArgs>(args: SelectSubset<T, LiftDeleteArgs<ExtArgs>>): Prisma__LiftClient<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lift.
     * @param {LiftUpdateArgs} args - Arguments to update one Lift.
     * @example
     * // Update one Lift
     * const lift = await prisma.lift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LiftUpdateArgs>(args: SelectSubset<T, LiftUpdateArgs<ExtArgs>>): Prisma__LiftClient<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lifts.
     * @param {LiftDeleteManyArgs} args - Arguments to filter Lifts to delete.
     * @example
     * // Delete a few Lifts
     * const { count } = await prisma.lift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LiftDeleteManyArgs>(args?: SelectSubset<T, LiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lifts
     * const lift = await prisma.lift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LiftUpdateManyArgs>(args: SelectSubset<T, LiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lifts and returns the data updated in the database.
     * @param {LiftUpdateManyAndReturnArgs} args - Arguments to update many Lifts.
     * @example
     * // Update many Lifts
     * const lift = await prisma.lift.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lifts and only return the `id`
     * const liftWithIdOnly = await prisma.lift.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LiftUpdateManyAndReturnArgs>(args: SelectSubset<T, LiftUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lift.
     * @param {LiftUpsertArgs} args - Arguments to update or create a Lift.
     * @example
     * // Update or create a Lift
     * const lift = await prisma.lift.upsert({
     *   create: {
     *     // ... data to create a Lift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lift we want to update
     *   }
     * })
     */
    upsert<T extends LiftUpsertArgs>(args: SelectSubset<T, LiftUpsertArgs<ExtArgs>>): Prisma__LiftClient<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftCountArgs} args - Arguments to filter Lifts to count.
     * @example
     * // Count the number of Lifts
     * const count = await prisma.lift.count({
     *   where: {
     *     // ... the filter for the Lifts we want to count
     *   }
     * })
    **/
    count<T extends LiftCountArgs>(
      args?: Subset<T, LiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiftAggregateArgs>(args: Subset<T, LiftAggregateArgs>): Prisma.PrismaPromise<GetLiftAggregateType<T>>

    /**
     * Group by Lift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiftGroupByArgs['orderBy'] }
        : { orderBy?: LiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lift model
   */
  readonly fields: LiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    liftChecks<T extends Lift$liftChecksArgs<ExtArgs> = {}>(args?: Subset<T, Lift$liftChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    location<T extends Lift$locationArgs<ExtArgs> = {}>(args?: Subset<T, Lift$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lift model
   */
  interface LiftFieldRefs {
    readonly id: FieldRef<"Lift", 'String'>
    readonly mountainId: FieldRef<"Lift", 'String'>
    readonly name: FieldRef<"Lift", 'String'>
    readonly type: FieldRef<"Lift", 'LIFT_TYPE'>
    readonly status: FieldRef<"Lift", 'STATUS'>
    readonly capacity: FieldRef<"Lift", 'Int'>
    readonly latitude: FieldRef<"Lift", 'Decimal'>
    readonly longitude: FieldRef<"Lift", 'Decimal'>
    readonly locationId: FieldRef<"Lift", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lift findUnique
   */
  export type LiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
    /**
     * Filter, which Lift to fetch.
     */
    where: LiftWhereUniqueInput
  }

  /**
   * Lift findUniqueOrThrow
   */
  export type LiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
    /**
     * Filter, which Lift to fetch.
     */
    where: LiftWhereUniqueInput
  }

  /**
   * Lift findFirst
   */
  export type LiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
    /**
     * Filter, which Lift to fetch.
     */
    where?: LiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lifts to fetch.
     */
    orderBy?: LiftOrderByWithRelationInput | LiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lifts.
     */
    cursor?: LiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lifts.
     */
    distinct?: LiftScalarFieldEnum | LiftScalarFieldEnum[]
  }

  /**
   * Lift findFirstOrThrow
   */
  export type LiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
    /**
     * Filter, which Lift to fetch.
     */
    where?: LiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lifts to fetch.
     */
    orderBy?: LiftOrderByWithRelationInput | LiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lifts.
     */
    cursor?: LiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lifts.
     */
    distinct?: LiftScalarFieldEnum | LiftScalarFieldEnum[]
  }

  /**
   * Lift findMany
   */
  export type LiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
    /**
     * Filter, which Lifts to fetch.
     */
    where?: LiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lifts to fetch.
     */
    orderBy?: LiftOrderByWithRelationInput | LiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lifts.
     */
    cursor?: LiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lifts.
     */
    skip?: number
    distinct?: LiftScalarFieldEnum | LiftScalarFieldEnum[]
  }

  /**
   * Lift create
   */
  export type LiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
    /**
     * The data needed to create a Lift.
     */
    data: XOR<LiftCreateInput, LiftUncheckedCreateInput>
  }

  /**
   * Lift createMany
   */
  export type LiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lifts.
     */
    data: LiftCreateManyInput | LiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lift createManyAndReturn
   */
  export type LiftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * The data used to create many Lifts.
     */
    data: LiftCreateManyInput | LiftCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lift update
   */
  export type LiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
    /**
     * The data needed to update a Lift.
     */
    data: XOR<LiftUpdateInput, LiftUncheckedUpdateInput>
    /**
     * Choose, which Lift to update.
     */
    where: LiftWhereUniqueInput
  }

  /**
   * Lift updateMany
   */
  export type LiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lifts.
     */
    data: XOR<LiftUpdateManyMutationInput, LiftUncheckedUpdateManyInput>
    /**
     * Filter which Lifts to update
     */
    where?: LiftWhereInput
    /**
     * Limit how many Lifts to update.
     */
    limit?: number
  }

  /**
   * Lift updateManyAndReturn
   */
  export type LiftUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * The data used to update Lifts.
     */
    data: XOR<LiftUpdateManyMutationInput, LiftUncheckedUpdateManyInput>
    /**
     * Filter which Lifts to update
     */
    where?: LiftWhereInput
    /**
     * Limit how many Lifts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lift upsert
   */
  export type LiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
    /**
     * The filter to search for the Lift to update in case it exists.
     */
    where: LiftWhereUniqueInput
    /**
     * In case the Lift found by the `where` argument doesn't exist, create a new Lift with this data.
     */
    create: XOR<LiftCreateInput, LiftUncheckedCreateInput>
    /**
     * In case the Lift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LiftUpdateInput, LiftUncheckedUpdateInput>
  }

  /**
   * Lift delete
   */
  export type LiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
    /**
     * Filter which Lift to delete.
     */
    where: LiftWhereUniqueInput
  }

  /**
   * Lift deleteMany
   */
  export type LiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lifts to delete
     */
    where?: LiftWhereInput
    /**
     * Limit how many Lifts to delete.
     */
    limit?: number
  }

  /**
   * Lift.liftChecks
   */
  export type Lift$liftChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    where?: LiftCheckWhereInput
    orderBy?: LiftCheckOrderByWithRelationInput | LiftCheckOrderByWithRelationInput[]
    cursor?: LiftCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiftCheckScalarFieldEnum | LiftCheckScalarFieldEnum[]
  }

  /**
   * Lift.location
   */
  export type Lift$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Lift without action
   */
  export type LiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
  }


  /**
   * Model Trail
   */

  export type AggregateTrail = {
    _count: TrailCountAggregateOutputType | null
    _avg: TrailAvgAggregateOutputType | null
    _sum: TrailSumAggregateOutputType | null
    _min: TrailMinAggregateOutputType | null
    _max: TrailMaxAggregateOutputType | null
  }

  export type TrailAvgAggregateOutputType = {
    length: number | null
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type TrailSumAggregateOutputType = {
    length: number | null
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type TrailMinAggregateOutputType = {
    id: string | null
    mountainId: string | null
    name: string | null
    difficulty: $Enums.TRAIL_DIFFICULTY | null
    status: $Enums.STATUS | null
    length: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    condition: $Enums.TRAIL_CONDITION | null
    locationId: string | null
  }

  export type TrailMaxAggregateOutputType = {
    id: string | null
    mountainId: string | null
    name: string | null
    difficulty: $Enums.TRAIL_DIFFICULTY | null
    status: $Enums.STATUS | null
    length: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    condition: $Enums.TRAIL_CONDITION | null
    locationId: string | null
  }

  export type TrailCountAggregateOutputType = {
    id: number
    mountainId: number
    name: number
    difficulty: number
    status: number
    length: number
    latitude: number
    longitude: number
    condition: number
    locationId: number
    _all: number
  }


  export type TrailAvgAggregateInputType = {
    length?: true
    latitude?: true
    longitude?: true
  }

  export type TrailSumAggregateInputType = {
    length?: true
    latitude?: true
    longitude?: true
  }

  export type TrailMinAggregateInputType = {
    id?: true
    mountainId?: true
    name?: true
    difficulty?: true
    status?: true
    length?: true
    latitude?: true
    longitude?: true
    condition?: true
    locationId?: true
  }

  export type TrailMaxAggregateInputType = {
    id?: true
    mountainId?: true
    name?: true
    difficulty?: true
    status?: true
    length?: true
    latitude?: true
    longitude?: true
    condition?: true
    locationId?: true
  }

  export type TrailCountAggregateInputType = {
    id?: true
    mountainId?: true
    name?: true
    difficulty?: true
    status?: true
    length?: true
    latitude?: true
    longitude?: true
    condition?: true
    locationId?: true
    _all?: true
  }

  export type TrailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trail to aggregate.
     */
    where?: TrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trails to fetch.
     */
    orderBy?: TrailOrderByWithRelationInput | TrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trails
    **/
    _count?: true | TrailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrailMaxAggregateInputType
  }

  export type GetTrailAggregateType<T extends TrailAggregateArgs> = {
        [P in keyof T & keyof AggregateTrail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrail[P]>
      : GetScalarType<T[P], AggregateTrail[P]>
  }




  export type TrailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrailWhereInput
    orderBy?: TrailOrderByWithAggregationInput | TrailOrderByWithAggregationInput[]
    by: TrailScalarFieldEnum[] | TrailScalarFieldEnum
    having?: TrailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrailCountAggregateInputType | true
    _avg?: TrailAvgAggregateInputType
    _sum?: TrailSumAggregateInputType
    _min?: TrailMinAggregateInputType
    _max?: TrailMaxAggregateInputType
  }

  export type TrailGroupByOutputType = {
    id: string
    mountainId: string
    name: string
    difficulty: $Enums.TRAIL_DIFFICULTY
    status: $Enums.STATUS
    length: number
    latitude: Decimal | null
    longitude: Decimal | null
    condition: $Enums.TRAIL_CONDITION
    locationId: string | null
    _count: TrailCountAggregateOutputType | null
    _avg: TrailAvgAggregateOutputType | null
    _sum: TrailSumAggregateOutputType | null
    _min: TrailMinAggregateOutputType | null
    _max: TrailMaxAggregateOutputType | null
  }

  type GetTrailGroupByPayload<T extends TrailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrailGroupByOutputType[P]>
            : GetScalarType<T[P], TrailGroupByOutputType[P]>
        }
      >
    >


  export type TrailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    name?: boolean
    difficulty?: boolean
    status?: boolean
    length?: boolean
    latitude?: boolean
    longitude?: boolean
    condition?: boolean
    locationId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    trailChecks?: boolean | Trail$trailChecksArgs<ExtArgs>
    location?: boolean | Trail$locationArgs<ExtArgs>
    _count?: boolean | TrailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trail"]>

  export type TrailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    name?: boolean
    difficulty?: boolean
    status?: boolean
    length?: boolean
    latitude?: boolean
    longitude?: boolean
    condition?: boolean
    locationId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | Trail$locationArgs<ExtArgs>
  }, ExtArgs["result"]["trail"]>

  export type TrailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    name?: boolean
    difficulty?: boolean
    status?: boolean
    length?: boolean
    latitude?: boolean
    longitude?: boolean
    condition?: boolean
    locationId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | Trail$locationArgs<ExtArgs>
  }, ExtArgs["result"]["trail"]>

  export type TrailSelectScalar = {
    id?: boolean
    mountainId?: boolean
    name?: boolean
    difficulty?: boolean
    status?: boolean
    length?: boolean
    latitude?: boolean
    longitude?: boolean
    condition?: boolean
    locationId?: boolean
  }

  export type TrailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mountainId" | "name" | "difficulty" | "status" | "length" | "latitude" | "longitude" | "condition" | "locationId", ExtArgs["result"]["trail"]>
  export type TrailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    trailChecks?: boolean | Trail$trailChecksArgs<ExtArgs>
    location?: boolean | Trail$locationArgs<ExtArgs>
    _count?: boolean | TrailCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TrailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | Trail$locationArgs<ExtArgs>
  }
  export type TrailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | Trail$locationArgs<ExtArgs>
  }

  export type $TrailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trail"
    objects: {
      mountain: Prisma.$MountainPayload<ExtArgs>
      trailChecks: Prisma.$TrailCheckPayload<ExtArgs>[]
      location: Prisma.$LocationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mountainId: string
      name: string
      difficulty: $Enums.TRAIL_DIFFICULTY
      status: $Enums.STATUS
      length: number
      latitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      condition: $Enums.TRAIL_CONDITION
      locationId: string | null
    }, ExtArgs["result"]["trail"]>
    composites: {}
  }

  type TrailGetPayload<S extends boolean | null | undefined | TrailDefaultArgs> = $Result.GetResult<Prisma.$TrailPayload, S>

  type TrailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrailCountAggregateInputType | true
    }

  export interface TrailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trail'], meta: { name: 'Trail' } }
    /**
     * Find zero or one Trail that matches the filter.
     * @param {TrailFindUniqueArgs} args - Arguments to find a Trail
     * @example
     * // Get one Trail
     * const trail = await prisma.trail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrailFindUniqueArgs>(args: SelectSubset<T, TrailFindUniqueArgs<ExtArgs>>): Prisma__TrailClient<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrailFindUniqueOrThrowArgs} args - Arguments to find a Trail
     * @example
     * // Get one Trail
     * const trail = await prisma.trail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrailFindUniqueOrThrowArgs>(args: SelectSubset<T, TrailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrailClient<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailFindFirstArgs} args - Arguments to find a Trail
     * @example
     * // Get one Trail
     * const trail = await prisma.trail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrailFindFirstArgs>(args?: SelectSubset<T, TrailFindFirstArgs<ExtArgs>>): Prisma__TrailClient<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailFindFirstOrThrowArgs} args - Arguments to find a Trail
     * @example
     * // Get one Trail
     * const trail = await prisma.trail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrailFindFirstOrThrowArgs>(args?: SelectSubset<T, TrailFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrailClient<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trails
     * const trails = await prisma.trail.findMany()
     * 
     * // Get first 10 Trails
     * const trails = await prisma.trail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trailWithIdOnly = await prisma.trail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrailFindManyArgs>(args?: SelectSubset<T, TrailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trail.
     * @param {TrailCreateArgs} args - Arguments to create a Trail.
     * @example
     * // Create one Trail
     * const Trail = await prisma.trail.create({
     *   data: {
     *     // ... data to create a Trail
     *   }
     * })
     * 
     */
    create<T extends TrailCreateArgs>(args: SelectSubset<T, TrailCreateArgs<ExtArgs>>): Prisma__TrailClient<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trails.
     * @param {TrailCreateManyArgs} args - Arguments to create many Trails.
     * @example
     * // Create many Trails
     * const trail = await prisma.trail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrailCreateManyArgs>(args?: SelectSubset<T, TrailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trails and returns the data saved in the database.
     * @param {TrailCreateManyAndReturnArgs} args - Arguments to create many Trails.
     * @example
     * // Create many Trails
     * const trail = await prisma.trail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trails and only return the `id`
     * const trailWithIdOnly = await prisma.trail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrailCreateManyAndReturnArgs>(args?: SelectSubset<T, TrailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Trail.
     * @param {TrailDeleteArgs} args - Arguments to delete one Trail.
     * @example
     * // Delete one Trail
     * const Trail = await prisma.trail.delete({
     *   where: {
     *     // ... filter to delete one Trail
     *   }
     * })
     * 
     */
    delete<T extends TrailDeleteArgs>(args: SelectSubset<T, TrailDeleteArgs<ExtArgs>>): Prisma__TrailClient<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trail.
     * @param {TrailUpdateArgs} args - Arguments to update one Trail.
     * @example
     * // Update one Trail
     * const trail = await prisma.trail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrailUpdateArgs>(args: SelectSubset<T, TrailUpdateArgs<ExtArgs>>): Prisma__TrailClient<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trails.
     * @param {TrailDeleteManyArgs} args - Arguments to filter Trails to delete.
     * @example
     * // Delete a few Trails
     * const { count } = await prisma.trail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrailDeleteManyArgs>(args?: SelectSubset<T, TrailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trails
     * const trail = await prisma.trail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrailUpdateManyArgs>(args: SelectSubset<T, TrailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trails and returns the data updated in the database.
     * @param {TrailUpdateManyAndReturnArgs} args - Arguments to update many Trails.
     * @example
     * // Update many Trails
     * const trail = await prisma.trail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Trails and only return the `id`
     * const trailWithIdOnly = await prisma.trail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrailUpdateManyAndReturnArgs>(args: SelectSubset<T, TrailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Trail.
     * @param {TrailUpsertArgs} args - Arguments to update or create a Trail.
     * @example
     * // Update or create a Trail
     * const trail = await prisma.trail.upsert({
     *   create: {
     *     // ... data to create a Trail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trail we want to update
     *   }
     * })
     */
    upsert<T extends TrailUpsertArgs>(args: SelectSubset<T, TrailUpsertArgs<ExtArgs>>): Prisma__TrailClient<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailCountArgs} args - Arguments to filter Trails to count.
     * @example
     * // Count the number of Trails
     * const count = await prisma.trail.count({
     *   where: {
     *     // ... the filter for the Trails we want to count
     *   }
     * })
    **/
    count<T extends TrailCountArgs>(
      args?: Subset<T, TrailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrailAggregateArgs>(args: Subset<T, TrailAggregateArgs>): Prisma.PrismaPromise<GetTrailAggregateType<T>>

    /**
     * Group by Trail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrailGroupByArgs['orderBy'] }
        : { orderBy?: TrailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trail model
   */
  readonly fields: TrailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    trailChecks<T extends Trail$trailChecksArgs<ExtArgs> = {}>(args?: Subset<T, Trail$trailChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    location<T extends Trail$locationArgs<ExtArgs> = {}>(args?: Subset<T, Trail$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trail model
   */
  interface TrailFieldRefs {
    readonly id: FieldRef<"Trail", 'String'>
    readonly mountainId: FieldRef<"Trail", 'String'>
    readonly name: FieldRef<"Trail", 'String'>
    readonly difficulty: FieldRef<"Trail", 'TRAIL_DIFFICULTY'>
    readonly status: FieldRef<"Trail", 'STATUS'>
    readonly length: FieldRef<"Trail", 'Float'>
    readonly latitude: FieldRef<"Trail", 'Decimal'>
    readonly longitude: FieldRef<"Trail", 'Decimal'>
    readonly condition: FieldRef<"Trail", 'TRAIL_CONDITION'>
    readonly locationId: FieldRef<"Trail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Trail findUnique
   */
  export type TrailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
    /**
     * Filter, which Trail to fetch.
     */
    where: TrailWhereUniqueInput
  }

  /**
   * Trail findUniqueOrThrow
   */
  export type TrailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
    /**
     * Filter, which Trail to fetch.
     */
    where: TrailWhereUniqueInput
  }

  /**
   * Trail findFirst
   */
  export type TrailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
    /**
     * Filter, which Trail to fetch.
     */
    where?: TrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trails to fetch.
     */
    orderBy?: TrailOrderByWithRelationInput | TrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trails.
     */
    cursor?: TrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trails.
     */
    distinct?: TrailScalarFieldEnum | TrailScalarFieldEnum[]
  }

  /**
   * Trail findFirstOrThrow
   */
  export type TrailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
    /**
     * Filter, which Trail to fetch.
     */
    where?: TrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trails to fetch.
     */
    orderBy?: TrailOrderByWithRelationInput | TrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trails.
     */
    cursor?: TrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trails.
     */
    distinct?: TrailScalarFieldEnum | TrailScalarFieldEnum[]
  }

  /**
   * Trail findMany
   */
  export type TrailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
    /**
     * Filter, which Trails to fetch.
     */
    where?: TrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trails to fetch.
     */
    orderBy?: TrailOrderByWithRelationInput | TrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trails.
     */
    cursor?: TrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trails.
     */
    skip?: number
    distinct?: TrailScalarFieldEnum | TrailScalarFieldEnum[]
  }

  /**
   * Trail create
   */
  export type TrailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
    /**
     * The data needed to create a Trail.
     */
    data: XOR<TrailCreateInput, TrailUncheckedCreateInput>
  }

  /**
   * Trail createMany
   */
  export type TrailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trails.
     */
    data: TrailCreateManyInput | TrailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trail createManyAndReturn
   */
  export type TrailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * The data used to create many Trails.
     */
    data: TrailCreateManyInput | TrailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Trail update
   */
  export type TrailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
    /**
     * The data needed to update a Trail.
     */
    data: XOR<TrailUpdateInput, TrailUncheckedUpdateInput>
    /**
     * Choose, which Trail to update.
     */
    where: TrailWhereUniqueInput
  }

  /**
   * Trail updateMany
   */
  export type TrailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trails.
     */
    data: XOR<TrailUpdateManyMutationInput, TrailUncheckedUpdateManyInput>
    /**
     * Filter which Trails to update
     */
    where?: TrailWhereInput
    /**
     * Limit how many Trails to update.
     */
    limit?: number
  }

  /**
   * Trail updateManyAndReturn
   */
  export type TrailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * The data used to update Trails.
     */
    data: XOR<TrailUpdateManyMutationInput, TrailUncheckedUpdateManyInput>
    /**
     * Filter which Trails to update
     */
    where?: TrailWhereInput
    /**
     * Limit how many Trails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Trail upsert
   */
  export type TrailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
    /**
     * The filter to search for the Trail to update in case it exists.
     */
    where: TrailWhereUniqueInput
    /**
     * In case the Trail found by the `where` argument doesn't exist, create a new Trail with this data.
     */
    create: XOR<TrailCreateInput, TrailUncheckedCreateInput>
    /**
     * In case the Trail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrailUpdateInput, TrailUncheckedUpdateInput>
  }

  /**
   * Trail delete
   */
  export type TrailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
    /**
     * Filter which Trail to delete.
     */
    where: TrailWhereUniqueInput
  }

  /**
   * Trail deleteMany
   */
  export type TrailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trails to delete
     */
    where?: TrailWhereInput
    /**
     * Limit how many Trails to delete.
     */
    limit?: number
  }

  /**
   * Trail.trailChecks
   */
  export type Trail$trailChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    where?: TrailCheckWhereInput
    orderBy?: TrailCheckOrderByWithRelationInput | TrailCheckOrderByWithRelationInput[]
    cursor?: TrailCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrailCheckScalarFieldEnum | TrailCheckScalarFieldEnum[]
  }

  /**
   * Trail.location
   */
  export type Trail$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Trail without action
   */
  export type TrailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
  }


  /**
   * Model Lodge
   */

  export type AggregateLodge = {
    _count: LodgeCountAggregateOutputType | null
    _avg: LodgeAvgAggregateOutputType | null
    _sum: LodgeSumAggregateOutputType | null
    _min: LodgeMinAggregateOutputType | null
    _max: LodgeMaxAggregateOutputType | null
  }

  export type LodgeAvgAggregateOutputType = {
    capacity: number | null
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type LodgeSumAggregateOutputType = {
    capacity: number | null
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type LodgeMinAggregateOutputType = {
    id: string | null
    mountainId: string | null
    name: string | null
    capacity: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    status: $Enums.STATUS | null
    locationId: string | null
  }

  export type LodgeMaxAggregateOutputType = {
    id: string | null
    mountainId: string | null
    name: string | null
    capacity: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    status: $Enums.STATUS | null
    locationId: string | null
  }

  export type LodgeCountAggregateOutputType = {
    id: number
    mountainId: number
    name: number
    capacity: number
    latitude: number
    longitude: number
    status: number
    locationId: number
    _all: number
  }


  export type LodgeAvgAggregateInputType = {
    capacity?: true
    latitude?: true
    longitude?: true
  }

  export type LodgeSumAggregateInputType = {
    capacity?: true
    latitude?: true
    longitude?: true
  }

  export type LodgeMinAggregateInputType = {
    id?: true
    mountainId?: true
    name?: true
    capacity?: true
    latitude?: true
    longitude?: true
    status?: true
    locationId?: true
  }

  export type LodgeMaxAggregateInputType = {
    id?: true
    mountainId?: true
    name?: true
    capacity?: true
    latitude?: true
    longitude?: true
    status?: true
    locationId?: true
  }

  export type LodgeCountAggregateInputType = {
    id?: true
    mountainId?: true
    name?: true
    capacity?: true
    latitude?: true
    longitude?: true
    status?: true
    locationId?: true
    _all?: true
  }

  export type LodgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lodge to aggregate.
     */
    where?: LodgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lodges to fetch.
     */
    orderBy?: LodgeOrderByWithRelationInput | LodgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LodgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lodges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lodges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lodges
    **/
    _count?: true | LodgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LodgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LodgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LodgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LodgeMaxAggregateInputType
  }

  export type GetLodgeAggregateType<T extends LodgeAggregateArgs> = {
        [P in keyof T & keyof AggregateLodge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLodge[P]>
      : GetScalarType<T[P], AggregateLodge[P]>
  }




  export type LodgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LodgeWhereInput
    orderBy?: LodgeOrderByWithAggregationInput | LodgeOrderByWithAggregationInput[]
    by: LodgeScalarFieldEnum[] | LodgeScalarFieldEnum
    having?: LodgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LodgeCountAggregateInputType | true
    _avg?: LodgeAvgAggregateInputType
    _sum?: LodgeSumAggregateInputType
    _min?: LodgeMinAggregateInputType
    _max?: LodgeMaxAggregateInputType
  }

  export type LodgeGroupByOutputType = {
    id: string
    mountainId: string
    name: string
    capacity: number
    latitude: Decimal | null
    longitude: Decimal | null
    status: $Enums.STATUS
    locationId: string | null
    _count: LodgeCountAggregateOutputType | null
    _avg: LodgeAvgAggregateOutputType | null
    _sum: LodgeSumAggregateOutputType | null
    _min: LodgeMinAggregateOutputType | null
    _max: LodgeMaxAggregateOutputType | null
  }

  type GetLodgeGroupByPayload<T extends LodgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LodgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LodgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LodgeGroupByOutputType[P]>
            : GetScalarType<T[P], LodgeGroupByOutputType[P]>
        }
      >
    >


  export type LodgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    name?: boolean
    capacity?: boolean
    latitude?: boolean
    longitude?: boolean
    status?: boolean
    locationId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | Lodge$locationArgs<ExtArgs>
  }, ExtArgs["result"]["lodge"]>

  export type LodgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    name?: boolean
    capacity?: boolean
    latitude?: boolean
    longitude?: boolean
    status?: boolean
    locationId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | Lodge$locationArgs<ExtArgs>
  }, ExtArgs["result"]["lodge"]>

  export type LodgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    name?: boolean
    capacity?: boolean
    latitude?: boolean
    longitude?: boolean
    status?: boolean
    locationId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | Lodge$locationArgs<ExtArgs>
  }, ExtArgs["result"]["lodge"]>

  export type LodgeSelectScalar = {
    id?: boolean
    mountainId?: boolean
    name?: boolean
    capacity?: boolean
    latitude?: boolean
    longitude?: boolean
    status?: boolean
    locationId?: boolean
  }

  export type LodgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mountainId" | "name" | "capacity" | "latitude" | "longitude" | "status" | "locationId", ExtArgs["result"]["lodge"]>
  export type LodgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | Lodge$locationArgs<ExtArgs>
  }
  export type LodgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | Lodge$locationArgs<ExtArgs>
  }
  export type LodgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | Lodge$locationArgs<ExtArgs>
  }

  export type $LodgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lodge"
    objects: {
      mountain: Prisma.$MountainPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mountainId: string
      name: string
      capacity: number
      latitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      status: $Enums.STATUS
      locationId: string | null
    }, ExtArgs["result"]["lodge"]>
    composites: {}
  }

  type LodgeGetPayload<S extends boolean | null | undefined | LodgeDefaultArgs> = $Result.GetResult<Prisma.$LodgePayload, S>

  type LodgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LodgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LodgeCountAggregateInputType | true
    }

  export interface LodgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lodge'], meta: { name: 'Lodge' } }
    /**
     * Find zero or one Lodge that matches the filter.
     * @param {LodgeFindUniqueArgs} args - Arguments to find a Lodge
     * @example
     * // Get one Lodge
     * const lodge = await prisma.lodge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LodgeFindUniqueArgs>(args: SelectSubset<T, LodgeFindUniqueArgs<ExtArgs>>): Prisma__LodgeClient<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lodge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LodgeFindUniqueOrThrowArgs} args - Arguments to find a Lodge
     * @example
     * // Get one Lodge
     * const lodge = await prisma.lodge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LodgeFindUniqueOrThrowArgs>(args: SelectSubset<T, LodgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LodgeClient<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lodge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LodgeFindFirstArgs} args - Arguments to find a Lodge
     * @example
     * // Get one Lodge
     * const lodge = await prisma.lodge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LodgeFindFirstArgs>(args?: SelectSubset<T, LodgeFindFirstArgs<ExtArgs>>): Prisma__LodgeClient<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lodge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LodgeFindFirstOrThrowArgs} args - Arguments to find a Lodge
     * @example
     * // Get one Lodge
     * const lodge = await prisma.lodge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LodgeFindFirstOrThrowArgs>(args?: SelectSubset<T, LodgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LodgeClient<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lodges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LodgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lodges
     * const lodges = await prisma.lodge.findMany()
     * 
     * // Get first 10 Lodges
     * const lodges = await prisma.lodge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lodgeWithIdOnly = await prisma.lodge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LodgeFindManyArgs>(args?: SelectSubset<T, LodgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lodge.
     * @param {LodgeCreateArgs} args - Arguments to create a Lodge.
     * @example
     * // Create one Lodge
     * const Lodge = await prisma.lodge.create({
     *   data: {
     *     // ... data to create a Lodge
     *   }
     * })
     * 
     */
    create<T extends LodgeCreateArgs>(args: SelectSubset<T, LodgeCreateArgs<ExtArgs>>): Prisma__LodgeClient<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lodges.
     * @param {LodgeCreateManyArgs} args - Arguments to create many Lodges.
     * @example
     * // Create many Lodges
     * const lodge = await prisma.lodge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LodgeCreateManyArgs>(args?: SelectSubset<T, LodgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lodges and returns the data saved in the database.
     * @param {LodgeCreateManyAndReturnArgs} args - Arguments to create many Lodges.
     * @example
     * // Create many Lodges
     * const lodge = await prisma.lodge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lodges and only return the `id`
     * const lodgeWithIdOnly = await prisma.lodge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LodgeCreateManyAndReturnArgs>(args?: SelectSubset<T, LodgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lodge.
     * @param {LodgeDeleteArgs} args - Arguments to delete one Lodge.
     * @example
     * // Delete one Lodge
     * const Lodge = await prisma.lodge.delete({
     *   where: {
     *     // ... filter to delete one Lodge
     *   }
     * })
     * 
     */
    delete<T extends LodgeDeleteArgs>(args: SelectSubset<T, LodgeDeleteArgs<ExtArgs>>): Prisma__LodgeClient<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lodge.
     * @param {LodgeUpdateArgs} args - Arguments to update one Lodge.
     * @example
     * // Update one Lodge
     * const lodge = await prisma.lodge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LodgeUpdateArgs>(args: SelectSubset<T, LodgeUpdateArgs<ExtArgs>>): Prisma__LodgeClient<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lodges.
     * @param {LodgeDeleteManyArgs} args - Arguments to filter Lodges to delete.
     * @example
     * // Delete a few Lodges
     * const { count } = await prisma.lodge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LodgeDeleteManyArgs>(args?: SelectSubset<T, LodgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lodges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LodgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lodges
     * const lodge = await prisma.lodge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LodgeUpdateManyArgs>(args: SelectSubset<T, LodgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lodges and returns the data updated in the database.
     * @param {LodgeUpdateManyAndReturnArgs} args - Arguments to update many Lodges.
     * @example
     * // Update many Lodges
     * const lodge = await prisma.lodge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lodges and only return the `id`
     * const lodgeWithIdOnly = await prisma.lodge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LodgeUpdateManyAndReturnArgs>(args: SelectSubset<T, LodgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lodge.
     * @param {LodgeUpsertArgs} args - Arguments to update or create a Lodge.
     * @example
     * // Update or create a Lodge
     * const lodge = await prisma.lodge.upsert({
     *   create: {
     *     // ... data to create a Lodge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lodge we want to update
     *   }
     * })
     */
    upsert<T extends LodgeUpsertArgs>(args: SelectSubset<T, LodgeUpsertArgs<ExtArgs>>): Prisma__LodgeClient<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lodges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LodgeCountArgs} args - Arguments to filter Lodges to count.
     * @example
     * // Count the number of Lodges
     * const count = await prisma.lodge.count({
     *   where: {
     *     // ... the filter for the Lodges we want to count
     *   }
     * })
    **/
    count<T extends LodgeCountArgs>(
      args?: Subset<T, LodgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LodgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lodge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LodgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LodgeAggregateArgs>(args: Subset<T, LodgeAggregateArgs>): Prisma.PrismaPromise<GetLodgeAggregateType<T>>

    /**
     * Group by Lodge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LodgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LodgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LodgeGroupByArgs['orderBy'] }
        : { orderBy?: LodgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LodgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLodgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lodge model
   */
  readonly fields: LodgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lodge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LodgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location<T extends Lodge$locationArgs<ExtArgs> = {}>(args?: Subset<T, Lodge$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lodge model
   */
  interface LodgeFieldRefs {
    readonly id: FieldRef<"Lodge", 'String'>
    readonly mountainId: FieldRef<"Lodge", 'String'>
    readonly name: FieldRef<"Lodge", 'String'>
    readonly capacity: FieldRef<"Lodge", 'Int'>
    readonly latitude: FieldRef<"Lodge", 'Decimal'>
    readonly longitude: FieldRef<"Lodge", 'Decimal'>
    readonly status: FieldRef<"Lodge", 'STATUS'>
    readonly locationId: FieldRef<"Lodge", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lodge findUnique
   */
  export type LodgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
    /**
     * Filter, which Lodge to fetch.
     */
    where: LodgeWhereUniqueInput
  }

  /**
   * Lodge findUniqueOrThrow
   */
  export type LodgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
    /**
     * Filter, which Lodge to fetch.
     */
    where: LodgeWhereUniqueInput
  }

  /**
   * Lodge findFirst
   */
  export type LodgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
    /**
     * Filter, which Lodge to fetch.
     */
    where?: LodgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lodges to fetch.
     */
    orderBy?: LodgeOrderByWithRelationInput | LodgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lodges.
     */
    cursor?: LodgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lodges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lodges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lodges.
     */
    distinct?: LodgeScalarFieldEnum | LodgeScalarFieldEnum[]
  }

  /**
   * Lodge findFirstOrThrow
   */
  export type LodgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
    /**
     * Filter, which Lodge to fetch.
     */
    where?: LodgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lodges to fetch.
     */
    orderBy?: LodgeOrderByWithRelationInput | LodgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lodges.
     */
    cursor?: LodgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lodges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lodges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lodges.
     */
    distinct?: LodgeScalarFieldEnum | LodgeScalarFieldEnum[]
  }

  /**
   * Lodge findMany
   */
  export type LodgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
    /**
     * Filter, which Lodges to fetch.
     */
    where?: LodgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lodges to fetch.
     */
    orderBy?: LodgeOrderByWithRelationInput | LodgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lodges.
     */
    cursor?: LodgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lodges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lodges.
     */
    skip?: number
    distinct?: LodgeScalarFieldEnum | LodgeScalarFieldEnum[]
  }

  /**
   * Lodge create
   */
  export type LodgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Lodge.
     */
    data: XOR<LodgeCreateInput, LodgeUncheckedCreateInput>
  }

  /**
   * Lodge createMany
   */
  export type LodgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lodges.
     */
    data: LodgeCreateManyInput | LodgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lodge createManyAndReturn
   */
  export type LodgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * The data used to create many Lodges.
     */
    data: LodgeCreateManyInput | LodgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lodge update
   */
  export type LodgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Lodge.
     */
    data: XOR<LodgeUpdateInput, LodgeUncheckedUpdateInput>
    /**
     * Choose, which Lodge to update.
     */
    where: LodgeWhereUniqueInput
  }

  /**
   * Lodge updateMany
   */
  export type LodgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lodges.
     */
    data: XOR<LodgeUpdateManyMutationInput, LodgeUncheckedUpdateManyInput>
    /**
     * Filter which Lodges to update
     */
    where?: LodgeWhereInput
    /**
     * Limit how many Lodges to update.
     */
    limit?: number
  }

  /**
   * Lodge updateManyAndReturn
   */
  export type LodgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * The data used to update Lodges.
     */
    data: XOR<LodgeUpdateManyMutationInput, LodgeUncheckedUpdateManyInput>
    /**
     * Filter which Lodges to update
     */
    where?: LodgeWhereInput
    /**
     * Limit how many Lodges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lodge upsert
   */
  export type LodgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Lodge to update in case it exists.
     */
    where: LodgeWhereUniqueInput
    /**
     * In case the Lodge found by the `where` argument doesn't exist, create a new Lodge with this data.
     */
    create: XOR<LodgeCreateInput, LodgeUncheckedCreateInput>
    /**
     * In case the Lodge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LodgeUpdateInput, LodgeUncheckedUpdateInput>
  }

  /**
   * Lodge delete
   */
  export type LodgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
    /**
     * Filter which Lodge to delete.
     */
    where: LodgeWhereUniqueInput
  }

  /**
   * Lodge deleteMany
   */
  export type LodgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lodges to delete
     */
    where?: LodgeWhereInput
    /**
     * Limit how many Lodges to delete.
     */
    limit?: number
  }

  /**
   * Lodge.location
   */
  export type Lodge$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Lodge without action
   */
  export type LodgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
  }


  /**
   * Model Hut
   */

  export type AggregateHut = {
    _count: HutCountAggregateOutputType | null
    _avg: HutAvgAggregateOutputType | null
    _sum: HutSumAggregateOutputType | null
    _min: HutMinAggregateOutputType | null
    _max: HutMaxAggregateOutputType | null
  }

  export type HutAvgAggregateOutputType = {
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type HutSumAggregateOutputType = {
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type HutMinAggregateOutputType = {
    id: string | null
    mountainId: string | null
    name: string | null
    status: $Enums.STATUS | null
    latitude: Decimal | null
    longitude: Decimal | null
    locationId: string | null
  }

  export type HutMaxAggregateOutputType = {
    id: string | null
    mountainId: string | null
    name: string | null
    status: $Enums.STATUS | null
    latitude: Decimal | null
    longitude: Decimal | null
    locationId: string | null
  }

  export type HutCountAggregateOutputType = {
    id: number
    mountainId: number
    name: number
    status: number
    latitude: number
    longitude: number
    locationId: number
    _all: number
  }


  export type HutAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type HutSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type HutMinAggregateInputType = {
    id?: true
    mountainId?: true
    name?: true
    status?: true
    latitude?: true
    longitude?: true
    locationId?: true
  }

  export type HutMaxAggregateInputType = {
    id?: true
    mountainId?: true
    name?: true
    status?: true
    latitude?: true
    longitude?: true
    locationId?: true
  }

  export type HutCountAggregateInputType = {
    id?: true
    mountainId?: true
    name?: true
    status?: true
    latitude?: true
    longitude?: true
    locationId?: true
    _all?: true
  }

  export type HutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hut to aggregate.
     */
    where?: HutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Huts to fetch.
     */
    orderBy?: HutOrderByWithRelationInput | HutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Huts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Huts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Huts
    **/
    _count?: true | HutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HutMaxAggregateInputType
  }

  export type GetHutAggregateType<T extends HutAggregateArgs> = {
        [P in keyof T & keyof AggregateHut]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHut[P]>
      : GetScalarType<T[P], AggregateHut[P]>
  }




  export type HutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HutWhereInput
    orderBy?: HutOrderByWithAggregationInput | HutOrderByWithAggregationInput[]
    by: HutScalarFieldEnum[] | HutScalarFieldEnum
    having?: HutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HutCountAggregateInputType | true
    _avg?: HutAvgAggregateInputType
    _sum?: HutSumAggregateInputType
    _min?: HutMinAggregateInputType
    _max?: HutMaxAggregateInputType
  }

  export type HutGroupByOutputType = {
    id: string
    mountainId: string
    name: string
    status: $Enums.STATUS
    latitude: Decimal | null
    longitude: Decimal | null
    locationId: string | null
    _count: HutCountAggregateOutputType | null
    _avg: HutAvgAggregateOutputType | null
    _sum: HutSumAggregateOutputType | null
    _min: HutMinAggregateOutputType | null
    _max: HutMaxAggregateOutputType | null
  }

  type GetHutGroupByPayload<T extends HutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HutGroupByOutputType[P]>
            : GetScalarType<T[P], HutGroupByOutputType[P]>
        }
      >
    >


  export type HutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    name?: boolean
    status?: boolean
    latitude?: boolean
    longitude?: boolean
    locationId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    hutChecks?: boolean | Hut$hutChecksArgs<ExtArgs>
    location?: boolean | Hut$locationArgs<ExtArgs>
    _count?: boolean | HutCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hut"]>

  export type HutSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    name?: boolean
    status?: boolean
    latitude?: boolean
    longitude?: boolean
    locationId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | Hut$locationArgs<ExtArgs>
  }, ExtArgs["result"]["hut"]>

  export type HutSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    name?: boolean
    status?: boolean
    latitude?: boolean
    longitude?: boolean
    locationId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | Hut$locationArgs<ExtArgs>
  }, ExtArgs["result"]["hut"]>

  export type HutSelectScalar = {
    id?: boolean
    mountainId?: boolean
    name?: boolean
    status?: boolean
    latitude?: boolean
    longitude?: boolean
    locationId?: boolean
  }

  export type HutOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mountainId" | "name" | "status" | "latitude" | "longitude" | "locationId", ExtArgs["result"]["hut"]>
  export type HutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    hutChecks?: boolean | Hut$hutChecksArgs<ExtArgs>
    location?: boolean | Hut$locationArgs<ExtArgs>
    _count?: boolean | HutCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HutIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | Hut$locationArgs<ExtArgs>
  }
  export type HutIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | Hut$locationArgs<ExtArgs>
  }

  export type $HutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hut"
    objects: {
      mountain: Prisma.$MountainPayload<ExtArgs>
      hutChecks: Prisma.$HutCheckPayload<ExtArgs>[]
      location: Prisma.$LocationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mountainId: string
      name: string
      status: $Enums.STATUS
      latitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      locationId: string | null
    }, ExtArgs["result"]["hut"]>
    composites: {}
  }

  type HutGetPayload<S extends boolean | null | undefined | HutDefaultArgs> = $Result.GetResult<Prisma.$HutPayload, S>

  type HutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HutFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HutCountAggregateInputType | true
    }

  export interface HutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hut'], meta: { name: 'Hut' } }
    /**
     * Find zero or one Hut that matches the filter.
     * @param {HutFindUniqueArgs} args - Arguments to find a Hut
     * @example
     * // Get one Hut
     * const hut = await prisma.hut.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HutFindUniqueArgs>(args: SelectSubset<T, HutFindUniqueArgs<ExtArgs>>): Prisma__HutClient<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hut that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HutFindUniqueOrThrowArgs} args - Arguments to find a Hut
     * @example
     * // Get one Hut
     * const hut = await prisma.hut.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HutFindUniqueOrThrowArgs>(args: SelectSubset<T, HutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HutClient<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hut that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutFindFirstArgs} args - Arguments to find a Hut
     * @example
     * // Get one Hut
     * const hut = await prisma.hut.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HutFindFirstArgs>(args?: SelectSubset<T, HutFindFirstArgs<ExtArgs>>): Prisma__HutClient<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hut that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutFindFirstOrThrowArgs} args - Arguments to find a Hut
     * @example
     * // Get one Hut
     * const hut = await prisma.hut.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HutFindFirstOrThrowArgs>(args?: SelectSubset<T, HutFindFirstOrThrowArgs<ExtArgs>>): Prisma__HutClient<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Huts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Huts
     * const huts = await prisma.hut.findMany()
     * 
     * // Get first 10 Huts
     * const huts = await prisma.hut.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hutWithIdOnly = await prisma.hut.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HutFindManyArgs>(args?: SelectSubset<T, HutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hut.
     * @param {HutCreateArgs} args - Arguments to create a Hut.
     * @example
     * // Create one Hut
     * const Hut = await prisma.hut.create({
     *   data: {
     *     // ... data to create a Hut
     *   }
     * })
     * 
     */
    create<T extends HutCreateArgs>(args: SelectSubset<T, HutCreateArgs<ExtArgs>>): Prisma__HutClient<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Huts.
     * @param {HutCreateManyArgs} args - Arguments to create many Huts.
     * @example
     * // Create many Huts
     * const hut = await prisma.hut.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HutCreateManyArgs>(args?: SelectSubset<T, HutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Huts and returns the data saved in the database.
     * @param {HutCreateManyAndReturnArgs} args - Arguments to create many Huts.
     * @example
     * // Create many Huts
     * const hut = await prisma.hut.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Huts and only return the `id`
     * const hutWithIdOnly = await prisma.hut.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HutCreateManyAndReturnArgs>(args?: SelectSubset<T, HutCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Hut.
     * @param {HutDeleteArgs} args - Arguments to delete one Hut.
     * @example
     * // Delete one Hut
     * const Hut = await prisma.hut.delete({
     *   where: {
     *     // ... filter to delete one Hut
     *   }
     * })
     * 
     */
    delete<T extends HutDeleteArgs>(args: SelectSubset<T, HutDeleteArgs<ExtArgs>>): Prisma__HutClient<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hut.
     * @param {HutUpdateArgs} args - Arguments to update one Hut.
     * @example
     * // Update one Hut
     * const hut = await prisma.hut.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HutUpdateArgs>(args: SelectSubset<T, HutUpdateArgs<ExtArgs>>): Prisma__HutClient<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Huts.
     * @param {HutDeleteManyArgs} args - Arguments to filter Huts to delete.
     * @example
     * // Delete a few Huts
     * const { count } = await prisma.hut.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HutDeleteManyArgs>(args?: SelectSubset<T, HutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Huts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Huts
     * const hut = await prisma.hut.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HutUpdateManyArgs>(args: SelectSubset<T, HutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Huts and returns the data updated in the database.
     * @param {HutUpdateManyAndReturnArgs} args - Arguments to update many Huts.
     * @example
     * // Update many Huts
     * const hut = await prisma.hut.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Huts and only return the `id`
     * const hutWithIdOnly = await prisma.hut.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HutUpdateManyAndReturnArgs>(args: SelectSubset<T, HutUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Hut.
     * @param {HutUpsertArgs} args - Arguments to update or create a Hut.
     * @example
     * // Update or create a Hut
     * const hut = await prisma.hut.upsert({
     *   create: {
     *     // ... data to create a Hut
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hut we want to update
     *   }
     * })
     */
    upsert<T extends HutUpsertArgs>(args: SelectSubset<T, HutUpsertArgs<ExtArgs>>): Prisma__HutClient<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Huts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutCountArgs} args - Arguments to filter Huts to count.
     * @example
     * // Count the number of Huts
     * const count = await prisma.hut.count({
     *   where: {
     *     // ... the filter for the Huts we want to count
     *   }
     * })
    **/
    count<T extends HutCountArgs>(
      args?: Subset<T, HutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HutAggregateArgs>(args: Subset<T, HutAggregateArgs>): Prisma.PrismaPromise<GetHutAggregateType<T>>

    /**
     * Group by Hut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HutGroupByArgs['orderBy'] }
        : { orderBy?: HutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hut model
   */
  readonly fields: HutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hut.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    hutChecks<T extends Hut$hutChecksArgs<ExtArgs> = {}>(args?: Subset<T, Hut$hutChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    location<T extends Hut$locationArgs<ExtArgs> = {}>(args?: Subset<T, Hut$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hut model
   */
  interface HutFieldRefs {
    readonly id: FieldRef<"Hut", 'String'>
    readonly mountainId: FieldRef<"Hut", 'String'>
    readonly name: FieldRef<"Hut", 'String'>
    readonly status: FieldRef<"Hut", 'STATUS'>
    readonly latitude: FieldRef<"Hut", 'Decimal'>
    readonly longitude: FieldRef<"Hut", 'Decimal'>
    readonly locationId: FieldRef<"Hut", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Hut findUnique
   */
  export type HutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
    /**
     * Filter, which Hut to fetch.
     */
    where: HutWhereUniqueInput
  }

  /**
   * Hut findUniqueOrThrow
   */
  export type HutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
    /**
     * Filter, which Hut to fetch.
     */
    where: HutWhereUniqueInput
  }

  /**
   * Hut findFirst
   */
  export type HutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
    /**
     * Filter, which Hut to fetch.
     */
    where?: HutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Huts to fetch.
     */
    orderBy?: HutOrderByWithRelationInput | HutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Huts.
     */
    cursor?: HutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Huts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Huts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Huts.
     */
    distinct?: HutScalarFieldEnum | HutScalarFieldEnum[]
  }

  /**
   * Hut findFirstOrThrow
   */
  export type HutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
    /**
     * Filter, which Hut to fetch.
     */
    where?: HutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Huts to fetch.
     */
    orderBy?: HutOrderByWithRelationInput | HutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Huts.
     */
    cursor?: HutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Huts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Huts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Huts.
     */
    distinct?: HutScalarFieldEnum | HutScalarFieldEnum[]
  }

  /**
   * Hut findMany
   */
  export type HutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
    /**
     * Filter, which Huts to fetch.
     */
    where?: HutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Huts to fetch.
     */
    orderBy?: HutOrderByWithRelationInput | HutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Huts.
     */
    cursor?: HutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Huts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Huts.
     */
    skip?: number
    distinct?: HutScalarFieldEnum | HutScalarFieldEnum[]
  }

  /**
   * Hut create
   */
  export type HutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
    /**
     * The data needed to create a Hut.
     */
    data: XOR<HutCreateInput, HutUncheckedCreateInput>
  }

  /**
   * Hut createMany
   */
  export type HutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Huts.
     */
    data: HutCreateManyInput | HutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hut createManyAndReturn
   */
  export type HutCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * The data used to create many Huts.
     */
    data: HutCreateManyInput | HutCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hut update
   */
  export type HutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
    /**
     * The data needed to update a Hut.
     */
    data: XOR<HutUpdateInput, HutUncheckedUpdateInput>
    /**
     * Choose, which Hut to update.
     */
    where: HutWhereUniqueInput
  }

  /**
   * Hut updateMany
   */
  export type HutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Huts.
     */
    data: XOR<HutUpdateManyMutationInput, HutUncheckedUpdateManyInput>
    /**
     * Filter which Huts to update
     */
    where?: HutWhereInput
    /**
     * Limit how many Huts to update.
     */
    limit?: number
  }

  /**
   * Hut updateManyAndReturn
   */
  export type HutUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * The data used to update Huts.
     */
    data: XOR<HutUpdateManyMutationInput, HutUncheckedUpdateManyInput>
    /**
     * Filter which Huts to update
     */
    where?: HutWhereInput
    /**
     * Limit how many Huts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hut upsert
   */
  export type HutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
    /**
     * The filter to search for the Hut to update in case it exists.
     */
    where: HutWhereUniqueInput
    /**
     * In case the Hut found by the `where` argument doesn't exist, create a new Hut with this data.
     */
    create: XOR<HutCreateInput, HutUncheckedCreateInput>
    /**
     * In case the Hut was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HutUpdateInput, HutUncheckedUpdateInput>
  }

  /**
   * Hut delete
   */
  export type HutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
    /**
     * Filter which Hut to delete.
     */
    where: HutWhereUniqueInput
  }

  /**
   * Hut deleteMany
   */
  export type HutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Huts to delete
     */
    where?: HutWhereInput
    /**
     * Limit how many Huts to delete.
     */
    limit?: number
  }

  /**
   * Hut.hutChecks
   */
  export type Hut$hutChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    where?: HutCheckWhereInput
    orderBy?: HutCheckOrderByWithRelationInput | HutCheckOrderByWithRelationInput[]
    cursor?: HutCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HutCheckScalarFieldEnum | HutCheckScalarFieldEnum[]
  }

  /**
   * Hut.location
   */
  export type Hut$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Hut without action
   */
  export type HutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
  }


  /**
   * Model AidRoom
   */

  export type AggregateAidRoom = {
    _count: AidRoomCountAggregateOutputType | null
    _avg: AidRoomAvgAggregateOutputType | null
    _sum: AidRoomSumAggregateOutputType | null
    _min: AidRoomMinAggregateOutputType | null
    _max: AidRoomMaxAggregateOutputType | null
  }

  export type AidRoomAvgAggregateOutputType = {
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type AidRoomSumAggregateOutputType = {
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type AidRoomMinAggregateOutputType = {
    id: string | null
    mountainId: string | null
    name: string | null
    status: $Enums.STATUS | null
    latitude: Decimal | null
    longitude: Decimal | null
    locationId: string | null
  }

  export type AidRoomMaxAggregateOutputType = {
    id: string | null
    mountainId: string | null
    name: string | null
    status: $Enums.STATUS | null
    latitude: Decimal | null
    longitude: Decimal | null
    locationId: string | null
  }

  export type AidRoomCountAggregateOutputType = {
    id: number
    mountainId: number
    name: number
    status: number
    latitude: number
    longitude: number
    locationId: number
    _all: number
  }


  export type AidRoomAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type AidRoomSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type AidRoomMinAggregateInputType = {
    id?: true
    mountainId?: true
    name?: true
    status?: true
    latitude?: true
    longitude?: true
    locationId?: true
  }

  export type AidRoomMaxAggregateInputType = {
    id?: true
    mountainId?: true
    name?: true
    status?: true
    latitude?: true
    longitude?: true
    locationId?: true
  }

  export type AidRoomCountAggregateInputType = {
    id?: true
    mountainId?: true
    name?: true
    status?: true
    latitude?: true
    longitude?: true
    locationId?: true
    _all?: true
  }

  export type AidRoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AidRoom to aggregate.
     */
    where?: AidRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AidRooms to fetch.
     */
    orderBy?: AidRoomOrderByWithRelationInput | AidRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AidRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AidRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AidRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AidRooms
    **/
    _count?: true | AidRoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AidRoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AidRoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AidRoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AidRoomMaxAggregateInputType
  }

  export type GetAidRoomAggregateType<T extends AidRoomAggregateArgs> = {
        [P in keyof T & keyof AggregateAidRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAidRoom[P]>
      : GetScalarType<T[P], AggregateAidRoom[P]>
  }




  export type AidRoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AidRoomWhereInput
    orderBy?: AidRoomOrderByWithAggregationInput | AidRoomOrderByWithAggregationInput[]
    by: AidRoomScalarFieldEnum[] | AidRoomScalarFieldEnum
    having?: AidRoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AidRoomCountAggregateInputType | true
    _avg?: AidRoomAvgAggregateInputType
    _sum?: AidRoomSumAggregateInputType
    _min?: AidRoomMinAggregateInputType
    _max?: AidRoomMaxAggregateInputType
  }

  export type AidRoomGroupByOutputType = {
    id: string
    mountainId: string
    name: string
    status: $Enums.STATUS
    latitude: Decimal | null
    longitude: Decimal | null
    locationId: string | null
    _count: AidRoomCountAggregateOutputType | null
    _avg: AidRoomAvgAggregateOutputType | null
    _sum: AidRoomSumAggregateOutputType | null
    _min: AidRoomMinAggregateOutputType | null
    _max: AidRoomMaxAggregateOutputType | null
  }

  type GetAidRoomGroupByPayload<T extends AidRoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AidRoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AidRoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AidRoomGroupByOutputType[P]>
            : GetScalarType<T[P], AidRoomGroupByOutputType[P]>
        }
      >
    >


  export type AidRoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    name?: boolean
    status?: boolean
    latitude?: boolean
    longitude?: boolean
    locationId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    aidRoomChecks?: boolean | AidRoom$aidRoomChecksArgs<ExtArgs>
    location?: boolean | AidRoom$locationArgs<ExtArgs>
    _count?: boolean | AidRoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aidRoom"]>

  export type AidRoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    name?: boolean
    status?: boolean
    latitude?: boolean
    longitude?: boolean
    locationId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | AidRoom$locationArgs<ExtArgs>
  }, ExtArgs["result"]["aidRoom"]>

  export type AidRoomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    name?: boolean
    status?: boolean
    latitude?: boolean
    longitude?: boolean
    locationId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | AidRoom$locationArgs<ExtArgs>
  }, ExtArgs["result"]["aidRoom"]>

  export type AidRoomSelectScalar = {
    id?: boolean
    mountainId?: boolean
    name?: boolean
    status?: boolean
    latitude?: boolean
    longitude?: boolean
    locationId?: boolean
  }

  export type AidRoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mountainId" | "name" | "status" | "latitude" | "longitude" | "locationId", ExtArgs["result"]["aidRoom"]>
  export type AidRoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    aidRoomChecks?: boolean | AidRoom$aidRoomChecksArgs<ExtArgs>
    location?: boolean | AidRoom$locationArgs<ExtArgs>
    _count?: boolean | AidRoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AidRoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | AidRoom$locationArgs<ExtArgs>
  }
  export type AidRoomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | AidRoom$locationArgs<ExtArgs>
  }

  export type $AidRoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AidRoom"
    objects: {
      mountain: Prisma.$MountainPayload<ExtArgs>
      aidRoomChecks: Prisma.$AidRoomCheckPayload<ExtArgs>[]
      location: Prisma.$LocationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mountainId: string
      name: string
      status: $Enums.STATUS
      latitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      locationId: string | null
    }, ExtArgs["result"]["aidRoom"]>
    composites: {}
  }

  type AidRoomGetPayload<S extends boolean | null | undefined | AidRoomDefaultArgs> = $Result.GetResult<Prisma.$AidRoomPayload, S>

  type AidRoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AidRoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AidRoomCountAggregateInputType | true
    }

  export interface AidRoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AidRoom'], meta: { name: 'AidRoom' } }
    /**
     * Find zero or one AidRoom that matches the filter.
     * @param {AidRoomFindUniqueArgs} args - Arguments to find a AidRoom
     * @example
     * // Get one AidRoom
     * const aidRoom = await prisma.aidRoom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AidRoomFindUniqueArgs>(args: SelectSubset<T, AidRoomFindUniqueArgs<ExtArgs>>): Prisma__AidRoomClient<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AidRoom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AidRoomFindUniqueOrThrowArgs} args - Arguments to find a AidRoom
     * @example
     * // Get one AidRoom
     * const aidRoom = await prisma.aidRoom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AidRoomFindUniqueOrThrowArgs>(args: SelectSubset<T, AidRoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AidRoomClient<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AidRoom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomFindFirstArgs} args - Arguments to find a AidRoom
     * @example
     * // Get one AidRoom
     * const aidRoom = await prisma.aidRoom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AidRoomFindFirstArgs>(args?: SelectSubset<T, AidRoomFindFirstArgs<ExtArgs>>): Prisma__AidRoomClient<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AidRoom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomFindFirstOrThrowArgs} args - Arguments to find a AidRoom
     * @example
     * // Get one AidRoom
     * const aidRoom = await prisma.aidRoom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AidRoomFindFirstOrThrowArgs>(args?: SelectSubset<T, AidRoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__AidRoomClient<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AidRooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AidRooms
     * const aidRooms = await prisma.aidRoom.findMany()
     * 
     * // Get first 10 AidRooms
     * const aidRooms = await prisma.aidRoom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aidRoomWithIdOnly = await prisma.aidRoom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AidRoomFindManyArgs>(args?: SelectSubset<T, AidRoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AidRoom.
     * @param {AidRoomCreateArgs} args - Arguments to create a AidRoom.
     * @example
     * // Create one AidRoom
     * const AidRoom = await prisma.aidRoom.create({
     *   data: {
     *     // ... data to create a AidRoom
     *   }
     * })
     * 
     */
    create<T extends AidRoomCreateArgs>(args: SelectSubset<T, AidRoomCreateArgs<ExtArgs>>): Prisma__AidRoomClient<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AidRooms.
     * @param {AidRoomCreateManyArgs} args - Arguments to create many AidRooms.
     * @example
     * // Create many AidRooms
     * const aidRoom = await prisma.aidRoom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AidRoomCreateManyArgs>(args?: SelectSubset<T, AidRoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AidRooms and returns the data saved in the database.
     * @param {AidRoomCreateManyAndReturnArgs} args - Arguments to create many AidRooms.
     * @example
     * // Create many AidRooms
     * const aidRoom = await prisma.aidRoom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AidRooms and only return the `id`
     * const aidRoomWithIdOnly = await prisma.aidRoom.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AidRoomCreateManyAndReturnArgs>(args?: SelectSubset<T, AidRoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AidRoom.
     * @param {AidRoomDeleteArgs} args - Arguments to delete one AidRoom.
     * @example
     * // Delete one AidRoom
     * const AidRoom = await prisma.aidRoom.delete({
     *   where: {
     *     // ... filter to delete one AidRoom
     *   }
     * })
     * 
     */
    delete<T extends AidRoomDeleteArgs>(args: SelectSubset<T, AidRoomDeleteArgs<ExtArgs>>): Prisma__AidRoomClient<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AidRoom.
     * @param {AidRoomUpdateArgs} args - Arguments to update one AidRoom.
     * @example
     * // Update one AidRoom
     * const aidRoom = await prisma.aidRoom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AidRoomUpdateArgs>(args: SelectSubset<T, AidRoomUpdateArgs<ExtArgs>>): Prisma__AidRoomClient<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AidRooms.
     * @param {AidRoomDeleteManyArgs} args - Arguments to filter AidRooms to delete.
     * @example
     * // Delete a few AidRooms
     * const { count } = await prisma.aidRoom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AidRoomDeleteManyArgs>(args?: SelectSubset<T, AidRoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AidRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AidRooms
     * const aidRoom = await prisma.aidRoom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AidRoomUpdateManyArgs>(args: SelectSubset<T, AidRoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AidRooms and returns the data updated in the database.
     * @param {AidRoomUpdateManyAndReturnArgs} args - Arguments to update many AidRooms.
     * @example
     * // Update many AidRooms
     * const aidRoom = await prisma.aidRoom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AidRooms and only return the `id`
     * const aidRoomWithIdOnly = await prisma.aidRoom.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AidRoomUpdateManyAndReturnArgs>(args: SelectSubset<T, AidRoomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AidRoom.
     * @param {AidRoomUpsertArgs} args - Arguments to update or create a AidRoom.
     * @example
     * // Update or create a AidRoom
     * const aidRoom = await prisma.aidRoom.upsert({
     *   create: {
     *     // ... data to create a AidRoom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AidRoom we want to update
     *   }
     * })
     */
    upsert<T extends AidRoomUpsertArgs>(args: SelectSubset<T, AidRoomUpsertArgs<ExtArgs>>): Prisma__AidRoomClient<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AidRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomCountArgs} args - Arguments to filter AidRooms to count.
     * @example
     * // Count the number of AidRooms
     * const count = await prisma.aidRoom.count({
     *   where: {
     *     // ... the filter for the AidRooms we want to count
     *   }
     * })
    **/
    count<T extends AidRoomCountArgs>(
      args?: Subset<T, AidRoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AidRoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AidRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AidRoomAggregateArgs>(args: Subset<T, AidRoomAggregateArgs>): Prisma.PrismaPromise<GetAidRoomAggregateType<T>>

    /**
     * Group by AidRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AidRoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AidRoomGroupByArgs['orderBy'] }
        : { orderBy?: AidRoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AidRoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAidRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AidRoom model
   */
  readonly fields: AidRoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AidRoom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AidRoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    aidRoomChecks<T extends AidRoom$aidRoomChecksArgs<ExtArgs> = {}>(args?: Subset<T, AidRoom$aidRoomChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    location<T extends AidRoom$locationArgs<ExtArgs> = {}>(args?: Subset<T, AidRoom$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AidRoom model
   */
  interface AidRoomFieldRefs {
    readonly id: FieldRef<"AidRoom", 'String'>
    readonly mountainId: FieldRef<"AidRoom", 'String'>
    readonly name: FieldRef<"AidRoom", 'String'>
    readonly status: FieldRef<"AidRoom", 'STATUS'>
    readonly latitude: FieldRef<"AidRoom", 'Decimal'>
    readonly longitude: FieldRef<"AidRoom", 'Decimal'>
    readonly locationId: FieldRef<"AidRoom", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AidRoom findUnique
   */
  export type AidRoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
    /**
     * Filter, which AidRoom to fetch.
     */
    where: AidRoomWhereUniqueInput
  }

  /**
   * AidRoom findUniqueOrThrow
   */
  export type AidRoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
    /**
     * Filter, which AidRoom to fetch.
     */
    where: AidRoomWhereUniqueInput
  }

  /**
   * AidRoom findFirst
   */
  export type AidRoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
    /**
     * Filter, which AidRoom to fetch.
     */
    where?: AidRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AidRooms to fetch.
     */
    orderBy?: AidRoomOrderByWithRelationInput | AidRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AidRooms.
     */
    cursor?: AidRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AidRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AidRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AidRooms.
     */
    distinct?: AidRoomScalarFieldEnum | AidRoomScalarFieldEnum[]
  }

  /**
   * AidRoom findFirstOrThrow
   */
  export type AidRoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
    /**
     * Filter, which AidRoom to fetch.
     */
    where?: AidRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AidRooms to fetch.
     */
    orderBy?: AidRoomOrderByWithRelationInput | AidRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AidRooms.
     */
    cursor?: AidRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AidRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AidRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AidRooms.
     */
    distinct?: AidRoomScalarFieldEnum | AidRoomScalarFieldEnum[]
  }

  /**
   * AidRoom findMany
   */
  export type AidRoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
    /**
     * Filter, which AidRooms to fetch.
     */
    where?: AidRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AidRooms to fetch.
     */
    orderBy?: AidRoomOrderByWithRelationInput | AidRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AidRooms.
     */
    cursor?: AidRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AidRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AidRooms.
     */
    skip?: number
    distinct?: AidRoomScalarFieldEnum | AidRoomScalarFieldEnum[]
  }

  /**
   * AidRoom create
   */
  export type AidRoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
    /**
     * The data needed to create a AidRoom.
     */
    data: XOR<AidRoomCreateInput, AidRoomUncheckedCreateInput>
  }

  /**
   * AidRoom createMany
   */
  export type AidRoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AidRooms.
     */
    data: AidRoomCreateManyInput | AidRoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AidRoom createManyAndReturn
   */
  export type AidRoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * The data used to create many AidRooms.
     */
    data: AidRoomCreateManyInput | AidRoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AidRoom update
   */
  export type AidRoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
    /**
     * The data needed to update a AidRoom.
     */
    data: XOR<AidRoomUpdateInput, AidRoomUncheckedUpdateInput>
    /**
     * Choose, which AidRoom to update.
     */
    where: AidRoomWhereUniqueInput
  }

  /**
   * AidRoom updateMany
   */
  export type AidRoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AidRooms.
     */
    data: XOR<AidRoomUpdateManyMutationInput, AidRoomUncheckedUpdateManyInput>
    /**
     * Filter which AidRooms to update
     */
    where?: AidRoomWhereInput
    /**
     * Limit how many AidRooms to update.
     */
    limit?: number
  }

  /**
   * AidRoom updateManyAndReturn
   */
  export type AidRoomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * The data used to update AidRooms.
     */
    data: XOR<AidRoomUpdateManyMutationInput, AidRoomUncheckedUpdateManyInput>
    /**
     * Filter which AidRooms to update
     */
    where?: AidRoomWhereInput
    /**
     * Limit how many AidRooms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AidRoom upsert
   */
  export type AidRoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
    /**
     * The filter to search for the AidRoom to update in case it exists.
     */
    where: AidRoomWhereUniqueInput
    /**
     * In case the AidRoom found by the `where` argument doesn't exist, create a new AidRoom with this data.
     */
    create: XOR<AidRoomCreateInput, AidRoomUncheckedCreateInput>
    /**
     * In case the AidRoom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AidRoomUpdateInput, AidRoomUncheckedUpdateInput>
  }

  /**
   * AidRoom delete
   */
  export type AidRoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
    /**
     * Filter which AidRoom to delete.
     */
    where: AidRoomWhereUniqueInput
  }

  /**
   * AidRoom deleteMany
   */
  export type AidRoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AidRooms to delete
     */
    where?: AidRoomWhereInput
    /**
     * Limit how many AidRooms to delete.
     */
    limit?: number
  }

  /**
   * AidRoom.aidRoomChecks
   */
  export type AidRoom$aidRoomChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    where?: AidRoomCheckWhereInput
    orderBy?: AidRoomCheckOrderByWithRelationInput | AidRoomCheckOrderByWithRelationInput[]
    cursor?: AidRoomCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AidRoomCheckScalarFieldEnum | AidRoomCheckScalarFieldEnum[]
  }

  /**
   * AidRoom.location
   */
  export type AidRoom$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * AidRoom without action
   */
  export type AidRoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
  }


  /**
   * Model EquipmentServiceLog
   */

  export type AggregateEquipmentServiceLog = {
    _count: EquipmentServiceLogCountAggregateOutputType | null
    _min: EquipmentServiceLogMinAggregateOutputType | null
    _max: EquipmentServiceLogMaxAggregateOutputType | null
  }

  export type EquipmentServiceLogMinAggregateOutputType = {
    id: string | null
    mountainId: string | null
    equipmentId: string | null
    employeeId: string | null
    status: $Enums.EQUIPMENT_STATUS | null
    changedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentServiceLogMaxAggregateOutputType = {
    id: string | null
    mountainId: string | null
    equipmentId: string | null
    employeeId: string | null
    status: $Enums.EQUIPMENT_STATUS | null
    changedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentServiceLogCountAggregateOutputType = {
    id: number
    mountainId: number
    equipmentId: number
    employeeId: number
    status: number
    changedAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EquipmentServiceLogMinAggregateInputType = {
    id?: true
    mountainId?: true
    equipmentId?: true
    employeeId?: true
    status?: true
    changedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentServiceLogMaxAggregateInputType = {
    id?: true
    mountainId?: true
    equipmentId?: true
    employeeId?: true
    status?: true
    changedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentServiceLogCountAggregateInputType = {
    id?: true
    mountainId?: true
    equipmentId?: true
    employeeId?: true
    status?: true
    changedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EquipmentServiceLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentServiceLog to aggregate.
     */
    where?: EquipmentServiceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentServiceLogs to fetch.
     */
    orderBy?: EquipmentServiceLogOrderByWithRelationInput | EquipmentServiceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentServiceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentServiceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentServiceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EquipmentServiceLogs
    **/
    _count?: true | EquipmentServiceLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentServiceLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentServiceLogMaxAggregateInputType
  }

  export type GetEquipmentServiceLogAggregateType<T extends EquipmentServiceLogAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipmentServiceLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipmentServiceLog[P]>
      : GetScalarType<T[P], AggregateEquipmentServiceLog[P]>
  }




  export type EquipmentServiceLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentServiceLogWhereInput
    orderBy?: EquipmentServiceLogOrderByWithAggregationInput | EquipmentServiceLogOrderByWithAggregationInput[]
    by: EquipmentServiceLogScalarFieldEnum[] | EquipmentServiceLogScalarFieldEnum
    having?: EquipmentServiceLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentServiceLogCountAggregateInputType | true
    _min?: EquipmentServiceLogMinAggregateInputType
    _max?: EquipmentServiceLogMaxAggregateInputType
  }

  export type EquipmentServiceLogGroupByOutputType = {
    id: string
    mountainId: string
    equipmentId: string
    employeeId: string | null
    status: $Enums.EQUIPMENT_STATUS
    changedAt: Date
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: EquipmentServiceLogCountAggregateOutputType | null
    _min: EquipmentServiceLogMinAggregateOutputType | null
    _max: EquipmentServiceLogMaxAggregateOutputType | null
  }

  type GetEquipmentServiceLogGroupByPayload<T extends EquipmentServiceLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentServiceLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentServiceLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentServiceLogGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentServiceLogGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentServiceLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    equipmentId?: boolean
    employeeId?: boolean
    status?: boolean
    changedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    employee?: boolean | EquipmentServiceLog$employeeArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentServiceLog"]>

  export type EquipmentServiceLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    equipmentId?: boolean
    employeeId?: boolean
    status?: boolean
    changedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    employee?: boolean | EquipmentServiceLog$employeeArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentServiceLog"]>

  export type EquipmentServiceLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    equipmentId?: boolean
    employeeId?: boolean
    status?: boolean
    changedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    employee?: boolean | EquipmentServiceLog$employeeArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentServiceLog"]>

  export type EquipmentServiceLogSelectScalar = {
    id?: boolean
    mountainId?: boolean
    equipmentId?: boolean
    employeeId?: boolean
    status?: boolean
    changedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EquipmentServiceLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mountainId" | "equipmentId" | "employeeId" | "status" | "changedAt" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["equipmentServiceLog"]>
  export type EquipmentServiceLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    employee?: boolean | EquipmentServiceLog$employeeArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }
  export type EquipmentServiceLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    employee?: boolean | EquipmentServiceLog$employeeArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }
  export type EquipmentServiceLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    employee?: boolean | EquipmentServiceLog$employeeArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }

  export type $EquipmentServiceLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EquipmentServiceLog"
    objects: {
      mountain: Prisma.$MountainPayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs> | null
      equipment: Prisma.$EquipmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mountainId: string
      equipmentId: string
      employeeId: string | null
      status: $Enums.EQUIPMENT_STATUS
      changedAt: Date
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["equipmentServiceLog"]>
    composites: {}
  }

  type EquipmentServiceLogGetPayload<S extends boolean | null | undefined | EquipmentServiceLogDefaultArgs> = $Result.GetResult<Prisma.$EquipmentServiceLogPayload, S>

  type EquipmentServiceLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipmentServiceLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipmentServiceLogCountAggregateInputType | true
    }

  export interface EquipmentServiceLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EquipmentServiceLog'], meta: { name: 'EquipmentServiceLog' } }
    /**
     * Find zero or one EquipmentServiceLog that matches the filter.
     * @param {EquipmentServiceLogFindUniqueArgs} args - Arguments to find a EquipmentServiceLog
     * @example
     * // Get one EquipmentServiceLog
     * const equipmentServiceLog = await prisma.equipmentServiceLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentServiceLogFindUniqueArgs>(args: SelectSubset<T, EquipmentServiceLogFindUniqueArgs<ExtArgs>>): Prisma__EquipmentServiceLogClient<$Result.GetResult<Prisma.$EquipmentServiceLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EquipmentServiceLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipmentServiceLogFindUniqueOrThrowArgs} args - Arguments to find a EquipmentServiceLog
     * @example
     * // Get one EquipmentServiceLog
     * const equipmentServiceLog = await prisma.equipmentServiceLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentServiceLogFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentServiceLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentServiceLogClient<$Result.GetResult<Prisma.$EquipmentServiceLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipmentServiceLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentServiceLogFindFirstArgs} args - Arguments to find a EquipmentServiceLog
     * @example
     * // Get one EquipmentServiceLog
     * const equipmentServiceLog = await prisma.equipmentServiceLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentServiceLogFindFirstArgs>(args?: SelectSubset<T, EquipmentServiceLogFindFirstArgs<ExtArgs>>): Prisma__EquipmentServiceLogClient<$Result.GetResult<Prisma.$EquipmentServiceLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipmentServiceLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentServiceLogFindFirstOrThrowArgs} args - Arguments to find a EquipmentServiceLog
     * @example
     * // Get one EquipmentServiceLog
     * const equipmentServiceLog = await prisma.equipmentServiceLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentServiceLogFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentServiceLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentServiceLogClient<$Result.GetResult<Prisma.$EquipmentServiceLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EquipmentServiceLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentServiceLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipmentServiceLogs
     * const equipmentServiceLogs = await prisma.equipmentServiceLog.findMany()
     * 
     * // Get first 10 EquipmentServiceLogs
     * const equipmentServiceLogs = await prisma.equipmentServiceLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentServiceLogWithIdOnly = await prisma.equipmentServiceLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentServiceLogFindManyArgs>(args?: SelectSubset<T, EquipmentServiceLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentServiceLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EquipmentServiceLog.
     * @param {EquipmentServiceLogCreateArgs} args - Arguments to create a EquipmentServiceLog.
     * @example
     * // Create one EquipmentServiceLog
     * const EquipmentServiceLog = await prisma.equipmentServiceLog.create({
     *   data: {
     *     // ... data to create a EquipmentServiceLog
     *   }
     * })
     * 
     */
    create<T extends EquipmentServiceLogCreateArgs>(args: SelectSubset<T, EquipmentServiceLogCreateArgs<ExtArgs>>): Prisma__EquipmentServiceLogClient<$Result.GetResult<Prisma.$EquipmentServiceLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EquipmentServiceLogs.
     * @param {EquipmentServiceLogCreateManyArgs} args - Arguments to create many EquipmentServiceLogs.
     * @example
     * // Create many EquipmentServiceLogs
     * const equipmentServiceLog = await prisma.equipmentServiceLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentServiceLogCreateManyArgs>(args?: SelectSubset<T, EquipmentServiceLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EquipmentServiceLogs and returns the data saved in the database.
     * @param {EquipmentServiceLogCreateManyAndReturnArgs} args - Arguments to create many EquipmentServiceLogs.
     * @example
     * // Create many EquipmentServiceLogs
     * const equipmentServiceLog = await prisma.equipmentServiceLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EquipmentServiceLogs and only return the `id`
     * const equipmentServiceLogWithIdOnly = await prisma.equipmentServiceLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipmentServiceLogCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipmentServiceLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentServiceLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EquipmentServiceLog.
     * @param {EquipmentServiceLogDeleteArgs} args - Arguments to delete one EquipmentServiceLog.
     * @example
     * // Delete one EquipmentServiceLog
     * const EquipmentServiceLog = await prisma.equipmentServiceLog.delete({
     *   where: {
     *     // ... filter to delete one EquipmentServiceLog
     *   }
     * })
     * 
     */
    delete<T extends EquipmentServiceLogDeleteArgs>(args: SelectSubset<T, EquipmentServiceLogDeleteArgs<ExtArgs>>): Prisma__EquipmentServiceLogClient<$Result.GetResult<Prisma.$EquipmentServiceLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EquipmentServiceLog.
     * @param {EquipmentServiceLogUpdateArgs} args - Arguments to update one EquipmentServiceLog.
     * @example
     * // Update one EquipmentServiceLog
     * const equipmentServiceLog = await prisma.equipmentServiceLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentServiceLogUpdateArgs>(args: SelectSubset<T, EquipmentServiceLogUpdateArgs<ExtArgs>>): Prisma__EquipmentServiceLogClient<$Result.GetResult<Prisma.$EquipmentServiceLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EquipmentServiceLogs.
     * @param {EquipmentServiceLogDeleteManyArgs} args - Arguments to filter EquipmentServiceLogs to delete.
     * @example
     * // Delete a few EquipmentServiceLogs
     * const { count } = await prisma.equipmentServiceLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentServiceLogDeleteManyArgs>(args?: SelectSubset<T, EquipmentServiceLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentServiceLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentServiceLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipmentServiceLogs
     * const equipmentServiceLog = await prisma.equipmentServiceLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentServiceLogUpdateManyArgs>(args: SelectSubset<T, EquipmentServiceLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentServiceLogs and returns the data updated in the database.
     * @param {EquipmentServiceLogUpdateManyAndReturnArgs} args - Arguments to update many EquipmentServiceLogs.
     * @example
     * // Update many EquipmentServiceLogs
     * const equipmentServiceLog = await prisma.equipmentServiceLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EquipmentServiceLogs and only return the `id`
     * const equipmentServiceLogWithIdOnly = await prisma.equipmentServiceLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EquipmentServiceLogUpdateManyAndReturnArgs>(args: SelectSubset<T, EquipmentServiceLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentServiceLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EquipmentServiceLog.
     * @param {EquipmentServiceLogUpsertArgs} args - Arguments to update or create a EquipmentServiceLog.
     * @example
     * // Update or create a EquipmentServiceLog
     * const equipmentServiceLog = await prisma.equipmentServiceLog.upsert({
     *   create: {
     *     // ... data to create a EquipmentServiceLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipmentServiceLog we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentServiceLogUpsertArgs>(args: SelectSubset<T, EquipmentServiceLogUpsertArgs<ExtArgs>>): Prisma__EquipmentServiceLogClient<$Result.GetResult<Prisma.$EquipmentServiceLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EquipmentServiceLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentServiceLogCountArgs} args - Arguments to filter EquipmentServiceLogs to count.
     * @example
     * // Count the number of EquipmentServiceLogs
     * const count = await prisma.equipmentServiceLog.count({
     *   where: {
     *     // ... the filter for the EquipmentServiceLogs we want to count
     *   }
     * })
    **/
    count<T extends EquipmentServiceLogCountArgs>(
      args?: Subset<T, EquipmentServiceLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentServiceLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipmentServiceLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentServiceLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentServiceLogAggregateArgs>(args: Subset<T, EquipmentServiceLogAggregateArgs>): Prisma.PrismaPromise<GetEquipmentServiceLogAggregateType<T>>

    /**
     * Group by EquipmentServiceLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentServiceLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentServiceLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentServiceLogGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentServiceLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentServiceLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentServiceLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EquipmentServiceLog model
   */
  readonly fields: EquipmentServiceLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EquipmentServiceLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentServiceLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends EquipmentServiceLog$employeeArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentServiceLog$employeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    equipment<T extends EquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentDefaultArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EquipmentServiceLog model
   */
  interface EquipmentServiceLogFieldRefs {
    readonly id: FieldRef<"EquipmentServiceLog", 'String'>
    readonly mountainId: FieldRef<"EquipmentServiceLog", 'String'>
    readonly equipmentId: FieldRef<"EquipmentServiceLog", 'String'>
    readonly employeeId: FieldRef<"EquipmentServiceLog", 'String'>
    readonly status: FieldRef<"EquipmentServiceLog", 'EQUIPMENT_STATUS'>
    readonly changedAt: FieldRef<"EquipmentServiceLog", 'DateTime'>
    readonly notes: FieldRef<"EquipmentServiceLog", 'String'>
    readonly createdAt: FieldRef<"EquipmentServiceLog", 'DateTime'>
    readonly updatedAt: FieldRef<"EquipmentServiceLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EquipmentServiceLog findUnique
   */
  export type EquipmentServiceLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentServiceLog
     */
    select?: EquipmentServiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentServiceLog
     */
    omit?: EquipmentServiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentServiceLogInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentServiceLog to fetch.
     */
    where: EquipmentServiceLogWhereUniqueInput
  }

  /**
   * EquipmentServiceLog findUniqueOrThrow
   */
  export type EquipmentServiceLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentServiceLog
     */
    select?: EquipmentServiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentServiceLog
     */
    omit?: EquipmentServiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentServiceLogInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentServiceLog to fetch.
     */
    where: EquipmentServiceLogWhereUniqueInput
  }

  /**
   * EquipmentServiceLog findFirst
   */
  export type EquipmentServiceLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentServiceLog
     */
    select?: EquipmentServiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentServiceLog
     */
    omit?: EquipmentServiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentServiceLogInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentServiceLog to fetch.
     */
    where?: EquipmentServiceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentServiceLogs to fetch.
     */
    orderBy?: EquipmentServiceLogOrderByWithRelationInput | EquipmentServiceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentServiceLogs.
     */
    cursor?: EquipmentServiceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentServiceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentServiceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentServiceLogs.
     */
    distinct?: EquipmentServiceLogScalarFieldEnum | EquipmentServiceLogScalarFieldEnum[]
  }

  /**
   * EquipmentServiceLog findFirstOrThrow
   */
  export type EquipmentServiceLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentServiceLog
     */
    select?: EquipmentServiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentServiceLog
     */
    omit?: EquipmentServiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentServiceLogInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentServiceLog to fetch.
     */
    where?: EquipmentServiceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentServiceLogs to fetch.
     */
    orderBy?: EquipmentServiceLogOrderByWithRelationInput | EquipmentServiceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentServiceLogs.
     */
    cursor?: EquipmentServiceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentServiceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentServiceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentServiceLogs.
     */
    distinct?: EquipmentServiceLogScalarFieldEnum | EquipmentServiceLogScalarFieldEnum[]
  }

  /**
   * EquipmentServiceLog findMany
   */
  export type EquipmentServiceLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentServiceLog
     */
    select?: EquipmentServiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentServiceLog
     */
    omit?: EquipmentServiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentServiceLogInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentServiceLogs to fetch.
     */
    where?: EquipmentServiceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentServiceLogs to fetch.
     */
    orderBy?: EquipmentServiceLogOrderByWithRelationInput | EquipmentServiceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EquipmentServiceLogs.
     */
    cursor?: EquipmentServiceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentServiceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentServiceLogs.
     */
    skip?: number
    distinct?: EquipmentServiceLogScalarFieldEnum | EquipmentServiceLogScalarFieldEnum[]
  }

  /**
   * EquipmentServiceLog create
   */
  export type EquipmentServiceLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentServiceLog
     */
    select?: EquipmentServiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentServiceLog
     */
    omit?: EquipmentServiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentServiceLogInclude<ExtArgs> | null
    /**
     * The data needed to create a EquipmentServiceLog.
     */
    data: XOR<EquipmentServiceLogCreateInput, EquipmentServiceLogUncheckedCreateInput>
  }

  /**
   * EquipmentServiceLog createMany
   */
  export type EquipmentServiceLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EquipmentServiceLogs.
     */
    data: EquipmentServiceLogCreateManyInput | EquipmentServiceLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EquipmentServiceLog createManyAndReturn
   */
  export type EquipmentServiceLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentServiceLog
     */
    select?: EquipmentServiceLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentServiceLog
     */
    omit?: EquipmentServiceLogOmit<ExtArgs> | null
    /**
     * The data used to create many EquipmentServiceLogs.
     */
    data: EquipmentServiceLogCreateManyInput | EquipmentServiceLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentServiceLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EquipmentServiceLog update
   */
  export type EquipmentServiceLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentServiceLog
     */
    select?: EquipmentServiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentServiceLog
     */
    omit?: EquipmentServiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentServiceLogInclude<ExtArgs> | null
    /**
     * The data needed to update a EquipmentServiceLog.
     */
    data: XOR<EquipmentServiceLogUpdateInput, EquipmentServiceLogUncheckedUpdateInput>
    /**
     * Choose, which EquipmentServiceLog to update.
     */
    where: EquipmentServiceLogWhereUniqueInput
  }

  /**
   * EquipmentServiceLog updateMany
   */
  export type EquipmentServiceLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EquipmentServiceLogs.
     */
    data: XOR<EquipmentServiceLogUpdateManyMutationInput, EquipmentServiceLogUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentServiceLogs to update
     */
    where?: EquipmentServiceLogWhereInput
    /**
     * Limit how many EquipmentServiceLogs to update.
     */
    limit?: number
  }

  /**
   * EquipmentServiceLog updateManyAndReturn
   */
  export type EquipmentServiceLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentServiceLog
     */
    select?: EquipmentServiceLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentServiceLog
     */
    omit?: EquipmentServiceLogOmit<ExtArgs> | null
    /**
     * The data used to update EquipmentServiceLogs.
     */
    data: XOR<EquipmentServiceLogUpdateManyMutationInput, EquipmentServiceLogUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentServiceLogs to update
     */
    where?: EquipmentServiceLogWhereInput
    /**
     * Limit how many EquipmentServiceLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentServiceLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EquipmentServiceLog upsert
   */
  export type EquipmentServiceLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentServiceLog
     */
    select?: EquipmentServiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentServiceLog
     */
    omit?: EquipmentServiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentServiceLogInclude<ExtArgs> | null
    /**
     * The filter to search for the EquipmentServiceLog to update in case it exists.
     */
    where: EquipmentServiceLogWhereUniqueInput
    /**
     * In case the EquipmentServiceLog found by the `where` argument doesn't exist, create a new EquipmentServiceLog with this data.
     */
    create: XOR<EquipmentServiceLogCreateInput, EquipmentServiceLogUncheckedCreateInput>
    /**
     * In case the EquipmentServiceLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentServiceLogUpdateInput, EquipmentServiceLogUncheckedUpdateInput>
  }

  /**
   * EquipmentServiceLog delete
   */
  export type EquipmentServiceLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentServiceLog
     */
    select?: EquipmentServiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentServiceLog
     */
    omit?: EquipmentServiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentServiceLogInclude<ExtArgs> | null
    /**
     * Filter which EquipmentServiceLog to delete.
     */
    where: EquipmentServiceLogWhereUniqueInput
  }

  /**
   * EquipmentServiceLog deleteMany
   */
  export type EquipmentServiceLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentServiceLogs to delete
     */
    where?: EquipmentServiceLogWhereInput
    /**
     * Limit how many EquipmentServiceLogs to delete.
     */
    limit?: number
  }

  /**
   * EquipmentServiceLog.employee
   */
  export type EquipmentServiceLog$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * EquipmentServiceLog without action
   */
  export type EquipmentServiceLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentServiceLog
     */
    select?: EquipmentServiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentServiceLog
     */
    omit?: EquipmentServiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentServiceLogInclude<ExtArgs> | null
  }


  /**
   * Model Equipment
   */

  export type AggregateEquipment = {
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  export type EquipmentAvgAggregateOutputType = {
    number: number | null
    cost: number | null
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type EquipmentSumAggregateOutputType = {
    number: number | null
    cost: number | null
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type EquipmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    status: $Enums.EQUIPMENT_STATUS | null
    number: number | null
    description: string | null
    picture: string | null
    cost: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    mountainId: string | null
    locationId: string | null
    dateAdded: Date | null
  }

  export type EquipmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    status: $Enums.EQUIPMENT_STATUS | null
    number: number | null
    description: string | null
    picture: string | null
    cost: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    mountainId: string | null
    locationId: string | null
    dateAdded: Date | null
  }

  export type EquipmentCountAggregateOutputType = {
    id: number
    name: number
    type: number
    status: number
    number: number
    description: number
    picture: number
    cost: number
    latitude: number
    longitude: number
    mountainId: number
    locationId: number
    dateAdded: number
    _all: number
  }


  export type EquipmentAvgAggregateInputType = {
    number?: true
    cost?: true
    latitude?: true
    longitude?: true
  }

  export type EquipmentSumAggregateInputType = {
    number?: true
    cost?: true
    latitude?: true
    longitude?: true
  }

  export type EquipmentMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    number?: true
    description?: true
    picture?: true
    cost?: true
    latitude?: true
    longitude?: true
    mountainId?: true
    locationId?: true
    dateAdded?: true
  }

  export type EquipmentMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    number?: true
    description?: true
    picture?: true
    cost?: true
    latitude?: true
    longitude?: true
    mountainId?: true
    locationId?: true
    dateAdded?: true
  }

  export type EquipmentCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    number?: true
    description?: true
    picture?: true
    cost?: true
    latitude?: true
    longitude?: true
    mountainId?: true
    locationId?: true
    dateAdded?: true
    _all?: true
  }

  export type EquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to aggregate.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Equipment
    **/
    _count?: true | EquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentMaxAggregateInputType
  }

  export type GetEquipmentAggregateType<T extends EquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment[P]>
      : GetScalarType<T[P], AggregateEquipment[P]>
  }




  export type EquipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithAggregationInput | EquipmentOrderByWithAggregationInput[]
    by: EquipmentScalarFieldEnum[] | EquipmentScalarFieldEnum
    having?: EquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentCountAggregateInputType | true
    _avg?: EquipmentAvgAggregateInputType
    _sum?: EquipmentSumAggregateInputType
    _min?: EquipmentMinAggregateInputType
    _max?: EquipmentMaxAggregateInputType
  }

  export type EquipmentGroupByOutputType = {
    id: string
    name: string
    type: string
    status: $Enums.EQUIPMENT_STATUS
    number: number | null
    description: string | null
    picture: string | null
    cost: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    mountainId: string | null
    locationId: string | null
    dateAdded: Date
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  type GetEquipmentGroupByPayload<T extends EquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    number?: boolean
    description?: boolean
    picture?: boolean
    cost?: boolean
    latitude?: boolean
    longitude?: boolean
    mountainId?: boolean
    locationId?: boolean
    dateAdded?: boolean
    mountain?: boolean | Equipment$mountainArgs<ExtArgs>
    location?: boolean | Equipment$locationArgs<ExtArgs>
    incidentEquipmentUsageLogs?: boolean | Equipment$incidentEquipmentUsageLogsArgs<ExtArgs>
    equipmentChecks?: boolean | Equipment$equipmentChecksArgs<ExtArgs>
    equipmentServiceLogs?: boolean | Equipment$equipmentServiceLogsArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    number?: boolean
    description?: boolean
    picture?: boolean
    cost?: boolean
    latitude?: boolean
    longitude?: boolean
    mountainId?: boolean
    locationId?: boolean
    dateAdded?: boolean
    mountain?: boolean | Equipment$mountainArgs<ExtArgs>
    location?: boolean | Equipment$locationArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    number?: boolean
    description?: boolean
    picture?: boolean
    cost?: boolean
    latitude?: boolean
    longitude?: boolean
    mountainId?: boolean
    locationId?: boolean
    dateAdded?: boolean
    mountain?: boolean | Equipment$mountainArgs<ExtArgs>
    location?: boolean | Equipment$locationArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    number?: boolean
    description?: boolean
    picture?: boolean
    cost?: boolean
    latitude?: boolean
    longitude?: boolean
    mountainId?: boolean
    locationId?: boolean
    dateAdded?: boolean
  }

  export type EquipmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "status" | "number" | "description" | "picture" | "cost" | "latitude" | "longitude" | "mountainId" | "locationId" | "dateAdded", ExtArgs["result"]["equipment"]>
  export type EquipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | Equipment$mountainArgs<ExtArgs>
    location?: boolean | Equipment$locationArgs<ExtArgs>
    incidentEquipmentUsageLogs?: boolean | Equipment$incidentEquipmentUsageLogsArgs<ExtArgs>
    equipmentChecks?: boolean | Equipment$equipmentChecksArgs<ExtArgs>
    equipmentServiceLogs?: boolean | Equipment$equipmentServiceLogsArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EquipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | Equipment$mountainArgs<ExtArgs>
    location?: boolean | Equipment$locationArgs<ExtArgs>
  }
  export type EquipmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | Equipment$mountainArgs<ExtArgs>
    location?: boolean | Equipment$locationArgs<ExtArgs>
  }

  export type $EquipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Equipment"
    objects: {
      mountain: Prisma.$MountainPayload<ExtArgs> | null
      location: Prisma.$LocationPayload<ExtArgs> | null
      incidentEquipmentUsageLogs: Prisma.$IncidentEquipmentUsageLogPayload<ExtArgs>[]
      equipmentChecks: Prisma.$EquipmentCheckPayload<ExtArgs>[]
      equipmentServiceLogs: Prisma.$EquipmentServiceLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      status: $Enums.EQUIPMENT_STATUS
      number: number | null
      description: string | null
      picture: string | null
      cost: number | null
      latitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      mountainId: string | null
      locationId: string | null
      dateAdded: Date
    }, ExtArgs["result"]["equipment"]>
    composites: {}
  }

  type EquipmentGetPayload<S extends boolean | null | undefined | EquipmentDefaultArgs> = $Result.GetResult<Prisma.$EquipmentPayload, S>

  type EquipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipmentCountAggregateInputType | true
    }

  export interface EquipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Equipment'], meta: { name: 'Equipment' } }
    /**
     * Find zero or one Equipment that matches the filter.
     * @param {EquipmentFindUniqueArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentFindUniqueArgs>(args: SelectSubset<T, EquipmentFindUniqueArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Equipment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipmentFindUniqueOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentFindFirstArgs>(args?: SelectSubset<T, EquipmentFindFirstArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment
     * const equipment = await prisma.equipment.findMany()
     * 
     * // Get first 10 Equipment
     * const equipment = await prisma.equipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentWithIdOnly = await prisma.equipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentFindManyArgs>(args?: SelectSubset<T, EquipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Equipment.
     * @param {EquipmentCreateArgs} args - Arguments to create a Equipment.
     * @example
     * // Create one Equipment
     * const Equipment = await prisma.equipment.create({
     *   data: {
     *     // ... data to create a Equipment
     *   }
     * })
     * 
     */
    create<T extends EquipmentCreateArgs>(args: SelectSubset<T, EquipmentCreateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Equipment.
     * @param {EquipmentCreateManyArgs} args - Arguments to create many Equipment.
     * @example
     * // Create many Equipment
     * const equipment = await prisma.equipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentCreateManyArgs>(args?: SelectSubset<T, EquipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Equipment and returns the data saved in the database.
     * @param {EquipmentCreateManyAndReturnArgs} args - Arguments to create many Equipment.
     * @example
     * // Create many Equipment
     * const equipment = await prisma.equipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Equipment and only return the `id`
     * const equipmentWithIdOnly = await prisma.equipment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Equipment.
     * @param {EquipmentDeleteArgs} args - Arguments to delete one Equipment.
     * @example
     * // Delete one Equipment
     * const Equipment = await prisma.equipment.delete({
     *   where: {
     *     // ... filter to delete one Equipment
     *   }
     * })
     * 
     */
    delete<T extends EquipmentDeleteArgs>(args: SelectSubset<T, EquipmentDeleteArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Equipment.
     * @param {EquipmentUpdateArgs} args - Arguments to update one Equipment.
     * @example
     * // Update one Equipment
     * const equipment = await prisma.equipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentUpdateArgs>(args: SelectSubset<T, EquipmentUpdateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Equipment.
     * @param {EquipmentDeleteManyArgs} args - Arguments to filter Equipment to delete.
     * @example
     * // Delete a few Equipment
     * const { count } = await prisma.equipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentDeleteManyArgs>(args?: SelectSubset<T, EquipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentUpdateManyArgs>(args: SelectSubset<T, EquipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment and returns the data updated in the database.
     * @param {EquipmentUpdateManyAndReturnArgs} args - Arguments to update many Equipment.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Equipment and only return the `id`
     * const equipmentWithIdOnly = await prisma.equipment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EquipmentUpdateManyAndReturnArgs>(args: SelectSubset<T, EquipmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Equipment.
     * @param {EquipmentUpsertArgs} args - Arguments to update or create a Equipment.
     * @example
     * // Update or create a Equipment
     * const equipment = await prisma.equipment.upsert({
     *   create: {
     *     // ... data to create a Equipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentUpsertArgs>(args: SelectSubset<T, EquipmentUpsertArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCountArgs} args - Arguments to filter Equipment to count.
     * @example
     * // Count the number of Equipment
     * const count = await prisma.equipment.count({
     *   where: {
     *     // ... the filter for the Equipment we want to count
     *   }
     * })
    **/
    count<T extends EquipmentCountArgs>(
      args?: Subset<T, EquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentAggregateArgs>(args: Subset<T, EquipmentAggregateArgs>): Prisma.PrismaPromise<GetEquipmentAggregateType<T>>

    /**
     * Group by Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Equipment model
   */
  readonly fields: EquipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Equipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mountain<T extends Equipment$mountainArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$mountainArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    location<T extends Equipment$locationArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    incidentEquipmentUsageLogs<T extends Equipment$incidentEquipmentUsageLogsArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$incidentEquipmentUsageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentEquipmentUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipmentChecks<T extends Equipment$equipmentChecksArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$equipmentChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipmentServiceLogs<T extends Equipment$equipmentServiceLogsArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$equipmentServiceLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentServiceLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Equipment model
   */
  interface EquipmentFieldRefs {
    readonly id: FieldRef<"Equipment", 'String'>
    readonly name: FieldRef<"Equipment", 'String'>
    readonly type: FieldRef<"Equipment", 'String'>
    readonly status: FieldRef<"Equipment", 'EQUIPMENT_STATUS'>
    readonly number: FieldRef<"Equipment", 'Int'>
    readonly description: FieldRef<"Equipment", 'String'>
    readonly picture: FieldRef<"Equipment", 'String'>
    readonly cost: FieldRef<"Equipment", 'Float'>
    readonly latitude: FieldRef<"Equipment", 'Decimal'>
    readonly longitude: FieldRef<"Equipment", 'Decimal'>
    readonly mountainId: FieldRef<"Equipment", 'String'>
    readonly locationId: FieldRef<"Equipment", 'String'>
    readonly dateAdded: FieldRef<"Equipment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Equipment findUnique
   */
  export type EquipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findUniqueOrThrow
   */
  export type EquipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findFirst
   */
  export type EquipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findFirstOrThrow
   */
  export type EquipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findMany
   */
  export type EquipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment create
   */
  export type EquipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Equipment.
     */
    data: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
  }

  /**
   * Equipment createMany
   */
  export type EquipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Equipment.
     */
    data: EquipmentCreateManyInput | EquipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Equipment createManyAndReturn
   */
  export type EquipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * The data used to create many Equipment.
     */
    data: EquipmentCreateManyInput | EquipmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Equipment update
   */
  export type EquipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Equipment.
     */
    data: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
    /**
     * Choose, which Equipment to update.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment updateMany
   */
  export type EquipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to update.
     */
    limit?: number
  }

  /**
   * Equipment updateManyAndReturn
   */
  export type EquipmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Equipment upsert
   */
  export type EquipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Equipment to update in case it exists.
     */
    where: EquipmentWhereUniqueInput
    /**
     * In case the Equipment found by the `where` argument doesn't exist, create a new Equipment with this data.
     */
    create: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
    /**
     * In case the Equipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
  }

  /**
   * Equipment delete
   */
  export type EquipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter which Equipment to delete.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment deleteMany
   */
  export type EquipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to delete
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to delete.
     */
    limit?: number
  }

  /**
   * Equipment.mountain
   */
  export type Equipment$mountainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MountainInclude<ExtArgs> | null
    where?: MountainWhereInput
  }

  /**
   * Equipment.location
   */
  export type Equipment$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Equipment.incidentEquipmentUsageLogs
   */
  export type Equipment$incidentEquipmentUsageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentEquipmentUsageLog
     */
    select?: IncidentEquipmentUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentEquipmentUsageLog
     */
    omit?: IncidentEquipmentUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentEquipmentUsageLogInclude<ExtArgs> | null
    where?: IncidentEquipmentUsageLogWhereInput
    orderBy?: IncidentEquipmentUsageLogOrderByWithRelationInput | IncidentEquipmentUsageLogOrderByWithRelationInput[]
    cursor?: IncidentEquipmentUsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentEquipmentUsageLogScalarFieldEnum | IncidentEquipmentUsageLogScalarFieldEnum[]
  }

  /**
   * Equipment.equipmentChecks
   */
  export type Equipment$equipmentChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    where?: EquipmentCheckWhereInput
    orderBy?: EquipmentCheckOrderByWithRelationInput | EquipmentCheckOrderByWithRelationInput[]
    cursor?: EquipmentCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentCheckScalarFieldEnum | EquipmentCheckScalarFieldEnum[]
  }

  /**
   * Equipment.equipmentServiceLogs
   */
  export type Equipment$equipmentServiceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentServiceLog
     */
    select?: EquipmentServiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentServiceLog
     */
    omit?: EquipmentServiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentServiceLogInclude<ExtArgs> | null
    where?: EquipmentServiceLogWhereInput
    orderBy?: EquipmentServiceLogOrderByWithRelationInput | EquipmentServiceLogOrderByWithRelationInput[]
    cursor?: EquipmentServiceLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentServiceLogScalarFieldEnum | EquipmentServiceLogScalarFieldEnum[]
  }

  /**
   * Equipment without action
   */
  export type EquipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
  }


  /**
   * Model Incident
   */

  export type AggregateIncident = {
    _count: IncidentCountAggregateOutputType | null
    _avg: IncidentAvgAggregateOutputType | null
    _sum: IncidentSumAggregateOutputType | null
    _min: IncidentMinAggregateOutputType | null
    _max: IncidentMaxAggregateOutputType | null
  }

  export type IncidentAvgAggregateOutputType = {
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type IncidentSumAggregateOutputType = {
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type IncidentMinAggregateOutputType = {
    id: string | null
    description: string | null
    status: $Enums.INCIDENT_STATUS | null
    latitude: Decimal | null
    longitude: Decimal | null
    mountainId: string | null
    startTime: Date | null
    endTime: Date | null
    onSceneTime: Date | null
    stableTime: Date | null
    transportTime: Date | null
    emptyRun: boolean | null
    emptyRunAt: Date | null
    locationId: string | null
  }

  export type IncidentMaxAggregateOutputType = {
    id: string | null
    description: string | null
    status: $Enums.INCIDENT_STATUS | null
    latitude: Decimal | null
    longitude: Decimal | null
    mountainId: string | null
    startTime: Date | null
    endTime: Date | null
    onSceneTime: Date | null
    stableTime: Date | null
    transportTime: Date | null
    emptyRun: boolean | null
    emptyRunAt: Date | null
    locationId: string | null
  }

  export type IncidentCountAggregateOutputType = {
    id: number
    description: number
    status: number
    latitude: number
    longitude: number
    mountainId: number
    startTime: number
    endTime: number
    onSceneTime: number
    stableTime: number
    transportTime: number
    emptyRun: number
    emptyRunAt: number
    locationId: number
    _all: number
  }


  export type IncidentAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type IncidentSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type IncidentMinAggregateInputType = {
    id?: true
    description?: true
    status?: true
    latitude?: true
    longitude?: true
    mountainId?: true
    startTime?: true
    endTime?: true
    onSceneTime?: true
    stableTime?: true
    transportTime?: true
    emptyRun?: true
    emptyRunAt?: true
    locationId?: true
  }

  export type IncidentMaxAggregateInputType = {
    id?: true
    description?: true
    status?: true
    latitude?: true
    longitude?: true
    mountainId?: true
    startTime?: true
    endTime?: true
    onSceneTime?: true
    stableTime?: true
    transportTime?: true
    emptyRun?: true
    emptyRunAt?: true
    locationId?: true
  }

  export type IncidentCountAggregateInputType = {
    id?: true
    description?: true
    status?: true
    latitude?: true
    longitude?: true
    mountainId?: true
    startTime?: true
    endTime?: true
    onSceneTime?: true
    stableTime?: true
    transportTime?: true
    emptyRun?: true
    emptyRunAt?: true
    locationId?: true
    _all?: true
  }

  export type IncidentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incident to aggregate.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Incidents
    **/
    _count?: true | IncidentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IncidentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IncidentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncidentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncidentMaxAggregateInputType
  }

  export type GetIncidentAggregateType<T extends IncidentAggregateArgs> = {
        [P in keyof T & keyof AggregateIncident]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncident[P]>
      : GetScalarType<T[P], AggregateIncident[P]>
  }




  export type IncidentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithAggregationInput | IncidentOrderByWithAggregationInput[]
    by: IncidentScalarFieldEnum[] | IncidentScalarFieldEnum
    having?: IncidentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncidentCountAggregateInputType | true
    _avg?: IncidentAvgAggregateInputType
    _sum?: IncidentSumAggregateInputType
    _min?: IncidentMinAggregateInputType
    _max?: IncidentMaxAggregateInputType
  }

  export type IncidentGroupByOutputType = {
    id: string
    description: string
    status: $Enums.INCIDENT_STATUS
    latitude: Decimal | null
    longitude: Decimal | null
    mountainId: string
    startTime: Date
    endTime: Date | null
    onSceneTime: Date | null
    stableTime: Date | null
    transportTime: Date | null
    emptyRun: boolean
    emptyRunAt: Date | null
    locationId: string
    _count: IncidentCountAggregateOutputType | null
    _avg: IncidentAvgAggregateOutputType | null
    _sum: IncidentSumAggregateOutputType | null
    _min: IncidentMinAggregateOutputType | null
    _max: IncidentMaxAggregateOutputType | null
  }

  type GetIncidentGroupByPayload<T extends IncidentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncidentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncidentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncidentGroupByOutputType[P]>
            : GetScalarType<T[P], IncidentGroupByOutputType[P]>
        }
      >
    >


  export type IncidentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    status?: boolean
    latitude?: boolean
    longitude?: boolean
    mountainId?: boolean
    startTime?: boolean
    endTime?: boolean
    onSceneTime?: boolean
    stableTime?: boolean
    transportTime?: boolean
    emptyRun?: boolean
    emptyRunAt?: boolean
    locationId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incidentEquipmentUsageLog?: boolean | Incident$incidentEquipmentUsageLogArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    employees?: boolean | Incident$employeesArgs<ExtArgs>
    _count?: boolean | IncidentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incident"]>

  export type IncidentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    status?: boolean
    latitude?: boolean
    longitude?: boolean
    mountainId?: boolean
    startTime?: boolean
    endTime?: boolean
    onSceneTime?: boolean
    stableTime?: boolean
    transportTime?: boolean
    emptyRun?: boolean
    emptyRunAt?: boolean
    locationId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incident"]>

  export type IncidentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    status?: boolean
    latitude?: boolean
    longitude?: boolean
    mountainId?: boolean
    startTime?: boolean
    endTime?: boolean
    onSceneTime?: boolean
    stableTime?: boolean
    transportTime?: boolean
    emptyRun?: boolean
    emptyRunAt?: boolean
    locationId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incident"]>

  export type IncidentSelectScalar = {
    id?: boolean
    description?: boolean
    status?: boolean
    latitude?: boolean
    longitude?: boolean
    mountainId?: boolean
    startTime?: boolean
    endTime?: boolean
    onSceneTime?: boolean
    stableTime?: boolean
    transportTime?: boolean
    emptyRun?: boolean
    emptyRunAt?: boolean
    locationId?: boolean
  }

  export type IncidentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "status" | "latitude" | "longitude" | "mountainId" | "startTime" | "endTime" | "onSceneTime" | "stableTime" | "transportTime" | "emptyRun" | "emptyRunAt" | "locationId", ExtArgs["result"]["incident"]>
  export type IncidentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incidentEquipmentUsageLog?: boolean | Incident$incidentEquipmentUsageLogArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    employees?: boolean | Incident$employeesArgs<ExtArgs>
    _count?: boolean | IncidentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IncidentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type IncidentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $IncidentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Incident"
    objects: {
      mountain: Prisma.$MountainPayload<ExtArgs>
      incidentEquipmentUsageLog: Prisma.$IncidentEquipmentUsageLogPayload<ExtArgs>[]
      location: Prisma.$LocationPayload<ExtArgs>
      employees: Prisma.$EmployeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      status: $Enums.INCIDENT_STATUS
      latitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      mountainId: string
      startTime: Date
      endTime: Date | null
      onSceneTime: Date | null
      stableTime: Date | null
      transportTime: Date | null
      emptyRun: boolean
      emptyRunAt: Date | null
      locationId: string
    }, ExtArgs["result"]["incident"]>
    composites: {}
  }

  type IncidentGetPayload<S extends boolean | null | undefined | IncidentDefaultArgs> = $Result.GetResult<Prisma.$IncidentPayload, S>

  type IncidentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IncidentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IncidentCountAggregateInputType | true
    }

  export interface IncidentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Incident'], meta: { name: 'Incident' } }
    /**
     * Find zero or one Incident that matches the filter.
     * @param {IncidentFindUniqueArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncidentFindUniqueArgs>(args: SelectSubset<T, IncidentFindUniqueArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Incident that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IncidentFindUniqueOrThrowArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncidentFindUniqueOrThrowArgs>(args: SelectSubset<T, IncidentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Incident that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindFirstArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncidentFindFirstArgs>(args?: SelectSubset<T, IncidentFindFirstArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Incident that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindFirstOrThrowArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncidentFindFirstOrThrowArgs>(args?: SelectSubset<T, IncidentFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Incidents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Incidents
     * const incidents = await prisma.incident.findMany()
     * 
     * // Get first 10 Incidents
     * const incidents = await prisma.incident.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incidentWithIdOnly = await prisma.incident.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncidentFindManyArgs>(args?: SelectSubset<T, IncidentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Incident.
     * @param {IncidentCreateArgs} args - Arguments to create a Incident.
     * @example
     * // Create one Incident
     * const Incident = await prisma.incident.create({
     *   data: {
     *     // ... data to create a Incident
     *   }
     * })
     * 
     */
    create<T extends IncidentCreateArgs>(args: SelectSubset<T, IncidentCreateArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Incidents.
     * @param {IncidentCreateManyArgs} args - Arguments to create many Incidents.
     * @example
     * // Create many Incidents
     * const incident = await prisma.incident.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncidentCreateManyArgs>(args?: SelectSubset<T, IncidentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Incidents and returns the data saved in the database.
     * @param {IncidentCreateManyAndReturnArgs} args - Arguments to create many Incidents.
     * @example
     * // Create many Incidents
     * const incident = await prisma.incident.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Incidents and only return the `id`
     * const incidentWithIdOnly = await prisma.incident.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncidentCreateManyAndReturnArgs>(args?: SelectSubset<T, IncidentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Incident.
     * @param {IncidentDeleteArgs} args - Arguments to delete one Incident.
     * @example
     * // Delete one Incident
     * const Incident = await prisma.incident.delete({
     *   where: {
     *     // ... filter to delete one Incident
     *   }
     * })
     * 
     */
    delete<T extends IncidentDeleteArgs>(args: SelectSubset<T, IncidentDeleteArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Incident.
     * @param {IncidentUpdateArgs} args - Arguments to update one Incident.
     * @example
     * // Update one Incident
     * const incident = await prisma.incident.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncidentUpdateArgs>(args: SelectSubset<T, IncidentUpdateArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Incidents.
     * @param {IncidentDeleteManyArgs} args - Arguments to filter Incidents to delete.
     * @example
     * // Delete a few Incidents
     * const { count } = await prisma.incident.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncidentDeleteManyArgs>(args?: SelectSubset<T, IncidentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Incidents
     * const incident = await prisma.incident.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncidentUpdateManyArgs>(args: SelectSubset<T, IncidentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incidents and returns the data updated in the database.
     * @param {IncidentUpdateManyAndReturnArgs} args - Arguments to update many Incidents.
     * @example
     * // Update many Incidents
     * const incident = await prisma.incident.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Incidents and only return the `id`
     * const incidentWithIdOnly = await prisma.incident.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IncidentUpdateManyAndReturnArgs>(args: SelectSubset<T, IncidentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Incident.
     * @param {IncidentUpsertArgs} args - Arguments to update or create a Incident.
     * @example
     * // Update or create a Incident
     * const incident = await prisma.incident.upsert({
     *   create: {
     *     // ... data to create a Incident
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Incident we want to update
     *   }
     * })
     */
    upsert<T extends IncidentUpsertArgs>(args: SelectSubset<T, IncidentUpsertArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Incidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentCountArgs} args - Arguments to filter Incidents to count.
     * @example
     * // Count the number of Incidents
     * const count = await prisma.incident.count({
     *   where: {
     *     // ... the filter for the Incidents we want to count
     *   }
     * })
    **/
    count<T extends IncidentCountArgs>(
      args?: Subset<T, IncidentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncidentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Incident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncidentAggregateArgs>(args: Subset<T, IncidentAggregateArgs>): Prisma.PrismaPromise<GetIncidentAggregateType<T>>

    /**
     * Group by Incident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncidentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncidentGroupByArgs['orderBy'] }
        : { orderBy?: IncidentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncidentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncidentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Incident model
   */
  readonly fields: IncidentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Incident.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncidentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    incidentEquipmentUsageLog<T extends Incident$incidentEquipmentUsageLogArgs<ExtArgs> = {}>(args?: Subset<T, Incident$incidentEquipmentUsageLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentEquipmentUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employees<T extends Incident$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Incident$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Incident model
   */
  interface IncidentFieldRefs {
    readonly id: FieldRef<"Incident", 'String'>
    readonly description: FieldRef<"Incident", 'String'>
    readonly status: FieldRef<"Incident", 'INCIDENT_STATUS'>
    readonly latitude: FieldRef<"Incident", 'Decimal'>
    readonly longitude: FieldRef<"Incident", 'Decimal'>
    readonly mountainId: FieldRef<"Incident", 'String'>
    readonly startTime: FieldRef<"Incident", 'DateTime'>
    readonly endTime: FieldRef<"Incident", 'DateTime'>
    readonly onSceneTime: FieldRef<"Incident", 'DateTime'>
    readonly stableTime: FieldRef<"Incident", 'DateTime'>
    readonly transportTime: FieldRef<"Incident", 'DateTime'>
    readonly emptyRun: FieldRef<"Incident", 'Boolean'>
    readonly emptyRunAt: FieldRef<"Incident", 'DateTime'>
    readonly locationId: FieldRef<"Incident", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Incident findUnique
   */
  export type IncidentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident findUniqueOrThrow
   */
  export type IncidentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident findFirst
   */
  export type IncidentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidents.
     */
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident findFirstOrThrow
   */
  export type IncidentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidents.
     */
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident findMany
   */
  export type IncidentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incidents to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident create
   */
  export type IncidentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The data needed to create a Incident.
     */
    data: XOR<IncidentCreateInput, IncidentUncheckedCreateInput>
  }

  /**
   * Incident createMany
   */
  export type IncidentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Incidents.
     */
    data: IncidentCreateManyInput | IncidentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Incident createManyAndReturn
   */
  export type IncidentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * The data used to create many Incidents.
     */
    data: IncidentCreateManyInput | IncidentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Incident update
   */
  export type IncidentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The data needed to update a Incident.
     */
    data: XOR<IncidentUpdateInput, IncidentUncheckedUpdateInput>
    /**
     * Choose, which Incident to update.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident updateMany
   */
  export type IncidentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Incidents.
     */
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyInput>
    /**
     * Filter which Incidents to update
     */
    where?: IncidentWhereInput
    /**
     * Limit how many Incidents to update.
     */
    limit?: number
  }

  /**
   * Incident updateManyAndReturn
   */
  export type IncidentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * The data used to update Incidents.
     */
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyInput>
    /**
     * Filter which Incidents to update
     */
    where?: IncidentWhereInput
    /**
     * Limit how many Incidents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Incident upsert
   */
  export type IncidentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The filter to search for the Incident to update in case it exists.
     */
    where: IncidentWhereUniqueInput
    /**
     * In case the Incident found by the `where` argument doesn't exist, create a new Incident with this data.
     */
    create: XOR<IncidentCreateInput, IncidentUncheckedCreateInput>
    /**
     * In case the Incident was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncidentUpdateInput, IncidentUncheckedUpdateInput>
  }

  /**
   * Incident delete
   */
  export type IncidentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter which Incident to delete.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident deleteMany
   */
  export type IncidentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incidents to delete
     */
    where?: IncidentWhereInput
    /**
     * Limit how many Incidents to delete.
     */
    limit?: number
  }

  /**
   * Incident.incidentEquipmentUsageLog
   */
  export type Incident$incidentEquipmentUsageLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentEquipmentUsageLog
     */
    select?: IncidentEquipmentUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentEquipmentUsageLog
     */
    omit?: IncidentEquipmentUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentEquipmentUsageLogInclude<ExtArgs> | null
    where?: IncidentEquipmentUsageLogWhereInput
    orderBy?: IncidentEquipmentUsageLogOrderByWithRelationInput | IncidentEquipmentUsageLogOrderByWithRelationInput[]
    cursor?: IncidentEquipmentUsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentEquipmentUsageLogScalarFieldEnum | IncidentEquipmentUsageLogScalarFieldEnum[]
  }

  /**
   * Incident.employees
   */
  export type Incident$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Incident without action
   */
  export type IncidentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
  }


  /**
   * Model IncidentEquipmentUsageLog
   */

  export type AggregateIncidentEquipmentUsageLog = {
    _count: IncidentEquipmentUsageLogCountAggregateOutputType | null
    _min: IncidentEquipmentUsageLogMinAggregateOutputType | null
    _max: IncidentEquipmentUsageLogMaxAggregateOutputType | null
  }

  export type IncidentEquipmentUsageLogMinAggregateOutputType = {
    id: string | null
    usedAt: Date | null
    notes: string | null
    mountainId: string | null
    equipmentId: string | null
    incidentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncidentEquipmentUsageLogMaxAggregateOutputType = {
    id: string | null
    usedAt: Date | null
    notes: string | null
    mountainId: string | null
    equipmentId: string | null
    incidentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncidentEquipmentUsageLogCountAggregateOutputType = {
    id: number
    usedAt: number
    notes: number
    mountainId: number
    equipmentId: number
    incidentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IncidentEquipmentUsageLogMinAggregateInputType = {
    id?: true
    usedAt?: true
    notes?: true
    mountainId?: true
    equipmentId?: true
    incidentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncidentEquipmentUsageLogMaxAggregateInputType = {
    id?: true
    usedAt?: true
    notes?: true
    mountainId?: true
    equipmentId?: true
    incidentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncidentEquipmentUsageLogCountAggregateInputType = {
    id?: true
    usedAt?: true
    notes?: true
    mountainId?: true
    equipmentId?: true
    incidentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IncidentEquipmentUsageLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncidentEquipmentUsageLog to aggregate.
     */
    where?: IncidentEquipmentUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentEquipmentUsageLogs to fetch.
     */
    orderBy?: IncidentEquipmentUsageLogOrderByWithRelationInput | IncidentEquipmentUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncidentEquipmentUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentEquipmentUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentEquipmentUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IncidentEquipmentUsageLogs
    **/
    _count?: true | IncidentEquipmentUsageLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncidentEquipmentUsageLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncidentEquipmentUsageLogMaxAggregateInputType
  }

  export type GetIncidentEquipmentUsageLogAggregateType<T extends IncidentEquipmentUsageLogAggregateArgs> = {
        [P in keyof T & keyof AggregateIncidentEquipmentUsageLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncidentEquipmentUsageLog[P]>
      : GetScalarType<T[P], AggregateIncidentEquipmentUsageLog[P]>
  }




  export type IncidentEquipmentUsageLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentEquipmentUsageLogWhereInput
    orderBy?: IncidentEquipmentUsageLogOrderByWithAggregationInput | IncidentEquipmentUsageLogOrderByWithAggregationInput[]
    by: IncidentEquipmentUsageLogScalarFieldEnum[] | IncidentEquipmentUsageLogScalarFieldEnum
    having?: IncidentEquipmentUsageLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncidentEquipmentUsageLogCountAggregateInputType | true
    _min?: IncidentEquipmentUsageLogMinAggregateInputType
    _max?: IncidentEquipmentUsageLogMaxAggregateInputType
  }

  export type IncidentEquipmentUsageLogGroupByOutputType = {
    id: string
    usedAt: Date
    notes: string | null
    mountainId: string
    equipmentId: string
    incidentId: string
    createdAt: Date
    updatedAt: Date
    _count: IncidentEquipmentUsageLogCountAggregateOutputType | null
    _min: IncidentEquipmentUsageLogMinAggregateOutputType | null
    _max: IncidentEquipmentUsageLogMaxAggregateOutputType | null
  }

  type GetIncidentEquipmentUsageLogGroupByPayload<T extends IncidentEquipmentUsageLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncidentEquipmentUsageLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncidentEquipmentUsageLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncidentEquipmentUsageLogGroupByOutputType[P]>
            : GetScalarType<T[P], IncidentEquipmentUsageLogGroupByOutputType[P]>
        }
      >
    >


  export type IncidentEquipmentUsageLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usedAt?: boolean
    notes?: boolean
    mountainId?: boolean
    equipmentId?: boolean
    incidentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incidentEquipmentUsageLog"]>

  export type IncidentEquipmentUsageLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usedAt?: boolean
    notes?: boolean
    mountainId?: boolean
    equipmentId?: boolean
    incidentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incidentEquipmentUsageLog"]>

  export type IncidentEquipmentUsageLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usedAt?: boolean
    notes?: boolean
    mountainId?: boolean
    equipmentId?: boolean
    incidentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incidentEquipmentUsageLog"]>

  export type IncidentEquipmentUsageLogSelectScalar = {
    id?: boolean
    usedAt?: boolean
    notes?: boolean
    mountainId?: boolean
    equipmentId?: boolean
    incidentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IncidentEquipmentUsageLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usedAt" | "notes" | "mountainId" | "equipmentId" | "incidentId" | "createdAt" | "updatedAt", ExtArgs["result"]["incidentEquipmentUsageLog"]>
  export type IncidentEquipmentUsageLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }
  export type IncidentEquipmentUsageLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }
  export type IncidentEquipmentUsageLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }

  export type $IncidentEquipmentUsageLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IncidentEquipmentUsageLog"
    objects: {
      mountain: Prisma.$MountainPayload<ExtArgs>
      incident: Prisma.$IncidentPayload<ExtArgs>
      equipment: Prisma.$EquipmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usedAt: Date
      notes: string | null
      mountainId: string
      equipmentId: string
      incidentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["incidentEquipmentUsageLog"]>
    composites: {}
  }

  type IncidentEquipmentUsageLogGetPayload<S extends boolean | null | undefined | IncidentEquipmentUsageLogDefaultArgs> = $Result.GetResult<Prisma.$IncidentEquipmentUsageLogPayload, S>

  type IncidentEquipmentUsageLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IncidentEquipmentUsageLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IncidentEquipmentUsageLogCountAggregateInputType | true
    }

  export interface IncidentEquipmentUsageLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IncidentEquipmentUsageLog'], meta: { name: 'IncidentEquipmentUsageLog' } }
    /**
     * Find zero or one IncidentEquipmentUsageLog that matches the filter.
     * @param {IncidentEquipmentUsageLogFindUniqueArgs} args - Arguments to find a IncidentEquipmentUsageLog
     * @example
     * // Get one IncidentEquipmentUsageLog
     * const incidentEquipmentUsageLog = await prisma.incidentEquipmentUsageLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncidentEquipmentUsageLogFindUniqueArgs>(args: SelectSubset<T, IncidentEquipmentUsageLogFindUniqueArgs<ExtArgs>>): Prisma__IncidentEquipmentUsageLogClient<$Result.GetResult<Prisma.$IncidentEquipmentUsageLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IncidentEquipmentUsageLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IncidentEquipmentUsageLogFindUniqueOrThrowArgs} args - Arguments to find a IncidentEquipmentUsageLog
     * @example
     * // Get one IncidentEquipmentUsageLog
     * const incidentEquipmentUsageLog = await prisma.incidentEquipmentUsageLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncidentEquipmentUsageLogFindUniqueOrThrowArgs>(args: SelectSubset<T, IncidentEquipmentUsageLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncidentEquipmentUsageLogClient<$Result.GetResult<Prisma.$IncidentEquipmentUsageLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IncidentEquipmentUsageLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentEquipmentUsageLogFindFirstArgs} args - Arguments to find a IncidentEquipmentUsageLog
     * @example
     * // Get one IncidentEquipmentUsageLog
     * const incidentEquipmentUsageLog = await prisma.incidentEquipmentUsageLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncidentEquipmentUsageLogFindFirstArgs>(args?: SelectSubset<T, IncidentEquipmentUsageLogFindFirstArgs<ExtArgs>>): Prisma__IncidentEquipmentUsageLogClient<$Result.GetResult<Prisma.$IncidentEquipmentUsageLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IncidentEquipmentUsageLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentEquipmentUsageLogFindFirstOrThrowArgs} args - Arguments to find a IncidentEquipmentUsageLog
     * @example
     * // Get one IncidentEquipmentUsageLog
     * const incidentEquipmentUsageLog = await prisma.incidentEquipmentUsageLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncidentEquipmentUsageLogFindFirstOrThrowArgs>(args?: SelectSubset<T, IncidentEquipmentUsageLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncidentEquipmentUsageLogClient<$Result.GetResult<Prisma.$IncidentEquipmentUsageLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IncidentEquipmentUsageLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentEquipmentUsageLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IncidentEquipmentUsageLogs
     * const incidentEquipmentUsageLogs = await prisma.incidentEquipmentUsageLog.findMany()
     * 
     * // Get first 10 IncidentEquipmentUsageLogs
     * const incidentEquipmentUsageLogs = await prisma.incidentEquipmentUsageLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incidentEquipmentUsageLogWithIdOnly = await prisma.incidentEquipmentUsageLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncidentEquipmentUsageLogFindManyArgs>(args?: SelectSubset<T, IncidentEquipmentUsageLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentEquipmentUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IncidentEquipmentUsageLog.
     * @param {IncidentEquipmentUsageLogCreateArgs} args - Arguments to create a IncidentEquipmentUsageLog.
     * @example
     * // Create one IncidentEquipmentUsageLog
     * const IncidentEquipmentUsageLog = await prisma.incidentEquipmentUsageLog.create({
     *   data: {
     *     // ... data to create a IncidentEquipmentUsageLog
     *   }
     * })
     * 
     */
    create<T extends IncidentEquipmentUsageLogCreateArgs>(args: SelectSubset<T, IncidentEquipmentUsageLogCreateArgs<ExtArgs>>): Prisma__IncidentEquipmentUsageLogClient<$Result.GetResult<Prisma.$IncidentEquipmentUsageLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IncidentEquipmentUsageLogs.
     * @param {IncidentEquipmentUsageLogCreateManyArgs} args - Arguments to create many IncidentEquipmentUsageLogs.
     * @example
     * // Create many IncidentEquipmentUsageLogs
     * const incidentEquipmentUsageLog = await prisma.incidentEquipmentUsageLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncidentEquipmentUsageLogCreateManyArgs>(args?: SelectSubset<T, IncidentEquipmentUsageLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IncidentEquipmentUsageLogs and returns the data saved in the database.
     * @param {IncidentEquipmentUsageLogCreateManyAndReturnArgs} args - Arguments to create many IncidentEquipmentUsageLogs.
     * @example
     * // Create many IncidentEquipmentUsageLogs
     * const incidentEquipmentUsageLog = await prisma.incidentEquipmentUsageLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IncidentEquipmentUsageLogs and only return the `id`
     * const incidentEquipmentUsageLogWithIdOnly = await prisma.incidentEquipmentUsageLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncidentEquipmentUsageLogCreateManyAndReturnArgs>(args?: SelectSubset<T, IncidentEquipmentUsageLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentEquipmentUsageLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IncidentEquipmentUsageLog.
     * @param {IncidentEquipmentUsageLogDeleteArgs} args - Arguments to delete one IncidentEquipmentUsageLog.
     * @example
     * // Delete one IncidentEquipmentUsageLog
     * const IncidentEquipmentUsageLog = await prisma.incidentEquipmentUsageLog.delete({
     *   where: {
     *     // ... filter to delete one IncidentEquipmentUsageLog
     *   }
     * })
     * 
     */
    delete<T extends IncidentEquipmentUsageLogDeleteArgs>(args: SelectSubset<T, IncidentEquipmentUsageLogDeleteArgs<ExtArgs>>): Prisma__IncidentEquipmentUsageLogClient<$Result.GetResult<Prisma.$IncidentEquipmentUsageLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IncidentEquipmentUsageLog.
     * @param {IncidentEquipmentUsageLogUpdateArgs} args - Arguments to update one IncidentEquipmentUsageLog.
     * @example
     * // Update one IncidentEquipmentUsageLog
     * const incidentEquipmentUsageLog = await prisma.incidentEquipmentUsageLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncidentEquipmentUsageLogUpdateArgs>(args: SelectSubset<T, IncidentEquipmentUsageLogUpdateArgs<ExtArgs>>): Prisma__IncidentEquipmentUsageLogClient<$Result.GetResult<Prisma.$IncidentEquipmentUsageLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IncidentEquipmentUsageLogs.
     * @param {IncidentEquipmentUsageLogDeleteManyArgs} args - Arguments to filter IncidentEquipmentUsageLogs to delete.
     * @example
     * // Delete a few IncidentEquipmentUsageLogs
     * const { count } = await prisma.incidentEquipmentUsageLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncidentEquipmentUsageLogDeleteManyArgs>(args?: SelectSubset<T, IncidentEquipmentUsageLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncidentEquipmentUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentEquipmentUsageLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IncidentEquipmentUsageLogs
     * const incidentEquipmentUsageLog = await prisma.incidentEquipmentUsageLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncidentEquipmentUsageLogUpdateManyArgs>(args: SelectSubset<T, IncidentEquipmentUsageLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncidentEquipmentUsageLogs and returns the data updated in the database.
     * @param {IncidentEquipmentUsageLogUpdateManyAndReturnArgs} args - Arguments to update many IncidentEquipmentUsageLogs.
     * @example
     * // Update many IncidentEquipmentUsageLogs
     * const incidentEquipmentUsageLog = await prisma.incidentEquipmentUsageLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IncidentEquipmentUsageLogs and only return the `id`
     * const incidentEquipmentUsageLogWithIdOnly = await prisma.incidentEquipmentUsageLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IncidentEquipmentUsageLogUpdateManyAndReturnArgs>(args: SelectSubset<T, IncidentEquipmentUsageLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentEquipmentUsageLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IncidentEquipmentUsageLog.
     * @param {IncidentEquipmentUsageLogUpsertArgs} args - Arguments to update or create a IncidentEquipmentUsageLog.
     * @example
     * // Update or create a IncidentEquipmentUsageLog
     * const incidentEquipmentUsageLog = await prisma.incidentEquipmentUsageLog.upsert({
     *   create: {
     *     // ... data to create a IncidentEquipmentUsageLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IncidentEquipmentUsageLog we want to update
     *   }
     * })
     */
    upsert<T extends IncidentEquipmentUsageLogUpsertArgs>(args: SelectSubset<T, IncidentEquipmentUsageLogUpsertArgs<ExtArgs>>): Prisma__IncidentEquipmentUsageLogClient<$Result.GetResult<Prisma.$IncidentEquipmentUsageLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IncidentEquipmentUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentEquipmentUsageLogCountArgs} args - Arguments to filter IncidentEquipmentUsageLogs to count.
     * @example
     * // Count the number of IncidentEquipmentUsageLogs
     * const count = await prisma.incidentEquipmentUsageLog.count({
     *   where: {
     *     // ... the filter for the IncidentEquipmentUsageLogs we want to count
     *   }
     * })
    **/
    count<T extends IncidentEquipmentUsageLogCountArgs>(
      args?: Subset<T, IncidentEquipmentUsageLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncidentEquipmentUsageLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IncidentEquipmentUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentEquipmentUsageLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncidentEquipmentUsageLogAggregateArgs>(args: Subset<T, IncidentEquipmentUsageLogAggregateArgs>): Prisma.PrismaPromise<GetIncidentEquipmentUsageLogAggregateType<T>>

    /**
     * Group by IncidentEquipmentUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentEquipmentUsageLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncidentEquipmentUsageLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncidentEquipmentUsageLogGroupByArgs['orderBy'] }
        : { orderBy?: IncidentEquipmentUsageLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncidentEquipmentUsageLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncidentEquipmentUsageLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IncidentEquipmentUsageLog model
   */
  readonly fields: IncidentEquipmentUsageLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IncidentEquipmentUsageLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncidentEquipmentUsageLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    incident<T extends IncidentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IncidentDefaultArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    equipment<T extends EquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentDefaultArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IncidentEquipmentUsageLog model
   */
  interface IncidentEquipmentUsageLogFieldRefs {
    readonly id: FieldRef<"IncidentEquipmentUsageLog", 'String'>
    readonly usedAt: FieldRef<"IncidentEquipmentUsageLog", 'DateTime'>
    readonly notes: FieldRef<"IncidentEquipmentUsageLog", 'String'>
    readonly mountainId: FieldRef<"IncidentEquipmentUsageLog", 'String'>
    readonly equipmentId: FieldRef<"IncidentEquipmentUsageLog", 'String'>
    readonly incidentId: FieldRef<"IncidentEquipmentUsageLog", 'String'>
    readonly createdAt: FieldRef<"IncidentEquipmentUsageLog", 'DateTime'>
    readonly updatedAt: FieldRef<"IncidentEquipmentUsageLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IncidentEquipmentUsageLog findUnique
   */
  export type IncidentEquipmentUsageLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentEquipmentUsageLog
     */
    select?: IncidentEquipmentUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentEquipmentUsageLog
     */
    omit?: IncidentEquipmentUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentEquipmentUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which IncidentEquipmentUsageLog to fetch.
     */
    where: IncidentEquipmentUsageLogWhereUniqueInput
  }

  /**
   * IncidentEquipmentUsageLog findUniqueOrThrow
   */
  export type IncidentEquipmentUsageLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentEquipmentUsageLog
     */
    select?: IncidentEquipmentUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentEquipmentUsageLog
     */
    omit?: IncidentEquipmentUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentEquipmentUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which IncidentEquipmentUsageLog to fetch.
     */
    where: IncidentEquipmentUsageLogWhereUniqueInput
  }

  /**
   * IncidentEquipmentUsageLog findFirst
   */
  export type IncidentEquipmentUsageLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentEquipmentUsageLog
     */
    select?: IncidentEquipmentUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentEquipmentUsageLog
     */
    omit?: IncidentEquipmentUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentEquipmentUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which IncidentEquipmentUsageLog to fetch.
     */
    where?: IncidentEquipmentUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentEquipmentUsageLogs to fetch.
     */
    orderBy?: IncidentEquipmentUsageLogOrderByWithRelationInput | IncidentEquipmentUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncidentEquipmentUsageLogs.
     */
    cursor?: IncidentEquipmentUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentEquipmentUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentEquipmentUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncidentEquipmentUsageLogs.
     */
    distinct?: IncidentEquipmentUsageLogScalarFieldEnum | IncidentEquipmentUsageLogScalarFieldEnum[]
  }

  /**
   * IncidentEquipmentUsageLog findFirstOrThrow
   */
  export type IncidentEquipmentUsageLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentEquipmentUsageLog
     */
    select?: IncidentEquipmentUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentEquipmentUsageLog
     */
    omit?: IncidentEquipmentUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentEquipmentUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which IncidentEquipmentUsageLog to fetch.
     */
    where?: IncidentEquipmentUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentEquipmentUsageLogs to fetch.
     */
    orderBy?: IncidentEquipmentUsageLogOrderByWithRelationInput | IncidentEquipmentUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncidentEquipmentUsageLogs.
     */
    cursor?: IncidentEquipmentUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentEquipmentUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentEquipmentUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncidentEquipmentUsageLogs.
     */
    distinct?: IncidentEquipmentUsageLogScalarFieldEnum | IncidentEquipmentUsageLogScalarFieldEnum[]
  }

  /**
   * IncidentEquipmentUsageLog findMany
   */
  export type IncidentEquipmentUsageLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentEquipmentUsageLog
     */
    select?: IncidentEquipmentUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentEquipmentUsageLog
     */
    omit?: IncidentEquipmentUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentEquipmentUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which IncidentEquipmentUsageLogs to fetch.
     */
    where?: IncidentEquipmentUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentEquipmentUsageLogs to fetch.
     */
    orderBy?: IncidentEquipmentUsageLogOrderByWithRelationInput | IncidentEquipmentUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IncidentEquipmentUsageLogs.
     */
    cursor?: IncidentEquipmentUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentEquipmentUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentEquipmentUsageLogs.
     */
    skip?: number
    distinct?: IncidentEquipmentUsageLogScalarFieldEnum | IncidentEquipmentUsageLogScalarFieldEnum[]
  }

  /**
   * IncidentEquipmentUsageLog create
   */
  export type IncidentEquipmentUsageLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentEquipmentUsageLog
     */
    select?: IncidentEquipmentUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentEquipmentUsageLog
     */
    omit?: IncidentEquipmentUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentEquipmentUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to create a IncidentEquipmentUsageLog.
     */
    data: XOR<IncidentEquipmentUsageLogCreateInput, IncidentEquipmentUsageLogUncheckedCreateInput>
  }

  /**
   * IncidentEquipmentUsageLog createMany
   */
  export type IncidentEquipmentUsageLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IncidentEquipmentUsageLogs.
     */
    data: IncidentEquipmentUsageLogCreateManyInput | IncidentEquipmentUsageLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IncidentEquipmentUsageLog createManyAndReturn
   */
  export type IncidentEquipmentUsageLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentEquipmentUsageLog
     */
    select?: IncidentEquipmentUsageLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentEquipmentUsageLog
     */
    omit?: IncidentEquipmentUsageLogOmit<ExtArgs> | null
    /**
     * The data used to create many IncidentEquipmentUsageLogs.
     */
    data: IncidentEquipmentUsageLogCreateManyInput | IncidentEquipmentUsageLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentEquipmentUsageLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IncidentEquipmentUsageLog update
   */
  export type IncidentEquipmentUsageLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentEquipmentUsageLog
     */
    select?: IncidentEquipmentUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentEquipmentUsageLog
     */
    omit?: IncidentEquipmentUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentEquipmentUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to update a IncidentEquipmentUsageLog.
     */
    data: XOR<IncidentEquipmentUsageLogUpdateInput, IncidentEquipmentUsageLogUncheckedUpdateInput>
    /**
     * Choose, which IncidentEquipmentUsageLog to update.
     */
    where: IncidentEquipmentUsageLogWhereUniqueInput
  }

  /**
   * IncidentEquipmentUsageLog updateMany
   */
  export type IncidentEquipmentUsageLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IncidentEquipmentUsageLogs.
     */
    data: XOR<IncidentEquipmentUsageLogUpdateManyMutationInput, IncidentEquipmentUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which IncidentEquipmentUsageLogs to update
     */
    where?: IncidentEquipmentUsageLogWhereInput
    /**
     * Limit how many IncidentEquipmentUsageLogs to update.
     */
    limit?: number
  }

  /**
   * IncidentEquipmentUsageLog updateManyAndReturn
   */
  export type IncidentEquipmentUsageLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentEquipmentUsageLog
     */
    select?: IncidentEquipmentUsageLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentEquipmentUsageLog
     */
    omit?: IncidentEquipmentUsageLogOmit<ExtArgs> | null
    /**
     * The data used to update IncidentEquipmentUsageLogs.
     */
    data: XOR<IncidentEquipmentUsageLogUpdateManyMutationInput, IncidentEquipmentUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which IncidentEquipmentUsageLogs to update
     */
    where?: IncidentEquipmentUsageLogWhereInput
    /**
     * Limit how many IncidentEquipmentUsageLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentEquipmentUsageLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IncidentEquipmentUsageLog upsert
   */
  export type IncidentEquipmentUsageLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentEquipmentUsageLog
     */
    select?: IncidentEquipmentUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentEquipmentUsageLog
     */
    omit?: IncidentEquipmentUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentEquipmentUsageLogInclude<ExtArgs> | null
    /**
     * The filter to search for the IncidentEquipmentUsageLog to update in case it exists.
     */
    where: IncidentEquipmentUsageLogWhereUniqueInput
    /**
     * In case the IncidentEquipmentUsageLog found by the `where` argument doesn't exist, create a new IncidentEquipmentUsageLog with this data.
     */
    create: XOR<IncidentEquipmentUsageLogCreateInput, IncidentEquipmentUsageLogUncheckedCreateInput>
    /**
     * In case the IncidentEquipmentUsageLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncidentEquipmentUsageLogUpdateInput, IncidentEquipmentUsageLogUncheckedUpdateInput>
  }

  /**
   * IncidentEquipmentUsageLog delete
   */
  export type IncidentEquipmentUsageLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentEquipmentUsageLog
     */
    select?: IncidentEquipmentUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentEquipmentUsageLog
     */
    omit?: IncidentEquipmentUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentEquipmentUsageLogInclude<ExtArgs> | null
    /**
     * Filter which IncidentEquipmentUsageLog to delete.
     */
    where: IncidentEquipmentUsageLogWhereUniqueInput
  }

  /**
   * IncidentEquipmentUsageLog deleteMany
   */
  export type IncidentEquipmentUsageLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncidentEquipmentUsageLogs to delete
     */
    where?: IncidentEquipmentUsageLogWhereInput
    /**
     * Limit how many IncidentEquipmentUsageLogs to delete.
     */
    limit?: number
  }

  /**
   * IncidentEquipmentUsageLog without action
   */
  export type IncidentEquipmentUsageLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentEquipmentUsageLog
     */
    select?: IncidentEquipmentUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentEquipmentUsageLog
     */
    omit?: IncidentEquipmentUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentEquipmentUsageLogInclude<ExtArgs> | null
  }


  /**
   * Model LiftCheck
   */

  export type AggregateLiftCheck = {
    _count: LiftCheckCountAggregateOutputType | null
    _min: LiftCheckMinAggregateOutputType | null
    _max: LiftCheckMaxAggregateOutputType | null
  }

  export type LiftCheckMinAggregateOutputType = {
    id: string | null
    recordedAt: Date | null
    employeeId: string | null
    mountainId: string | null
    liftId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LiftCheckMaxAggregateOutputType = {
    id: string | null
    recordedAt: Date | null
    employeeId: string | null
    mountainId: string | null
    liftId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LiftCheckCountAggregateOutputType = {
    id: number
    recordedAt: number
    employeeId: number
    mountainId: number
    liftId: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LiftCheckMinAggregateInputType = {
    id?: true
    recordedAt?: true
    employeeId?: true
    mountainId?: true
    liftId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LiftCheckMaxAggregateInputType = {
    id?: true
    recordedAt?: true
    employeeId?: true
    mountainId?: true
    liftId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LiftCheckCountAggregateInputType = {
    id?: true
    recordedAt?: true
    employeeId?: true
    mountainId?: true
    liftId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LiftCheckAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiftCheck to aggregate.
     */
    where?: LiftCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiftChecks to fetch.
     */
    orderBy?: LiftCheckOrderByWithRelationInput | LiftCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LiftCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiftChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiftChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LiftChecks
    **/
    _count?: true | LiftCheckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiftCheckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiftCheckMaxAggregateInputType
  }

  export type GetLiftCheckAggregateType<T extends LiftCheckAggregateArgs> = {
        [P in keyof T & keyof AggregateLiftCheck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiftCheck[P]>
      : GetScalarType<T[P], AggregateLiftCheck[P]>
  }




  export type LiftCheckGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiftCheckWhereInput
    orderBy?: LiftCheckOrderByWithAggregationInput | LiftCheckOrderByWithAggregationInput[]
    by: LiftCheckScalarFieldEnum[] | LiftCheckScalarFieldEnum
    having?: LiftCheckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiftCheckCountAggregateInputType | true
    _min?: LiftCheckMinAggregateInputType
    _max?: LiftCheckMaxAggregateInputType
  }

  export type LiftCheckGroupByOutputType = {
    id: string
    recordedAt: Date
    employeeId: string
    mountainId: string
    liftId: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: LiftCheckCountAggregateOutputType | null
    _min: LiftCheckMinAggregateOutputType | null
    _max: LiftCheckMaxAggregateOutputType | null
  }

  type GetLiftCheckGroupByPayload<T extends LiftCheckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LiftCheckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LiftCheckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LiftCheckGroupByOutputType[P]>
            : GetScalarType<T[P], LiftCheckGroupByOutputType[P]>
        }
      >
    >


  export type LiftCheckSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recordedAt?: boolean
    employeeId?: boolean
    mountainId?: boolean
    liftId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    lift?: boolean | LiftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liftCheck"]>

  export type LiftCheckSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recordedAt?: boolean
    employeeId?: boolean
    mountainId?: boolean
    liftId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    lift?: boolean | LiftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liftCheck"]>

  export type LiftCheckSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recordedAt?: boolean
    employeeId?: boolean
    mountainId?: boolean
    liftId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    lift?: boolean | LiftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liftCheck"]>

  export type LiftCheckSelectScalar = {
    id?: boolean
    recordedAt?: boolean
    employeeId?: boolean
    mountainId?: boolean
    liftId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LiftCheckOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recordedAt" | "employeeId" | "mountainId" | "liftId" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["liftCheck"]>
  export type LiftCheckInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    lift?: boolean | LiftDefaultArgs<ExtArgs>
  }
  export type LiftCheckIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    lift?: boolean | LiftDefaultArgs<ExtArgs>
  }
  export type LiftCheckIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    lift?: boolean | LiftDefaultArgs<ExtArgs>
  }

  export type $LiftCheckPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LiftCheck"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      mountain: Prisma.$MountainPayload<ExtArgs>
      lift: Prisma.$LiftPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recordedAt: Date
      employeeId: string
      mountainId: string
      liftId: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["liftCheck"]>
    composites: {}
  }

  type LiftCheckGetPayload<S extends boolean | null | undefined | LiftCheckDefaultArgs> = $Result.GetResult<Prisma.$LiftCheckPayload, S>

  type LiftCheckCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LiftCheckFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LiftCheckCountAggregateInputType | true
    }

  export interface LiftCheckDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LiftCheck'], meta: { name: 'LiftCheck' } }
    /**
     * Find zero or one LiftCheck that matches the filter.
     * @param {LiftCheckFindUniqueArgs} args - Arguments to find a LiftCheck
     * @example
     * // Get one LiftCheck
     * const liftCheck = await prisma.liftCheck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LiftCheckFindUniqueArgs>(args: SelectSubset<T, LiftCheckFindUniqueArgs<ExtArgs>>): Prisma__LiftCheckClient<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LiftCheck that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LiftCheckFindUniqueOrThrowArgs} args - Arguments to find a LiftCheck
     * @example
     * // Get one LiftCheck
     * const liftCheck = await prisma.liftCheck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LiftCheckFindUniqueOrThrowArgs>(args: SelectSubset<T, LiftCheckFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LiftCheckClient<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LiftCheck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftCheckFindFirstArgs} args - Arguments to find a LiftCheck
     * @example
     * // Get one LiftCheck
     * const liftCheck = await prisma.liftCheck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LiftCheckFindFirstArgs>(args?: SelectSubset<T, LiftCheckFindFirstArgs<ExtArgs>>): Prisma__LiftCheckClient<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LiftCheck that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftCheckFindFirstOrThrowArgs} args - Arguments to find a LiftCheck
     * @example
     * // Get one LiftCheck
     * const liftCheck = await prisma.liftCheck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LiftCheckFindFirstOrThrowArgs>(args?: SelectSubset<T, LiftCheckFindFirstOrThrowArgs<ExtArgs>>): Prisma__LiftCheckClient<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LiftChecks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftCheckFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LiftChecks
     * const liftChecks = await prisma.liftCheck.findMany()
     * 
     * // Get first 10 LiftChecks
     * const liftChecks = await prisma.liftCheck.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const liftCheckWithIdOnly = await prisma.liftCheck.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LiftCheckFindManyArgs>(args?: SelectSubset<T, LiftCheckFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LiftCheck.
     * @param {LiftCheckCreateArgs} args - Arguments to create a LiftCheck.
     * @example
     * // Create one LiftCheck
     * const LiftCheck = await prisma.liftCheck.create({
     *   data: {
     *     // ... data to create a LiftCheck
     *   }
     * })
     * 
     */
    create<T extends LiftCheckCreateArgs>(args: SelectSubset<T, LiftCheckCreateArgs<ExtArgs>>): Prisma__LiftCheckClient<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LiftChecks.
     * @param {LiftCheckCreateManyArgs} args - Arguments to create many LiftChecks.
     * @example
     * // Create many LiftChecks
     * const liftCheck = await prisma.liftCheck.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LiftCheckCreateManyArgs>(args?: SelectSubset<T, LiftCheckCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LiftChecks and returns the data saved in the database.
     * @param {LiftCheckCreateManyAndReturnArgs} args - Arguments to create many LiftChecks.
     * @example
     * // Create many LiftChecks
     * const liftCheck = await prisma.liftCheck.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LiftChecks and only return the `id`
     * const liftCheckWithIdOnly = await prisma.liftCheck.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LiftCheckCreateManyAndReturnArgs>(args?: SelectSubset<T, LiftCheckCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LiftCheck.
     * @param {LiftCheckDeleteArgs} args - Arguments to delete one LiftCheck.
     * @example
     * // Delete one LiftCheck
     * const LiftCheck = await prisma.liftCheck.delete({
     *   where: {
     *     // ... filter to delete one LiftCheck
     *   }
     * })
     * 
     */
    delete<T extends LiftCheckDeleteArgs>(args: SelectSubset<T, LiftCheckDeleteArgs<ExtArgs>>): Prisma__LiftCheckClient<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LiftCheck.
     * @param {LiftCheckUpdateArgs} args - Arguments to update one LiftCheck.
     * @example
     * // Update one LiftCheck
     * const liftCheck = await prisma.liftCheck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LiftCheckUpdateArgs>(args: SelectSubset<T, LiftCheckUpdateArgs<ExtArgs>>): Prisma__LiftCheckClient<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LiftChecks.
     * @param {LiftCheckDeleteManyArgs} args - Arguments to filter LiftChecks to delete.
     * @example
     * // Delete a few LiftChecks
     * const { count } = await prisma.liftCheck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LiftCheckDeleteManyArgs>(args?: SelectSubset<T, LiftCheckDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiftChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftCheckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LiftChecks
     * const liftCheck = await prisma.liftCheck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LiftCheckUpdateManyArgs>(args: SelectSubset<T, LiftCheckUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiftChecks and returns the data updated in the database.
     * @param {LiftCheckUpdateManyAndReturnArgs} args - Arguments to update many LiftChecks.
     * @example
     * // Update many LiftChecks
     * const liftCheck = await prisma.liftCheck.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LiftChecks and only return the `id`
     * const liftCheckWithIdOnly = await prisma.liftCheck.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LiftCheckUpdateManyAndReturnArgs>(args: SelectSubset<T, LiftCheckUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LiftCheck.
     * @param {LiftCheckUpsertArgs} args - Arguments to update or create a LiftCheck.
     * @example
     * // Update or create a LiftCheck
     * const liftCheck = await prisma.liftCheck.upsert({
     *   create: {
     *     // ... data to create a LiftCheck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LiftCheck we want to update
     *   }
     * })
     */
    upsert<T extends LiftCheckUpsertArgs>(args: SelectSubset<T, LiftCheckUpsertArgs<ExtArgs>>): Prisma__LiftCheckClient<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LiftChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftCheckCountArgs} args - Arguments to filter LiftChecks to count.
     * @example
     * // Count the number of LiftChecks
     * const count = await prisma.liftCheck.count({
     *   where: {
     *     // ... the filter for the LiftChecks we want to count
     *   }
     * })
    **/
    count<T extends LiftCheckCountArgs>(
      args?: Subset<T, LiftCheckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiftCheckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LiftCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftCheckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiftCheckAggregateArgs>(args: Subset<T, LiftCheckAggregateArgs>): Prisma.PrismaPromise<GetLiftCheckAggregateType<T>>

    /**
     * Group by LiftCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftCheckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiftCheckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiftCheckGroupByArgs['orderBy'] }
        : { orderBy?: LiftCheckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiftCheckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiftCheckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LiftCheck model
   */
  readonly fields: LiftCheckFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LiftCheck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LiftCheckClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lift<T extends LiftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LiftDefaultArgs<ExtArgs>>): Prisma__LiftClient<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LiftCheck model
   */
  interface LiftCheckFieldRefs {
    readonly id: FieldRef<"LiftCheck", 'String'>
    readonly recordedAt: FieldRef<"LiftCheck", 'DateTime'>
    readonly employeeId: FieldRef<"LiftCheck", 'String'>
    readonly mountainId: FieldRef<"LiftCheck", 'String'>
    readonly liftId: FieldRef<"LiftCheck", 'String'>
    readonly notes: FieldRef<"LiftCheck", 'String'>
    readonly createdAt: FieldRef<"LiftCheck", 'DateTime'>
    readonly updatedAt: FieldRef<"LiftCheck", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LiftCheck findUnique
   */
  export type LiftCheckFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    /**
     * Filter, which LiftCheck to fetch.
     */
    where: LiftCheckWhereUniqueInput
  }

  /**
   * LiftCheck findUniqueOrThrow
   */
  export type LiftCheckFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    /**
     * Filter, which LiftCheck to fetch.
     */
    where: LiftCheckWhereUniqueInput
  }

  /**
   * LiftCheck findFirst
   */
  export type LiftCheckFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    /**
     * Filter, which LiftCheck to fetch.
     */
    where?: LiftCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiftChecks to fetch.
     */
    orderBy?: LiftCheckOrderByWithRelationInput | LiftCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiftChecks.
     */
    cursor?: LiftCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiftChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiftChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiftChecks.
     */
    distinct?: LiftCheckScalarFieldEnum | LiftCheckScalarFieldEnum[]
  }

  /**
   * LiftCheck findFirstOrThrow
   */
  export type LiftCheckFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    /**
     * Filter, which LiftCheck to fetch.
     */
    where?: LiftCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiftChecks to fetch.
     */
    orderBy?: LiftCheckOrderByWithRelationInput | LiftCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiftChecks.
     */
    cursor?: LiftCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiftChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiftChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiftChecks.
     */
    distinct?: LiftCheckScalarFieldEnum | LiftCheckScalarFieldEnum[]
  }

  /**
   * LiftCheck findMany
   */
  export type LiftCheckFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    /**
     * Filter, which LiftChecks to fetch.
     */
    where?: LiftCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiftChecks to fetch.
     */
    orderBy?: LiftCheckOrderByWithRelationInput | LiftCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LiftChecks.
     */
    cursor?: LiftCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiftChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiftChecks.
     */
    skip?: number
    distinct?: LiftCheckScalarFieldEnum | LiftCheckScalarFieldEnum[]
  }

  /**
   * LiftCheck create
   */
  export type LiftCheckCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    /**
     * The data needed to create a LiftCheck.
     */
    data: XOR<LiftCheckCreateInput, LiftCheckUncheckedCreateInput>
  }

  /**
   * LiftCheck createMany
   */
  export type LiftCheckCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LiftChecks.
     */
    data: LiftCheckCreateManyInput | LiftCheckCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LiftCheck createManyAndReturn
   */
  export type LiftCheckCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * The data used to create many LiftChecks.
     */
    data: LiftCheckCreateManyInput | LiftCheckCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiftCheck update
   */
  export type LiftCheckUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    /**
     * The data needed to update a LiftCheck.
     */
    data: XOR<LiftCheckUpdateInput, LiftCheckUncheckedUpdateInput>
    /**
     * Choose, which LiftCheck to update.
     */
    where: LiftCheckWhereUniqueInput
  }

  /**
   * LiftCheck updateMany
   */
  export type LiftCheckUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LiftChecks.
     */
    data: XOR<LiftCheckUpdateManyMutationInput, LiftCheckUncheckedUpdateManyInput>
    /**
     * Filter which LiftChecks to update
     */
    where?: LiftCheckWhereInput
    /**
     * Limit how many LiftChecks to update.
     */
    limit?: number
  }

  /**
   * LiftCheck updateManyAndReturn
   */
  export type LiftCheckUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * The data used to update LiftChecks.
     */
    data: XOR<LiftCheckUpdateManyMutationInput, LiftCheckUncheckedUpdateManyInput>
    /**
     * Filter which LiftChecks to update
     */
    where?: LiftCheckWhereInput
    /**
     * Limit how many LiftChecks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiftCheck upsert
   */
  export type LiftCheckUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    /**
     * The filter to search for the LiftCheck to update in case it exists.
     */
    where: LiftCheckWhereUniqueInput
    /**
     * In case the LiftCheck found by the `where` argument doesn't exist, create a new LiftCheck with this data.
     */
    create: XOR<LiftCheckCreateInput, LiftCheckUncheckedCreateInput>
    /**
     * In case the LiftCheck was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LiftCheckUpdateInput, LiftCheckUncheckedUpdateInput>
  }

  /**
   * LiftCheck delete
   */
  export type LiftCheckDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    /**
     * Filter which LiftCheck to delete.
     */
    where: LiftCheckWhereUniqueInput
  }

  /**
   * LiftCheck deleteMany
   */
  export type LiftCheckDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiftChecks to delete
     */
    where?: LiftCheckWhereInput
    /**
     * Limit how many LiftChecks to delete.
     */
    limit?: number
  }

  /**
   * LiftCheck without action
   */
  export type LiftCheckDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
  }


  /**
   * Model TrailCheck
   */

  export type AggregateTrailCheck = {
    _count: TrailCheckCountAggregateOutputType | null
    _min: TrailCheckMinAggregateOutputType | null
    _max: TrailCheckMaxAggregateOutputType | null
  }

  export type TrailCheckMinAggregateOutputType = {
    id: string | null
    recordedAt: Date | null
    employeeId: string | null
    mountainId: string | null
    trailId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrailCheckMaxAggregateOutputType = {
    id: string | null
    recordedAt: Date | null
    employeeId: string | null
    mountainId: string | null
    trailId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrailCheckCountAggregateOutputType = {
    id: number
    recordedAt: number
    employeeId: number
    mountainId: number
    trailId: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrailCheckMinAggregateInputType = {
    id?: true
    recordedAt?: true
    employeeId?: true
    mountainId?: true
    trailId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrailCheckMaxAggregateInputType = {
    id?: true
    recordedAt?: true
    employeeId?: true
    mountainId?: true
    trailId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrailCheckCountAggregateInputType = {
    id?: true
    recordedAt?: true
    employeeId?: true
    mountainId?: true
    trailId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrailCheckAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrailCheck to aggregate.
     */
    where?: TrailCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrailChecks to fetch.
     */
    orderBy?: TrailCheckOrderByWithRelationInput | TrailCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrailCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrailChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrailChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrailChecks
    **/
    _count?: true | TrailCheckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrailCheckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrailCheckMaxAggregateInputType
  }

  export type GetTrailCheckAggregateType<T extends TrailCheckAggregateArgs> = {
        [P in keyof T & keyof AggregateTrailCheck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrailCheck[P]>
      : GetScalarType<T[P], AggregateTrailCheck[P]>
  }




  export type TrailCheckGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrailCheckWhereInput
    orderBy?: TrailCheckOrderByWithAggregationInput | TrailCheckOrderByWithAggregationInput[]
    by: TrailCheckScalarFieldEnum[] | TrailCheckScalarFieldEnum
    having?: TrailCheckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrailCheckCountAggregateInputType | true
    _min?: TrailCheckMinAggregateInputType
    _max?: TrailCheckMaxAggregateInputType
  }

  export type TrailCheckGroupByOutputType = {
    id: string
    recordedAt: Date
    employeeId: string
    mountainId: string
    trailId: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: TrailCheckCountAggregateOutputType | null
    _min: TrailCheckMinAggregateOutputType | null
    _max: TrailCheckMaxAggregateOutputType | null
  }

  type GetTrailCheckGroupByPayload<T extends TrailCheckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrailCheckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrailCheckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrailCheckGroupByOutputType[P]>
            : GetScalarType<T[P], TrailCheckGroupByOutputType[P]>
        }
      >
    >


  export type TrailCheckSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recordedAt?: boolean
    employeeId?: boolean
    mountainId?: boolean
    trailId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    trail?: boolean | TrailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trailCheck"]>

  export type TrailCheckSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recordedAt?: boolean
    employeeId?: boolean
    mountainId?: boolean
    trailId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    trail?: boolean | TrailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trailCheck"]>

  export type TrailCheckSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recordedAt?: boolean
    employeeId?: boolean
    mountainId?: boolean
    trailId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    trail?: boolean | TrailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trailCheck"]>

  export type TrailCheckSelectScalar = {
    id?: boolean
    recordedAt?: boolean
    employeeId?: boolean
    mountainId?: boolean
    trailId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrailCheckOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recordedAt" | "employeeId" | "mountainId" | "trailId" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["trailCheck"]>
  export type TrailCheckInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    trail?: boolean | TrailDefaultArgs<ExtArgs>
  }
  export type TrailCheckIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    trail?: boolean | TrailDefaultArgs<ExtArgs>
  }
  export type TrailCheckIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    trail?: boolean | TrailDefaultArgs<ExtArgs>
  }

  export type $TrailCheckPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrailCheck"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      mountain: Prisma.$MountainPayload<ExtArgs>
      trail: Prisma.$TrailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recordedAt: Date
      employeeId: string
      mountainId: string
      trailId: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trailCheck"]>
    composites: {}
  }

  type TrailCheckGetPayload<S extends boolean | null | undefined | TrailCheckDefaultArgs> = $Result.GetResult<Prisma.$TrailCheckPayload, S>

  type TrailCheckCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrailCheckFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrailCheckCountAggregateInputType | true
    }

  export interface TrailCheckDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrailCheck'], meta: { name: 'TrailCheck' } }
    /**
     * Find zero or one TrailCheck that matches the filter.
     * @param {TrailCheckFindUniqueArgs} args - Arguments to find a TrailCheck
     * @example
     * // Get one TrailCheck
     * const trailCheck = await prisma.trailCheck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrailCheckFindUniqueArgs>(args: SelectSubset<T, TrailCheckFindUniqueArgs<ExtArgs>>): Prisma__TrailCheckClient<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrailCheck that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrailCheckFindUniqueOrThrowArgs} args - Arguments to find a TrailCheck
     * @example
     * // Get one TrailCheck
     * const trailCheck = await prisma.trailCheck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrailCheckFindUniqueOrThrowArgs>(args: SelectSubset<T, TrailCheckFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrailCheckClient<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrailCheck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailCheckFindFirstArgs} args - Arguments to find a TrailCheck
     * @example
     * // Get one TrailCheck
     * const trailCheck = await prisma.trailCheck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrailCheckFindFirstArgs>(args?: SelectSubset<T, TrailCheckFindFirstArgs<ExtArgs>>): Prisma__TrailCheckClient<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrailCheck that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailCheckFindFirstOrThrowArgs} args - Arguments to find a TrailCheck
     * @example
     * // Get one TrailCheck
     * const trailCheck = await prisma.trailCheck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrailCheckFindFirstOrThrowArgs>(args?: SelectSubset<T, TrailCheckFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrailCheckClient<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrailChecks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailCheckFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrailChecks
     * const trailChecks = await prisma.trailCheck.findMany()
     * 
     * // Get first 10 TrailChecks
     * const trailChecks = await prisma.trailCheck.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trailCheckWithIdOnly = await prisma.trailCheck.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrailCheckFindManyArgs>(args?: SelectSubset<T, TrailCheckFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrailCheck.
     * @param {TrailCheckCreateArgs} args - Arguments to create a TrailCheck.
     * @example
     * // Create one TrailCheck
     * const TrailCheck = await prisma.trailCheck.create({
     *   data: {
     *     // ... data to create a TrailCheck
     *   }
     * })
     * 
     */
    create<T extends TrailCheckCreateArgs>(args: SelectSubset<T, TrailCheckCreateArgs<ExtArgs>>): Prisma__TrailCheckClient<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrailChecks.
     * @param {TrailCheckCreateManyArgs} args - Arguments to create many TrailChecks.
     * @example
     * // Create many TrailChecks
     * const trailCheck = await prisma.trailCheck.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrailCheckCreateManyArgs>(args?: SelectSubset<T, TrailCheckCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrailChecks and returns the data saved in the database.
     * @param {TrailCheckCreateManyAndReturnArgs} args - Arguments to create many TrailChecks.
     * @example
     * // Create many TrailChecks
     * const trailCheck = await prisma.trailCheck.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrailChecks and only return the `id`
     * const trailCheckWithIdOnly = await prisma.trailCheck.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrailCheckCreateManyAndReturnArgs>(args?: SelectSubset<T, TrailCheckCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrailCheck.
     * @param {TrailCheckDeleteArgs} args - Arguments to delete one TrailCheck.
     * @example
     * // Delete one TrailCheck
     * const TrailCheck = await prisma.trailCheck.delete({
     *   where: {
     *     // ... filter to delete one TrailCheck
     *   }
     * })
     * 
     */
    delete<T extends TrailCheckDeleteArgs>(args: SelectSubset<T, TrailCheckDeleteArgs<ExtArgs>>): Prisma__TrailCheckClient<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrailCheck.
     * @param {TrailCheckUpdateArgs} args - Arguments to update one TrailCheck.
     * @example
     * // Update one TrailCheck
     * const trailCheck = await prisma.trailCheck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrailCheckUpdateArgs>(args: SelectSubset<T, TrailCheckUpdateArgs<ExtArgs>>): Prisma__TrailCheckClient<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrailChecks.
     * @param {TrailCheckDeleteManyArgs} args - Arguments to filter TrailChecks to delete.
     * @example
     * // Delete a few TrailChecks
     * const { count } = await prisma.trailCheck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrailCheckDeleteManyArgs>(args?: SelectSubset<T, TrailCheckDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrailChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailCheckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrailChecks
     * const trailCheck = await prisma.trailCheck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrailCheckUpdateManyArgs>(args: SelectSubset<T, TrailCheckUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrailChecks and returns the data updated in the database.
     * @param {TrailCheckUpdateManyAndReturnArgs} args - Arguments to update many TrailChecks.
     * @example
     * // Update many TrailChecks
     * const trailCheck = await prisma.trailCheck.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrailChecks and only return the `id`
     * const trailCheckWithIdOnly = await prisma.trailCheck.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrailCheckUpdateManyAndReturnArgs>(args: SelectSubset<T, TrailCheckUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrailCheck.
     * @param {TrailCheckUpsertArgs} args - Arguments to update or create a TrailCheck.
     * @example
     * // Update or create a TrailCheck
     * const trailCheck = await prisma.trailCheck.upsert({
     *   create: {
     *     // ... data to create a TrailCheck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrailCheck we want to update
     *   }
     * })
     */
    upsert<T extends TrailCheckUpsertArgs>(args: SelectSubset<T, TrailCheckUpsertArgs<ExtArgs>>): Prisma__TrailCheckClient<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrailChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailCheckCountArgs} args - Arguments to filter TrailChecks to count.
     * @example
     * // Count the number of TrailChecks
     * const count = await prisma.trailCheck.count({
     *   where: {
     *     // ... the filter for the TrailChecks we want to count
     *   }
     * })
    **/
    count<T extends TrailCheckCountArgs>(
      args?: Subset<T, TrailCheckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrailCheckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrailCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailCheckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrailCheckAggregateArgs>(args: Subset<T, TrailCheckAggregateArgs>): Prisma.PrismaPromise<GetTrailCheckAggregateType<T>>

    /**
     * Group by TrailCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailCheckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrailCheckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrailCheckGroupByArgs['orderBy'] }
        : { orderBy?: TrailCheckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrailCheckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrailCheckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrailCheck model
   */
  readonly fields: TrailCheckFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrailCheck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrailCheckClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    trail<T extends TrailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrailDefaultArgs<ExtArgs>>): Prisma__TrailClient<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrailCheck model
   */
  interface TrailCheckFieldRefs {
    readonly id: FieldRef<"TrailCheck", 'String'>
    readonly recordedAt: FieldRef<"TrailCheck", 'DateTime'>
    readonly employeeId: FieldRef<"TrailCheck", 'String'>
    readonly mountainId: FieldRef<"TrailCheck", 'String'>
    readonly trailId: FieldRef<"TrailCheck", 'String'>
    readonly notes: FieldRef<"TrailCheck", 'String'>
    readonly createdAt: FieldRef<"TrailCheck", 'DateTime'>
    readonly updatedAt: FieldRef<"TrailCheck", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrailCheck findUnique
   */
  export type TrailCheckFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    /**
     * Filter, which TrailCheck to fetch.
     */
    where: TrailCheckWhereUniqueInput
  }

  /**
   * TrailCheck findUniqueOrThrow
   */
  export type TrailCheckFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    /**
     * Filter, which TrailCheck to fetch.
     */
    where: TrailCheckWhereUniqueInput
  }

  /**
   * TrailCheck findFirst
   */
  export type TrailCheckFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    /**
     * Filter, which TrailCheck to fetch.
     */
    where?: TrailCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrailChecks to fetch.
     */
    orderBy?: TrailCheckOrderByWithRelationInput | TrailCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrailChecks.
     */
    cursor?: TrailCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrailChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrailChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrailChecks.
     */
    distinct?: TrailCheckScalarFieldEnum | TrailCheckScalarFieldEnum[]
  }

  /**
   * TrailCheck findFirstOrThrow
   */
  export type TrailCheckFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    /**
     * Filter, which TrailCheck to fetch.
     */
    where?: TrailCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrailChecks to fetch.
     */
    orderBy?: TrailCheckOrderByWithRelationInput | TrailCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrailChecks.
     */
    cursor?: TrailCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrailChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrailChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrailChecks.
     */
    distinct?: TrailCheckScalarFieldEnum | TrailCheckScalarFieldEnum[]
  }

  /**
   * TrailCheck findMany
   */
  export type TrailCheckFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    /**
     * Filter, which TrailChecks to fetch.
     */
    where?: TrailCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrailChecks to fetch.
     */
    orderBy?: TrailCheckOrderByWithRelationInput | TrailCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrailChecks.
     */
    cursor?: TrailCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrailChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrailChecks.
     */
    skip?: number
    distinct?: TrailCheckScalarFieldEnum | TrailCheckScalarFieldEnum[]
  }

  /**
   * TrailCheck create
   */
  export type TrailCheckCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    /**
     * The data needed to create a TrailCheck.
     */
    data: XOR<TrailCheckCreateInput, TrailCheckUncheckedCreateInput>
  }

  /**
   * TrailCheck createMany
   */
  export type TrailCheckCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrailChecks.
     */
    data: TrailCheckCreateManyInput | TrailCheckCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrailCheck createManyAndReturn
   */
  export type TrailCheckCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * The data used to create many TrailChecks.
     */
    data: TrailCheckCreateManyInput | TrailCheckCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrailCheck update
   */
  export type TrailCheckUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    /**
     * The data needed to update a TrailCheck.
     */
    data: XOR<TrailCheckUpdateInput, TrailCheckUncheckedUpdateInput>
    /**
     * Choose, which TrailCheck to update.
     */
    where: TrailCheckWhereUniqueInput
  }

  /**
   * TrailCheck updateMany
   */
  export type TrailCheckUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrailChecks.
     */
    data: XOR<TrailCheckUpdateManyMutationInput, TrailCheckUncheckedUpdateManyInput>
    /**
     * Filter which TrailChecks to update
     */
    where?: TrailCheckWhereInput
    /**
     * Limit how many TrailChecks to update.
     */
    limit?: number
  }

  /**
   * TrailCheck updateManyAndReturn
   */
  export type TrailCheckUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * The data used to update TrailChecks.
     */
    data: XOR<TrailCheckUpdateManyMutationInput, TrailCheckUncheckedUpdateManyInput>
    /**
     * Filter which TrailChecks to update
     */
    where?: TrailCheckWhereInput
    /**
     * Limit how many TrailChecks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrailCheck upsert
   */
  export type TrailCheckUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    /**
     * The filter to search for the TrailCheck to update in case it exists.
     */
    where: TrailCheckWhereUniqueInput
    /**
     * In case the TrailCheck found by the `where` argument doesn't exist, create a new TrailCheck with this data.
     */
    create: XOR<TrailCheckCreateInput, TrailCheckUncheckedCreateInput>
    /**
     * In case the TrailCheck was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrailCheckUpdateInput, TrailCheckUncheckedUpdateInput>
  }

  /**
   * TrailCheck delete
   */
  export type TrailCheckDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    /**
     * Filter which TrailCheck to delete.
     */
    where: TrailCheckWhereUniqueInput
  }

  /**
   * TrailCheck deleteMany
   */
  export type TrailCheckDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrailChecks to delete
     */
    where?: TrailCheckWhereInput
    /**
     * Limit how many TrailChecks to delete.
     */
    limit?: number
  }

  /**
   * TrailCheck without action
   */
  export type TrailCheckDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
  }


  /**
   * Model HutCheck
   */

  export type AggregateHutCheck = {
    _count: HutCheckCountAggregateOutputType | null
    _min: HutCheckMinAggregateOutputType | null
    _max: HutCheckMaxAggregateOutputType | null
  }

  export type HutCheckMinAggregateOutputType = {
    id: string | null
    recordedAt: Date | null
    employeeId: string | null
    mountainId: string | null
    hutId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HutCheckMaxAggregateOutputType = {
    id: string | null
    recordedAt: Date | null
    employeeId: string | null
    mountainId: string | null
    hutId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HutCheckCountAggregateOutputType = {
    id: number
    recordedAt: number
    employeeId: number
    mountainId: number
    hutId: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HutCheckMinAggregateInputType = {
    id?: true
    recordedAt?: true
    employeeId?: true
    mountainId?: true
    hutId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HutCheckMaxAggregateInputType = {
    id?: true
    recordedAt?: true
    employeeId?: true
    mountainId?: true
    hutId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HutCheckCountAggregateInputType = {
    id?: true
    recordedAt?: true
    employeeId?: true
    mountainId?: true
    hutId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HutCheckAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HutCheck to aggregate.
     */
    where?: HutCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HutChecks to fetch.
     */
    orderBy?: HutCheckOrderByWithRelationInput | HutCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HutCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HutChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HutChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HutChecks
    **/
    _count?: true | HutCheckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HutCheckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HutCheckMaxAggregateInputType
  }

  export type GetHutCheckAggregateType<T extends HutCheckAggregateArgs> = {
        [P in keyof T & keyof AggregateHutCheck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHutCheck[P]>
      : GetScalarType<T[P], AggregateHutCheck[P]>
  }




  export type HutCheckGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HutCheckWhereInput
    orderBy?: HutCheckOrderByWithAggregationInput | HutCheckOrderByWithAggregationInput[]
    by: HutCheckScalarFieldEnum[] | HutCheckScalarFieldEnum
    having?: HutCheckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HutCheckCountAggregateInputType | true
    _min?: HutCheckMinAggregateInputType
    _max?: HutCheckMaxAggregateInputType
  }

  export type HutCheckGroupByOutputType = {
    id: string
    recordedAt: Date
    employeeId: string
    mountainId: string
    hutId: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: HutCheckCountAggregateOutputType | null
    _min: HutCheckMinAggregateOutputType | null
    _max: HutCheckMaxAggregateOutputType | null
  }

  type GetHutCheckGroupByPayload<T extends HutCheckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HutCheckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HutCheckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HutCheckGroupByOutputType[P]>
            : GetScalarType<T[P], HutCheckGroupByOutputType[P]>
        }
      >
    >


  export type HutCheckSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recordedAt?: boolean
    employeeId?: boolean
    mountainId?: boolean
    hutId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    hut?: boolean | HutDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hutCheck"]>

  export type HutCheckSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recordedAt?: boolean
    employeeId?: boolean
    mountainId?: boolean
    hutId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    hut?: boolean | HutDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hutCheck"]>

  export type HutCheckSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recordedAt?: boolean
    employeeId?: boolean
    mountainId?: boolean
    hutId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    hut?: boolean | HutDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hutCheck"]>

  export type HutCheckSelectScalar = {
    id?: boolean
    recordedAt?: boolean
    employeeId?: boolean
    mountainId?: boolean
    hutId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HutCheckOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recordedAt" | "employeeId" | "mountainId" | "hutId" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["hutCheck"]>
  export type HutCheckInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    hut?: boolean | HutDefaultArgs<ExtArgs>
  }
  export type HutCheckIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    hut?: boolean | HutDefaultArgs<ExtArgs>
  }
  export type HutCheckIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    hut?: boolean | HutDefaultArgs<ExtArgs>
  }

  export type $HutCheckPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HutCheck"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      mountain: Prisma.$MountainPayload<ExtArgs>
      hut: Prisma.$HutPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recordedAt: Date
      employeeId: string
      mountainId: string
      hutId: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hutCheck"]>
    composites: {}
  }

  type HutCheckGetPayload<S extends boolean | null | undefined | HutCheckDefaultArgs> = $Result.GetResult<Prisma.$HutCheckPayload, S>

  type HutCheckCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HutCheckFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HutCheckCountAggregateInputType | true
    }

  export interface HutCheckDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HutCheck'], meta: { name: 'HutCheck' } }
    /**
     * Find zero or one HutCheck that matches the filter.
     * @param {HutCheckFindUniqueArgs} args - Arguments to find a HutCheck
     * @example
     * // Get one HutCheck
     * const hutCheck = await prisma.hutCheck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HutCheckFindUniqueArgs>(args: SelectSubset<T, HutCheckFindUniqueArgs<ExtArgs>>): Prisma__HutCheckClient<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HutCheck that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HutCheckFindUniqueOrThrowArgs} args - Arguments to find a HutCheck
     * @example
     * // Get one HutCheck
     * const hutCheck = await prisma.hutCheck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HutCheckFindUniqueOrThrowArgs>(args: SelectSubset<T, HutCheckFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HutCheckClient<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HutCheck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutCheckFindFirstArgs} args - Arguments to find a HutCheck
     * @example
     * // Get one HutCheck
     * const hutCheck = await prisma.hutCheck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HutCheckFindFirstArgs>(args?: SelectSubset<T, HutCheckFindFirstArgs<ExtArgs>>): Prisma__HutCheckClient<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HutCheck that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutCheckFindFirstOrThrowArgs} args - Arguments to find a HutCheck
     * @example
     * // Get one HutCheck
     * const hutCheck = await prisma.hutCheck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HutCheckFindFirstOrThrowArgs>(args?: SelectSubset<T, HutCheckFindFirstOrThrowArgs<ExtArgs>>): Prisma__HutCheckClient<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HutChecks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutCheckFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HutChecks
     * const hutChecks = await prisma.hutCheck.findMany()
     * 
     * // Get first 10 HutChecks
     * const hutChecks = await prisma.hutCheck.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hutCheckWithIdOnly = await prisma.hutCheck.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HutCheckFindManyArgs>(args?: SelectSubset<T, HutCheckFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HutCheck.
     * @param {HutCheckCreateArgs} args - Arguments to create a HutCheck.
     * @example
     * // Create one HutCheck
     * const HutCheck = await prisma.hutCheck.create({
     *   data: {
     *     // ... data to create a HutCheck
     *   }
     * })
     * 
     */
    create<T extends HutCheckCreateArgs>(args: SelectSubset<T, HutCheckCreateArgs<ExtArgs>>): Prisma__HutCheckClient<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HutChecks.
     * @param {HutCheckCreateManyArgs} args - Arguments to create many HutChecks.
     * @example
     * // Create many HutChecks
     * const hutCheck = await prisma.hutCheck.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HutCheckCreateManyArgs>(args?: SelectSubset<T, HutCheckCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HutChecks and returns the data saved in the database.
     * @param {HutCheckCreateManyAndReturnArgs} args - Arguments to create many HutChecks.
     * @example
     * // Create many HutChecks
     * const hutCheck = await prisma.hutCheck.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HutChecks and only return the `id`
     * const hutCheckWithIdOnly = await prisma.hutCheck.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HutCheckCreateManyAndReturnArgs>(args?: SelectSubset<T, HutCheckCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HutCheck.
     * @param {HutCheckDeleteArgs} args - Arguments to delete one HutCheck.
     * @example
     * // Delete one HutCheck
     * const HutCheck = await prisma.hutCheck.delete({
     *   where: {
     *     // ... filter to delete one HutCheck
     *   }
     * })
     * 
     */
    delete<T extends HutCheckDeleteArgs>(args: SelectSubset<T, HutCheckDeleteArgs<ExtArgs>>): Prisma__HutCheckClient<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HutCheck.
     * @param {HutCheckUpdateArgs} args - Arguments to update one HutCheck.
     * @example
     * // Update one HutCheck
     * const hutCheck = await prisma.hutCheck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HutCheckUpdateArgs>(args: SelectSubset<T, HutCheckUpdateArgs<ExtArgs>>): Prisma__HutCheckClient<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HutChecks.
     * @param {HutCheckDeleteManyArgs} args - Arguments to filter HutChecks to delete.
     * @example
     * // Delete a few HutChecks
     * const { count } = await prisma.hutCheck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HutCheckDeleteManyArgs>(args?: SelectSubset<T, HutCheckDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HutChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutCheckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HutChecks
     * const hutCheck = await prisma.hutCheck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HutCheckUpdateManyArgs>(args: SelectSubset<T, HutCheckUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HutChecks and returns the data updated in the database.
     * @param {HutCheckUpdateManyAndReturnArgs} args - Arguments to update many HutChecks.
     * @example
     * // Update many HutChecks
     * const hutCheck = await prisma.hutCheck.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HutChecks and only return the `id`
     * const hutCheckWithIdOnly = await prisma.hutCheck.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HutCheckUpdateManyAndReturnArgs>(args: SelectSubset<T, HutCheckUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HutCheck.
     * @param {HutCheckUpsertArgs} args - Arguments to update or create a HutCheck.
     * @example
     * // Update or create a HutCheck
     * const hutCheck = await prisma.hutCheck.upsert({
     *   create: {
     *     // ... data to create a HutCheck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HutCheck we want to update
     *   }
     * })
     */
    upsert<T extends HutCheckUpsertArgs>(args: SelectSubset<T, HutCheckUpsertArgs<ExtArgs>>): Prisma__HutCheckClient<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HutChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutCheckCountArgs} args - Arguments to filter HutChecks to count.
     * @example
     * // Count the number of HutChecks
     * const count = await prisma.hutCheck.count({
     *   where: {
     *     // ... the filter for the HutChecks we want to count
     *   }
     * })
    **/
    count<T extends HutCheckCountArgs>(
      args?: Subset<T, HutCheckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HutCheckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HutCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutCheckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HutCheckAggregateArgs>(args: Subset<T, HutCheckAggregateArgs>): Prisma.PrismaPromise<GetHutCheckAggregateType<T>>

    /**
     * Group by HutCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutCheckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HutCheckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HutCheckGroupByArgs['orderBy'] }
        : { orderBy?: HutCheckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HutCheckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHutCheckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HutCheck model
   */
  readonly fields: HutCheckFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HutCheck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HutCheckClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    hut<T extends HutDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HutDefaultArgs<ExtArgs>>): Prisma__HutClient<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HutCheck model
   */
  interface HutCheckFieldRefs {
    readonly id: FieldRef<"HutCheck", 'String'>
    readonly recordedAt: FieldRef<"HutCheck", 'DateTime'>
    readonly employeeId: FieldRef<"HutCheck", 'String'>
    readonly mountainId: FieldRef<"HutCheck", 'String'>
    readonly hutId: FieldRef<"HutCheck", 'String'>
    readonly notes: FieldRef<"HutCheck", 'String'>
    readonly createdAt: FieldRef<"HutCheck", 'DateTime'>
    readonly updatedAt: FieldRef<"HutCheck", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HutCheck findUnique
   */
  export type HutCheckFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    /**
     * Filter, which HutCheck to fetch.
     */
    where: HutCheckWhereUniqueInput
  }

  /**
   * HutCheck findUniqueOrThrow
   */
  export type HutCheckFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    /**
     * Filter, which HutCheck to fetch.
     */
    where: HutCheckWhereUniqueInput
  }

  /**
   * HutCheck findFirst
   */
  export type HutCheckFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    /**
     * Filter, which HutCheck to fetch.
     */
    where?: HutCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HutChecks to fetch.
     */
    orderBy?: HutCheckOrderByWithRelationInput | HutCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HutChecks.
     */
    cursor?: HutCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HutChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HutChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HutChecks.
     */
    distinct?: HutCheckScalarFieldEnum | HutCheckScalarFieldEnum[]
  }

  /**
   * HutCheck findFirstOrThrow
   */
  export type HutCheckFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    /**
     * Filter, which HutCheck to fetch.
     */
    where?: HutCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HutChecks to fetch.
     */
    orderBy?: HutCheckOrderByWithRelationInput | HutCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HutChecks.
     */
    cursor?: HutCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HutChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HutChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HutChecks.
     */
    distinct?: HutCheckScalarFieldEnum | HutCheckScalarFieldEnum[]
  }

  /**
   * HutCheck findMany
   */
  export type HutCheckFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    /**
     * Filter, which HutChecks to fetch.
     */
    where?: HutCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HutChecks to fetch.
     */
    orderBy?: HutCheckOrderByWithRelationInput | HutCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HutChecks.
     */
    cursor?: HutCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HutChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HutChecks.
     */
    skip?: number
    distinct?: HutCheckScalarFieldEnum | HutCheckScalarFieldEnum[]
  }

  /**
   * HutCheck create
   */
  export type HutCheckCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    /**
     * The data needed to create a HutCheck.
     */
    data: XOR<HutCheckCreateInput, HutCheckUncheckedCreateInput>
  }

  /**
   * HutCheck createMany
   */
  export type HutCheckCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HutChecks.
     */
    data: HutCheckCreateManyInput | HutCheckCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HutCheck createManyAndReturn
   */
  export type HutCheckCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * The data used to create many HutChecks.
     */
    data: HutCheckCreateManyInput | HutCheckCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HutCheck update
   */
  export type HutCheckUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    /**
     * The data needed to update a HutCheck.
     */
    data: XOR<HutCheckUpdateInput, HutCheckUncheckedUpdateInput>
    /**
     * Choose, which HutCheck to update.
     */
    where: HutCheckWhereUniqueInput
  }

  /**
   * HutCheck updateMany
   */
  export type HutCheckUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HutChecks.
     */
    data: XOR<HutCheckUpdateManyMutationInput, HutCheckUncheckedUpdateManyInput>
    /**
     * Filter which HutChecks to update
     */
    where?: HutCheckWhereInput
    /**
     * Limit how many HutChecks to update.
     */
    limit?: number
  }

  /**
   * HutCheck updateManyAndReturn
   */
  export type HutCheckUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * The data used to update HutChecks.
     */
    data: XOR<HutCheckUpdateManyMutationInput, HutCheckUncheckedUpdateManyInput>
    /**
     * Filter which HutChecks to update
     */
    where?: HutCheckWhereInput
    /**
     * Limit how many HutChecks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HutCheck upsert
   */
  export type HutCheckUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    /**
     * The filter to search for the HutCheck to update in case it exists.
     */
    where: HutCheckWhereUniqueInput
    /**
     * In case the HutCheck found by the `where` argument doesn't exist, create a new HutCheck with this data.
     */
    create: XOR<HutCheckCreateInput, HutCheckUncheckedCreateInput>
    /**
     * In case the HutCheck was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HutCheckUpdateInput, HutCheckUncheckedUpdateInput>
  }

  /**
   * HutCheck delete
   */
  export type HutCheckDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    /**
     * Filter which HutCheck to delete.
     */
    where: HutCheckWhereUniqueInput
  }

  /**
   * HutCheck deleteMany
   */
  export type HutCheckDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HutChecks to delete
     */
    where?: HutCheckWhereInput
    /**
     * Limit how many HutChecks to delete.
     */
    limit?: number
  }

  /**
   * HutCheck without action
   */
  export type HutCheckDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
  }


  /**
   * Model AidRoomCheck
   */

  export type AggregateAidRoomCheck = {
    _count: AidRoomCheckCountAggregateOutputType | null
    _min: AidRoomCheckMinAggregateOutputType | null
    _max: AidRoomCheckMaxAggregateOutputType | null
  }

  export type AidRoomCheckMinAggregateOutputType = {
    id: string | null
    recordedAt: Date | null
    employeeId: string | null
    mountainId: string | null
    aidRoomId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AidRoomCheckMaxAggregateOutputType = {
    id: string | null
    recordedAt: Date | null
    employeeId: string | null
    mountainId: string | null
    aidRoomId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AidRoomCheckCountAggregateOutputType = {
    id: number
    recordedAt: number
    employeeId: number
    mountainId: number
    aidRoomId: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AidRoomCheckMinAggregateInputType = {
    id?: true
    recordedAt?: true
    employeeId?: true
    mountainId?: true
    aidRoomId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AidRoomCheckMaxAggregateInputType = {
    id?: true
    recordedAt?: true
    employeeId?: true
    mountainId?: true
    aidRoomId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AidRoomCheckCountAggregateInputType = {
    id?: true
    recordedAt?: true
    employeeId?: true
    mountainId?: true
    aidRoomId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AidRoomCheckAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AidRoomCheck to aggregate.
     */
    where?: AidRoomCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AidRoomChecks to fetch.
     */
    orderBy?: AidRoomCheckOrderByWithRelationInput | AidRoomCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AidRoomCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AidRoomChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AidRoomChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AidRoomChecks
    **/
    _count?: true | AidRoomCheckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AidRoomCheckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AidRoomCheckMaxAggregateInputType
  }

  export type GetAidRoomCheckAggregateType<T extends AidRoomCheckAggregateArgs> = {
        [P in keyof T & keyof AggregateAidRoomCheck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAidRoomCheck[P]>
      : GetScalarType<T[P], AggregateAidRoomCheck[P]>
  }




  export type AidRoomCheckGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AidRoomCheckWhereInput
    orderBy?: AidRoomCheckOrderByWithAggregationInput | AidRoomCheckOrderByWithAggregationInput[]
    by: AidRoomCheckScalarFieldEnum[] | AidRoomCheckScalarFieldEnum
    having?: AidRoomCheckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AidRoomCheckCountAggregateInputType | true
    _min?: AidRoomCheckMinAggregateInputType
    _max?: AidRoomCheckMaxAggregateInputType
  }

  export type AidRoomCheckGroupByOutputType = {
    id: string
    recordedAt: Date
    employeeId: string
    mountainId: string
    aidRoomId: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: AidRoomCheckCountAggregateOutputType | null
    _min: AidRoomCheckMinAggregateOutputType | null
    _max: AidRoomCheckMaxAggregateOutputType | null
  }

  type GetAidRoomCheckGroupByPayload<T extends AidRoomCheckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AidRoomCheckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AidRoomCheckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AidRoomCheckGroupByOutputType[P]>
            : GetScalarType<T[P], AidRoomCheckGroupByOutputType[P]>
        }
      >
    >


  export type AidRoomCheckSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recordedAt?: boolean
    employeeId?: boolean
    mountainId?: boolean
    aidRoomId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    aidRoom?: boolean | AidRoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aidRoomCheck"]>

  export type AidRoomCheckSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recordedAt?: boolean
    employeeId?: boolean
    mountainId?: boolean
    aidRoomId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    aidRoom?: boolean | AidRoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aidRoomCheck"]>

  export type AidRoomCheckSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recordedAt?: boolean
    employeeId?: boolean
    mountainId?: boolean
    aidRoomId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    aidRoom?: boolean | AidRoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aidRoomCheck"]>

  export type AidRoomCheckSelectScalar = {
    id?: boolean
    recordedAt?: boolean
    employeeId?: boolean
    mountainId?: boolean
    aidRoomId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AidRoomCheckOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recordedAt" | "employeeId" | "mountainId" | "aidRoomId" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["aidRoomCheck"]>
  export type AidRoomCheckInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    aidRoom?: boolean | AidRoomDefaultArgs<ExtArgs>
  }
  export type AidRoomCheckIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    aidRoom?: boolean | AidRoomDefaultArgs<ExtArgs>
  }
  export type AidRoomCheckIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    aidRoom?: boolean | AidRoomDefaultArgs<ExtArgs>
  }

  export type $AidRoomCheckPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AidRoomCheck"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      mountain: Prisma.$MountainPayload<ExtArgs>
      aidRoom: Prisma.$AidRoomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recordedAt: Date
      employeeId: string
      mountainId: string
      aidRoomId: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aidRoomCheck"]>
    composites: {}
  }

  type AidRoomCheckGetPayload<S extends boolean | null | undefined | AidRoomCheckDefaultArgs> = $Result.GetResult<Prisma.$AidRoomCheckPayload, S>

  type AidRoomCheckCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AidRoomCheckFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AidRoomCheckCountAggregateInputType | true
    }

  export interface AidRoomCheckDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AidRoomCheck'], meta: { name: 'AidRoomCheck' } }
    /**
     * Find zero or one AidRoomCheck that matches the filter.
     * @param {AidRoomCheckFindUniqueArgs} args - Arguments to find a AidRoomCheck
     * @example
     * // Get one AidRoomCheck
     * const aidRoomCheck = await prisma.aidRoomCheck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AidRoomCheckFindUniqueArgs>(args: SelectSubset<T, AidRoomCheckFindUniqueArgs<ExtArgs>>): Prisma__AidRoomCheckClient<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AidRoomCheck that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AidRoomCheckFindUniqueOrThrowArgs} args - Arguments to find a AidRoomCheck
     * @example
     * // Get one AidRoomCheck
     * const aidRoomCheck = await prisma.aidRoomCheck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AidRoomCheckFindUniqueOrThrowArgs>(args: SelectSubset<T, AidRoomCheckFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AidRoomCheckClient<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AidRoomCheck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomCheckFindFirstArgs} args - Arguments to find a AidRoomCheck
     * @example
     * // Get one AidRoomCheck
     * const aidRoomCheck = await prisma.aidRoomCheck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AidRoomCheckFindFirstArgs>(args?: SelectSubset<T, AidRoomCheckFindFirstArgs<ExtArgs>>): Prisma__AidRoomCheckClient<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AidRoomCheck that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomCheckFindFirstOrThrowArgs} args - Arguments to find a AidRoomCheck
     * @example
     * // Get one AidRoomCheck
     * const aidRoomCheck = await prisma.aidRoomCheck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AidRoomCheckFindFirstOrThrowArgs>(args?: SelectSubset<T, AidRoomCheckFindFirstOrThrowArgs<ExtArgs>>): Prisma__AidRoomCheckClient<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AidRoomChecks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomCheckFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AidRoomChecks
     * const aidRoomChecks = await prisma.aidRoomCheck.findMany()
     * 
     * // Get first 10 AidRoomChecks
     * const aidRoomChecks = await prisma.aidRoomCheck.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aidRoomCheckWithIdOnly = await prisma.aidRoomCheck.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AidRoomCheckFindManyArgs>(args?: SelectSubset<T, AidRoomCheckFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AidRoomCheck.
     * @param {AidRoomCheckCreateArgs} args - Arguments to create a AidRoomCheck.
     * @example
     * // Create one AidRoomCheck
     * const AidRoomCheck = await prisma.aidRoomCheck.create({
     *   data: {
     *     // ... data to create a AidRoomCheck
     *   }
     * })
     * 
     */
    create<T extends AidRoomCheckCreateArgs>(args: SelectSubset<T, AidRoomCheckCreateArgs<ExtArgs>>): Prisma__AidRoomCheckClient<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AidRoomChecks.
     * @param {AidRoomCheckCreateManyArgs} args - Arguments to create many AidRoomChecks.
     * @example
     * // Create many AidRoomChecks
     * const aidRoomCheck = await prisma.aidRoomCheck.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AidRoomCheckCreateManyArgs>(args?: SelectSubset<T, AidRoomCheckCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AidRoomChecks and returns the data saved in the database.
     * @param {AidRoomCheckCreateManyAndReturnArgs} args - Arguments to create many AidRoomChecks.
     * @example
     * // Create many AidRoomChecks
     * const aidRoomCheck = await prisma.aidRoomCheck.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AidRoomChecks and only return the `id`
     * const aidRoomCheckWithIdOnly = await prisma.aidRoomCheck.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AidRoomCheckCreateManyAndReturnArgs>(args?: SelectSubset<T, AidRoomCheckCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AidRoomCheck.
     * @param {AidRoomCheckDeleteArgs} args - Arguments to delete one AidRoomCheck.
     * @example
     * // Delete one AidRoomCheck
     * const AidRoomCheck = await prisma.aidRoomCheck.delete({
     *   where: {
     *     // ... filter to delete one AidRoomCheck
     *   }
     * })
     * 
     */
    delete<T extends AidRoomCheckDeleteArgs>(args: SelectSubset<T, AidRoomCheckDeleteArgs<ExtArgs>>): Prisma__AidRoomCheckClient<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AidRoomCheck.
     * @param {AidRoomCheckUpdateArgs} args - Arguments to update one AidRoomCheck.
     * @example
     * // Update one AidRoomCheck
     * const aidRoomCheck = await prisma.aidRoomCheck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AidRoomCheckUpdateArgs>(args: SelectSubset<T, AidRoomCheckUpdateArgs<ExtArgs>>): Prisma__AidRoomCheckClient<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AidRoomChecks.
     * @param {AidRoomCheckDeleteManyArgs} args - Arguments to filter AidRoomChecks to delete.
     * @example
     * // Delete a few AidRoomChecks
     * const { count } = await prisma.aidRoomCheck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AidRoomCheckDeleteManyArgs>(args?: SelectSubset<T, AidRoomCheckDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AidRoomChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomCheckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AidRoomChecks
     * const aidRoomCheck = await prisma.aidRoomCheck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AidRoomCheckUpdateManyArgs>(args: SelectSubset<T, AidRoomCheckUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AidRoomChecks and returns the data updated in the database.
     * @param {AidRoomCheckUpdateManyAndReturnArgs} args - Arguments to update many AidRoomChecks.
     * @example
     * // Update many AidRoomChecks
     * const aidRoomCheck = await prisma.aidRoomCheck.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AidRoomChecks and only return the `id`
     * const aidRoomCheckWithIdOnly = await prisma.aidRoomCheck.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AidRoomCheckUpdateManyAndReturnArgs>(args: SelectSubset<T, AidRoomCheckUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AidRoomCheck.
     * @param {AidRoomCheckUpsertArgs} args - Arguments to update or create a AidRoomCheck.
     * @example
     * // Update or create a AidRoomCheck
     * const aidRoomCheck = await prisma.aidRoomCheck.upsert({
     *   create: {
     *     // ... data to create a AidRoomCheck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AidRoomCheck we want to update
     *   }
     * })
     */
    upsert<T extends AidRoomCheckUpsertArgs>(args: SelectSubset<T, AidRoomCheckUpsertArgs<ExtArgs>>): Prisma__AidRoomCheckClient<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AidRoomChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomCheckCountArgs} args - Arguments to filter AidRoomChecks to count.
     * @example
     * // Count the number of AidRoomChecks
     * const count = await prisma.aidRoomCheck.count({
     *   where: {
     *     // ... the filter for the AidRoomChecks we want to count
     *   }
     * })
    **/
    count<T extends AidRoomCheckCountArgs>(
      args?: Subset<T, AidRoomCheckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AidRoomCheckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AidRoomCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomCheckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AidRoomCheckAggregateArgs>(args: Subset<T, AidRoomCheckAggregateArgs>): Prisma.PrismaPromise<GetAidRoomCheckAggregateType<T>>

    /**
     * Group by AidRoomCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomCheckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AidRoomCheckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AidRoomCheckGroupByArgs['orderBy'] }
        : { orderBy?: AidRoomCheckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AidRoomCheckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAidRoomCheckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AidRoomCheck model
   */
  readonly fields: AidRoomCheckFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AidRoomCheck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AidRoomCheckClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    aidRoom<T extends AidRoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AidRoomDefaultArgs<ExtArgs>>): Prisma__AidRoomClient<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AidRoomCheck model
   */
  interface AidRoomCheckFieldRefs {
    readonly id: FieldRef<"AidRoomCheck", 'String'>
    readonly recordedAt: FieldRef<"AidRoomCheck", 'DateTime'>
    readonly employeeId: FieldRef<"AidRoomCheck", 'String'>
    readonly mountainId: FieldRef<"AidRoomCheck", 'String'>
    readonly aidRoomId: FieldRef<"AidRoomCheck", 'String'>
    readonly notes: FieldRef<"AidRoomCheck", 'String'>
    readonly createdAt: FieldRef<"AidRoomCheck", 'DateTime'>
    readonly updatedAt: FieldRef<"AidRoomCheck", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AidRoomCheck findUnique
   */
  export type AidRoomCheckFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    /**
     * Filter, which AidRoomCheck to fetch.
     */
    where: AidRoomCheckWhereUniqueInput
  }

  /**
   * AidRoomCheck findUniqueOrThrow
   */
  export type AidRoomCheckFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    /**
     * Filter, which AidRoomCheck to fetch.
     */
    where: AidRoomCheckWhereUniqueInput
  }

  /**
   * AidRoomCheck findFirst
   */
  export type AidRoomCheckFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    /**
     * Filter, which AidRoomCheck to fetch.
     */
    where?: AidRoomCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AidRoomChecks to fetch.
     */
    orderBy?: AidRoomCheckOrderByWithRelationInput | AidRoomCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AidRoomChecks.
     */
    cursor?: AidRoomCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AidRoomChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AidRoomChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AidRoomChecks.
     */
    distinct?: AidRoomCheckScalarFieldEnum | AidRoomCheckScalarFieldEnum[]
  }

  /**
   * AidRoomCheck findFirstOrThrow
   */
  export type AidRoomCheckFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    /**
     * Filter, which AidRoomCheck to fetch.
     */
    where?: AidRoomCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AidRoomChecks to fetch.
     */
    orderBy?: AidRoomCheckOrderByWithRelationInput | AidRoomCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AidRoomChecks.
     */
    cursor?: AidRoomCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AidRoomChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AidRoomChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AidRoomChecks.
     */
    distinct?: AidRoomCheckScalarFieldEnum | AidRoomCheckScalarFieldEnum[]
  }

  /**
   * AidRoomCheck findMany
   */
  export type AidRoomCheckFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    /**
     * Filter, which AidRoomChecks to fetch.
     */
    where?: AidRoomCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AidRoomChecks to fetch.
     */
    orderBy?: AidRoomCheckOrderByWithRelationInput | AidRoomCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AidRoomChecks.
     */
    cursor?: AidRoomCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AidRoomChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AidRoomChecks.
     */
    skip?: number
    distinct?: AidRoomCheckScalarFieldEnum | AidRoomCheckScalarFieldEnum[]
  }

  /**
   * AidRoomCheck create
   */
  export type AidRoomCheckCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    /**
     * The data needed to create a AidRoomCheck.
     */
    data: XOR<AidRoomCheckCreateInput, AidRoomCheckUncheckedCreateInput>
  }

  /**
   * AidRoomCheck createMany
   */
  export type AidRoomCheckCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AidRoomChecks.
     */
    data: AidRoomCheckCreateManyInput | AidRoomCheckCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AidRoomCheck createManyAndReturn
   */
  export type AidRoomCheckCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * The data used to create many AidRoomChecks.
     */
    data: AidRoomCheckCreateManyInput | AidRoomCheckCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AidRoomCheck update
   */
  export type AidRoomCheckUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    /**
     * The data needed to update a AidRoomCheck.
     */
    data: XOR<AidRoomCheckUpdateInput, AidRoomCheckUncheckedUpdateInput>
    /**
     * Choose, which AidRoomCheck to update.
     */
    where: AidRoomCheckWhereUniqueInput
  }

  /**
   * AidRoomCheck updateMany
   */
  export type AidRoomCheckUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AidRoomChecks.
     */
    data: XOR<AidRoomCheckUpdateManyMutationInput, AidRoomCheckUncheckedUpdateManyInput>
    /**
     * Filter which AidRoomChecks to update
     */
    where?: AidRoomCheckWhereInput
    /**
     * Limit how many AidRoomChecks to update.
     */
    limit?: number
  }

  /**
   * AidRoomCheck updateManyAndReturn
   */
  export type AidRoomCheckUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * The data used to update AidRoomChecks.
     */
    data: XOR<AidRoomCheckUpdateManyMutationInput, AidRoomCheckUncheckedUpdateManyInput>
    /**
     * Filter which AidRoomChecks to update
     */
    where?: AidRoomCheckWhereInput
    /**
     * Limit how many AidRoomChecks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AidRoomCheck upsert
   */
  export type AidRoomCheckUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    /**
     * The filter to search for the AidRoomCheck to update in case it exists.
     */
    where: AidRoomCheckWhereUniqueInput
    /**
     * In case the AidRoomCheck found by the `where` argument doesn't exist, create a new AidRoomCheck with this data.
     */
    create: XOR<AidRoomCheckCreateInput, AidRoomCheckUncheckedCreateInput>
    /**
     * In case the AidRoomCheck was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AidRoomCheckUpdateInput, AidRoomCheckUncheckedUpdateInput>
  }

  /**
   * AidRoomCheck delete
   */
  export type AidRoomCheckDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    /**
     * Filter which AidRoomCheck to delete.
     */
    where: AidRoomCheckWhereUniqueInput
  }

  /**
   * AidRoomCheck deleteMany
   */
  export type AidRoomCheckDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AidRoomChecks to delete
     */
    where?: AidRoomCheckWhereInput
    /**
     * Limit how many AidRoomChecks to delete.
     */
    limit?: number
  }

  /**
   * AidRoomCheck without action
   */
  export type AidRoomCheckDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
  }


  /**
   * Model EquipmentCheck
   */

  export type AggregateEquipmentCheck = {
    _count: EquipmentCheckCountAggregateOutputType | null
    _min: EquipmentCheckMinAggregateOutputType | null
    _max: EquipmentCheckMaxAggregateOutputType | null
  }

  export type EquipmentCheckMinAggregateOutputType = {
    id: string | null
    recordedAt: Date | null
    employeeId: string | null
    mountainId: string | null
    equipmentId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentCheckMaxAggregateOutputType = {
    id: string | null
    recordedAt: Date | null
    employeeId: string | null
    mountainId: string | null
    equipmentId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentCheckCountAggregateOutputType = {
    id: number
    recordedAt: number
    employeeId: number
    mountainId: number
    equipmentId: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EquipmentCheckMinAggregateInputType = {
    id?: true
    recordedAt?: true
    employeeId?: true
    mountainId?: true
    equipmentId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentCheckMaxAggregateInputType = {
    id?: true
    recordedAt?: true
    employeeId?: true
    mountainId?: true
    equipmentId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentCheckCountAggregateInputType = {
    id?: true
    recordedAt?: true
    employeeId?: true
    mountainId?: true
    equipmentId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EquipmentCheckAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentCheck to aggregate.
     */
    where?: EquipmentCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentChecks to fetch.
     */
    orderBy?: EquipmentCheckOrderByWithRelationInput | EquipmentCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EquipmentChecks
    **/
    _count?: true | EquipmentCheckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentCheckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentCheckMaxAggregateInputType
  }

  export type GetEquipmentCheckAggregateType<T extends EquipmentCheckAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipmentCheck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipmentCheck[P]>
      : GetScalarType<T[P], AggregateEquipmentCheck[P]>
  }




  export type EquipmentCheckGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentCheckWhereInput
    orderBy?: EquipmentCheckOrderByWithAggregationInput | EquipmentCheckOrderByWithAggregationInput[]
    by: EquipmentCheckScalarFieldEnum[] | EquipmentCheckScalarFieldEnum
    having?: EquipmentCheckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentCheckCountAggregateInputType | true
    _min?: EquipmentCheckMinAggregateInputType
    _max?: EquipmentCheckMaxAggregateInputType
  }

  export type EquipmentCheckGroupByOutputType = {
    id: string
    recordedAt: Date
    employeeId: string
    mountainId: string
    equipmentId: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: EquipmentCheckCountAggregateOutputType | null
    _min: EquipmentCheckMinAggregateOutputType | null
    _max: EquipmentCheckMaxAggregateOutputType | null
  }

  type GetEquipmentCheckGroupByPayload<T extends EquipmentCheckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentCheckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentCheckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentCheckGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentCheckGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentCheckSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recordedAt?: boolean
    employeeId?: boolean
    mountainId?: boolean
    equipmentId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentCheck"]>

  export type EquipmentCheckSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recordedAt?: boolean
    employeeId?: boolean
    mountainId?: boolean
    equipmentId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentCheck"]>

  export type EquipmentCheckSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recordedAt?: boolean
    employeeId?: boolean
    mountainId?: boolean
    equipmentId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentCheck"]>

  export type EquipmentCheckSelectScalar = {
    id?: boolean
    recordedAt?: boolean
    employeeId?: boolean
    mountainId?: boolean
    equipmentId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EquipmentCheckOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recordedAt" | "employeeId" | "mountainId" | "equipmentId" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["equipmentCheck"]>
  export type EquipmentCheckInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }
  export type EquipmentCheckIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }
  export type EquipmentCheckIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }

  export type $EquipmentCheckPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EquipmentCheck"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      mountain: Prisma.$MountainPayload<ExtArgs>
      equipment: Prisma.$EquipmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recordedAt: Date
      employeeId: string
      mountainId: string
      equipmentId: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["equipmentCheck"]>
    composites: {}
  }

  type EquipmentCheckGetPayload<S extends boolean | null | undefined | EquipmentCheckDefaultArgs> = $Result.GetResult<Prisma.$EquipmentCheckPayload, S>

  type EquipmentCheckCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipmentCheckFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipmentCheckCountAggregateInputType | true
    }

  export interface EquipmentCheckDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EquipmentCheck'], meta: { name: 'EquipmentCheck' } }
    /**
     * Find zero or one EquipmentCheck that matches the filter.
     * @param {EquipmentCheckFindUniqueArgs} args - Arguments to find a EquipmentCheck
     * @example
     * // Get one EquipmentCheck
     * const equipmentCheck = await prisma.equipmentCheck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentCheckFindUniqueArgs>(args: SelectSubset<T, EquipmentCheckFindUniqueArgs<ExtArgs>>): Prisma__EquipmentCheckClient<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EquipmentCheck that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipmentCheckFindUniqueOrThrowArgs} args - Arguments to find a EquipmentCheck
     * @example
     * // Get one EquipmentCheck
     * const equipmentCheck = await prisma.equipmentCheck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentCheckFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentCheckFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentCheckClient<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipmentCheck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCheckFindFirstArgs} args - Arguments to find a EquipmentCheck
     * @example
     * // Get one EquipmentCheck
     * const equipmentCheck = await prisma.equipmentCheck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentCheckFindFirstArgs>(args?: SelectSubset<T, EquipmentCheckFindFirstArgs<ExtArgs>>): Prisma__EquipmentCheckClient<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipmentCheck that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCheckFindFirstOrThrowArgs} args - Arguments to find a EquipmentCheck
     * @example
     * // Get one EquipmentCheck
     * const equipmentCheck = await prisma.equipmentCheck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentCheckFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentCheckFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentCheckClient<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EquipmentChecks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCheckFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipmentChecks
     * const equipmentChecks = await prisma.equipmentCheck.findMany()
     * 
     * // Get first 10 EquipmentChecks
     * const equipmentChecks = await prisma.equipmentCheck.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentCheckWithIdOnly = await prisma.equipmentCheck.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentCheckFindManyArgs>(args?: SelectSubset<T, EquipmentCheckFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EquipmentCheck.
     * @param {EquipmentCheckCreateArgs} args - Arguments to create a EquipmentCheck.
     * @example
     * // Create one EquipmentCheck
     * const EquipmentCheck = await prisma.equipmentCheck.create({
     *   data: {
     *     // ... data to create a EquipmentCheck
     *   }
     * })
     * 
     */
    create<T extends EquipmentCheckCreateArgs>(args: SelectSubset<T, EquipmentCheckCreateArgs<ExtArgs>>): Prisma__EquipmentCheckClient<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EquipmentChecks.
     * @param {EquipmentCheckCreateManyArgs} args - Arguments to create many EquipmentChecks.
     * @example
     * // Create many EquipmentChecks
     * const equipmentCheck = await prisma.equipmentCheck.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentCheckCreateManyArgs>(args?: SelectSubset<T, EquipmentCheckCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EquipmentChecks and returns the data saved in the database.
     * @param {EquipmentCheckCreateManyAndReturnArgs} args - Arguments to create many EquipmentChecks.
     * @example
     * // Create many EquipmentChecks
     * const equipmentCheck = await prisma.equipmentCheck.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EquipmentChecks and only return the `id`
     * const equipmentCheckWithIdOnly = await prisma.equipmentCheck.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipmentCheckCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipmentCheckCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EquipmentCheck.
     * @param {EquipmentCheckDeleteArgs} args - Arguments to delete one EquipmentCheck.
     * @example
     * // Delete one EquipmentCheck
     * const EquipmentCheck = await prisma.equipmentCheck.delete({
     *   where: {
     *     // ... filter to delete one EquipmentCheck
     *   }
     * })
     * 
     */
    delete<T extends EquipmentCheckDeleteArgs>(args: SelectSubset<T, EquipmentCheckDeleteArgs<ExtArgs>>): Prisma__EquipmentCheckClient<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EquipmentCheck.
     * @param {EquipmentCheckUpdateArgs} args - Arguments to update one EquipmentCheck.
     * @example
     * // Update one EquipmentCheck
     * const equipmentCheck = await prisma.equipmentCheck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentCheckUpdateArgs>(args: SelectSubset<T, EquipmentCheckUpdateArgs<ExtArgs>>): Prisma__EquipmentCheckClient<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EquipmentChecks.
     * @param {EquipmentCheckDeleteManyArgs} args - Arguments to filter EquipmentChecks to delete.
     * @example
     * // Delete a few EquipmentChecks
     * const { count } = await prisma.equipmentCheck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentCheckDeleteManyArgs>(args?: SelectSubset<T, EquipmentCheckDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCheckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipmentChecks
     * const equipmentCheck = await prisma.equipmentCheck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentCheckUpdateManyArgs>(args: SelectSubset<T, EquipmentCheckUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentChecks and returns the data updated in the database.
     * @param {EquipmentCheckUpdateManyAndReturnArgs} args - Arguments to update many EquipmentChecks.
     * @example
     * // Update many EquipmentChecks
     * const equipmentCheck = await prisma.equipmentCheck.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EquipmentChecks and only return the `id`
     * const equipmentCheckWithIdOnly = await prisma.equipmentCheck.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EquipmentCheckUpdateManyAndReturnArgs>(args: SelectSubset<T, EquipmentCheckUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EquipmentCheck.
     * @param {EquipmentCheckUpsertArgs} args - Arguments to update or create a EquipmentCheck.
     * @example
     * // Update or create a EquipmentCheck
     * const equipmentCheck = await prisma.equipmentCheck.upsert({
     *   create: {
     *     // ... data to create a EquipmentCheck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipmentCheck we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentCheckUpsertArgs>(args: SelectSubset<T, EquipmentCheckUpsertArgs<ExtArgs>>): Prisma__EquipmentCheckClient<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EquipmentChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCheckCountArgs} args - Arguments to filter EquipmentChecks to count.
     * @example
     * // Count the number of EquipmentChecks
     * const count = await prisma.equipmentCheck.count({
     *   where: {
     *     // ... the filter for the EquipmentChecks we want to count
     *   }
     * })
    **/
    count<T extends EquipmentCheckCountArgs>(
      args?: Subset<T, EquipmentCheckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentCheckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipmentCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCheckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentCheckAggregateArgs>(args: Subset<T, EquipmentCheckAggregateArgs>): Prisma.PrismaPromise<GetEquipmentCheckAggregateType<T>>

    /**
     * Group by EquipmentCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCheckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentCheckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentCheckGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentCheckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentCheckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentCheckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EquipmentCheck model
   */
  readonly fields: EquipmentCheckFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EquipmentCheck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentCheckClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    equipment<T extends EquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentDefaultArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EquipmentCheck model
   */
  interface EquipmentCheckFieldRefs {
    readonly id: FieldRef<"EquipmentCheck", 'String'>
    readonly recordedAt: FieldRef<"EquipmentCheck", 'DateTime'>
    readonly employeeId: FieldRef<"EquipmentCheck", 'String'>
    readonly mountainId: FieldRef<"EquipmentCheck", 'String'>
    readonly equipmentId: FieldRef<"EquipmentCheck", 'String'>
    readonly notes: FieldRef<"EquipmentCheck", 'String'>
    readonly createdAt: FieldRef<"EquipmentCheck", 'DateTime'>
    readonly updatedAt: FieldRef<"EquipmentCheck", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EquipmentCheck findUnique
   */
  export type EquipmentCheckFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentCheck to fetch.
     */
    where: EquipmentCheckWhereUniqueInput
  }

  /**
   * EquipmentCheck findUniqueOrThrow
   */
  export type EquipmentCheckFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentCheck to fetch.
     */
    where: EquipmentCheckWhereUniqueInput
  }

  /**
   * EquipmentCheck findFirst
   */
  export type EquipmentCheckFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentCheck to fetch.
     */
    where?: EquipmentCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentChecks to fetch.
     */
    orderBy?: EquipmentCheckOrderByWithRelationInput | EquipmentCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentChecks.
     */
    cursor?: EquipmentCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentChecks.
     */
    distinct?: EquipmentCheckScalarFieldEnum | EquipmentCheckScalarFieldEnum[]
  }

  /**
   * EquipmentCheck findFirstOrThrow
   */
  export type EquipmentCheckFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentCheck to fetch.
     */
    where?: EquipmentCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentChecks to fetch.
     */
    orderBy?: EquipmentCheckOrderByWithRelationInput | EquipmentCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentChecks.
     */
    cursor?: EquipmentCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentChecks.
     */
    distinct?: EquipmentCheckScalarFieldEnum | EquipmentCheckScalarFieldEnum[]
  }

  /**
   * EquipmentCheck findMany
   */
  export type EquipmentCheckFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentChecks to fetch.
     */
    where?: EquipmentCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentChecks to fetch.
     */
    orderBy?: EquipmentCheckOrderByWithRelationInput | EquipmentCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EquipmentChecks.
     */
    cursor?: EquipmentCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentChecks.
     */
    skip?: number
    distinct?: EquipmentCheckScalarFieldEnum | EquipmentCheckScalarFieldEnum[]
  }

  /**
   * EquipmentCheck create
   */
  export type EquipmentCheckCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    /**
     * The data needed to create a EquipmentCheck.
     */
    data: XOR<EquipmentCheckCreateInput, EquipmentCheckUncheckedCreateInput>
  }

  /**
   * EquipmentCheck createMany
   */
  export type EquipmentCheckCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EquipmentChecks.
     */
    data: EquipmentCheckCreateManyInput | EquipmentCheckCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EquipmentCheck createManyAndReturn
   */
  export type EquipmentCheckCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * The data used to create many EquipmentChecks.
     */
    data: EquipmentCheckCreateManyInput | EquipmentCheckCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EquipmentCheck update
   */
  export type EquipmentCheckUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    /**
     * The data needed to update a EquipmentCheck.
     */
    data: XOR<EquipmentCheckUpdateInput, EquipmentCheckUncheckedUpdateInput>
    /**
     * Choose, which EquipmentCheck to update.
     */
    where: EquipmentCheckWhereUniqueInput
  }

  /**
   * EquipmentCheck updateMany
   */
  export type EquipmentCheckUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EquipmentChecks.
     */
    data: XOR<EquipmentCheckUpdateManyMutationInput, EquipmentCheckUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentChecks to update
     */
    where?: EquipmentCheckWhereInput
    /**
     * Limit how many EquipmentChecks to update.
     */
    limit?: number
  }

  /**
   * EquipmentCheck updateManyAndReturn
   */
  export type EquipmentCheckUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * The data used to update EquipmentChecks.
     */
    data: XOR<EquipmentCheckUpdateManyMutationInput, EquipmentCheckUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentChecks to update
     */
    where?: EquipmentCheckWhereInput
    /**
     * Limit how many EquipmentChecks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EquipmentCheck upsert
   */
  export type EquipmentCheckUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    /**
     * The filter to search for the EquipmentCheck to update in case it exists.
     */
    where: EquipmentCheckWhereUniqueInput
    /**
     * In case the EquipmentCheck found by the `where` argument doesn't exist, create a new EquipmentCheck with this data.
     */
    create: XOR<EquipmentCheckCreateInput, EquipmentCheckUncheckedCreateInput>
    /**
     * In case the EquipmentCheck was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentCheckUpdateInput, EquipmentCheckUncheckedUpdateInput>
  }

  /**
   * EquipmentCheck delete
   */
  export type EquipmentCheckDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    /**
     * Filter which EquipmentCheck to delete.
     */
    where: EquipmentCheckWhereUniqueInput
  }

  /**
   * EquipmentCheck deleteMany
   */
  export type EquipmentCheckDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentChecks to delete
     */
    where?: EquipmentCheckWhereInput
    /**
     * Limit how many EquipmentChecks to delete.
     */
    limit?: number
  }

  /**
   * EquipmentCheck without action
   */
  export type EquipmentCheckDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AreaScalarFieldEnum: {
    id: 'id',
    mountainId: 'mountainId',
    name: 'name',
    type: 'type',
    description: 'description'
  };

  export type AreaScalarFieldEnum = (typeof AreaScalarFieldEnum)[keyof typeof AreaScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    mountainId: 'mountainId',
    name: 'name',
    areaId: 'areaId',
    entityId: 'entityId',
    entityType: 'entityType'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const HoursScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    dayOfWeek: 'dayOfWeek',
    date: 'date',
    openTime: 'openTime',
    closeTime: 'closeTime',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HoursScalarFieldEnum = (typeof HoursScalarFieldEnum)[keyof typeof HoursScalarFieldEnum]


  export const MountainScalarFieldEnum: {
    id: 'id',
    name: 'name',
    latitude: 'latitude',
    longitude: 'longitude',
    height: 'height',
    phoneNumber: 'phoneNumber',
    address: 'address',
    city: 'city',
    state: 'state',
    zipcode: 'zipcode',
    openingDate: 'openingDate',
    closingDate: 'closingDate'
  };

  export type MountainScalarFieldEnum = (typeof MountainScalarFieldEnum)[keyof typeof MountainScalarFieldEnum]


  export const WeatherScalarFieldEnum: {
    id: 'id',
    mountainId: 'mountainId',
    date: 'date',
    temperature: 'temperature',
    windSpeed: 'windSpeed',
    windDirection: 'windDirection',
    visibility: 'visibility',
    conditions: 'conditions',
    snowfallRecent: 'snowfallRecent',
    snowfall24h: 'snowfall24h',
    snowfall7d: 'snowfall7d',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WeatherScalarFieldEnum = (typeof WeatherScalarFieldEnum)[keyof typeof WeatherScalarFieldEnum]


  export const EmployeeMountainAssignmentScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    mountainId: 'mountainId',
    assignedAt: 'assignedAt'
  };

  export type EmployeeMountainAssignmentScalarFieldEnum = (typeof EmployeeMountainAssignmentScalarFieldEnum)[keyof typeof EmployeeMountainAssignmentScalarFieldEnum]


  export const DispatcherAssignmentScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    mountainId: 'mountainId',
    assignedAt: 'assignedAt'
  };

  export type DispatcherAssignmentScalarFieldEnum = (typeof DispatcherAssignmentScalarFieldEnum)[keyof typeof DispatcherAssignmentScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    department: 'department',
    name: 'name',
    title: 'title',
    position: 'position',
    level: 'level',
    permissions: 'permissions'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const EmployeeRoleScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    roleId: 'roleId'
  };

  export type EmployeeRoleScalarFieldEnum = (typeof EmployeeRoleScalarFieldEnum)[keyof typeof EmployeeRoleScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    employeeIdNumber: 'employeeIdNumber',
    email: 'email',
    phoneNumber: 'phoneNumber',
    name: 'name',
    roleId: 'roleId'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const LiftScalarFieldEnum: {
    id: 'id',
    mountainId: 'mountainId',
    name: 'name',
    type: 'type',
    status: 'status',
    capacity: 'capacity',
    latitude: 'latitude',
    longitude: 'longitude',
    locationId: 'locationId'
  };

  export type LiftScalarFieldEnum = (typeof LiftScalarFieldEnum)[keyof typeof LiftScalarFieldEnum]


  export const TrailScalarFieldEnum: {
    id: 'id',
    mountainId: 'mountainId',
    name: 'name',
    difficulty: 'difficulty',
    status: 'status',
    length: 'length',
    latitude: 'latitude',
    longitude: 'longitude',
    condition: 'condition',
    locationId: 'locationId'
  };

  export type TrailScalarFieldEnum = (typeof TrailScalarFieldEnum)[keyof typeof TrailScalarFieldEnum]


  export const LodgeScalarFieldEnum: {
    id: 'id',
    mountainId: 'mountainId',
    name: 'name',
    capacity: 'capacity',
    latitude: 'latitude',
    longitude: 'longitude',
    status: 'status',
    locationId: 'locationId'
  };

  export type LodgeScalarFieldEnum = (typeof LodgeScalarFieldEnum)[keyof typeof LodgeScalarFieldEnum]


  export const HutScalarFieldEnum: {
    id: 'id',
    mountainId: 'mountainId',
    name: 'name',
    status: 'status',
    latitude: 'latitude',
    longitude: 'longitude',
    locationId: 'locationId'
  };

  export type HutScalarFieldEnum = (typeof HutScalarFieldEnum)[keyof typeof HutScalarFieldEnum]


  export const AidRoomScalarFieldEnum: {
    id: 'id',
    mountainId: 'mountainId',
    name: 'name',
    status: 'status',
    latitude: 'latitude',
    longitude: 'longitude',
    locationId: 'locationId'
  };

  export type AidRoomScalarFieldEnum = (typeof AidRoomScalarFieldEnum)[keyof typeof AidRoomScalarFieldEnum]


  export const EquipmentServiceLogScalarFieldEnum: {
    id: 'id',
    mountainId: 'mountainId',
    equipmentId: 'equipmentId',
    employeeId: 'employeeId',
    status: 'status',
    changedAt: 'changedAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EquipmentServiceLogScalarFieldEnum = (typeof EquipmentServiceLogScalarFieldEnum)[keyof typeof EquipmentServiceLogScalarFieldEnum]


  export const EquipmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    status: 'status',
    number: 'number',
    description: 'description',
    picture: 'picture',
    cost: 'cost',
    latitude: 'latitude',
    longitude: 'longitude',
    mountainId: 'mountainId',
    locationId: 'locationId',
    dateAdded: 'dateAdded'
  };

  export type EquipmentScalarFieldEnum = (typeof EquipmentScalarFieldEnum)[keyof typeof EquipmentScalarFieldEnum]


  export const IncidentScalarFieldEnum: {
    id: 'id',
    description: 'description',
    status: 'status',
    latitude: 'latitude',
    longitude: 'longitude',
    mountainId: 'mountainId',
    startTime: 'startTime',
    endTime: 'endTime',
    onSceneTime: 'onSceneTime',
    stableTime: 'stableTime',
    transportTime: 'transportTime',
    emptyRun: 'emptyRun',
    emptyRunAt: 'emptyRunAt',
    locationId: 'locationId'
  };

  export type IncidentScalarFieldEnum = (typeof IncidentScalarFieldEnum)[keyof typeof IncidentScalarFieldEnum]


  export const IncidentEquipmentUsageLogScalarFieldEnum: {
    id: 'id',
    usedAt: 'usedAt',
    notes: 'notes',
    mountainId: 'mountainId',
    equipmentId: 'equipmentId',
    incidentId: 'incidentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IncidentEquipmentUsageLogScalarFieldEnum = (typeof IncidentEquipmentUsageLogScalarFieldEnum)[keyof typeof IncidentEquipmentUsageLogScalarFieldEnum]


  export const LiftCheckScalarFieldEnum: {
    id: 'id',
    recordedAt: 'recordedAt',
    employeeId: 'employeeId',
    mountainId: 'mountainId',
    liftId: 'liftId',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LiftCheckScalarFieldEnum = (typeof LiftCheckScalarFieldEnum)[keyof typeof LiftCheckScalarFieldEnum]


  export const TrailCheckScalarFieldEnum: {
    id: 'id',
    recordedAt: 'recordedAt',
    employeeId: 'employeeId',
    mountainId: 'mountainId',
    trailId: 'trailId',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrailCheckScalarFieldEnum = (typeof TrailCheckScalarFieldEnum)[keyof typeof TrailCheckScalarFieldEnum]


  export const HutCheckScalarFieldEnum: {
    id: 'id',
    recordedAt: 'recordedAt',
    employeeId: 'employeeId',
    mountainId: 'mountainId',
    hutId: 'hutId',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HutCheckScalarFieldEnum = (typeof HutCheckScalarFieldEnum)[keyof typeof HutCheckScalarFieldEnum]


  export const AidRoomCheckScalarFieldEnum: {
    id: 'id',
    recordedAt: 'recordedAt',
    employeeId: 'employeeId',
    mountainId: 'mountainId',
    aidRoomId: 'aidRoomId',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AidRoomCheckScalarFieldEnum = (typeof AidRoomCheckScalarFieldEnum)[keyof typeof AidRoomCheckScalarFieldEnum]


  export const EquipmentCheckScalarFieldEnum: {
    id: 'id',
    recordedAt: 'recordedAt',
    employeeId: 'employeeId',
    mountainId: 'mountainId',
    equipmentId: 'equipmentId',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EquipmentCheckScalarFieldEnum = (typeof EquipmentCheckScalarFieldEnum)[keyof typeof EquipmentCheckScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'AREA_TYPE'
   */
  export type EnumAREA_TYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AREA_TYPE'>
    


  /**
   * Reference to a field of type 'AREA_TYPE[]'
   */
  export type ListEnumAREA_TYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AREA_TYPE[]'>
    


  /**
   * Reference to a field of type 'LOCATION_TYPE'
   */
  export type EnumLOCATION_TYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LOCATION_TYPE'>
    


  /**
   * Reference to a field of type 'LOCATION_TYPE[]'
   */
  export type ListEnumLOCATION_TYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LOCATION_TYPE[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'STATUS'
   */
  export type EnumSTATUSFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'STATUS'>
    


  /**
   * Reference to a field of type 'STATUS[]'
   */
  export type ListEnumSTATUSFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'STATUS[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DEPARTMENT'
   */
  export type EnumDEPARTMENTFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DEPARTMENT'>
    


  /**
   * Reference to a field of type 'DEPARTMENT[]'
   */
  export type ListEnumDEPARTMENTFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DEPARTMENT[]'>
    


  /**
   * Reference to a field of type 'LIFT_TYPE'
   */
  export type EnumLIFT_TYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LIFT_TYPE'>
    


  /**
   * Reference to a field of type 'LIFT_TYPE[]'
   */
  export type ListEnumLIFT_TYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LIFT_TYPE[]'>
    


  /**
   * Reference to a field of type 'TRAIL_DIFFICULTY'
   */
  export type EnumTRAIL_DIFFICULTYFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TRAIL_DIFFICULTY'>
    


  /**
   * Reference to a field of type 'TRAIL_DIFFICULTY[]'
   */
  export type ListEnumTRAIL_DIFFICULTYFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TRAIL_DIFFICULTY[]'>
    


  /**
   * Reference to a field of type 'TRAIL_CONDITION'
   */
  export type EnumTRAIL_CONDITIONFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TRAIL_CONDITION'>
    


  /**
   * Reference to a field of type 'TRAIL_CONDITION[]'
   */
  export type ListEnumTRAIL_CONDITIONFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TRAIL_CONDITION[]'>
    


  /**
   * Reference to a field of type 'EQUIPMENT_STATUS'
   */
  export type EnumEQUIPMENT_STATUSFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EQUIPMENT_STATUS'>
    


  /**
   * Reference to a field of type 'EQUIPMENT_STATUS[]'
   */
  export type ListEnumEQUIPMENT_STATUSFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EQUIPMENT_STATUS[]'>
    


  /**
   * Reference to a field of type 'INCIDENT_STATUS'
   */
  export type EnumINCIDENT_STATUSFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'INCIDENT_STATUS'>
    


  /**
   * Reference to a field of type 'INCIDENT_STATUS[]'
   */
  export type ListEnumINCIDENT_STATUSFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'INCIDENT_STATUS[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type AreaWhereInput = {
    AND?: AreaWhereInput | AreaWhereInput[]
    OR?: AreaWhereInput[]
    NOT?: AreaWhereInput | AreaWhereInput[]
    id?: StringFilter<"Area"> | string
    mountainId?: StringFilter<"Area"> | string
    name?: StringFilter<"Area"> | string
    type?: EnumAREA_TYPEFilter<"Area"> | $Enums.AREA_TYPE
    description?: StringNullableFilter<"Area"> | string | null
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    locations?: LocationListRelationFilter
  }

  export type AreaOrderByWithRelationInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    mountain?: MountainOrderByWithRelationInput
    locations?: LocationOrderByRelationAggregateInput
  }

  export type AreaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_type?: AreaNameTypeCompoundUniqueInput
    AND?: AreaWhereInput | AreaWhereInput[]
    OR?: AreaWhereInput[]
    NOT?: AreaWhereInput | AreaWhereInput[]
    mountainId?: StringFilter<"Area"> | string
    name?: StringFilter<"Area"> | string
    type?: EnumAREA_TYPEFilter<"Area"> | $Enums.AREA_TYPE
    description?: StringNullableFilter<"Area"> | string | null
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    locations?: LocationListRelationFilter
  }, "id" | "name_type">

  export type AreaOrderByWithAggregationInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: AreaCountOrderByAggregateInput
    _max?: AreaMaxOrderByAggregateInput
    _min?: AreaMinOrderByAggregateInput
  }

  export type AreaScalarWhereWithAggregatesInput = {
    AND?: AreaScalarWhereWithAggregatesInput | AreaScalarWhereWithAggregatesInput[]
    OR?: AreaScalarWhereWithAggregatesInput[]
    NOT?: AreaScalarWhereWithAggregatesInput | AreaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Area"> | string
    mountainId?: StringWithAggregatesFilter<"Area"> | string
    name?: StringWithAggregatesFilter<"Area"> | string
    type?: EnumAREA_TYPEWithAggregatesFilter<"Area"> | $Enums.AREA_TYPE
    description?: StringNullableWithAggregatesFilter<"Area"> | string | null
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    mountainId?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    areaId?: StringNullableFilter<"Location"> | string | null
    entityId?: StringFilter<"Location"> | string
    entityType?: EnumLOCATION_TYPEFilter<"Location"> | $Enums.LOCATION_TYPE
    area?: XOR<AreaNullableScalarRelationFilter, AreaWhereInput> | null
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    lift?: XOR<LiftNullableScalarRelationFilter, LiftWhereInput> | null
    trail?: XOR<TrailNullableScalarRelationFilter, TrailWhereInput> | null
    hut?: XOR<HutNullableScalarRelationFilter, HutWhereInput> | null
    lodge?: XOR<LodgeNullableScalarRelationFilter, LodgeWhereInput> | null
    aidRoom?: XOR<AidRoomNullableScalarRelationFilter, AidRoomWhereInput> | null
    hours?: HoursListRelationFilter
    equipment?: EquipmentListRelationFilter
    incidents?: IncidentListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    areaId?: SortOrderInput | SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    area?: AreaOrderByWithRelationInput
    mountain?: MountainOrderByWithRelationInput
    lift?: LiftOrderByWithRelationInput
    trail?: TrailOrderByWithRelationInput
    hut?: HutOrderByWithRelationInput
    lodge?: LodgeOrderByWithRelationInput
    aidRoom?: AidRoomOrderByWithRelationInput
    hours?: HoursOrderByRelationAggregateInput
    equipment?: EquipmentOrderByRelationAggregateInput
    incidents?: IncidentOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    entityId?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    mountainId?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    areaId?: StringNullableFilter<"Location"> | string | null
    entityType?: EnumLOCATION_TYPEFilter<"Location"> | $Enums.LOCATION_TYPE
    area?: XOR<AreaNullableScalarRelationFilter, AreaWhereInput> | null
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    lift?: XOR<LiftNullableScalarRelationFilter, LiftWhereInput> | null
    trail?: XOR<TrailNullableScalarRelationFilter, TrailWhereInput> | null
    hut?: XOR<HutNullableScalarRelationFilter, HutWhereInput> | null
    lodge?: XOR<LodgeNullableScalarRelationFilter, LodgeWhereInput> | null
    aidRoom?: XOR<AidRoomNullableScalarRelationFilter, AidRoomWhereInput> | null
    hours?: HoursListRelationFilter
    equipment?: EquipmentListRelationFilter
    incidents?: IncidentListRelationFilter
  }, "id" | "entityId">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    areaId?: SortOrderInput | SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    mountainId?: StringWithAggregatesFilter<"Location"> | string
    name?: StringWithAggregatesFilter<"Location"> | string
    areaId?: StringNullableWithAggregatesFilter<"Location"> | string | null
    entityId?: StringWithAggregatesFilter<"Location"> | string
    entityType?: EnumLOCATION_TYPEWithAggregatesFilter<"Location"> | $Enums.LOCATION_TYPE
  }

  export type HoursWhereInput = {
    AND?: HoursWhereInput | HoursWhereInput[]
    OR?: HoursWhereInput[]
    NOT?: HoursWhereInput | HoursWhereInput[]
    id?: StringFilter<"Hours"> | string
    locationId?: StringFilter<"Hours"> | string
    dayOfWeek?: IntNullableFilter<"Hours"> | number | null
    date?: DateTimeNullableFilter<"Hours"> | Date | string | null
    openTime?: DateTimeNullableFilter<"Hours"> | Date | string | null
    closeTime?: DateTimeNullableFilter<"Hours"> | Date | string | null
    status?: EnumSTATUSFilter<"Hours"> | $Enums.STATUS
    createdAt?: DateTimeFilter<"Hours"> | Date | string
    updatedAt?: DateTimeFilter<"Hours"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }

  export type HoursOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    openTime?: SortOrderInput | SortOrder
    closeTime?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: LocationOrderByWithRelationInput
  }

  export type HoursWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    locationId_dayOfWeek_date?: HoursLocationIdDayOfWeekDateCompoundUniqueInput
    AND?: HoursWhereInput | HoursWhereInput[]
    OR?: HoursWhereInput[]
    NOT?: HoursWhereInput | HoursWhereInput[]
    locationId?: StringFilter<"Hours"> | string
    dayOfWeek?: IntNullableFilter<"Hours"> | number | null
    date?: DateTimeNullableFilter<"Hours"> | Date | string | null
    openTime?: DateTimeNullableFilter<"Hours"> | Date | string | null
    closeTime?: DateTimeNullableFilter<"Hours"> | Date | string | null
    status?: EnumSTATUSFilter<"Hours"> | $Enums.STATUS
    createdAt?: DateTimeFilter<"Hours"> | Date | string
    updatedAt?: DateTimeFilter<"Hours"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }, "id" | "locationId_dayOfWeek_date">

  export type HoursOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    openTime?: SortOrderInput | SortOrder
    closeTime?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HoursCountOrderByAggregateInput
    _avg?: HoursAvgOrderByAggregateInput
    _max?: HoursMaxOrderByAggregateInput
    _min?: HoursMinOrderByAggregateInput
    _sum?: HoursSumOrderByAggregateInput
  }

  export type HoursScalarWhereWithAggregatesInput = {
    AND?: HoursScalarWhereWithAggregatesInput | HoursScalarWhereWithAggregatesInput[]
    OR?: HoursScalarWhereWithAggregatesInput[]
    NOT?: HoursScalarWhereWithAggregatesInput | HoursScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Hours"> | string
    locationId?: StringWithAggregatesFilter<"Hours"> | string
    dayOfWeek?: IntNullableWithAggregatesFilter<"Hours"> | number | null
    date?: DateTimeNullableWithAggregatesFilter<"Hours"> | Date | string | null
    openTime?: DateTimeNullableWithAggregatesFilter<"Hours"> | Date | string | null
    closeTime?: DateTimeNullableWithAggregatesFilter<"Hours"> | Date | string | null
    status?: EnumSTATUSWithAggregatesFilter<"Hours"> | $Enums.STATUS
    createdAt?: DateTimeWithAggregatesFilter<"Hours"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Hours"> | Date | string
  }

  export type MountainWhereInput = {
    AND?: MountainWhereInput | MountainWhereInput[]
    OR?: MountainWhereInput[]
    NOT?: MountainWhereInput | MountainWhereInput[]
    id?: StringFilter<"Mountain"> | string
    name?: StringFilter<"Mountain"> | string
    latitude?: DecimalNullableFilter<"Mountain"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Mountain"> | Decimal | DecimalJsLike | number | string | null
    height?: IntFilter<"Mountain"> | number
    phoneNumber?: StringFilter<"Mountain"> | string
    address?: StringFilter<"Mountain"> | string
    city?: StringFilter<"Mountain"> | string
    state?: StringFilter<"Mountain"> | string
    zipcode?: StringFilter<"Mountain"> | string
    openingDate?: DateTimeNullableFilter<"Mountain"> | Date | string | null
    closingDate?: DateTimeNullableFilter<"Mountain"> | Date | string | null
    weather?: WeatherListRelationFilter
    locations?: LocationListRelationFilter
    areas?: AreaListRelationFilter
    aidRooms?: AidRoomListRelationFilter
    huts?: HutListRelationFilter
    lodges?: LodgeListRelationFilter
    lifts?: LiftListRelationFilter
    trails?: TrailListRelationFilter
    aidRoomChecks?: AidRoomCheckListRelationFilter
    hutChecks?: HutCheckListRelationFilter
    liftChecks?: LiftCheckListRelationFilter
    trailChecks?: TrailCheckListRelationFilter
    equipmentChecks?: EquipmentCheckListRelationFilter
    incidents?: IncidentListRelationFilter
    equipment?: EquipmentListRelationFilter
    employeeAssignments?: EmployeeMountainAssignmentListRelationFilter
    dispatcherAssignments?: DispatcherAssignmentListRelationFilter
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogListRelationFilter
    equipmentServiceLogs?: EquipmentServiceLogListRelationFilter
  }

  export type MountainOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    height?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    openingDate?: SortOrderInput | SortOrder
    closingDate?: SortOrderInput | SortOrder
    weather?: WeatherOrderByRelationAggregateInput
    locations?: LocationOrderByRelationAggregateInput
    areas?: AreaOrderByRelationAggregateInput
    aidRooms?: AidRoomOrderByRelationAggregateInput
    huts?: HutOrderByRelationAggregateInput
    lodges?: LodgeOrderByRelationAggregateInput
    lifts?: LiftOrderByRelationAggregateInput
    trails?: TrailOrderByRelationAggregateInput
    aidRoomChecks?: AidRoomCheckOrderByRelationAggregateInput
    hutChecks?: HutCheckOrderByRelationAggregateInput
    liftChecks?: LiftCheckOrderByRelationAggregateInput
    trailChecks?: TrailCheckOrderByRelationAggregateInput
    equipmentChecks?: EquipmentCheckOrderByRelationAggregateInput
    incidents?: IncidentOrderByRelationAggregateInput
    equipment?: EquipmentOrderByRelationAggregateInput
    employeeAssignments?: EmployeeMountainAssignmentOrderByRelationAggregateInput
    dispatcherAssignments?: DispatcherAssignmentOrderByRelationAggregateInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogOrderByRelationAggregateInput
    equipmentServiceLogs?: EquipmentServiceLogOrderByRelationAggregateInput
  }

  export type MountainWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: MountainWhereInput | MountainWhereInput[]
    OR?: MountainWhereInput[]
    NOT?: MountainWhereInput | MountainWhereInput[]
    latitude?: DecimalNullableFilter<"Mountain"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Mountain"> | Decimal | DecimalJsLike | number | string | null
    height?: IntFilter<"Mountain"> | number
    phoneNumber?: StringFilter<"Mountain"> | string
    address?: StringFilter<"Mountain"> | string
    city?: StringFilter<"Mountain"> | string
    state?: StringFilter<"Mountain"> | string
    zipcode?: StringFilter<"Mountain"> | string
    openingDate?: DateTimeNullableFilter<"Mountain"> | Date | string | null
    closingDate?: DateTimeNullableFilter<"Mountain"> | Date | string | null
    weather?: WeatherListRelationFilter
    locations?: LocationListRelationFilter
    areas?: AreaListRelationFilter
    aidRooms?: AidRoomListRelationFilter
    huts?: HutListRelationFilter
    lodges?: LodgeListRelationFilter
    lifts?: LiftListRelationFilter
    trails?: TrailListRelationFilter
    aidRoomChecks?: AidRoomCheckListRelationFilter
    hutChecks?: HutCheckListRelationFilter
    liftChecks?: LiftCheckListRelationFilter
    trailChecks?: TrailCheckListRelationFilter
    equipmentChecks?: EquipmentCheckListRelationFilter
    incidents?: IncidentListRelationFilter
    equipment?: EquipmentListRelationFilter
    employeeAssignments?: EmployeeMountainAssignmentListRelationFilter
    dispatcherAssignments?: DispatcherAssignmentListRelationFilter
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogListRelationFilter
    equipmentServiceLogs?: EquipmentServiceLogListRelationFilter
  }, "id" | "name">

  export type MountainOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    height?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    openingDate?: SortOrderInput | SortOrder
    closingDate?: SortOrderInput | SortOrder
    _count?: MountainCountOrderByAggregateInput
    _avg?: MountainAvgOrderByAggregateInput
    _max?: MountainMaxOrderByAggregateInput
    _min?: MountainMinOrderByAggregateInput
    _sum?: MountainSumOrderByAggregateInput
  }

  export type MountainScalarWhereWithAggregatesInput = {
    AND?: MountainScalarWhereWithAggregatesInput | MountainScalarWhereWithAggregatesInput[]
    OR?: MountainScalarWhereWithAggregatesInput[]
    NOT?: MountainScalarWhereWithAggregatesInput | MountainScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Mountain"> | string
    name?: StringWithAggregatesFilter<"Mountain"> | string
    latitude?: DecimalNullableWithAggregatesFilter<"Mountain"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"Mountain"> | Decimal | DecimalJsLike | number | string | null
    height?: IntWithAggregatesFilter<"Mountain"> | number
    phoneNumber?: StringWithAggregatesFilter<"Mountain"> | string
    address?: StringWithAggregatesFilter<"Mountain"> | string
    city?: StringWithAggregatesFilter<"Mountain"> | string
    state?: StringWithAggregatesFilter<"Mountain"> | string
    zipcode?: StringWithAggregatesFilter<"Mountain"> | string
    openingDate?: DateTimeNullableWithAggregatesFilter<"Mountain"> | Date | string | null
    closingDate?: DateTimeNullableWithAggregatesFilter<"Mountain"> | Date | string | null
  }

  export type WeatherWhereInput = {
    AND?: WeatherWhereInput | WeatherWhereInput[]
    OR?: WeatherWhereInput[]
    NOT?: WeatherWhereInput | WeatherWhereInput[]
    id?: StringFilter<"Weather"> | string
    mountainId?: StringFilter<"Weather"> | string
    date?: DateTimeFilter<"Weather"> | Date | string
    temperature?: FloatFilter<"Weather"> | number
    windSpeed?: FloatFilter<"Weather"> | number
    windDirection?: StringNullableFilter<"Weather"> | string | null
    visibility?: FloatNullableFilter<"Weather"> | number | null
    conditions?: StringFilter<"Weather"> | string
    snowfallRecent?: FloatNullableFilter<"Weather"> | number | null
    snowfall24h?: FloatNullableFilter<"Weather"> | number | null
    snowfall7d?: FloatNullableFilter<"Weather"> | number | null
    createdAt?: DateTimeFilter<"Weather"> | Date | string
    updatedAt?: DateTimeFilter<"Weather"> | Date | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
  }

  export type WeatherOrderByWithRelationInput = {
    id?: SortOrder
    mountainId?: SortOrder
    date?: SortOrder
    temperature?: SortOrder
    windSpeed?: SortOrder
    windDirection?: SortOrderInput | SortOrder
    visibility?: SortOrderInput | SortOrder
    conditions?: SortOrder
    snowfallRecent?: SortOrderInput | SortOrder
    snowfall24h?: SortOrderInput | SortOrder
    snowfall7d?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mountain?: MountainOrderByWithRelationInput
  }

  export type WeatherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WeatherWhereInput | WeatherWhereInput[]
    OR?: WeatherWhereInput[]
    NOT?: WeatherWhereInput | WeatherWhereInput[]
    mountainId?: StringFilter<"Weather"> | string
    date?: DateTimeFilter<"Weather"> | Date | string
    temperature?: FloatFilter<"Weather"> | number
    windSpeed?: FloatFilter<"Weather"> | number
    windDirection?: StringNullableFilter<"Weather"> | string | null
    visibility?: FloatNullableFilter<"Weather"> | number | null
    conditions?: StringFilter<"Weather"> | string
    snowfallRecent?: FloatNullableFilter<"Weather"> | number | null
    snowfall24h?: FloatNullableFilter<"Weather"> | number | null
    snowfall7d?: FloatNullableFilter<"Weather"> | number | null
    createdAt?: DateTimeFilter<"Weather"> | Date | string
    updatedAt?: DateTimeFilter<"Weather"> | Date | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
  }, "id">

  export type WeatherOrderByWithAggregationInput = {
    id?: SortOrder
    mountainId?: SortOrder
    date?: SortOrder
    temperature?: SortOrder
    windSpeed?: SortOrder
    windDirection?: SortOrderInput | SortOrder
    visibility?: SortOrderInput | SortOrder
    conditions?: SortOrder
    snowfallRecent?: SortOrderInput | SortOrder
    snowfall24h?: SortOrderInput | SortOrder
    snowfall7d?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WeatherCountOrderByAggregateInput
    _avg?: WeatherAvgOrderByAggregateInput
    _max?: WeatherMaxOrderByAggregateInput
    _min?: WeatherMinOrderByAggregateInput
    _sum?: WeatherSumOrderByAggregateInput
  }

  export type WeatherScalarWhereWithAggregatesInput = {
    AND?: WeatherScalarWhereWithAggregatesInput | WeatherScalarWhereWithAggregatesInput[]
    OR?: WeatherScalarWhereWithAggregatesInput[]
    NOT?: WeatherScalarWhereWithAggregatesInput | WeatherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Weather"> | string
    mountainId?: StringWithAggregatesFilter<"Weather"> | string
    date?: DateTimeWithAggregatesFilter<"Weather"> | Date | string
    temperature?: FloatWithAggregatesFilter<"Weather"> | number
    windSpeed?: FloatWithAggregatesFilter<"Weather"> | number
    windDirection?: StringNullableWithAggregatesFilter<"Weather"> | string | null
    visibility?: FloatNullableWithAggregatesFilter<"Weather"> | number | null
    conditions?: StringWithAggregatesFilter<"Weather"> | string
    snowfallRecent?: FloatNullableWithAggregatesFilter<"Weather"> | number | null
    snowfall24h?: FloatNullableWithAggregatesFilter<"Weather"> | number | null
    snowfall7d?: FloatNullableWithAggregatesFilter<"Weather"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Weather"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Weather"> | Date | string
  }

  export type EmployeeMountainAssignmentWhereInput = {
    AND?: EmployeeMountainAssignmentWhereInput | EmployeeMountainAssignmentWhereInput[]
    OR?: EmployeeMountainAssignmentWhereInput[]
    NOT?: EmployeeMountainAssignmentWhereInput | EmployeeMountainAssignmentWhereInput[]
    id?: StringFilter<"EmployeeMountainAssignment"> | string
    employeeId?: StringFilter<"EmployeeMountainAssignment"> | string
    mountainId?: StringFilter<"EmployeeMountainAssignment"> | string
    assignedAt?: DateTimeFilter<"EmployeeMountainAssignment"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
  }

  export type EmployeeMountainAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    assignedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    mountain?: MountainOrderByWithRelationInput
  }

  export type EmployeeMountainAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId_mountainId?: EmployeeMountainAssignmentEmployeeIdMountainIdCompoundUniqueInput
    AND?: EmployeeMountainAssignmentWhereInput | EmployeeMountainAssignmentWhereInput[]
    OR?: EmployeeMountainAssignmentWhereInput[]
    NOT?: EmployeeMountainAssignmentWhereInput | EmployeeMountainAssignmentWhereInput[]
    employeeId?: StringFilter<"EmployeeMountainAssignment"> | string
    mountainId?: StringFilter<"EmployeeMountainAssignment"> | string
    assignedAt?: DateTimeFilter<"EmployeeMountainAssignment"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
  }, "id" | "employeeId_mountainId">

  export type EmployeeMountainAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    assignedAt?: SortOrder
    _count?: EmployeeMountainAssignmentCountOrderByAggregateInput
    _max?: EmployeeMountainAssignmentMaxOrderByAggregateInput
    _min?: EmployeeMountainAssignmentMinOrderByAggregateInput
  }

  export type EmployeeMountainAssignmentScalarWhereWithAggregatesInput = {
    AND?: EmployeeMountainAssignmentScalarWhereWithAggregatesInput | EmployeeMountainAssignmentScalarWhereWithAggregatesInput[]
    OR?: EmployeeMountainAssignmentScalarWhereWithAggregatesInput[]
    NOT?: EmployeeMountainAssignmentScalarWhereWithAggregatesInput | EmployeeMountainAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmployeeMountainAssignment"> | string
    employeeId?: StringWithAggregatesFilter<"EmployeeMountainAssignment"> | string
    mountainId?: StringWithAggregatesFilter<"EmployeeMountainAssignment"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"EmployeeMountainAssignment"> | Date | string
  }

  export type DispatcherAssignmentWhereInput = {
    AND?: DispatcherAssignmentWhereInput | DispatcherAssignmentWhereInput[]
    OR?: DispatcherAssignmentWhereInput[]
    NOT?: DispatcherAssignmentWhereInput | DispatcherAssignmentWhereInput[]
    id?: StringFilter<"DispatcherAssignment"> | string
    employeeId?: StringFilter<"DispatcherAssignment"> | string
    mountainId?: StringFilter<"DispatcherAssignment"> | string
    assignedAt?: DateTimeFilter<"DispatcherAssignment"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
  }

  export type DispatcherAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    assignedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    mountain?: MountainOrderByWithRelationInput
  }

  export type DispatcherAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId_mountainId_assignedAt?: DispatcherAssignmentEmployeeIdMountainIdAssignedAtCompoundUniqueInput
    AND?: DispatcherAssignmentWhereInput | DispatcherAssignmentWhereInput[]
    OR?: DispatcherAssignmentWhereInput[]
    NOT?: DispatcherAssignmentWhereInput | DispatcherAssignmentWhereInput[]
    employeeId?: StringFilter<"DispatcherAssignment"> | string
    mountainId?: StringFilter<"DispatcherAssignment"> | string
    assignedAt?: DateTimeFilter<"DispatcherAssignment"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
  }, "id" | "employeeId_mountainId_assignedAt">

  export type DispatcherAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    assignedAt?: SortOrder
    _count?: DispatcherAssignmentCountOrderByAggregateInput
    _max?: DispatcherAssignmentMaxOrderByAggregateInput
    _min?: DispatcherAssignmentMinOrderByAggregateInput
  }

  export type DispatcherAssignmentScalarWhereWithAggregatesInput = {
    AND?: DispatcherAssignmentScalarWhereWithAggregatesInput | DispatcherAssignmentScalarWhereWithAggregatesInput[]
    OR?: DispatcherAssignmentScalarWhereWithAggregatesInput[]
    NOT?: DispatcherAssignmentScalarWhereWithAggregatesInput | DispatcherAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DispatcherAssignment"> | string
    employeeId?: StringWithAggregatesFilter<"DispatcherAssignment"> | string
    mountainId?: StringWithAggregatesFilter<"DispatcherAssignment"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"DispatcherAssignment"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    department?: EnumDEPARTMENTFilter<"Role"> | $Enums.DEPARTMENT
    name?: StringFilter<"Role"> | string
    title?: StringFilter<"Role"> | string
    position?: StringFilter<"Role"> | string
    level?: IntNullableFilter<"Role"> | number | null
    permissions?: StringNullableListFilter<"Role">
    employees?: EmployeeListRelationFilter
    employeeRole?: EmployeeRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    department?: SortOrder
    name?: SortOrder
    title?: SortOrder
    position?: SortOrder
    level?: SortOrderInput | SortOrder
    permissions?: SortOrder
    employees?: EmployeeOrderByRelationAggregateInput
    employeeRole?: EmployeeRoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    department_name?: RoleDepartmentNameCompoundUniqueInput
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    department?: EnumDEPARTMENTFilter<"Role"> | $Enums.DEPARTMENT
    name?: StringFilter<"Role"> | string
    title?: StringFilter<"Role"> | string
    position?: StringFilter<"Role"> | string
    level?: IntNullableFilter<"Role"> | number | null
    permissions?: StringNullableListFilter<"Role">
    employees?: EmployeeListRelationFilter
    employeeRole?: EmployeeRoleListRelationFilter
  }, "id" | "department_name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    department?: SortOrder
    name?: SortOrder
    title?: SortOrder
    position?: SortOrder
    level?: SortOrderInput | SortOrder
    permissions?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    department?: EnumDEPARTMENTWithAggregatesFilter<"Role"> | $Enums.DEPARTMENT
    name?: StringWithAggregatesFilter<"Role"> | string
    title?: StringWithAggregatesFilter<"Role"> | string
    position?: StringWithAggregatesFilter<"Role"> | string
    level?: IntNullableWithAggregatesFilter<"Role"> | number | null
    permissions?: StringNullableListFilter<"Role">
  }

  export type EmployeeRoleWhereInput = {
    AND?: EmployeeRoleWhereInput | EmployeeRoleWhereInput[]
    OR?: EmployeeRoleWhereInput[]
    NOT?: EmployeeRoleWhereInput | EmployeeRoleWhereInput[]
    id?: StringFilter<"EmployeeRole"> | string
    employeeId?: StringFilter<"EmployeeRole"> | string
    roleId?: StringFilter<"EmployeeRole"> | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type EmployeeRoleOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    roleId?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type EmployeeRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId_roleId?: EmployeeRoleEmployeeIdRoleIdCompoundUniqueInput
    AND?: EmployeeRoleWhereInput | EmployeeRoleWhereInput[]
    OR?: EmployeeRoleWhereInput[]
    NOT?: EmployeeRoleWhereInput | EmployeeRoleWhereInput[]
    employeeId?: StringFilter<"EmployeeRole"> | string
    roleId?: StringFilter<"EmployeeRole"> | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "id" | "employeeId_roleId">

  export type EmployeeRoleOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    roleId?: SortOrder
    _count?: EmployeeRoleCountOrderByAggregateInput
    _max?: EmployeeRoleMaxOrderByAggregateInput
    _min?: EmployeeRoleMinOrderByAggregateInput
  }

  export type EmployeeRoleScalarWhereWithAggregatesInput = {
    AND?: EmployeeRoleScalarWhereWithAggregatesInput | EmployeeRoleScalarWhereWithAggregatesInput[]
    OR?: EmployeeRoleScalarWhereWithAggregatesInput[]
    NOT?: EmployeeRoleScalarWhereWithAggregatesInput | EmployeeRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmployeeRole"> | string
    employeeId?: StringWithAggregatesFilter<"EmployeeRole"> | string
    roleId?: StringWithAggregatesFilter<"EmployeeRole"> | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: StringFilter<"Employee"> | string
    employeeIdNumber?: IntFilter<"Employee"> | number
    email?: StringFilter<"Employee"> | string
    phoneNumber?: StringFilter<"Employee"> | string
    name?: StringFilter<"Employee"> | string
    roleId?: StringNullableFilter<"Employee"> | string | null
    role?: XOR<RoleNullableScalarRelationFilter, RoleWhereInput> | null
    additionalRoles?: EmployeeRoleListRelationFilter
    mountainAssignments?: EmployeeMountainAssignmentListRelationFilter
    dispatcherAssignments?: DispatcherAssignmentListRelationFilter
    incidents?: IncidentListRelationFilter
    aidRoomChecks?: AidRoomCheckListRelationFilter
    hutChecks?: HutCheckListRelationFilter
    liftChecks?: LiftCheckListRelationFilter
    trailChecks?: TrailCheckListRelationFilter
    equipmentChecks?: EquipmentCheckListRelationFilter
    equipmentServiceLogs?: EquipmentServiceLogListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    employeeIdNumber?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    roleId?: SortOrderInput | SortOrder
    role?: RoleOrderByWithRelationInput
    additionalRoles?: EmployeeRoleOrderByRelationAggregateInput
    mountainAssignments?: EmployeeMountainAssignmentOrderByRelationAggregateInput
    dispatcherAssignments?: DispatcherAssignmentOrderByRelationAggregateInput
    incidents?: IncidentOrderByRelationAggregateInput
    aidRoomChecks?: AidRoomCheckOrderByRelationAggregateInput
    hutChecks?: HutCheckOrderByRelationAggregateInput
    liftChecks?: LiftCheckOrderByRelationAggregateInput
    trailChecks?: TrailCheckOrderByRelationAggregateInput
    equipmentChecks?: EquipmentCheckOrderByRelationAggregateInput
    equipmentServiceLogs?: EquipmentServiceLogOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeIdNumber?: number
    email?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    phoneNumber?: StringFilter<"Employee"> | string
    name?: StringFilter<"Employee"> | string
    roleId?: StringNullableFilter<"Employee"> | string | null
    role?: XOR<RoleNullableScalarRelationFilter, RoleWhereInput> | null
    additionalRoles?: EmployeeRoleListRelationFilter
    mountainAssignments?: EmployeeMountainAssignmentListRelationFilter
    dispatcherAssignments?: DispatcherAssignmentListRelationFilter
    incidents?: IncidentListRelationFilter
    aidRoomChecks?: AidRoomCheckListRelationFilter
    hutChecks?: HutCheckListRelationFilter
    liftChecks?: LiftCheckListRelationFilter
    trailChecks?: TrailCheckListRelationFilter
    equipmentChecks?: EquipmentCheckListRelationFilter
    equipmentServiceLogs?: EquipmentServiceLogListRelationFilter
  }, "id" | "employeeIdNumber" | "email">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    employeeIdNumber?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    roleId?: SortOrderInput | SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Employee"> | string
    employeeIdNumber?: IntWithAggregatesFilter<"Employee"> | number
    email?: StringWithAggregatesFilter<"Employee"> | string
    phoneNumber?: StringWithAggregatesFilter<"Employee"> | string
    name?: StringWithAggregatesFilter<"Employee"> | string
    roleId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
  }

  export type LiftWhereInput = {
    AND?: LiftWhereInput | LiftWhereInput[]
    OR?: LiftWhereInput[]
    NOT?: LiftWhereInput | LiftWhereInput[]
    id?: StringFilter<"Lift"> | string
    mountainId?: StringFilter<"Lift"> | string
    name?: StringFilter<"Lift"> | string
    type?: EnumLIFT_TYPEFilter<"Lift"> | $Enums.LIFT_TYPE
    status?: EnumSTATUSFilter<"Lift"> | $Enums.STATUS
    capacity?: IntFilter<"Lift"> | number
    latitude?: DecimalNullableFilter<"Lift"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Lift"> | Decimal | DecimalJsLike | number | string | null
    locationId?: StringNullableFilter<"Lift"> | string | null
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    liftChecks?: LiftCheckListRelationFilter
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
  }

  export type LiftOrderByWithRelationInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    mountain?: MountainOrderByWithRelationInput
    liftChecks?: LiftCheckOrderByRelationAggregateInput
    location?: LocationOrderByWithRelationInput
  }

  export type LiftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    locationId?: string
    name_type?: LiftNameTypeCompoundUniqueInput
    mountainId_name?: LiftMountainIdNameCompoundUniqueInput
    AND?: LiftWhereInput | LiftWhereInput[]
    OR?: LiftWhereInput[]
    NOT?: LiftWhereInput | LiftWhereInput[]
    mountainId?: StringFilter<"Lift"> | string
    name?: StringFilter<"Lift"> | string
    type?: EnumLIFT_TYPEFilter<"Lift"> | $Enums.LIFT_TYPE
    status?: EnumSTATUSFilter<"Lift"> | $Enums.STATUS
    capacity?: IntFilter<"Lift"> | number
    latitude?: DecimalNullableFilter<"Lift"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Lift"> | Decimal | DecimalJsLike | number | string | null
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    liftChecks?: LiftCheckListRelationFilter
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
  }, "id" | "locationId" | "name_type" | "mountainId_name">

  export type LiftOrderByWithAggregationInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    _count?: LiftCountOrderByAggregateInput
    _avg?: LiftAvgOrderByAggregateInput
    _max?: LiftMaxOrderByAggregateInput
    _min?: LiftMinOrderByAggregateInput
    _sum?: LiftSumOrderByAggregateInput
  }

  export type LiftScalarWhereWithAggregatesInput = {
    AND?: LiftScalarWhereWithAggregatesInput | LiftScalarWhereWithAggregatesInput[]
    OR?: LiftScalarWhereWithAggregatesInput[]
    NOT?: LiftScalarWhereWithAggregatesInput | LiftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lift"> | string
    mountainId?: StringWithAggregatesFilter<"Lift"> | string
    name?: StringWithAggregatesFilter<"Lift"> | string
    type?: EnumLIFT_TYPEWithAggregatesFilter<"Lift"> | $Enums.LIFT_TYPE
    status?: EnumSTATUSWithAggregatesFilter<"Lift"> | $Enums.STATUS
    capacity?: IntWithAggregatesFilter<"Lift"> | number
    latitude?: DecimalNullableWithAggregatesFilter<"Lift"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"Lift"> | Decimal | DecimalJsLike | number | string | null
    locationId?: StringNullableWithAggregatesFilter<"Lift"> | string | null
  }

  export type TrailWhereInput = {
    AND?: TrailWhereInput | TrailWhereInput[]
    OR?: TrailWhereInput[]
    NOT?: TrailWhereInput | TrailWhereInput[]
    id?: StringFilter<"Trail"> | string
    mountainId?: StringFilter<"Trail"> | string
    name?: StringFilter<"Trail"> | string
    difficulty?: EnumTRAIL_DIFFICULTYFilter<"Trail"> | $Enums.TRAIL_DIFFICULTY
    status?: EnumSTATUSFilter<"Trail"> | $Enums.STATUS
    length?: FloatFilter<"Trail"> | number
    latitude?: DecimalNullableFilter<"Trail"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Trail"> | Decimal | DecimalJsLike | number | string | null
    condition?: EnumTRAIL_CONDITIONFilter<"Trail"> | $Enums.TRAIL_CONDITION
    locationId?: StringNullableFilter<"Trail"> | string | null
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    trailChecks?: TrailCheckListRelationFilter
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
  }

  export type TrailOrderByWithRelationInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    length?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    condition?: SortOrder
    locationId?: SortOrderInput | SortOrder
    mountain?: MountainOrderByWithRelationInput
    trailChecks?: TrailCheckOrderByRelationAggregateInput
    location?: LocationOrderByWithRelationInput
  }

  export type TrailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    locationId?: string
    mountainId_name?: TrailMountainIdNameCompoundUniqueInput
    AND?: TrailWhereInput | TrailWhereInput[]
    OR?: TrailWhereInput[]
    NOT?: TrailWhereInput | TrailWhereInput[]
    mountainId?: StringFilter<"Trail"> | string
    name?: StringFilter<"Trail"> | string
    difficulty?: EnumTRAIL_DIFFICULTYFilter<"Trail"> | $Enums.TRAIL_DIFFICULTY
    status?: EnumSTATUSFilter<"Trail"> | $Enums.STATUS
    length?: FloatFilter<"Trail"> | number
    latitude?: DecimalNullableFilter<"Trail"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Trail"> | Decimal | DecimalJsLike | number | string | null
    condition?: EnumTRAIL_CONDITIONFilter<"Trail"> | $Enums.TRAIL_CONDITION
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    trailChecks?: TrailCheckListRelationFilter
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
  }, "id" | "locationId" | "mountainId_name">

  export type TrailOrderByWithAggregationInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    length?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    condition?: SortOrder
    locationId?: SortOrderInput | SortOrder
    _count?: TrailCountOrderByAggregateInput
    _avg?: TrailAvgOrderByAggregateInput
    _max?: TrailMaxOrderByAggregateInput
    _min?: TrailMinOrderByAggregateInput
    _sum?: TrailSumOrderByAggregateInput
  }

  export type TrailScalarWhereWithAggregatesInput = {
    AND?: TrailScalarWhereWithAggregatesInput | TrailScalarWhereWithAggregatesInput[]
    OR?: TrailScalarWhereWithAggregatesInput[]
    NOT?: TrailScalarWhereWithAggregatesInput | TrailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Trail"> | string
    mountainId?: StringWithAggregatesFilter<"Trail"> | string
    name?: StringWithAggregatesFilter<"Trail"> | string
    difficulty?: EnumTRAIL_DIFFICULTYWithAggregatesFilter<"Trail"> | $Enums.TRAIL_DIFFICULTY
    status?: EnumSTATUSWithAggregatesFilter<"Trail"> | $Enums.STATUS
    length?: FloatWithAggregatesFilter<"Trail"> | number
    latitude?: DecimalNullableWithAggregatesFilter<"Trail"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"Trail"> | Decimal | DecimalJsLike | number | string | null
    condition?: EnumTRAIL_CONDITIONWithAggregatesFilter<"Trail"> | $Enums.TRAIL_CONDITION
    locationId?: StringNullableWithAggregatesFilter<"Trail"> | string | null
  }

  export type LodgeWhereInput = {
    AND?: LodgeWhereInput | LodgeWhereInput[]
    OR?: LodgeWhereInput[]
    NOT?: LodgeWhereInput | LodgeWhereInput[]
    id?: StringFilter<"Lodge"> | string
    mountainId?: StringFilter<"Lodge"> | string
    name?: StringFilter<"Lodge"> | string
    capacity?: IntFilter<"Lodge"> | number
    latitude?: DecimalNullableFilter<"Lodge"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Lodge"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumSTATUSFilter<"Lodge"> | $Enums.STATUS
    locationId?: StringNullableFilter<"Lodge"> | string | null
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
  }

  export type LodgeOrderByWithRelationInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    status?: SortOrder
    locationId?: SortOrderInput | SortOrder
    mountain?: MountainOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
  }

  export type LodgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    locationId?: string
    mountainId_name?: LodgeMountainIdNameCompoundUniqueInput
    AND?: LodgeWhereInput | LodgeWhereInput[]
    OR?: LodgeWhereInput[]
    NOT?: LodgeWhereInput | LodgeWhereInput[]
    mountainId?: StringFilter<"Lodge"> | string
    name?: StringFilter<"Lodge"> | string
    capacity?: IntFilter<"Lodge"> | number
    latitude?: DecimalNullableFilter<"Lodge"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Lodge"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumSTATUSFilter<"Lodge"> | $Enums.STATUS
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
  }, "id" | "locationId" | "mountainId_name">

  export type LodgeOrderByWithAggregationInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    status?: SortOrder
    locationId?: SortOrderInput | SortOrder
    _count?: LodgeCountOrderByAggregateInput
    _avg?: LodgeAvgOrderByAggregateInput
    _max?: LodgeMaxOrderByAggregateInput
    _min?: LodgeMinOrderByAggregateInput
    _sum?: LodgeSumOrderByAggregateInput
  }

  export type LodgeScalarWhereWithAggregatesInput = {
    AND?: LodgeScalarWhereWithAggregatesInput | LodgeScalarWhereWithAggregatesInput[]
    OR?: LodgeScalarWhereWithAggregatesInput[]
    NOT?: LodgeScalarWhereWithAggregatesInput | LodgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lodge"> | string
    mountainId?: StringWithAggregatesFilter<"Lodge"> | string
    name?: StringWithAggregatesFilter<"Lodge"> | string
    capacity?: IntWithAggregatesFilter<"Lodge"> | number
    latitude?: DecimalNullableWithAggregatesFilter<"Lodge"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"Lodge"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumSTATUSWithAggregatesFilter<"Lodge"> | $Enums.STATUS
    locationId?: StringNullableWithAggregatesFilter<"Lodge"> | string | null
  }

  export type HutWhereInput = {
    AND?: HutWhereInput | HutWhereInput[]
    OR?: HutWhereInput[]
    NOT?: HutWhereInput | HutWhereInput[]
    id?: StringFilter<"Hut"> | string
    mountainId?: StringFilter<"Hut"> | string
    name?: StringFilter<"Hut"> | string
    status?: EnumSTATUSFilter<"Hut"> | $Enums.STATUS
    latitude?: DecimalNullableFilter<"Hut"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Hut"> | Decimal | DecimalJsLike | number | string | null
    locationId?: StringNullableFilter<"Hut"> | string | null
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    hutChecks?: HutCheckListRelationFilter
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
  }

  export type HutOrderByWithRelationInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    mountain?: MountainOrderByWithRelationInput
    hutChecks?: HutCheckOrderByRelationAggregateInput
    location?: LocationOrderByWithRelationInput
  }

  export type HutWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    locationId?: string
    mountainId_name?: HutMountainIdNameCompoundUniqueInput
    AND?: HutWhereInput | HutWhereInput[]
    OR?: HutWhereInput[]
    NOT?: HutWhereInput | HutWhereInput[]
    mountainId?: StringFilter<"Hut"> | string
    name?: StringFilter<"Hut"> | string
    status?: EnumSTATUSFilter<"Hut"> | $Enums.STATUS
    latitude?: DecimalNullableFilter<"Hut"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Hut"> | Decimal | DecimalJsLike | number | string | null
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    hutChecks?: HutCheckListRelationFilter
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
  }, "id" | "locationId" | "mountainId_name">

  export type HutOrderByWithAggregationInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    _count?: HutCountOrderByAggregateInput
    _avg?: HutAvgOrderByAggregateInput
    _max?: HutMaxOrderByAggregateInput
    _min?: HutMinOrderByAggregateInput
    _sum?: HutSumOrderByAggregateInput
  }

  export type HutScalarWhereWithAggregatesInput = {
    AND?: HutScalarWhereWithAggregatesInput | HutScalarWhereWithAggregatesInput[]
    OR?: HutScalarWhereWithAggregatesInput[]
    NOT?: HutScalarWhereWithAggregatesInput | HutScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Hut"> | string
    mountainId?: StringWithAggregatesFilter<"Hut"> | string
    name?: StringWithAggregatesFilter<"Hut"> | string
    status?: EnumSTATUSWithAggregatesFilter<"Hut"> | $Enums.STATUS
    latitude?: DecimalNullableWithAggregatesFilter<"Hut"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"Hut"> | Decimal | DecimalJsLike | number | string | null
    locationId?: StringNullableWithAggregatesFilter<"Hut"> | string | null
  }

  export type AidRoomWhereInput = {
    AND?: AidRoomWhereInput | AidRoomWhereInput[]
    OR?: AidRoomWhereInput[]
    NOT?: AidRoomWhereInput | AidRoomWhereInput[]
    id?: StringFilter<"AidRoom"> | string
    mountainId?: StringFilter<"AidRoom"> | string
    name?: StringFilter<"AidRoom"> | string
    status?: EnumSTATUSFilter<"AidRoom"> | $Enums.STATUS
    latitude?: DecimalNullableFilter<"AidRoom"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"AidRoom"> | Decimal | DecimalJsLike | number | string | null
    locationId?: StringNullableFilter<"AidRoom"> | string | null
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    aidRoomChecks?: AidRoomCheckListRelationFilter
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
  }

  export type AidRoomOrderByWithRelationInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    mountain?: MountainOrderByWithRelationInput
    aidRoomChecks?: AidRoomCheckOrderByRelationAggregateInput
    location?: LocationOrderByWithRelationInput
  }

  export type AidRoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    locationId?: string
    mountainId_name?: AidRoomMountainIdNameCompoundUniqueInput
    AND?: AidRoomWhereInput | AidRoomWhereInput[]
    OR?: AidRoomWhereInput[]
    NOT?: AidRoomWhereInput | AidRoomWhereInput[]
    mountainId?: StringFilter<"AidRoom"> | string
    name?: StringFilter<"AidRoom"> | string
    status?: EnumSTATUSFilter<"AidRoom"> | $Enums.STATUS
    latitude?: DecimalNullableFilter<"AidRoom"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"AidRoom"> | Decimal | DecimalJsLike | number | string | null
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    aidRoomChecks?: AidRoomCheckListRelationFilter
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
  }, "id" | "locationId" | "mountainId_name">

  export type AidRoomOrderByWithAggregationInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    _count?: AidRoomCountOrderByAggregateInput
    _avg?: AidRoomAvgOrderByAggregateInput
    _max?: AidRoomMaxOrderByAggregateInput
    _min?: AidRoomMinOrderByAggregateInput
    _sum?: AidRoomSumOrderByAggregateInput
  }

  export type AidRoomScalarWhereWithAggregatesInput = {
    AND?: AidRoomScalarWhereWithAggregatesInput | AidRoomScalarWhereWithAggregatesInput[]
    OR?: AidRoomScalarWhereWithAggregatesInput[]
    NOT?: AidRoomScalarWhereWithAggregatesInput | AidRoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AidRoom"> | string
    mountainId?: StringWithAggregatesFilter<"AidRoom"> | string
    name?: StringWithAggregatesFilter<"AidRoom"> | string
    status?: EnumSTATUSWithAggregatesFilter<"AidRoom"> | $Enums.STATUS
    latitude?: DecimalNullableWithAggregatesFilter<"AidRoom"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"AidRoom"> | Decimal | DecimalJsLike | number | string | null
    locationId?: StringNullableWithAggregatesFilter<"AidRoom"> | string | null
  }

  export type EquipmentServiceLogWhereInput = {
    AND?: EquipmentServiceLogWhereInput | EquipmentServiceLogWhereInput[]
    OR?: EquipmentServiceLogWhereInput[]
    NOT?: EquipmentServiceLogWhereInput | EquipmentServiceLogWhereInput[]
    id?: StringFilter<"EquipmentServiceLog"> | string
    mountainId?: StringFilter<"EquipmentServiceLog"> | string
    equipmentId?: StringFilter<"EquipmentServiceLog"> | string
    employeeId?: StringNullableFilter<"EquipmentServiceLog"> | string | null
    status?: EnumEQUIPMENT_STATUSFilter<"EquipmentServiceLog"> | $Enums.EQUIPMENT_STATUS
    changedAt?: DateTimeFilter<"EquipmentServiceLog"> | Date | string
    notes?: StringNullableFilter<"EquipmentServiceLog"> | string | null
    createdAt?: DateTimeFilter<"EquipmentServiceLog"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentServiceLog"> | Date | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
  }

  export type EquipmentServiceLogOrderByWithRelationInput = {
    id?: SortOrder
    mountainId?: SortOrder
    equipmentId?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    status?: SortOrder
    changedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mountain?: MountainOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
    equipment?: EquipmentOrderByWithRelationInput
  }

  export type EquipmentServiceLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EquipmentServiceLogWhereInput | EquipmentServiceLogWhereInput[]
    OR?: EquipmentServiceLogWhereInput[]
    NOT?: EquipmentServiceLogWhereInput | EquipmentServiceLogWhereInput[]
    mountainId?: StringFilter<"EquipmentServiceLog"> | string
    equipmentId?: StringFilter<"EquipmentServiceLog"> | string
    employeeId?: StringNullableFilter<"EquipmentServiceLog"> | string | null
    status?: EnumEQUIPMENT_STATUSFilter<"EquipmentServiceLog"> | $Enums.EQUIPMENT_STATUS
    changedAt?: DateTimeFilter<"EquipmentServiceLog"> | Date | string
    notes?: StringNullableFilter<"EquipmentServiceLog"> | string | null
    createdAt?: DateTimeFilter<"EquipmentServiceLog"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentServiceLog"> | Date | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
  }, "id">

  export type EquipmentServiceLogOrderByWithAggregationInput = {
    id?: SortOrder
    mountainId?: SortOrder
    equipmentId?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    status?: SortOrder
    changedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EquipmentServiceLogCountOrderByAggregateInput
    _max?: EquipmentServiceLogMaxOrderByAggregateInput
    _min?: EquipmentServiceLogMinOrderByAggregateInput
  }

  export type EquipmentServiceLogScalarWhereWithAggregatesInput = {
    AND?: EquipmentServiceLogScalarWhereWithAggregatesInput | EquipmentServiceLogScalarWhereWithAggregatesInput[]
    OR?: EquipmentServiceLogScalarWhereWithAggregatesInput[]
    NOT?: EquipmentServiceLogScalarWhereWithAggregatesInput | EquipmentServiceLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EquipmentServiceLog"> | string
    mountainId?: StringWithAggregatesFilter<"EquipmentServiceLog"> | string
    equipmentId?: StringWithAggregatesFilter<"EquipmentServiceLog"> | string
    employeeId?: StringNullableWithAggregatesFilter<"EquipmentServiceLog"> | string | null
    status?: EnumEQUIPMENT_STATUSWithAggregatesFilter<"EquipmentServiceLog"> | $Enums.EQUIPMENT_STATUS
    changedAt?: DateTimeWithAggregatesFilter<"EquipmentServiceLog"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"EquipmentServiceLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EquipmentServiceLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EquipmentServiceLog"> | Date | string
  }

  export type EquipmentWhereInput = {
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    id?: StringFilter<"Equipment"> | string
    name?: StringFilter<"Equipment"> | string
    type?: StringFilter<"Equipment"> | string
    status?: EnumEQUIPMENT_STATUSFilter<"Equipment"> | $Enums.EQUIPMENT_STATUS
    number?: IntNullableFilter<"Equipment"> | number | null
    description?: StringNullableFilter<"Equipment"> | string | null
    picture?: StringNullableFilter<"Equipment"> | string | null
    cost?: FloatNullableFilter<"Equipment"> | number | null
    latitude?: DecimalNullableFilter<"Equipment"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Equipment"> | Decimal | DecimalJsLike | number | string | null
    mountainId?: StringNullableFilter<"Equipment"> | string | null
    locationId?: StringNullableFilter<"Equipment"> | string | null
    dateAdded?: DateTimeFilter<"Equipment"> | Date | string
    mountain?: XOR<MountainNullableScalarRelationFilter, MountainWhereInput> | null
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogListRelationFilter
    equipmentChecks?: EquipmentCheckListRelationFilter
    equipmentServiceLogs?: EquipmentServiceLogListRelationFilter
  }

  export type EquipmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    number?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    mountainId?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    dateAdded?: SortOrder
    mountain?: MountainOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogOrderByRelationAggregateInput
    equipmentChecks?: EquipmentCheckOrderByRelationAggregateInput
    equipmentServiceLogs?: EquipmentServiceLogOrderByRelationAggregateInput
  }

  export type EquipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    locationId?: string
    mountainId_number?: EquipmentMountainIdNumberCompoundUniqueInput
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    name?: StringFilter<"Equipment"> | string
    type?: StringFilter<"Equipment"> | string
    status?: EnumEQUIPMENT_STATUSFilter<"Equipment"> | $Enums.EQUIPMENT_STATUS
    number?: IntNullableFilter<"Equipment"> | number | null
    description?: StringNullableFilter<"Equipment"> | string | null
    picture?: StringNullableFilter<"Equipment"> | string | null
    cost?: FloatNullableFilter<"Equipment"> | number | null
    latitude?: DecimalNullableFilter<"Equipment"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Equipment"> | Decimal | DecimalJsLike | number | string | null
    mountainId?: StringNullableFilter<"Equipment"> | string | null
    dateAdded?: DateTimeFilter<"Equipment"> | Date | string
    mountain?: XOR<MountainNullableScalarRelationFilter, MountainWhereInput> | null
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogListRelationFilter
    equipmentChecks?: EquipmentCheckListRelationFilter
    equipmentServiceLogs?: EquipmentServiceLogListRelationFilter
  }, "id" | "locationId" | "mountainId_number">

  export type EquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    number?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    mountainId?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    dateAdded?: SortOrder
    _count?: EquipmentCountOrderByAggregateInput
    _avg?: EquipmentAvgOrderByAggregateInput
    _max?: EquipmentMaxOrderByAggregateInput
    _min?: EquipmentMinOrderByAggregateInput
    _sum?: EquipmentSumOrderByAggregateInput
  }

  export type EquipmentScalarWhereWithAggregatesInput = {
    AND?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    OR?: EquipmentScalarWhereWithAggregatesInput[]
    NOT?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Equipment"> | string
    name?: StringWithAggregatesFilter<"Equipment"> | string
    type?: StringWithAggregatesFilter<"Equipment"> | string
    status?: EnumEQUIPMENT_STATUSWithAggregatesFilter<"Equipment"> | $Enums.EQUIPMENT_STATUS
    number?: IntNullableWithAggregatesFilter<"Equipment"> | number | null
    description?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    picture?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    cost?: FloatNullableWithAggregatesFilter<"Equipment"> | number | null
    latitude?: DecimalNullableWithAggregatesFilter<"Equipment"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"Equipment"> | Decimal | DecimalJsLike | number | string | null
    mountainId?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    locationId?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    dateAdded?: DateTimeWithAggregatesFilter<"Equipment"> | Date | string
  }

  export type IncidentWhereInput = {
    AND?: IncidentWhereInput | IncidentWhereInput[]
    OR?: IncidentWhereInput[]
    NOT?: IncidentWhereInput | IncidentWhereInput[]
    id?: StringFilter<"Incident"> | string
    description?: StringFilter<"Incident"> | string
    status?: EnumINCIDENT_STATUSFilter<"Incident"> | $Enums.INCIDENT_STATUS
    latitude?: DecimalNullableFilter<"Incident"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Incident"> | Decimal | DecimalJsLike | number | string | null
    mountainId?: StringFilter<"Incident"> | string
    startTime?: DateTimeFilter<"Incident"> | Date | string
    endTime?: DateTimeNullableFilter<"Incident"> | Date | string | null
    onSceneTime?: DateTimeNullableFilter<"Incident"> | Date | string | null
    stableTime?: DateTimeNullableFilter<"Incident"> | Date | string | null
    transportTime?: DateTimeNullableFilter<"Incident"> | Date | string | null
    emptyRun?: BoolFilter<"Incident"> | boolean
    emptyRunAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    locationId?: StringFilter<"Incident"> | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogListRelationFilter
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    employees?: EmployeeListRelationFilter
  }

  export type IncidentOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    mountainId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    onSceneTime?: SortOrderInput | SortOrder
    stableTime?: SortOrderInput | SortOrder
    transportTime?: SortOrderInput | SortOrder
    emptyRun?: SortOrder
    emptyRunAt?: SortOrderInput | SortOrder
    locationId?: SortOrder
    mountain?: MountainOrderByWithRelationInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogOrderByRelationAggregateInput
    location?: LocationOrderByWithRelationInput
    employees?: EmployeeOrderByRelationAggregateInput
  }

  export type IncidentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncidentWhereInput | IncidentWhereInput[]
    OR?: IncidentWhereInput[]
    NOT?: IncidentWhereInput | IncidentWhereInput[]
    description?: StringFilter<"Incident"> | string
    status?: EnumINCIDENT_STATUSFilter<"Incident"> | $Enums.INCIDENT_STATUS
    latitude?: DecimalNullableFilter<"Incident"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Incident"> | Decimal | DecimalJsLike | number | string | null
    mountainId?: StringFilter<"Incident"> | string
    startTime?: DateTimeFilter<"Incident"> | Date | string
    endTime?: DateTimeNullableFilter<"Incident"> | Date | string | null
    onSceneTime?: DateTimeNullableFilter<"Incident"> | Date | string | null
    stableTime?: DateTimeNullableFilter<"Incident"> | Date | string | null
    transportTime?: DateTimeNullableFilter<"Incident"> | Date | string | null
    emptyRun?: BoolFilter<"Incident"> | boolean
    emptyRunAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    locationId?: StringFilter<"Incident"> | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogListRelationFilter
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    employees?: EmployeeListRelationFilter
  }, "id">

  export type IncidentOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    mountainId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    onSceneTime?: SortOrderInput | SortOrder
    stableTime?: SortOrderInput | SortOrder
    transportTime?: SortOrderInput | SortOrder
    emptyRun?: SortOrder
    emptyRunAt?: SortOrderInput | SortOrder
    locationId?: SortOrder
    _count?: IncidentCountOrderByAggregateInput
    _avg?: IncidentAvgOrderByAggregateInput
    _max?: IncidentMaxOrderByAggregateInput
    _min?: IncidentMinOrderByAggregateInput
    _sum?: IncidentSumOrderByAggregateInput
  }

  export type IncidentScalarWhereWithAggregatesInput = {
    AND?: IncidentScalarWhereWithAggregatesInput | IncidentScalarWhereWithAggregatesInput[]
    OR?: IncidentScalarWhereWithAggregatesInput[]
    NOT?: IncidentScalarWhereWithAggregatesInput | IncidentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Incident"> | string
    description?: StringWithAggregatesFilter<"Incident"> | string
    status?: EnumINCIDENT_STATUSWithAggregatesFilter<"Incident"> | $Enums.INCIDENT_STATUS
    latitude?: DecimalNullableWithAggregatesFilter<"Incident"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"Incident"> | Decimal | DecimalJsLike | number | string | null
    mountainId?: StringWithAggregatesFilter<"Incident"> | string
    startTime?: DateTimeWithAggregatesFilter<"Incident"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"Incident"> | Date | string | null
    onSceneTime?: DateTimeNullableWithAggregatesFilter<"Incident"> | Date | string | null
    stableTime?: DateTimeNullableWithAggregatesFilter<"Incident"> | Date | string | null
    transportTime?: DateTimeNullableWithAggregatesFilter<"Incident"> | Date | string | null
    emptyRun?: BoolWithAggregatesFilter<"Incident"> | boolean
    emptyRunAt?: DateTimeNullableWithAggregatesFilter<"Incident"> | Date | string | null
    locationId?: StringWithAggregatesFilter<"Incident"> | string
  }

  export type IncidentEquipmentUsageLogWhereInput = {
    AND?: IncidentEquipmentUsageLogWhereInput | IncidentEquipmentUsageLogWhereInput[]
    OR?: IncidentEquipmentUsageLogWhereInput[]
    NOT?: IncidentEquipmentUsageLogWhereInput | IncidentEquipmentUsageLogWhereInput[]
    id?: StringFilter<"IncidentEquipmentUsageLog"> | string
    usedAt?: DateTimeFilter<"IncidentEquipmentUsageLog"> | Date | string
    notes?: StringNullableFilter<"IncidentEquipmentUsageLog"> | string | null
    mountainId?: StringFilter<"IncidentEquipmentUsageLog"> | string
    equipmentId?: StringFilter<"IncidentEquipmentUsageLog"> | string
    incidentId?: StringFilter<"IncidentEquipmentUsageLog"> | string
    createdAt?: DateTimeFilter<"IncidentEquipmentUsageLog"> | Date | string
    updatedAt?: DateTimeFilter<"IncidentEquipmentUsageLog"> | Date | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    incident?: XOR<IncidentScalarRelationFilter, IncidentWhereInput>
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
  }

  export type IncidentEquipmentUsageLogOrderByWithRelationInput = {
    id?: SortOrder
    usedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    mountainId?: SortOrder
    equipmentId?: SortOrder
    incidentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mountain?: MountainOrderByWithRelationInput
    incident?: IncidentOrderByWithRelationInput
    equipment?: EquipmentOrderByWithRelationInput
  }

  export type IncidentEquipmentUsageLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncidentEquipmentUsageLogWhereInput | IncidentEquipmentUsageLogWhereInput[]
    OR?: IncidentEquipmentUsageLogWhereInput[]
    NOT?: IncidentEquipmentUsageLogWhereInput | IncidentEquipmentUsageLogWhereInput[]
    usedAt?: DateTimeFilter<"IncidentEquipmentUsageLog"> | Date | string
    notes?: StringNullableFilter<"IncidentEquipmentUsageLog"> | string | null
    mountainId?: StringFilter<"IncidentEquipmentUsageLog"> | string
    equipmentId?: StringFilter<"IncidentEquipmentUsageLog"> | string
    incidentId?: StringFilter<"IncidentEquipmentUsageLog"> | string
    createdAt?: DateTimeFilter<"IncidentEquipmentUsageLog"> | Date | string
    updatedAt?: DateTimeFilter<"IncidentEquipmentUsageLog"> | Date | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    incident?: XOR<IncidentScalarRelationFilter, IncidentWhereInput>
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
  }, "id">

  export type IncidentEquipmentUsageLogOrderByWithAggregationInput = {
    id?: SortOrder
    usedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    mountainId?: SortOrder
    equipmentId?: SortOrder
    incidentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IncidentEquipmentUsageLogCountOrderByAggregateInput
    _max?: IncidentEquipmentUsageLogMaxOrderByAggregateInput
    _min?: IncidentEquipmentUsageLogMinOrderByAggregateInput
  }

  export type IncidentEquipmentUsageLogScalarWhereWithAggregatesInput = {
    AND?: IncidentEquipmentUsageLogScalarWhereWithAggregatesInput | IncidentEquipmentUsageLogScalarWhereWithAggregatesInput[]
    OR?: IncidentEquipmentUsageLogScalarWhereWithAggregatesInput[]
    NOT?: IncidentEquipmentUsageLogScalarWhereWithAggregatesInput | IncidentEquipmentUsageLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IncidentEquipmentUsageLog"> | string
    usedAt?: DateTimeWithAggregatesFilter<"IncidentEquipmentUsageLog"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"IncidentEquipmentUsageLog"> | string | null
    mountainId?: StringWithAggregatesFilter<"IncidentEquipmentUsageLog"> | string
    equipmentId?: StringWithAggregatesFilter<"IncidentEquipmentUsageLog"> | string
    incidentId?: StringWithAggregatesFilter<"IncidentEquipmentUsageLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"IncidentEquipmentUsageLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IncidentEquipmentUsageLog"> | Date | string
  }

  export type LiftCheckWhereInput = {
    AND?: LiftCheckWhereInput | LiftCheckWhereInput[]
    OR?: LiftCheckWhereInput[]
    NOT?: LiftCheckWhereInput | LiftCheckWhereInput[]
    id?: StringFilter<"LiftCheck"> | string
    recordedAt?: DateTimeFilter<"LiftCheck"> | Date | string
    employeeId?: StringFilter<"LiftCheck"> | string
    mountainId?: StringFilter<"LiftCheck"> | string
    liftId?: StringFilter<"LiftCheck"> | string
    notes?: StringNullableFilter<"LiftCheck"> | string | null
    createdAt?: DateTimeFilter<"LiftCheck"> | Date | string
    updatedAt?: DateTimeFilter<"LiftCheck"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    lift?: XOR<LiftScalarRelationFilter, LiftWhereInput>
  }

  export type LiftCheckOrderByWithRelationInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    liftId?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    mountain?: MountainOrderByWithRelationInput
    lift?: LiftOrderByWithRelationInput
  }

  export type LiftCheckWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LiftCheckWhereInput | LiftCheckWhereInput[]
    OR?: LiftCheckWhereInput[]
    NOT?: LiftCheckWhereInput | LiftCheckWhereInput[]
    recordedAt?: DateTimeFilter<"LiftCheck"> | Date | string
    employeeId?: StringFilter<"LiftCheck"> | string
    mountainId?: StringFilter<"LiftCheck"> | string
    liftId?: StringFilter<"LiftCheck"> | string
    notes?: StringNullableFilter<"LiftCheck"> | string | null
    createdAt?: DateTimeFilter<"LiftCheck"> | Date | string
    updatedAt?: DateTimeFilter<"LiftCheck"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    lift?: XOR<LiftScalarRelationFilter, LiftWhereInput>
  }, "id">

  export type LiftCheckOrderByWithAggregationInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    liftId?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LiftCheckCountOrderByAggregateInput
    _max?: LiftCheckMaxOrderByAggregateInput
    _min?: LiftCheckMinOrderByAggregateInput
  }

  export type LiftCheckScalarWhereWithAggregatesInput = {
    AND?: LiftCheckScalarWhereWithAggregatesInput | LiftCheckScalarWhereWithAggregatesInput[]
    OR?: LiftCheckScalarWhereWithAggregatesInput[]
    NOT?: LiftCheckScalarWhereWithAggregatesInput | LiftCheckScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LiftCheck"> | string
    recordedAt?: DateTimeWithAggregatesFilter<"LiftCheck"> | Date | string
    employeeId?: StringWithAggregatesFilter<"LiftCheck"> | string
    mountainId?: StringWithAggregatesFilter<"LiftCheck"> | string
    liftId?: StringWithAggregatesFilter<"LiftCheck"> | string
    notes?: StringNullableWithAggregatesFilter<"LiftCheck"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LiftCheck"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LiftCheck"> | Date | string
  }

  export type TrailCheckWhereInput = {
    AND?: TrailCheckWhereInput | TrailCheckWhereInput[]
    OR?: TrailCheckWhereInput[]
    NOT?: TrailCheckWhereInput | TrailCheckWhereInput[]
    id?: StringFilter<"TrailCheck"> | string
    recordedAt?: DateTimeFilter<"TrailCheck"> | Date | string
    employeeId?: StringFilter<"TrailCheck"> | string
    mountainId?: StringFilter<"TrailCheck"> | string
    trailId?: StringFilter<"TrailCheck"> | string
    notes?: StringNullableFilter<"TrailCheck"> | string | null
    createdAt?: DateTimeFilter<"TrailCheck"> | Date | string
    updatedAt?: DateTimeFilter<"TrailCheck"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    trail?: XOR<TrailScalarRelationFilter, TrailWhereInput>
  }

  export type TrailCheckOrderByWithRelationInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    trailId?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    mountain?: MountainOrderByWithRelationInput
    trail?: TrailOrderByWithRelationInput
  }

  export type TrailCheckWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrailCheckWhereInput | TrailCheckWhereInput[]
    OR?: TrailCheckWhereInput[]
    NOT?: TrailCheckWhereInput | TrailCheckWhereInput[]
    recordedAt?: DateTimeFilter<"TrailCheck"> | Date | string
    employeeId?: StringFilter<"TrailCheck"> | string
    mountainId?: StringFilter<"TrailCheck"> | string
    trailId?: StringFilter<"TrailCheck"> | string
    notes?: StringNullableFilter<"TrailCheck"> | string | null
    createdAt?: DateTimeFilter<"TrailCheck"> | Date | string
    updatedAt?: DateTimeFilter<"TrailCheck"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    trail?: XOR<TrailScalarRelationFilter, TrailWhereInput>
  }, "id">

  export type TrailCheckOrderByWithAggregationInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    trailId?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrailCheckCountOrderByAggregateInput
    _max?: TrailCheckMaxOrderByAggregateInput
    _min?: TrailCheckMinOrderByAggregateInput
  }

  export type TrailCheckScalarWhereWithAggregatesInput = {
    AND?: TrailCheckScalarWhereWithAggregatesInput | TrailCheckScalarWhereWithAggregatesInput[]
    OR?: TrailCheckScalarWhereWithAggregatesInput[]
    NOT?: TrailCheckScalarWhereWithAggregatesInput | TrailCheckScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrailCheck"> | string
    recordedAt?: DateTimeWithAggregatesFilter<"TrailCheck"> | Date | string
    employeeId?: StringWithAggregatesFilter<"TrailCheck"> | string
    mountainId?: StringWithAggregatesFilter<"TrailCheck"> | string
    trailId?: StringWithAggregatesFilter<"TrailCheck"> | string
    notes?: StringNullableWithAggregatesFilter<"TrailCheck"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TrailCheck"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrailCheck"> | Date | string
  }

  export type HutCheckWhereInput = {
    AND?: HutCheckWhereInput | HutCheckWhereInput[]
    OR?: HutCheckWhereInput[]
    NOT?: HutCheckWhereInput | HutCheckWhereInput[]
    id?: StringFilter<"HutCheck"> | string
    recordedAt?: DateTimeFilter<"HutCheck"> | Date | string
    employeeId?: StringFilter<"HutCheck"> | string
    mountainId?: StringFilter<"HutCheck"> | string
    hutId?: StringFilter<"HutCheck"> | string
    notes?: StringNullableFilter<"HutCheck"> | string | null
    createdAt?: DateTimeFilter<"HutCheck"> | Date | string
    updatedAt?: DateTimeFilter<"HutCheck"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    hut?: XOR<HutScalarRelationFilter, HutWhereInput>
  }

  export type HutCheckOrderByWithRelationInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    hutId?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    mountain?: MountainOrderByWithRelationInput
    hut?: HutOrderByWithRelationInput
  }

  export type HutCheckWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HutCheckWhereInput | HutCheckWhereInput[]
    OR?: HutCheckWhereInput[]
    NOT?: HutCheckWhereInput | HutCheckWhereInput[]
    recordedAt?: DateTimeFilter<"HutCheck"> | Date | string
    employeeId?: StringFilter<"HutCheck"> | string
    mountainId?: StringFilter<"HutCheck"> | string
    hutId?: StringFilter<"HutCheck"> | string
    notes?: StringNullableFilter<"HutCheck"> | string | null
    createdAt?: DateTimeFilter<"HutCheck"> | Date | string
    updatedAt?: DateTimeFilter<"HutCheck"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    hut?: XOR<HutScalarRelationFilter, HutWhereInput>
  }, "id">

  export type HutCheckOrderByWithAggregationInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    hutId?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HutCheckCountOrderByAggregateInput
    _max?: HutCheckMaxOrderByAggregateInput
    _min?: HutCheckMinOrderByAggregateInput
  }

  export type HutCheckScalarWhereWithAggregatesInput = {
    AND?: HutCheckScalarWhereWithAggregatesInput | HutCheckScalarWhereWithAggregatesInput[]
    OR?: HutCheckScalarWhereWithAggregatesInput[]
    NOT?: HutCheckScalarWhereWithAggregatesInput | HutCheckScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HutCheck"> | string
    recordedAt?: DateTimeWithAggregatesFilter<"HutCheck"> | Date | string
    employeeId?: StringWithAggregatesFilter<"HutCheck"> | string
    mountainId?: StringWithAggregatesFilter<"HutCheck"> | string
    hutId?: StringWithAggregatesFilter<"HutCheck"> | string
    notes?: StringNullableWithAggregatesFilter<"HutCheck"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HutCheck"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HutCheck"> | Date | string
  }

  export type AidRoomCheckWhereInput = {
    AND?: AidRoomCheckWhereInput | AidRoomCheckWhereInput[]
    OR?: AidRoomCheckWhereInput[]
    NOT?: AidRoomCheckWhereInput | AidRoomCheckWhereInput[]
    id?: StringFilter<"AidRoomCheck"> | string
    recordedAt?: DateTimeFilter<"AidRoomCheck"> | Date | string
    employeeId?: StringFilter<"AidRoomCheck"> | string
    mountainId?: StringFilter<"AidRoomCheck"> | string
    aidRoomId?: StringFilter<"AidRoomCheck"> | string
    notes?: StringNullableFilter<"AidRoomCheck"> | string | null
    createdAt?: DateTimeFilter<"AidRoomCheck"> | Date | string
    updatedAt?: DateTimeFilter<"AidRoomCheck"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    aidRoom?: XOR<AidRoomScalarRelationFilter, AidRoomWhereInput>
  }

  export type AidRoomCheckOrderByWithRelationInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    aidRoomId?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    mountain?: MountainOrderByWithRelationInput
    aidRoom?: AidRoomOrderByWithRelationInput
  }

  export type AidRoomCheckWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AidRoomCheckWhereInput | AidRoomCheckWhereInput[]
    OR?: AidRoomCheckWhereInput[]
    NOT?: AidRoomCheckWhereInput | AidRoomCheckWhereInput[]
    recordedAt?: DateTimeFilter<"AidRoomCheck"> | Date | string
    employeeId?: StringFilter<"AidRoomCheck"> | string
    mountainId?: StringFilter<"AidRoomCheck"> | string
    aidRoomId?: StringFilter<"AidRoomCheck"> | string
    notes?: StringNullableFilter<"AidRoomCheck"> | string | null
    createdAt?: DateTimeFilter<"AidRoomCheck"> | Date | string
    updatedAt?: DateTimeFilter<"AidRoomCheck"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    aidRoom?: XOR<AidRoomScalarRelationFilter, AidRoomWhereInput>
  }, "id">

  export type AidRoomCheckOrderByWithAggregationInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    aidRoomId?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AidRoomCheckCountOrderByAggregateInput
    _max?: AidRoomCheckMaxOrderByAggregateInput
    _min?: AidRoomCheckMinOrderByAggregateInput
  }

  export type AidRoomCheckScalarWhereWithAggregatesInput = {
    AND?: AidRoomCheckScalarWhereWithAggregatesInput | AidRoomCheckScalarWhereWithAggregatesInput[]
    OR?: AidRoomCheckScalarWhereWithAggregatesInput[]
    NOT?: AidRoomCheckScalarWhereWithAggregatesInput | AidRoomCheckScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AidRoomCheck"> | string
    recordedAt?: DateTimeWithAggregatesFilter<"AidRoomCheck"> | Date | string
    employeeId?: StringWithAggregatesFilter<"AidRoomCheck"> | string
    mountainId?: StringWithAggregatesFilter<"AidRoomCheck"> | string
    aidRoomId?: StringWithAggregatesFilter<"AidRoomCheck"> | string
    notes?: StringNullableWithAggregatesFilter<"AidRoomCheck"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AidRoomCheck"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AidRoomCheck"> | Date | string
  }

  export type EquipmentCheckWhereInput = {
    AND?: EquipmentCheckWhereInput | EquipmentCheckWhereInput[]
    OR?: EquipmentCheckWhereInput[]
    NOT?: EquipmentCheckWhereInput | EquipmentCheckWhereInput[]
    id?: StringFilter<"EquipmentCheck"> | string
    recordedAt?: DateTimeFilter<"EquipmentCheck"> | Date | string
    employeeId?: StringFilter<"EquipmentCheck"> | string
    mountainId?: StringFilter<"EquipmentCheck"> | string
    equipmentId?: StringFilter<"EquipmentCheck"> | string
    notes?: StringNullableFilter<"EquipmentCheck"> | string | null
    createdAt?: DateTimeFilter<"EquipmentCheck"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentCheck"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
  }

  export type EquipmentCheckOrderByWithRelationInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    equipmentId?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    mountain?: MountainOrderByWithRelationInput
    equipment?: EquipmentOrderByWithRelationInput
  }

  export type EquipmentCheckWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EquipmentCheckWhereInput | EquipmentCheckWhereInput[]
    OR?: EquipmentCheckWhereInput[]
    NOT?: EquipmentCheckWhereInput | EquipmentCheckWhereInput[]
    recordedAt?: DateTimeFilter<"EquipmentCheck"> | Date | string
    employeeId?: StringFilter<"EquipmentCheck"> | string
    mountainId?: StringFilter<"EquipmentCheck"> | string
    equipmentId?: StringFilter<"EquipmentCheck"> | string
    notes?: StringNullableFilter<"EquipmentCheck"> | string | null
    createdAt?: DateTimeFilter<"EquipmentCheck"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentCheck"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
  }, "id">

  export type EquipmentCheckOrderByWithAggregationInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    equipmentId?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EquipmentCheckCountOrderByAggregateInput
    _max?: EquipmentCheckMaxOrderByAggregateInput
    _min?: EquipmentCheckMinOrderByAggregateInput
  }

  export type EquipmentCheckScalarWhereWithAggregatesInput = {
    AND?: EquipmentCheckScalarWhereWithAggregatesInput | EquipmentCheckScalarWhereWithAggregatesInput[]
    OR?: EquipmentCheckScalarWhereWithAggregatesInput[]
    NOT?: EquipmentCheckScalarWhereWithAggregatesInput | EquipmentCheckScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EquipmentCheck"> | string
    recordedAt?: DateTimeWithAggregatesFilter<"EquipmentCheck"> | Date | string
    employeeId?: StringWithAggregatesFilter<"EquipmentCheck"> | string
    mountainId?: StringWithAggregatesFilter<"EquipmentCheck"> | string
    equipmentId?: StringWithAggregatesFilter<"EquipmentCheck"> | string
    notes?: StringNullableWithAggregatesFilter<"EquipmentCheck"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EquipmentCheck"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EquipmentCheck"> | Date | string
  }

  export type AreaCreateInput = {
    id?: string
    name: string
    type: $Enums.AREA_TYPE
    description?: string | null
    mountain: MountainCreateNestedOneWithoutAreasInput
    locations?: LocationCreateNestedManyWithoutAreaInput
  }

  export type AreaUncheckedCreateInput = {
    id?: string
    mountainId: string
    name: string
    type: $Enums.AREA_TYPE
    description?: string | null
    locations?: LocationUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAREA_TYPEFieldUpdateOperationsInput | $Enums.AREA_TYPE
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mountain?: MountainUpdateOneRequiredWithoutAreasNestedInput
    locations?: LocationUpdateManyWithoutAreaNestedInput
  }

  export type AreaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAREA_TYPEFieldUpdateOperationsInput | $Enums.AREA_TYPE
    description?: NullableStringFieldUpdateOperationsInput | string | null
    locations?: LocationUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type AreaCreateManyInput = {
    id?: string
    mountainId: string
    name: string
    type: $Enums.AREA_TYPE
    description?: string | null
  }

  export type AreaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAREA_TYPEFieldUpdateOperationsInput | $Enums.AREA_TYPE
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AreaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAREA_TYPEFieldUpdateOperationsInput | $Enums.AREA_TYPE
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationCreateInput = {
    id?: string
    name: string
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    area?: AreaCreateNestedOneWithoutLocationsInput
    mountain: MountainCreateNestedOneWithoutLocationsInput
    lift?: LiftCreateNestedOneWithoutLocationInput
    trail?: TrailCreateNestedOneWithoutLocationInput
    hut?: HutCreateNestedOneWithoutLocationInput
    lodge?: LodgeCreateNestedOneWithoutLocationInput
    aidRoom?: AidRoomCreateNestedOneWithoutLocationInput
    hours?: HoursCreateNestedManyWithoutLocationInput
    equipment?: EquipmentCreateNestedManyWithoutLocationInput
    incidents?: IncidentCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    mountainId: string
    name: string
    areaId?: string | null
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    lift?: LiftUncheckedCreateNestedOneWithoutLocationInput
    trail?: TrailUncheckedCreateNestedOneWithoutLocationInput
    hut?: HutUncheckedCreateNestedOneWithoutLocationInput
    lodge?: LodgeUncheckedCreateNestedOneWithoutLocationInput
    aidRoom?: AidRoomUncheckedCreateNestedOneWithoutLocationInput
    hours?: HoursUncheckedCreateNestedManyWithoutLocationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutLocationInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
    area?: AreaUpdateOneWithoutLocationsNestedInput
    mountain?: MountainUpdateOneRequiredWithoutLocationsNestedInput
    lift?: LiftUpdateOneWithoutLocationNestedInput
    trail?: TrailUpdateOneWithoutLocationNestedInput
    hut?: HutUpdateOneWithoutLocationNestedInput
    lodge?: LodgeUpdateOneWithoutLocationNestedInput
    aidRoom?: AidRoomUpdateOneWithoutLocationNestedInput
    hours?: HoursUpdateManyWithoutLocationNestedInput
    equipment?: EquipmentUpdateManyWithoutLocationNestedInput
    incidents?: IncidentUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
    lift?: LiftUncheckedUpdateOneWithoutLocationNestedInput
    trail?: TrailUncheckedUpdateOneWithoutLocationNestedInput
    hut?: HutUncheckedUpdateOneWithoutLocationNestedInput
    lodge?: LodgeUncheckedUpdateOneWithoutLocationNestedInput
    aidRoom?: AidRoomUncheckedUpdateOneWithoutLocationNestedInput
    hours?: HoursUncheckedUpdateManyWithoutLocationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutLocationNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: string
    mountainId: string
    name: string
    areaId?: string | null
    entityId: string
    entityType: $Enums.LOCATION_TYPE
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
  }

  export type HoursCreateInput = {
    id?: string
    dayOfWeek?: number | null
    date?: Date | string | null
    openTime?: Date | string | null
    closeTime?: Date | string | null
    status?: $Enums.STATUS
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutHoursInput
  }

  export type HoursUncheckedCreateInput = {
    id?: string
    locationId: string
    dayOfWeek?: number | null
    date?: Date | string | null
    openTime?: Date | string | null
    closeTime?: Date | string | null
    status?: $Enums.STATUS
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HoursUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutHoursNestedInput
  }

  export type HoursUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoursCreateManyInput = {
    id?: string
    locationId: string
    dayOfWeek?: number | null
    date?: Date | string | null
    openTime?: Date | string | null
    closeTime?: Date | string | null
    status?: $Enums.STATUS
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HoursUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoursUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MountainCreateInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherCreateNestedManyWithoutMountainInput
    locations?: LocationCreateNestedManyWithoutMountainInput
    areas?: AreaCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    lifts?: LiftCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
    locations?: LocationUncheckedCreateNestedManyWithoutMountainInput
    areas?: AreaUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUpdateManyWithoutMountainNestedInput
    locations?: LocationUpdateManyWithoutMountainNestedInput
    areas?: AreaUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMountainNestedInput
    areas?: AreaUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type MountainCreateManyInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
  }

  export type MountainUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MountainUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WeatherCreateInput = {
    id?: string
    date?: Date | string
    temperature: number
    windSpeed: number
    windDirection?: string | null
    visibility?: number | null
    conditions: string
    snowfallRecent?: number | null
    snowfall24h?: number | null
    snowfall7d?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mountain: MountainCreateNestedOneWithoutWeatherInput
  }

  export type WeatherUncheckedCreateInput = {
    id?: string
    mountainId: string
    date?: Date | string
    temperature: number
    windSpeed: number
    windDirection?: string | null
    visibility?: number | null
    conditions: string
    snowfallRecent?: number | null
    snowfall24h?: number | null
    snowfall7d?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeatherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    windSpeed?: FloatFieldUpdateOperationsInput | number
    windDirection?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: NullableFloatFieldUpdateOperationsInput | number | null
    conditions?: StringFieldUpdateOperationsInput | string
    snowfallRecent?: NullableFloatFieldUpdateOperationsInput | number | null
    snowfall24h?: NullableFloatFieldUpdateOperationsInput | number | null
    snowfall7d?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountain?: MountainUpdateOneRequiredWithoutWeatherNestedInput
  }

  export type WeatherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    windSpeed?: FloatFieldUpdateOperationsInput | number
    windDirection?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: NullableFloatFieldUpdateOperationsInput | number | null
    conditions?: StringFieldUpdateOperationsInput | string
    snowfallRecent?: NullableFloatFieldUpdateOperationsInput | number | null
    snowfall24h?: NullableFloatFieldUpdateOperationsInput | number | null
    snowfall7d?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherCreateManyInput = {
    id?: string
    mountainId: string
    date?: Date | string
    temperature: number
    windSpeed: number
    windDirection?: string | null
    visibility?: number | null
    conditions: string
    snowfallRecent?: number | null
    snowfall24h?: number | null
    snowfall7d?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeatherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    windSpeed?: FloatFieldUpdateOperationsInput | number
    windDirection?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: NullableFloatFieldUpdateOperationsInput | number | null
    conditions?: StringFieldUpdateOperationsInput | string
    snowfallRecent?: NullableFloatFieldUpdateOperationsInput | number | null
    snowfall24h?: NullableFloatFieldUpdateOperationsInput | number | null
    snowfall7d?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    windSpeed?: FloatFieldUpdateOperationsInput | number
    windDirection?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: NullableFloatFieldUpdateOperationsInput | number | null
    conditions?: StringFieldUpdateOperationsInput | string
    snowfallRecent?: NullableFloatFieldUpdateOperationsInput | number | null
    snowfall24h?: NullableFloatFieldUpdateOperationsInput | number | null
    snowfall7d?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeMountainAssignmentCreateInput = {
    id?: string
    assignedAt: Date | string
    employee: EmployeeCreateNestedOneWithoutMountainAssignmentsInput
    mountain: MountainCreateNestedOneWithoutEmployeeAssignmentsInput
  }

  export type EmployeeMountainAssignmentUncheckedCreateInput = {
    id?: string
    employeeId: string
    mountainId: string
    assignedAt: Date | string
  }

  export type EmployeeMountainAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutMountainAssignmentsNestedInput
    mountain?: MountainUpdateOneRequiredWithoutEmployeeAssignmentsNestedInput
  }

  export type EmployeeMountainAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeMountainAssignmentCreateManyInput = {
    id?: string
    employeeId: string
    mountainId: string
    assignedAt: Date | string
  }

  export type EmployeeMountainAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeMountainAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatcherAssignmentCreateInput = {
    id?: string
    assignedAt: Date | string
    employee: EmployeeCreateNestedOneWithoutDispatcherAssignmentsInput
    mountain: MountainCreateNestedOneWithoutDispatcherAssignmentsInput
  }

  export type DispatcherAssignmentUncheckedCreateInput = {
    id?: string
    employeeId: string
    mountainId: string
    assignedAt: Date | string
  }

  export type DispatcherAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutDispatcherAssignmentsNestedInput
    mountain?: MountainUpdateOneRequiredWithoutDispatcherAssignmentsNestedInput
  }

  export type DispatcherAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatcherAssignmentCreateManyInput = {
    id?: string
    employeeId: string
    mountainId: string
    assignedAt: Date | string
  }

  export type DispatcherAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatcherAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    department: $Enums.DEPARTMENT
    name: string
    title: string
    position: string
    level?: number | null
    permissions?: RoleCreatepermissionsInput | string[]
    employees?: EmployeeCreateNestedManyWithoutRoleInput
    employeeRole?: EmployeeRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    department: $Enums.DEPARTMENT
    name: string
    title: string
    position: string
    level?: number | null
    permissions?: RoleCreatepermissionsInput | string[]
    employees?: EmployeeUncheckedCreateNestedManyWithoutRoleInput
    employeeRole?: EmployeeRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: EnumDEPARTMENTFieldUpdateOperationsInput | $Enums.DEPARTMENT
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    permissions?: RoleUpdatepermissionsInput | string[]
    employees?: EmployeeUpdateManyWithoutRoleNestedInput
    employeeRole?: EmployeeRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: EnumDEPARTMENTFieldUpdateOperationsInput | $Enums.DEPARTMENT
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    permissions?: RoleUpdatepermissionsInput | string[]
    employees?: EmployeeUncheckedUpdateManyWithoutRoleNestedInput
    employeeRole?: EmployeeRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    department: $Enums.DEPARTMENT
    name: string
    title: string
    position: string
    level?: number | null
    permissions?: RoleCreatepermissionsInput | string[]
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: EnumDEPARTMENTFieldUpdateOperationsInput | $Enums.DEPARTMENT
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    permissions?: RoleUpdatepermissionsInput | string[]
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: EnumDEPARTMENTFieldUpdateOperationsInput | $Enums.DEPARTMENT
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    permissions?: RoleUpdatepermissionsInput | string[]
  }

  export type EmployeeRoleCreateInput = {
    id?: string
    employee: EmployeeCreateNestedOneWithoutAdditionalRolesInput
    role: RoleCreateNestedOneWithoutEmployeeRoleInput
  }

  export type EmployeeRoleUncheckedCreateInput = {
    id?: string
    employeeId: string
    roleId: string
  }

  export type EmployeeRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee?: EmployeeUpdateOneRequiredWithoutAdditionalRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutEmployeeRoleNestedInput
  }

  export type EmployeeRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeRoleCreateManyInput = {
    id?: string
    employeeId: string
    roleId: string
  }

  export type EmployeeRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeCreateInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    role?: RoleCreateNestedOneWithoutEmployeesInput
    additionalRoles?: EmployeeRoleCreateNestedManyWithoutEmployeeInput
    mountainAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutEmployeeInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutEmployeeInput
    incidents?: IncidentCreateNestedManyWithoutEmployeesInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEmployeeInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    roleId?: string | null
    additionalRoles?: EmployeeRoleUncheckedCreateNestedManyWithoutEmployeeInput
    mountainAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutEmployeesInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: RoleUpdateOneWithoutEmployeesNestedInput
    additionalRoles?: EmployeeRoleUpdateManyWithoutEmployeeNestedInput
    mountainAssignments?: EmployeeMountainAssignmentUpdateManyWithoutEmployeeNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutEmployeeNestedInput
    incidents?: IncidentUpdateManyWithoutEmployeesNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEmployeeNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalRoles?: EmployeeRoleUncheckedUpdateManyWithoutEmployeeNestedInput
    mountainAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutEmployeesNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    roleId?: string | null
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LiftCreateInput = {
    id?: string
    name: string
    type: $Enums.LIFT_TYPE
    status?: $Enums.STATUS
    capacity: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    mountain: MountainCreateNestedOneWithoutLiftsInput
    liftChecks?: LiftCheckCreateNestedManyWithoutLiftInput
    location?: LocationCreateNestedOneWithoutLiftInput
  }

  export type LiftUncheckedCreateInput = {
    id?: string
    mountainId: string
    name: string
    type: $Enums.LIFT_TYPE
    status?: $Enums.STATUS
    capacity: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    locationId?: string | null
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutLiftInput
  }

  export type LiftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLIFT_TYPEFieldUpdateOperationsInput | $Enums.LIFT_TYPE
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    capacity?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountain?: MountainUpdateOneRequiredWithoutLiftsNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutLiftNestedInput
    location?: LocationUpdateOneWithoutLiftNestedInput
  }

  export type LiftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLIFT_TYPEFieldUpdateOperationsInput | $Enums.LIFT_TYPE
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    capacity?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutLiftNestedInput
  }

  export type LiftCreateManyInput = {
    id?: string
    mountainId: string
    name: string
    type: $Enums.LIFT_TYPE
    status?: $Enums.STATUS
    capacity: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    locationId?: string | null
  }

  export type LiftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLIFT_TYPEFieldUpdateOperationsInput | $Enums.LIFT_TYPE
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    capacity?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type LiftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLIFT_TYPEFieldUpdateOperationsInput | $Enums.LIFT_TYPE
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    capacity?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrailCreateInput = {
    id?: string
    name: string
    difficulty: $Enums.TRAIL_DIFFICULTY
    status?: $Enums.STATUS
    length: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    condition?: $Enums.TRAIL_CONDITION
    mountain: MountainCreateNestedOneWithoutTrailsInput
    trailChecks?: TrailCheckCreateNestedManyWithoutTrailInput
    location?: LocationCreateNestedOneWithoutTrailInput
  }

  export type TrailUncheckedCreateInput = {
    id?: string
    mountainId: string
    name: string
    difficulty: $Enums.TRAIL_DIFFICULTY
    status?: $Enums.STATUS
    length: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    condition?: $Enums.TRAIL_CONDITION
    locationId?: string | null
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutTrailInput
  }

  export type TrailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumTRAIL_DIFFICULTYFieldUpdateOperationsInput | $Enums.TRAIL_DIFFICULTY
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    length?: FloatFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition?: EnumTRAIL_CONDITIONFieldUpdateOperationsInput | $Enums.TRAIL_CONDITION
    mountain?: MountainUpdateOneRequiredWithoutTrailsNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutTrailNestedInput
    location?: LocationUpdateOneWithoutTrailNestedInput
  }

  export type TrailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumTRAIL_DIFFICULTYFieldUpdateOperationsInput | $Enums.TRAIL_DIFFICULTY
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    length?: FloatFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition?: EnumTRAIL_CONDITIONFieldUpdateOperationsInput | $Enums.TRAIL_CONDITION
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutTrailNestedInput
  }

  export type TrailCreateManyInput = {
    id?: string
    mountainId: string
    name: string
    difficulty: $Enums.TRAIL_DIFFICULTY
    status?: $Enums.STATUS
    length: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    condition?: $Enums.TRAIL_CONDITION
    locationId?: string | null
  }

  export type TrailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumTRAIL_DIFFICULTYFieldUpdateOperationsInput | $Enums.TRAIL_DIFFICULTY
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    length?: FloatFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition?: EnumTRAIL_CONDITIONFieldUpdateOperationsInput | $Enums.TRAIL_CONDITION
  }

  export type TrailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumTRAIL_DIFFICULTYFieldUpdateOperationsInput | $Enums.TRAIL_DIFFICULTY
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    length?: FloatFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition?: EnumTRAIL_CONDITIONFieldUpdateOperationsInput | $Enums.TRAIL_CONDITION
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LodgeCreateInput = {
    id?: string
    name: string
    capacity: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.STATUS
    mountain: MountainCreateNestedOneWithoutLodgesInput
    location?: LocationCreateNestedOneWithoutLodgeInput
  }

  export type LodgeUncheckedCreateInput = {
    id?: string
    mountainId: string
    name: string
    capacity: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.STATUS
    locationId?: string | null
  }

  export type LodgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    mountain?: MountainUpdateOneRequiredWithoutLodgesNestedInput
    location?: LocationUpdateOneWithoutLodgeNestedInput
  }

  export type LodgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LodgeCreateManyInput = {
    id?: string
    mountainId: string
    name: string
    capacity: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.STATUS
    locationId?: string | null
  }

  export type LodgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
  }

  export type LodgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HutCreateInput = {
    id?: string
    name: string
    status?: $Enums.STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    mountain: MountainCreateNestedOneWithoutHutsInput
    hutChecks?: HutCheckCreateNestedManyWithoutHutInput
    location?: LocationCreateNestedOneWithoutHutInput
  }

  export type HutUncheckedCreateInput = {
    id?: string
    mountainId: string
    name: string
    status?: $Enums.STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    locationId?: string | null
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutHutInput
  }

  export type HutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountain?: MountainUpdateOneRequiredWithoutHutsNestedInput
    hutChecks?: HutCheckUpdateManyWithoutHutNestedInput
    location?: LocationUpdateOneWithoutHutNestedInput
  }

  export type HutUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    hutChecks?: HutCheckUncheckedUpdateManyWithoutHutNestedInput
  }

  export type HutCreateManyInput = {
    id?: string
    mountainId: string
    name: string
    status?: $Enums.STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    locationId?: string | null
  }

  export type HutUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type HutUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AidRoomCreateInput = {
    id?: string
    name: string
    status?: $Enums.STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    mountain: MountainCreateNestedOneWithoutAidRoomsInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutAidRoomInput
    location?: LocationCreateNestedOneWithoutAidRoomInput
  }

  export type AidRoomUncheckedCreateInput = {
    id?: string
    mountainId: string
    name: string
    status?: $Enums.STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    locationId?: string | null
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutAidRoomInput
  }

  export type AidRoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountain?: MountainUpdateOneRequiredWithoutAidRoomsNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutAidRoomNestedInput
    location?: LocationUpdateOneWithoutAidRoomNestedInput
  }

  export type AidRoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutAidRoomNestedInput
  }

  export type AidRoomCreateManyInput = {
    id?: string
    mountainId: string
    name: string
    status?: $Enums.STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    locationId?: string | null
  }

  export type AidRoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type AidRoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipmentServiceLogCreateInput = {
    id?: string
    status?: $Enums.EQUIPMENT_STATUS
    changedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mountain: MountainCreateNestedOneWithoutEquipmentServiceLogsInput
    employee?: EmployeeCreateNestedOneWithoutEquipmentServiceLogsInput
    equipment: EquipmentCreateNestedOneWithoutEquipmentServiceLogsInput
  }

  export type EquipmentServiceLogUncheckedCreateInput = {
    id?: string
    mountainId: string
    equipmentId: string
    employeeId?: string | null
    status?: $Enums.EQUIPMENT_STATUS
    changedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentServiceLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountain?: MountainUpdateOneRequiredWithoutEquipmentServiceLogsNestedInput
    employee?: EmployeeUpdateOneWithoutEquipmentServiceLogsNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutEquipmentServiceLogsNestedInput
  }

  export type EquipmentServiceLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentServiceLogCreateManyInput = {
    id?: string
    mountainId: string
    equipmentId: string
    employeeId?: string | null
    status?: $Enums.EQUIPMENT_STATUS
    changedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentServiceLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentServiceLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCreateInput = {
    id?: string
    name: string
    type: string
    status?: $Enums.EQUIPMENT_STATUS
    number?: number | null
    description?: string | null
    picture?: string | null
    cost?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    dateAdded?: Date | string
    mountain?: MountainCreateNestedOneWithoutEquipmentInput
    location?: LocationCreateNestedOneWithoutEquipmentInput
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogCreateNestedManyWithoutEquipmentInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEquipmentInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    status?: $Enums.EQUIPMENT_STATUS
    number?: number | null
    description?: string | null
    picture?: string | null
    cost?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    mountainId?: string | null
    locationId?: string | null
    dateAdded?: Date | string
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutEquipmentInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEquipmentInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    number?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateAdded?: DateTimeFieldUpdateOperationsInput | Date | string
    mountain?: MountainUpdateOneWithoutEquipmentNestedInput
    location?: LocationUpdateOneWithoutEquipmentNestedInput
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogUpdateManyWithoutEquipmentNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEquipmentNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    number?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountainId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    dateAdded?: DateTimeFieldUpdateOperationsInput | Date | string
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutEquipmentNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEquipmentNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentCreateManyInput = {
    id?: string
    name: string
    type: string
    status?: $Enums.EQUIPMENT_STATUS
    number?: number | null
    description?: string | null
    picture?: string | null
    cost?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    mountainId?: string | null
    locationId?: string | null
    dateAdded?: Date | string
  }

  export type EquipmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    number?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateAdded?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    number?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountainId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    dateAdded?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentCreateInput = {
    id?: string
    description: string
    status?: $Enums.INCIDENT_STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    startTime?: Date | string
    endTime?: Date | string | null
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    emptyRun?: boolean
    emptyRunAt?: Date | string | null
    mountain: MountainCreateNestedOneWithoutIncidentsInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutIncidentInput
    location: LocationCreateNestedOneWithoutIncidentsInput
    employees?: EmployeeCreateNestedManyWithoutIncidentsInput
  }

  export type IncidentUncheckedCreateInput = {
    id?: string
    description: string
    status?: $Enums.INCIDENT_STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    mountainId: string
    startTime?: Date | string
    endTime?: Date | string | null
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    emptyRun?: boolean
    emptyRunAt?: Date | string | null
    locationId: string
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutIncidentInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutIncidentsInput
  }

  export type IncidentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumINCIDENT_STATUSFieldUpdateOperationsInput | $Enums.INCIDENT_STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emptyRun?: BoolFieldUpdateOperationsInput | boolean
    emptyRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mountain?: MountainUpdateOneRequiredWithoutIncidentsNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutIncidentNestedInput
    location?: LocationUpdateOneRequiredWithoutIncidentsNestedInput
    employees?: EmployeeUpdateManyWithoutIncidentsNestedInput
  }

  export type IncidentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumINCIDENT_STATUSFieldUpdateOperationsInput | $Enums.INCIDENT_STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountainId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emptyRun?: BoolFieldUpdateOperationsInput | boolean
    emptyRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutIncidentNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutIncidentsNestedInput
  }

  export type IncidentCreateManyInput = {
    id?: string
    description: string
    status?: $Enums.INCIDENT_STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    mountainId: string
    startTime?: Date | string
    endTime?: Date | string | null
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    emptyRun?: boolean
    emptyRunAt?: Date | string | null
    locationId: string
  }

  export type IncidentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumINCIDENT_STATUSFieldUpdateOperationsInput | $Enums.INCIDENT_STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emptyRun?: BoolFieldUpdateOperationsInput | boolean
    emptyRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IncidentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumINCIDENT_STATUSFieldUpdateOperationsInput | $Enums.INCIDENT_STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountainId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emptyRun?: BoolFieldUpdateOperationsInput | boolean
    emptyRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
  }

  export type IncidentEquipmentUsageLogCreateInput = {
    id?: string
    usedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mountain: MountainCreateNestedOneWithoutIncidentEquipmentUsageLogInput
    incident: IncidentCreateNestedOneWithoutIncidentEquipmentUsageLogInput
    equipment: EquipmentCreateNestedOneWithoutIncidentEquipmentUsageLogsInput
  }

  export type IncidentEquipmentUsageLogUncheckedCreateInput = {
    id?: string
    usedAt?: Date | string
    notes?: string | null
    mountainId: string
    equipmentId: string
    incidentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentEquipmentUsageLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountain?: MountainUpdateOneRequiredWithoutIncidentEquipmentUsageLogNestedInput
    incident?: IncidentUpdateOneRequiredWithoutIncidentEquipmentUsageLogNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutIncidentEquipmentUsageLogsNestedInput
  }

  export type IncidentEquipmentUsageLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mountainId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentEquipmentUsageLogCreateManyInput = {
    id?: string
    usedAt?: Date | string
    notes?: string | null
    mountainId: string
    equipmentId: string
    incidentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentEquipmentUsageLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentEquipmentUsageLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mountainId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiftCheckCreateInput = {
    id?: string
    recordedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutLiftChecksInput
    mountain: MountainCreateNestedOneWithoutLiftChecksInput
    lift: LiftCreateNestedOneWithoutLiftChecksInput
  }

  export type LiftCheckUncheckedCreateInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    mountainId: string
    liftId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiftCheckUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutLiftChecksNestedInput
    mountain?: MountainUpdateOneRequiredWithoutLiftChecksNestedInput
    lift?: LiftUpdateOneRequiredWithoutLiftChecksNestedInput
  }

  export type LiftCheckUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    liftId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiftCheckCreateManyInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    mountainId: string
    liftId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiftCheckUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiftCheckUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    liftId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrailCheckCreateInput = {
    id?: string
    recordedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutTrailChecksInput
    mountain: MountainCreateNestedOneWithoutTrailChecksInput
    trail: TrailCreateNestedOneWithoutTrailChecksInput
  }

  export type TrailCheckUncheckedCreateInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    mountainId: string
    trailId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrailCheckUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutTrailChecksNestedInput
    mountain?: MountainUpdateOneRequiredWithoutTrailChecksNestedInput
    trail?: TrailUpdateOneRequiredWithoutTrailChecksNestedInput
  }

  export type TrailCheckUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    trailId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrailCheckCreateManyInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    mountainId: string
    trailId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrailCheckUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrailCheckUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    trailId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HutCheckCreateInput = {
    id?: string
    recordedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutHutChecksInput
    mountain: MountainCreateNestedOneWithoutHutChecksInput
    hut: HutCreateNestedOneWithoutHutChecksInput
  }

  export type HutCheckUncheckedCreateInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    mountainId: string
    hutId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HutCheckUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutHutChecksNestedInput
    mountain?: MountainUpdateOneRequiredWithoutHutChecksNestedInput
    hut?: HutUpdateOneRequiredWithoutHutChecksNestedInput
  }

  export type HutCheckUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    hutId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HutCheckCreateManyInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    mountainId: string
    hutId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HutCheckUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HutCheckUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    hutId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AidRoomCheckCreateInput = {
    id?: string
    recordedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutAidRoomChecksInput
    mountain: MountainCreateNestedOneWithoutAidRoomChecksInput
    aidRoom: AidRoomCreateNestedOneWithoutAidRoomChecksInput
  }

  export type AidRoomCheckUncheckedCreateInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    mountainId: string
    aidRoomId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AidRoomCheckUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutAidRoomChecksNestedInput
    mountain?: MountainUpdateOneRequiredWithoutAidRoomChecksNestedInput
    aidRoom?: AidRoomUpdateOneRequiredWithoutAidRoomChecksNestedInput
  }

  export type AidRoomCheckUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    aidRoomId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AidRoomCheckCreateManyInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    mountainId: string
    aidRoomId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AidRoomCheckUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AidRoomCheckUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    aidRoomId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCheckCreateInput = {
    id?: string
    recordedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutEquipmentChecksInput
    mountain: MountainCreateNestedOneWithoutEquipmentChecksInput
    equipment: EquipmentCreateNestedOneWithoutEquipmentChecksInput
  }

  export type EquipmentCheckUncheckedCreateInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    mountainId: string
    equipmentId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentCheckUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutEquipmentChecksNestedInput
    mountain?: MountainUpdateOneRequiredWithoutEquipmentChecksNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutEquipmentChecksNestedInput
  }

  export type EquipmentCheckUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCheckCreateManyInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    mountainId: string
    equipmentId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentCheckUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCheckUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumAREA_TYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.AREA_TYPE | EnumAREA_TYPEFieldRefInput<$PrismaModel>
    in?: $Enums.AREA_TYPE[] | ListEnumAREA_TYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.AREA_TYPE[] | ListEnumAREA_TYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumAREA_TYPEFilter<$PrismaModel> | $Enums.AREA_TYPE
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type MountainScalarRelationFilter = {
    is?: MountainWhereInput
    isNot?: MountainWhereInput
  }

  export type LocationListRelationFilter = {
    every?: LocationWhereInput
    some?: LocationWhereInput
    none?: LocationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type LocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AreaNameTypeCompoundUniqueInput = {
    name: string
    type: $Enums.AREA_TYPE
  }

  export type AreaCountOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
  }

  export type AreaMaxOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
  }

  export type AreaMinOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumAREA_TYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AREA_TYPE | EnumAREA_TYPEFieldRefInput<$PrismaModel>
    in?: $Enums.AREA_TYPE[] | ListEnumAREA_TYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.AREA_TYPE[] | ListEnumAREA_TYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumAREA_TYPEWithAggregatesFilter<$PrismaModel> | $Enums.AREA_TYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAREA_TYPEFilter<$PrismaModel>
    _max?: NestedEnumAREA_TYPEFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumLOCATION_TYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.LOCATION_TYPE | EnumLOCATION_TYPEFieldRefInput<$PrismaModel>
    in?: $Enums.LOCATION_TYPE[] | ListEnumLOCATION_TYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.LOCATION_TYPE[] | ListEnumLOCATION_TYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumLOCATION_TYPEFilter<$PrismaModel> | $Enums.LOCATION_TYPE
  }

  export type AreaNullableScalarRelationFilter = {
    is?: AreaWhereInput | null
    isNot?: AreaWhereInput | null
  }

  export type LiftNullableScalarRelationFilter = {
    is?: LiftWhereInput | null
    isNot?: LiftWhereInput | null
  }

  export type TrailNullableScalarRelationFilter = {
    is?: TrailWhereInput | null
    isNot?: TrailWhereInput | null
  }

  export type HutNullableScalarRelationFilter = {
    is?: HutWhereInput | null
    isNot?: HutWhereInput | null
  }

  export type LodgeNullableScalarRelationFilter = {
    is?: LodgeWhereInput | null
    isNot?: LodgeWhereInput | null
  }

  export type AidRoomNullableScalarRelationFilter = {
    is?: AidRoomWhereInput | null
    isNot?: AidRoomWhereInput | null
  }

  export type HoursListRelationFilter = {
    every?: HoursWhereInput
    some?: HoursWhereInput
    none?: HoursWhereInput
  }

  export type EquipmentListRelationFilter = {
    every?: EquipmentWhereInput
    some?: EquipmentWhereInput
    none?: EquipmentWhereInput
  }

  export type IncidentListRelationFilter = {
    every?: IncidentWhereInput
    some?: IncidentWhereInput
    none?: IncidentWhereInput
  }

  export type HoursOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncidentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    areaId?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    areaId?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    areaId?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
  }

  export type EnumLOCATION_TYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LOCATION_TYPE | EnumLOCATION_TYPEFieldRefInput<$PrismaModel>
    in?: $Enums.LOCATION_TYPE[] | ListEnumLOCATION_TYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.LOCATION_TYPE[] | ListEnumLOCATION_TYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumLOCATION_TYPEWithAggregatesFilter<$PrismaModel> | $Enums.LOCATION_TYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLOCATION_TYPEFilter<$PrismaModel>
    _max?: NestedEnumLOCATION_TYPEFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumSTATUSFilter<$PrismaModel = never> = {
    equals?: $Enums.STATUS | EnumSTATUSFieldRefInput<$PrismaModel>
    in?: $Enums.STATUS[] | ListEnumSTATUSFieldRefInput<$PrismaModel>
    notIn?: $Enums.STATUS[] | ListEnumSTATUSFieldRefInput<$PrismaModel>
    not?: NestedEnumSTATUSFilter<$PrismaModel> | $Enums.STATUS
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type LocationScalarRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type HoursLocationIdDayOfWeekDateCompoundUniqueInput = {
    locationId: string
    dayOfWeek: number
    date: Date | string
  }

  export type HoursCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    dayOfWeek?: SortOrder
    date?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HoursAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type HoursMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    dayOfWeek?: SortOrder
    date?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HoursMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    dayOfWeek?: SortOrder
    date?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HoursSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumSTATUSWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.STATUS | EnumSTATUSFieldRefInput<$PrismaModel>
    in?: $Enums.STATUS[] | ListEnumSTATUSFieldRefInput<$PrismaModel>
    notIn?: $Enums.STATUS[] | ListEnumSTATUSFieldRefInput<$PrismaModel>
    not?: NestedEnumSTATUSWithAggregatesFilter<$PrismaModel> | $Enums.STATUS
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSTATUSFilter<$PrismaModel>
    _max?: NestedEnumSTATUSFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type WeatherListRelationFilter = {
    every?: WeatherWhereInput
    some?: WeatherWhereInput
    none?: WeatherWhereInput
  }

  export type AreaListRelationFilter = {
    every?: AreaWhereInput
    some?: AreaWhereInput
    none?: AreaWhereInput
  }

  export type AidRoomListRelationFilter = {
    every?: AidRoomWhereInput
    some?: AidRoomWhereInput
    none?: AidRoomWhereInput
  }

  export type HutListRelationFilter = {
    every?: HutWhereInput
    some?: HutWhereInput
    none?: HutWhereInput
  }

  export type LodgeListRelationFilter = {
    every?: LodgeWhereInput
    some?: LodgeWhereInput
    none?: LodgeWhereInput
  }

  export type LiftListRelationFilter = {
    every?: LiftWhereInput
    some?: LiftWhereInput
    none?: LiftWhereInput
  }

  export type TrailListRelationFilter = {
    every?: TrailWhereInput
    some?: TrailWhereInput
    none?: TrailWhereInput
  }

  export type AidRoomCheckListRelationFilter = {
    every?: AidRoomCheckWhereInput
    some?: AidRoomCheckWhereInput
    none?: AidRoomCheckWhereInput
  }

  export type HutCheckListRelationFilter = {
    every?: HutCheckWhereInput
    some?: HutCheckWhereInput
    none?: HutCheckWhereInput
  }

  export type LiftCheckListRelationFilter = {
    every?: LiftCheckWhereInput
    some?: LiftCheckWhereInput
    none?: LiftCheckWhereInput
  }

  export type TrailCheckListRelationFilter = {
    every?: TrailCheckWhereInput
    some?: TrailCheckWhereInput
    none?: TrailCheckWhereInput
  }

  export type EquipmentCheckListRelationFilter = {
    every?: EquipmentCheckWhereInput
    some?: EquipmentCheckWhereInput
    none?: EquipmentCheckWhereInput
  }

  export type EmployeeMountainAssignmentListRelationFilter = {
    every?: EmployeeMountainAssignmentWhereInput
    some?: EmployeeMountainAssignmentWhereInput
    none?: EmployeeMountainAssignmentWhereInput
  }

  export type DispatcherAssignmentListRelationFilter = {
    every?: DispatcherAssignmentWhereInput
    some?: DispatcherAssignmentWhereInput
    none?: DispatcherAssignmentWhereInput
  }

  export type IncidentEquipmentUsageLogListRelationFilter = {
    every?: IncidentEquipmentUsageLogWhereInput
    some?: IncidentEquipmentUsageLogWhereInput
    none?: IncidentEquipmentUsageLogWhereInput
  }

  export type EquipmentServiceLogListRelationFilter = {
    every?: EquipmentServiceLogWhereInput
    some?: EquipmentServiceLogWhereInput
    none?: EquipmentServiceLogWhereInput
  }

  export type WeatherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AreaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AidRoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LodgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LiftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AidRoomCheckOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HutCheckOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LiftCheckOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrailCheckOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentCheckOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeMountainAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DispatcherAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncidentEquipmentUsageLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentServiceLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MountainCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    height?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    openingDate?: SortOrder
    closingDate?: SortOrder
  }

  export type MountainAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    height?: SortOrder
  }

  export type MountainMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    height?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    openingDate?: SortOrder
    closingDate?: SortOrder
  }

  export type MountainMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    height?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    openingDate?: SortOrder
    closingDate?: SortOrder
  }

  export type MountainSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    height?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type WeatherCountOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    date?: SortOrder
    temperature?: SortOrder
    windSpeed?: SortOrder
    windDirection?: SortOrder
    visibility?: SortOrder
    conditions?: SortOrder
    snowfallRecent?: SortOrder
    snowfall24h?: SortOrder
    snowfall7d?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeatherAvgOrderByAggregateInput = {
    temperature?: SortOrder
    windSpeed?: SortOrder
    visibility?: SortOrder
    snowfallRecent?: SortOrder
    snowfall24h?: SortOrder
    snowfall7d?: SortOrder
  }

  export type WeatherMaxOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    date?: SortOrder
    temperature?: SortOrder
    windSpeed?: SortOrder
    windDirection?: SortOrder
    visibility?: SortOrder
    conditions?: SortOrder
    snowfallRecent?: SortOrder
    snowfall24h?: SortOrder
    snowfall7d?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeatherMinOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    date?: SortOrder
    temperature?: SortOrder
    windSpeed?: SortOrder
    windDirection?: SortOrder
    visibility?: SortOrder
    conditions?: SortOrder
    snowfallRecent?: SortOrder
    snowfall24h?: SortOrder
    snowfall7d?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeatherSumOrderByAggregateInput = {
    temperature?: SortOrder
    windSpeed?: SortOrder
    visibility?: SortOrder
    snowfallRecent?: SortOrder
    snowfall24h?: SortOrder
    snowfall7d?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type EmployeeMountainAssignmentEmployeeIdMountainIdCompoundUniqueInput = {
    employeeId: string
    mountainId: string
  }

  export type EmployeeMountainAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    assignedAt?: SortOrder
  }

  export type EmployeeMountainAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    assignedAt?: SortOrder
  }

  export type EmployeeMountainAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    assignedAt?: SortOrder
  }

  export type DispatcherAssignmentEmployeeIdMountainIdAssignedAtCompoundUniqueInput = {
    employeeId: string
    mountainId: string
    assignedAt: Date | string
  }

  export type DispatcherAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    assignedAt?: SortOrder
  }

  export type DispatcherAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    assignedAt?: SortOrder
  }

  export type DispatcherAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    assignedAt?: SortOrder
  }

  export type EnumDEPARTMENTFilter<$PrismaModel = never> = {
    equals?: $Enums.DEPARTMENT | EnumDEPARTMENTFieldRefInput<$PrismaModel>
    in?: $Enums.DEPARTMENT[] | ListEnumDEPARTMENTFieldRefInput<$PrismaModel>
    notIn?: $Enums.DEPARTMENT[] | ListEnumDEPARTMENTFieldRefInput<$PrismaModel>
    not?: NestedEnumDEPARTMENTFilter<$PrismaModel> | $Enums.DEPARTMENT
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type EmployeeRoleListRelationFilter = {
    every?: EmployeeRoleWhereInput
    some?: EmployeeRoleWhereInput
    none?: EmployeeRoleWhereInput
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleDepartmentNameCompoundUniqueInput = {
    department: $Enums.DEPARTMENT
    name: string
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    department?: SortOrder
    name?: SortOrder
    title?: SortOrder
    position?: SortOrder
    level?: SortOrder
    permissions?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    department?: SortOrder
    name?: SortOrder
    title?: SortOrder
    position?: SortOrder
    level?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    department?: SortOrder
    name?: SortOrder
    title?: SortOrder
    position?: SortOrder
    level?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type EnumDEPARTMENTWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DEPARTMENT | EnumDEPARTMENTFieldRefInput<$PrismaModel>
    in?: $Enums.DEPARTMENT[] | ListEnumDEPARTMENTFieldRefInput<$PrismaModel>
    notIn?: $Enums.DEPARTMENT[] | ListEnumDEPARTMENTFieldRefInput<$PrismaModel>
    not?: NestedEnumDEPARTMENTWithAggregatesFilter<$PrismaModel> | $Enums.DEPARTMENT
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDEPARTMENTFilter<$PrismaModel>
    _max?: NestedEnumDEPARTMENTFilter<$PrismaModel>
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type EmployeeRoleEmployeeIdRoleIdCompoundUniqueInput = {
    employeeId: string
    roleId: string
  }

  export type EmployeeRoleCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    roleId?: SortOrder
  }

  export type EmployeeRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    roleId?: SortOrder
  }

  export type EmployeeRoleMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    roleId?: SortOrder
  }

  export type RoleNullableScalarRelationFilter = {
    is?: RoleWhereInput | null
    isNot?: RoleWhereInput | null
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    employeeIdNumber?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    roleId?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    employeeIdNumber?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeIdNumber?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    roleId?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    employeeIdNumber?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    roleId?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    employeeIdNumber?: SortOrder
  }

  export type EnumLIFT_TYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.LIFT_TYPE | EnumLIFT_TYPEFieldRefInput<$PrismaModel>
    in?: $Enums.LIFT_TYPE[] | ListEnumLIFT_TYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.LIFT_TYPE[] | ListEnumLIFT_TYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumLIFT_TYPEFilter<$PrismaModel> | $Enums.LIFT_TYPE
  }

  export type LocationNullableScalarRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type LiftNameTypeCompoundUniqueInput = {
    name: string
    type: $Enums.LIFT_TYPE
  }

  export type LiftMountainIdNameCompoundUniqueInput = {
    mountainId: string
    name: string
  }

  export type LiftCountOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    locationId?: SortOrder
  }

  export type LiftAvgOrderByAggregateInput = {
    capacity?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type LiftMaxOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    locationId?: SortOrder
  }

  export type LiftMinOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    locationId?: SortOrder
  }

  export type LiftSumOrderByAggregateInput = {
    capacity?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EnumLIFT_TYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LIFT_TYPE | EnumLIFT_TYPEFieldRefInput<$PrismaModel>
    in?: $Enums.LIFT_TYPE[] | ListEnumLIFT_TYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.LIFT_TYPE[] | ListEnumLIFT_TYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumLIFT_TYPEWithAggregatesFilter<$PrismaModel> | $Enums.LIFT_TYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLIFT_TYPEFilter<$PrismaModel>
    _max?: NestedEnumLIFT_TYPEFilter<$PrismaModel>
  }

  export type EnumTRAIL_DIFFICULTYFilter<$PrismaModel = never> = {
    equals?: $Enums.TRAIL_DIFFICULTY | EnumTRAIL_DIFFICULTYFieldRefInput<$PrismaModel>
    in?: $Enums.TRAIL_DIFFICULTY[] | ListEnumTRAIL_DIFFICULTYFieldRefInput<$PrismaModel>
    notIn?: $Enums.TRAIL_DIFFICULTY[] | ListEnumTRAIL_DIFFICULTYFieldRefInput<$PrismaModel>
    not?: NestedEnumTRAIL_DIFFICULTYFilter<$PrismaModel> | $Enums.TRAIL_DIFFICULTY
  }

  export type EnumTRAIL_CONDITIONFilter<$PrismaModel = never> = {
    equals?: $Enums.TRAIL_CONDITION | EnumTRAIL_CONDITIONFieldRefInput<$PrismaModel>
    in?: $Enums.TRAIL_CONDITION[] | ListEnumTRAIL_CONDITIONFieldRefInput<$PrismaModel>
    notIn?: $Enums.TRAIL_CONDITION[] | ListEnumTRAIL_CONDITIONFieldRefInput<$PrismaModel>
    not?: NestedEnumTRAIL_CONDITIONFilter<$PrismaModel> | $Enums.TRAIL_CONDITION
  }

  export type TrailMountainIdNameCompoundUniqueInput = {
    mountainId: string
    name: string
  }

  export type TrailCountOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    length?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    condition?: SortOrder
    locationId?: SortOrder
  }

  export type TrailAvgOrderByAggregateInput = {
    length?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type TrailMaxOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    length?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    condition?: SortOrder
    locationId?: SortOrder
  }

  export type TrailMinOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    length?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    condition?: SortOrder
    locationId?: SortOrder
  }

  export type TrailSumOrderByAggregateInput = {
    length?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EnumTRAIL_DIFFICULTYWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TRAIL_DIFFICULTY | EnumTRAIL_DIFFICULTYFieldRefInput<$PrismaModel>
    in?: $Enums.TRAIL_DIFFICULTY[] | ListEnumTRAIL_DIFFICULTYFieldRefInput<$PrismaModel>
    notIn?: $Enums.TRAIL_DIFFICULTY[] | ListEnumTRAIL_DIFFICULTYFieldRefInput<$PrismaModel>
    not?: NestedEnumTRAIL_DIFFICULTYWithAggregatesFilter<$PrismaModel> | $Enums.TRAIL_DIFFICULTY
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTRAIL_DIFFICULTYFilter<$PrismaModel>
    _max?: NestedEnumTRAIL_DIFFICULTYFilter<$PrismaModel>
  }

  export type EnumTRAIL_CONDITIONWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TRAIL_CONDITION | EnumTRAIL_CONDITIONFieldRefInput<$PrismaModel>
    in?: $Enums.TRAIL_CONDITION[] | ListEnumTRAIL_CONDITIONFieldRefInput<$PrismaModel>
    notIn?: $Enums.TRAIL_CONDITION[] | ListEnumTRAIL_CONDITIONFieldRefInput<$PrismaModel>
    not?: NestedEnumTRAIL_CONDITIONWithAggregatesFilter<$PrismaModel> | $Enums.TRAIL_CONDITION
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTRAIL_CONDITIONFilter<$PrismaModel>
    _max?: NestedEnumTRAIL_CONDITIONFilter<$PrismaModel>
  }

  export type LodgeMountainIdNameCompoundUniqueInput = {
    mountainId: string
    name: string
  }

  export type LodgeCountOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
  }

  export type LodgeAvgOrderByAggregateInput = {
    capacity?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type LodgeMaxOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
  }

  export type LodgeMinOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
  }

  export type LodgeSumOrderByAggregateInput = {
    capacity?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type HutMountainIdNameCompoundUniqueInput = {
    mountainId: string
    name: string
  }

  export type HutCountOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    locationId?: SortOrder
  }

  export type HutAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type HutMaxOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    locationId?: SortOrder
  }

  export type HutMinOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    locationId?: SortOrder
  }

  export type HutSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type AidRoomMountainIdNameCompoundUniqueInput = {
    mountainId: string
    name: string
  }

  export type AidRoomCountOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    locationId?: SortOrder
  }

  export type AidRoomAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type AidRoomMaxOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    locationId?: SortOrder
  }

  export type AidRoomMinOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    locationId?: SortOrder
  }

  export type AidRoomSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EnumEQUIPMENT_STATUSFilter<$PrismaModel = never> = {
    equals?: $Enums.EQUIPMENT_STATUS | EnumEQUIPMENT_STATUSFieldRefInput<$PrismaModel>
    in?: $Enums.EQUIPMENT_STATUS[] | ListEnumEQUIPMENT_STATUSFieldRefInput<$PrismaModel>
    notIn?: $Enums.EQUIPMENT_STATUS[] | ListEnumEQUIPMENT_STATUSFieldRefInput<$PrismaModel>
    not?: NestedEnumEQUIPMENT_STATUSFilter<$PrismaModel> | $Enums.EQUIPMENT_STATUS
  }

  export type EmployeeNullableScalarRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type EquipmentScalarRelationFilter = {
    is?: EquipmentWhereInput
    isNot?: EquipmentWhereInput
  }

  export type EquipmentServiceLogCountOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    equipmentId?: SortOrder
    employeeId?: SortOrder
    status?: SortOrder
    changedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentServiceLogMaxOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    equipmentId?: SortOrder
    employeeId?: SortOrder
    status?: SortOrder
    changedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentServiceLogMinOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    equipmentId?: SortOrder
    employeeId?: SortOrder
    status?: SortOrder
    changedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEQUIPMENT_STATUSWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EQUIPMENT_STATUS | EnumEQUIPMENT_STATUSFieldRefInput<$PrismaModel>
    in?: $Enums.EQUIPMENT_STATUS[] | ListEnumEQUIPMENT_STATUSFieldRefInput<$PrismaModel>
    notIn?: $Enums.EQUIPMENT_STATUS[] | ListEnumEQUIPMENT_STATUSFieldRefInput<$PrismaModel>
    not?: NestedEnumEQUIPMENT_STATUSWithAggregatesFilter<$PrismaModel> | $Enums.EQUIPMENT_STATUS
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEQUIPMENT_STATUSFilter<$PrismaModel>
    _max?: NestedEnumEQUIPMENT_STATUSFilter<$PrismaModel>
  }

  export type MountainNullableScalarRelationFilter = {
    is?: MountainWhereInput | null
    isNot?: MountainWhereInput | null
  }

  export type EquipmentMountainIdNumberCompoundUniqueInput = {
    mountainId: string
    number: number
  }

  export type EquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    number?: SortOrder
    description?: SortOrder
    picture?: SortOrder
    cost?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    mountainId?: SortOrder
    locationId?: SortOrder
    dateAdded?: SortOrder
  }

  export type EquipmentAvgOrderByAggregateInput = {
    number?: SortOrder
    cost?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    number?: SortOrder
    description?: SortOrder
    picture?: SortOrder
    cost?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    mountainId?: SortOrder
    locationId?: SortOrder
    dateAdded?: SortOrder
  }

  export type EquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    number?: SortOrder
    description?: SortOrder
    picture?: SortOrder
    cost?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    mountainId?: SortOrder
    locationId?: SortOrder
    dateAdded?: SortOrder
  }

  export type EquipmentSumOrderByAggregateInput = {
    number?: SortOrder
    cost?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EnumINCIDENT_STATUSFilter<$PrismaModel = never> = {
    equals?: $Enums.INCIDENT_STATUS | EnumINCIDENT_STATUSFieldRefInput<$PrismaModel>
    in?: $Enums.INCIDENT_STATUS[] | ListEnumINCIDENT_STATUSFieldRefInput<$PrismaModel>
    notIn?: $Enums.INCIDENT_STATUS[] | ListEnumINCIDENT_STATUSFieldRefInput<$PrismaModel>
    not?: NestedEnumINCIDENT_STATUSFilter<$PrismaModel> | $Enums.INCIDENT_STATUS
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IncidentCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    mountainId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    onSceneTime?: SortOrder
    stableTime?: SortOrder
    transportTime?: SortOrder
    emptyRun?: SortOrder
    emptyRunAt?: SortOrder
    locationId?: SortOrder
  }

  export type IncidentAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type IncidentMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    mountainId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    onSceneTime?: SortOrder
    stableTime?: SortOrder
    transportTime?: SortOrder
    emptyRun?: SortOrder
    emptyRunAt?: SortOrder
    locationId?: SortOrder
  }

  export type IncidentMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    mountainId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    onSceneTime?: SortOrder
    stableTime?: SortOrder
    transportTime?: SortOrder
    emptyRun?: SortOrder
    emptyRunAt?: SortOrder
    locationId?: SortOrder
  }

  export type IncidentSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EnumINCIDENT_STATUSWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.INCIDENT_STATUS | EnumINCIDENT_STATUSFieldRefInput<$PrismaModel>
    in?: $Enums.INCIDENT_STATUS[] | ListEnumINCIDENT_STATUSFieldRefInput<$PrismaModel>
    notIn?: $Enums.INCIDENT_STATUS[] | ListEnumINCIDENT_STATUSFieldRefInput<$PrismaModel>
    not?: NestedEnumINCIDENT_STATUSWithAggregatesFilter<$PrismaModel> | $Enums.INCIDENT_STATUS
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumINCIDENT_STATUSFilter<$PrismaModel>
    _max?: NestedEnumINCIDENT_STATUSFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IncidentScalarRelationFilter = {
    is?: IncidentWhereInput
    isNot?: IncidentWhereInput
  }

  export type IncidentEquipmentUsageLogCountOrderByAggregateInput = {
    id?: SortOrder
    usedAt?: SortOrder
    notes?: SortOrder
    mountainId?: SortOrder
    equipmentId?: SortOrder
    incidentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncidentEquipmentUsageLogMaxOrderByAggregateInput = {
    id?: SortOrder
    usedAt?: SortOrder
    notes?: SortOrder
    mountainId?: SortOrder
    equipmentId?: SortOrder
    incidentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncidentEquipmentUsageLogMinOrderByAggregateInput = {
    id?: SortOrder
    usedAt?: SortOrder
    notes?: SortOrder
    mountainId?: SortOrder
    equipmentId?: SortOrder
    incidentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LiftScalarRelationFilter = {
    is?: LiftWhereInput
    isNot?: LiftWhereInput
  }

  export type LiftCheckCountOrderByAggregateInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    liftId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LiftCheckMaxOrderByAggregateInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    liftId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LiftCheckMinOrderByAggregateInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    liftId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrailScalarRelationFilter = {
    is?: TrailWhereInput
    isNot?: TrailWhereInput
  }

  export type TrailCheckCountOrderByAggregateInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    trailId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrailCheckMaxOrderByAggregateInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    trailId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrailCheckMinOrderByAggregateInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    trailId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HutScalarRelationFilter = {
    is?: HutWhereInput
    isNot?: HutWhereInput
  }

  export type HutCheckCountOrderByAggregateInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    hutId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HutCheckMaxOrderByAggregateInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    hutId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HutCheckMinOrderByAggregateInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    hutId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AidRoomScalarRelationFilter = {
    is?: AidRoomWhereInput
    isNot?: AidRoomWhereInput
  }

  export type AidRoomCheckCountOrderByAggregateInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    aidRoomId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AidRoomCheckMaxOrderByAggregateInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    aidRoomId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AidRoomCheckMinOrderByAggregateInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    aidRoomId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentCheckCountOrderByAggregateInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    equipmentId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentCheckMaxOrderByAggregateInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    equipmentId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentCheckMinOrderByAggregateInput = {
    id?: SortOrder
    recordedAt?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    equipmentId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MountainCreateNestedOneWithoutAreasInput = {
    create?: XOR<MountainCreateWithoutAreasInput, MountainUncheckedCreateWithoutAreasInput>
    connectOrCreate?: MountainCreateOrConnectWithoutAreasInput
    connect?: MountainWhereUniqueInput
  }

  export type LocationCreateNestedManyWithoutAreaInput = {
    create?: XOR<LocationCreateWithoutAreaInput, LocationUncheckedCreateWithoutAreaInput> | LocationCreateWithoutAreaInput[] | LocationUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutAreaInput | LocationCreateOrConnectWithoutAreaInput[]
    createMany?: LocationCreateManyAreaInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<LocationCreateWithoutAreaInput, LocationUncheckedCreateWithoutAreaInput> | LocationCreateWithoutAreaInput[] | LocationUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutAreaInput | LocationCreateOrConnectWithoutAreaInput[]
    createMany?: LocationCreateManyAreaInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumAREA_TYPEFieldUpdateOperationsInput = {
    set?: $Enums.AREA_TYPE
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type MountainUpdateOneRequiredWithoutAreasNestedInput = {
    create?: XOR<MountainCreateWithoutAreasInput, MountainUncheckedCreateWithoutAreasInput>
    connectOrCreate?: MountainCreateOrConnectWithoutAreasInput
    upsert?: MountainUpsertWithoutAreasInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutAreasInput, MountainUpdateWithoutAreasInput>, MountainUncheckedUpdateWithoutAreasInput>
  }

  export type LocationUpdateManyWithoutAreaNestedInput = {
    create?: XOR<LocationCreateWithoutAreaInput, LocationUncheckedCreateWithoutAreaInput> | LocationCreateWithoutAreaInput[] | LocationUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutAreaInput | LocationCreateOrConnectWithoutAreaInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutAreaInput | LocationUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: LocationCreateManyAreaInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutAreaInput | LocationUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutAreaInput | LocationUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<LocationCreateWithoutAreaInput, LocationUncheckedCreateWithoutAreaInput> | LocationCreateWithoutAreaInput[] | LocationUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutAreaInput | LocationCreateOrConnectWithoutAreaInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutAreaInput | LocationUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: LocationCreateManyAreaInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutAreaInput | LocationUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutAreaInput | LocationUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type AreaCreateNestedOneWithoutLocationsInput = {
    create?: XOR<AreaCreateWithoutLocationsInput, AreaUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: AreaCreateOrConnectWithoutLocationsInput
    connect?: AreaWhereUniqueInput
  }

  export type MountainCreateNestedOneWithoutLocationsInput = {
    create?: XOR<MountainCreateWithoutLocationsInput, MountainUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutLocationsInput
    connect?: MountainWhereUniqueInput
  }

  export type LiftCreateNestedOneWithoutLocationInput = {
    create?: XOR<LiftCreateWithoutLocationInput, LiftUncheckedCreateWithoutLocationInput>
    connectOrCreate?: LiftCreateOrConnectWithoutLocationInput
    connect?: LiftWhereUniqueInput
  }

  export type TrailCreateNestedOneWithoutLocationInput = {
    create?: XOR<TrailCreateWithoutLocationInput, TrailUncheckedCreateWithoutLocationInput>
    connectOrCreate?: TrailCreateOrConnectWithoutLocationInput
    connect?: TrailWhereUniqueInput
  }

  export type HutCreateNestedOneWithoutLocationInput = {
    create?: XOR<HutCreateWithoutLocationInput, HutUncheckedCreateWithoutLocationInput>
    connectOrCreate?: HutCreateOrConnectWithoutLocationInput
    connect?: HutWhereUniqueInput
  }

  export type LodgeCreateNestedOneWithoutLocationInput = {
    create?: XOR<LodgeCreateWithoutLocationInput, LodgeUncheckedCreateWithoutLocationInput>
    connectOrCreate?: LodgeCreateOrConnectWithoutLocationInput
    connect?: LodgeWhereUniqueInput
  }

  export type AidRoomCreateNestedOneWithoutLocationInput = {
    create?: XOR<AidRoomCreateWithoutLocationInput, AidRoomUncheckedCreateWithoutLocationInput>
    connectOrCreate?: AidRoomCreateOrConnectWithoutLocationInput
    connect?: AidRoomWhereUniqueInput
  }

  export type HoursCreateNestedManyWithoutLocationInput = {
    create?: XOR<HoursCreateWithoutLocationInput, HoursUncheckedCreateWithoutLocationInput> | HoursCreateWithoutLocationInput[] | HoursUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: HoursCreateOrConnectWithoutLocationInput | HoursCreateOrConnectWithoutLocationInput[]
    createMany?: HoursCreateManyLocationInputEnvelope
    connect?: HoursWhereUniqueInput | HoursWhereUniqueInput[]
  }

  export type EquipmentCreateNestedManyWithoutLocationInput = {
    create?: XOR<EquipmentCreateWithoutLocationInput, EquipmentUncheckedCreateWithoutLocationInput> | EquipmentCreateWithoutLocationInput[] | EquipmentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutLocationInput | EquipmentCreateOrConnectWithoutLocationInput[]
    createMany?: EquipmentCreateManyLocationInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type IncidentCreateNestedManyWithoutLocationInput = {
    create?: XOR<IncidentCreateWithoutLocationInput, IncidentUncheckedCreateWithoutLocationInput> | IncidentCreateWithoutLocationInput[] | IncidentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutLocationInput | IncidentCreateOrConnectWithoutLocationInput[]
    createMany?: IncidentCreateManyLocationInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type LiftUncheckedCreateNestedOneWithoutLocationInput = {
    create?: XOR<LiftCreateWithoutLocationInput, LiftUncheckedCreateWithoutLocationInput>
    connectOrCreate?: LiftCreateOrConnectWithoutLocationInput
    connect?: LiftWhereUniqueInput
  }

  export type TrailUncheckedCreateNestedOneWithoutLocationInput = {
    create?: XOR<TrailCreateWithoutLocationInput, TrailUncheckedCreateWithoutLocationInput>
    connectOrCreate?: TrailCreateOrConnectWithoutLocationInput
    connect?: TrailWhereUniqueInput
  }

  export type HutUncheckedCreateNestedOneWithoutLocationInput = {
    create?: XOR<HutCreateWithoutLocationInput, HutUncheckedCreateWithoutLocationInput>
    connectOrCreate?: HutCreateOrConnectWithoutLocationInput
    connect?: HutWhereUniqueInput
  }

  export type LodgeUncheckedCreateNestedOneWithoutLocationInput = {
    create?: XOR<LodgeCreateWithoutLocationInput, LodgeUncheckedCreateWithoutLocationInput>
    connectOrCreate?: LodgeCreateOrConnectWithoutLocationInput
    connect?: LodgeWhereUniqueInput
  }

  export type AidRoomUncheckedCreateNestedOneWithoutLocationInput = {
    create?: XOR<AidRoomCreateWithoutLocationInput, AidRoomUncheckedCreateWithoutLocationInput>
    connectOrCreate?: AidRoomCreateOrConnectWithoutLocationInput
    connect?: AidRoomWhereUniqueInput
  }

  export type HoursUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<HoursCreateWithoutLocationInput, HoursUncheckedCreateWithoutLocationInput> | HoursCreateWithoutLocationInput[] | HoursUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: HoursCreateOrConnectWithoutLocationInput | HoursCreateOrConnectWithoutLocationInput[]
    createMany?: HoursCreateManyLocationInputEnvelope
    connect?: HoursWhereUniqueInput | HoursWhereUniqueInput[]
  }

  export type EquipmentUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<EquipmentCreateWithoutLocationInput, EquipmentUncheckedCreateWithoutLocationInput> | EquipmentCreateWithoutLocationInput[] | EquipmentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutLocationInput | EquipmentCreateOrConnectWithoutLocationInput[]
    createMany?: EquipmentCreateManyLocationInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type IncidentUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<IncidentCreateWithoutLocationInput, IncidentUncheckedCreateWithoutLocationInput> | IncidentCreateWithoutLocationInput[] | IncidentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutLocationInput | IncidentCreateOrConnectWithoutLocationInput[]
    createMany?: IncidentCreateManyLocationInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type EnumLOCATION_TYPEFieldUpdateOperationsInput = {
    set?: $Enums.LOCATION_TYPE
  }

  export type AreaUpdateOneWithoutLocationsNestedInput = {
    create?: XOR<AreaCreateWithoutLocationsInput, AreaUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: AreaCreateOrConnectWithoutLocationsInput
    upsert?: AreaUpsertWithoutLocationsInput
    disconnect?: AreaWhereInput | boolean
    delete?: AreaWhereInput | boolean
    connect?: AreaWhereUniqueInput
    update?: XOR<XOR<AreaUpdateToOneWithWhereWithoutLocationsInput, AreaUpdateWithoutLocationsInput>, AreaUncheckedUpdateWithoutLocationsInput>
  }

  export type MountainUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<MountainCreateWithoutLocationsInput, MountainUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutLocationsInput
    upsert?: MountainUpsertWithoutLocationsInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutLocationsInput, MountainUpdateWithoutLocationsInput>, MountainUncheckedUpdateWithoutLocationsInput>
  }

  export type LiftUpdateOneWithoutLocationNestedInput = {
    create?: XOR<LiftCreateWithoutLocationInput, LiftUncheckedCreateWithoutLocationInput>
    connectOrCreate?: LiftCreateOrConnectWithoutLocationInput
    upsert?: LiftUpsertWithoutLocationInput
    disconnect?: LiftWhereInput | boolean
    delete?: LiftWhereInput | boolean
    connect?: LiftWhereUniqueInput
    update?: XOR<XOR<LiftUpdateToOneWithWhereWithoutLocationInput, LiftUpdateWithoutLocationInput>, LiftUncheckedUpdateWithoutLocationInput>
  }

  export type TrailUpdateOneWithoutLocationNestedInput = {
    create?: XOR<TrailCreateWithoutLocationInput, TrailUncheckedCreateWithoutLocationInput>
    connectOrCreate?: TrailCreateOrConnectWithoutLocationInput
    upsert?: TrailUpsertWithoutLocationInput
    disconnect?: TrailWhereInput | boolean
    delete?: TrailWhereInput | boolean
    connect?: TrailWhereUniqueInput
    update?: XOR<XOR<TrailUpdateToOneWithWhereWithoutLocationInput, TrailUpdateWithoutLocationInput>, TrailUncheckedUpdateWithoutLocationInput>
  }

  export type HutUpdateOneWithoutLocationNestedInput = {
    create?: XOR<HutCreateWithoutLocationInput, HutUncheckedCreateWithoutLocationInput>
    connectOrCreate?: HutCreateOrConnectWithoutLocationInput
    upsert?: HutUpsertWithoutLocationInput
    disconnect?: HutWhereInput | boolean
    delete?: HutWhereInput | boolean
    connect?: HutWhereUniqueInput
    update?: XOR<XOR<HutUpdateToOneWithWhereWithoutLocationInput, HutUpdateWithoutLocationInput>, HutUncheckedUpdateWithoutLocationInput>
  }

  export type LodgeUpdateOneWithoutLocationNestedInput = {
    create?: XOR<LodgeCreateWithoutLocationInput, LodgeUncheckedCreateWithoutLocationInput>
    connectOrCreate?: LodgeCreateOrConnectWithoutLocationInput
    upsert?: LodgeUpsertWithoutLocationInput
    disconnect?: LodgeWhereInput | boolean
    delete?: LodgeWhereInput | boolean
    connect?: LodgeWhereUniqueInput
    update?: XOR<XOR<LodgeUpdateToOneWithWhereWithoutLocationInput, LodgeUpdateWithoutLocationInput>, LodgeUncheckedUpdateWithoutLocationInput>
  }

  export type AidRoomUpdateOneWithoutLocationNestedInput = {
    create?: XOR<AidRoomCreateWithoutLocationInput, AidRoomUncheckedCreateWithoutLocationInput>
    connectOrCreate?: AidRoomCreateOrConnectWithoutLocationInput
    upsert?: AidRoomUpsertWithoutLocationInput
    disconnect?: AidRoomWhereInput | boolean
    delete?: AidRoomWhereInput | boolean
    connect?: AidRoomWhereUniqueInput
    update?: XOR<XOR<AidRoomUpdateToOneWithWhereWithoutLocationInput, AidRoomUpdateWithoutLocationInput>, AidRoomUncheckedUpdateWithoutLocationInput>
  }

  export type HoursUpdateManyWithoutLocationNestedInput = {
    create?: XOR<HoursCreateWithoutLocationInput, HoursUncheckedCreateWithoutLocationInput> | HoursCreateWithoutLocationInput[] | HoursUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: HoursCreateOrConnectWithoutLocationInput | HoursCreateOrConnectWithoutLocationInput[]
    upsert?: HoursUpsertWithWhereUniqueWithoutLocationInput | HoursUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: HoursCreateManyLocationInputEnvelope
    set?: HoursWhereUniqueInput | HoursWhereUniqueInput[]
    disconnect?: HoursWhereUniqueInput | HoursWhereUniqueInput[]
    delete?: HoursWhereUniqueInput | HoursWhereUniqueInput[]
    connect?: HoursWhereUniqueInput | HoursWhereUniqueInput[]
    update?: HoursUpdateWithWhereUniqueWithoutLocationInput | HoursUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: HoursUpdateManyWithWhereWithoutLocationInput | HoursUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: HoursScalarWhereInput | HoursScalarWhereInput[]
  }

  export type EquipmentUpdateManyWithoutLocationNestedInput = {
    create?: XOR<EquipmentCreateWithoutLocationInput, EquipmentUncheckedCreateWithoutLocationInput> | EquipmentCreateWithoutLocationInput[] | EquipmentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutLocationInput | EquipmentCreateOrConnectWithoutLocationInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutLocationInput | EquipmentUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: EquipmentCreateManyLocationInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutLocationInput | EquipmentUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutLocationInput | EquipmentUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type IncidentUpdateManyWithoutLocationNestedInput = {
    create?: XOR<IncidentCreateWithoutLocationInput, IncidentUncheckedCreateWithoutLocationInput> | IncidentCreateWithoutLocationInput[] | IncidentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutLocationInput | IncidentCreateOrConnectWithoutLocationInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutLocationInput | IncidentUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: IncidentCreateManyLocationInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutLocationInput | IncidentUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutLocationInput | IncidentUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type LiftUncheckedUpdateOneWithoutLocationNestedInput = {
    create?: XOR<LiftCreateWithoutLocationInput, LiftUncheckedCreateWithoutLocationInput>
    connectOrCreate?: LiftCreateOrConnectWithoutLocationInput
    upsert?: LiftUpsertWithoutLocationInput
    disconnect?: LiftWhereInput | boolean
    delete?: LiftWhereInput | boolean
    connect?: LiftWhereUniqueInput
    update?: XOR<XOR<LiftUpdateToOneWithWhereWithoutLocationInput, LiftUpdateWithoutLocationInput>, LiftUncheckedUpdateWithoutLocationInput>
  }

  export type TrailUncheckedUpdateOneWithoutLocationNestedInput = {
    create?: XOR<TrailCreateWithoutLocationInput, TrailUncheckedCreateWithoutLocationInput>
    connectOrCreate?: TrailCreateOrConnectWithoutLocationInput
    upsert?: TrailUpsertWithoutLocationInput
    disconnect?: TrailWhereInput | boolean
    delete?: TrailWhereInput | boolean
    connect?: TrailWhereUniqueInput
    update?: XOR<XOR<TrailUpdateToOneWithWhereWithoutLocationInput, TrailUpdateWithoutLocationInput>, TrailUncheckedUpdateWithoutLocationInput>
  }

  export type HutUncheckedUpdateOneWithoutLocationNestedInput = {
    create?: XOR<HutCreateWithoutLocationInput, HutUncheckedCreateWithoutLocationInput>
    connectOrCreate?: HutCreateOrConnectWithoutLocationInput
    upsert?: HutUpsertWithoutLocationInput
    disconnect?: HutWhereInput | boolean
    delete?: HutWhereInput | boolean
    connect?: HutWhereUniqueInput
    update?: XOR<XOR<HutUpdateToOneWithWhereWithoutLocationInput, HutUpdateWithoutLocationInput>, HutUncheckedUpdateWithoutLocationInput>
  }

  export type LodgeUncheckedUpdateOneWithoutLocationNestedInput = {
    create?: XOR<LodgeCreateWithoutLocationInput, LodgeUncheckedCreateWithoutLocationInput>
    connectOrCreate?: LodgeCreateOrConnectWithoutLocationInput
    upsert?: LodgeUpsertWithoutLocationInput
    disconnect?: LodgeWhereInput | boolean
    delete?: LodgeWhereInput | boolean
    connect?: LodgeWhereUniqueInput
    update?: XOR<XOR<LodgeUpdateToOneWithWhereWithoutLocationInput, LodgeUpdateWithoutLocationInput>, LodgeUncheckedUpdateWithoutLocationInput>
  }

  export type AidRoomUncheckedUpdateOneWithoutLocationNestedInput = {
    create?: XOR<AidRoomCreateWithoutLocationInput, AidRoomUncheckedCreateWithoutLocationInput>
    connectOrCreate?: AidRoomCreateOrConnectWithoutLocationInput
    upsert?: AidRoomUpsertWithoutLocationInput
    disconnect?: AidRoomWhereInput | boolean
    delete?: AidRoomWhereInput | boolean
    connect?: AidRoomWhereUniqueInput
    update?: XOR<XOR<AidRoomUpdateToOneWithWhereWithoutLocationInput, AidRoomUpdateWithoutLocationInput>, AidRoomUncheckedUpdateWithoutLocationInput>
  }

  export type HoursUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<HoursCreateWithoutLocationInput, HoursUncheckedCreateWithoutLocationInput> | HoursCreateWithoutLocationInput[] | HoursUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: HoursCreateOrConnectWithoutLocationInput | HoursCreateOrConnectWithoutLocationInput[]
    upsert?: HoursUpsertWithWhereUniqueWithoutLocationInput | HoursUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: HoursCreateManyLocationInputEnvelope
    set?: HoursWhereUniqueInput | HoursWhereUniqueInput[]
    disconnect?: HoursWhereUniqueInput | HoursWhereUniqueInput[]
    delete?: HoursWhereUniqueInput | HoursWhereUniqueInput[]
    connect?: HoursWhereUniqueInput | HoursWhereUniqueInput[]
    update?: HoursUpdateWithWhereUniqueWithoutLocationInput | HoursUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: HoursUpdateManyWithWhereWithoutLocationInput | HoursUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: HoursScalarWhereInput | HoursScalarWhereInput[]
  }

  export type EquipmentUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<EquipmentCreateWithoutLocationInput, EquipmentUncheckedCreateWithoutLocationInput> | EquipmentCreateWithoutLocationInput[] | EquipmentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutLocationInput | EquipmentCreateOrConnectWithoutLocationInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutLocationInput | EquipmentUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: EquipmentCreateManyLocationInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutLocationInput | EquipmentUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutLocationInput | EquipmentUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type IncidentUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<IncidentCreateWithoutLocationInput, IncidentUncheckedCreateWithoutLocationInput> | IncidentCreateWithoutLocationInput[] | IncidentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutLocationInput | IncidentCreateOrConnectWithoutLocationInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutLocationInput | IncidentUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: IncidentCreateManyLocationInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutLocationInput | IncidentUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutLocationInput | IncidentUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutHoursInput = {
    create?: XOR<LocationCreateWithoutHoursInput, LocationUncheckedCreateWithoutHoursInput>
    connectOrCreate?: LocationCreateOrConnectWithoutHoursInput
    connect?: LocationWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumSTATUSFieldUpdateOperationsInput = {
    set?: $Enums.STATUS
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type LocationUpdateOneRequiredWithoutHoursNestedInput = {
    create?: XOR<LocationCreateWithoutHoursInput, LocationUncheckedCreateWithoutHoursInput>
    connectOrCreate?: LocationCreateOrConnectWithoutHoursInput
    upsert?: LocationUpsertWithoutHoursInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutHoursInput, LocationUpdateWithoutHoursInput>, LocationUncheckedUpdateWithoutHoursInput>
  }

  export type WeatherCreateNestedManyWithoutMountainInput = {
    create?: XOR<WeatherCreateWithoutMountainInput, WeatherUncheckedCreateWithoutMountainInput> | WeatherCreateWithoutMountainInput[] | WeatherUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: WeatherCreateOrConnectWithoutMountainInput | WeatherCreateOrConnectWithoutMountainInput[]
    createMany?: WeatherCreateManyMountainInputEnvelope
    connect?: WeatherWhereUniqueInput | WeatherWhereUniqueInput[]
  }

  export type LocationCreateNestedManyWithoutMountainInput = {
    create?: XOR<LocationCreateWithoutMountainInput, LocationUncheckedCreateWithoutMountainInput> | LocationCreateWithoutMountainInput[] | LocationUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutMountainInput | LocationCreateOrConnectWithoutMountainInput[]
    createMany?: LocationCreateManyMountainInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type AreaCreateNestedManyWithoutMountainInput = {
    create?: XOR<AreaCreateWithoutMountainInput, AreaUncheckedCreateWithoutMountainInput> | AreaCreateWithoutMountainInput[] | AreaUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: AreaCreateOrConnectWithoutMountainInput | AreaCreateOrConnectWithoutMountainInput[]
    createMany?: AreaCreateManyMountainInputEnvelope
    connect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
  }

  export type AidRoomCreateNestedManyWithoutMountainInput = {
    create?: XOR<AidRoomCreateWithoutMountainInput, AidRoomUncheckedCreateWithoutMountainInput> | AidRoomCreateWithoutMountainInput[] | AidRoomUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: AidRoomCreateOrConnectWithoutMountainInput | AidRoomCreateOrConnectWithoutMountainInput[]
    createMany?: AidRoomCreateManyMountainInputEnvelope
    connect?: AidRoomWhereUniqueInput | AidRoomWhereUniqueInput[]
  }

  export type HutCreateNestedManyWithoutMountainInput = {
    create?: XOR<HutCreateWithoutMountainInput, HutUncheckedCreateWithoutMountainInput> | HutCreateWithoutMountainInput[] | HutUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: HutCreateOrConnectWithoutMountainInput | HutCreateOrConnectWithoutMountainInput[]
    createMany?: HutCreateManyMountainInputEnvelope
    connect?: HutWhereUniqueInput | HutWhereUniqueInput[]
  }

  export type LodgeCreateNestedManyWithoutMountainInput = {
    create?: XOR<LodgeCreateWithoutMountainInput, LodgeUncheckedCreateWithoutMountainInput> | LodgeCreateWithoutMountainInput[] | LodgeUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LodgeCreateOrConnectWithoutMountainInput | LodgeCreateOrConnectWithoutMountainInput[]
    createMany?: LodgeCreateManyMountainInputEnvelope
    connect?: LodgeWhereUniqueInput | LodgeWhereUniqueInput[]
  }

  export type LiftCreateNestedManyWithoutMountainInput = {
    create?: XOR<LiftCreateWithoutMountainInput, LiftUncheckedCreateWithoutMountainInput> | LiftCreateWithoutMountainInput[] | LiftUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LiftCreateOrConnectWithoutMountainInput | LiftCreateOrConnectWithoutMountainInput[]
    createMany?: LiftCreateManyMountainInputEnvelope
    connect?: LiftWhereUniqueInput | LiftWhereUniqueInput[]
  }

  export type TrailCreateNestedManyWithoutMountainInput = {
    create?: XOR<TrailCreateWithoutMountainInput, TrailUncheckedCreateWithoutMountainInput> | TrailCreateWithoutMountainInput[] | TrailUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: TrailCreateOrConnectWithoutMountainInput | TrailCreateOrConnectWithoutMountainInput[]
    createMany?: TrailCreateManyMountainInputEnvelope
    connect?: TrailWhereUniqueInput | TrailWhereUniqueInput[]
  }

  export type AidRoomCheckCreateNestedManyWithoutMountainInput = {
    create?: XOR<AidRoomCheckCreateWithoutMountainInput, AidRoomCheckUncheckedCreateWithoutMountainInput> | AidRoomCheckCreateWithoutMountainInput[] | AidRoomCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutMountainInput | AidRoomCheckCreateOrConnectWithoutMountainInput[]
    createMany?: AidRoomCheckCreateManyMountainInputEnvelope
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
  }

  export type HutCheckCreateNestedManyWithoutMountainInput = {
    create?: XOR<HutCheckCreateWithoutMountainInput, HutCheckUncheckedCreateWithoutMountainInput> | HutCheckCreateWithoutMountainInput[] | HutCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutMountainInput | HutCheckCreateOrConnectWithoutMountainInput[]
    createMany?: HutCheckCreateManyMountainInputEnvelope
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
  }

  export type LiftCheckCreateNestedManyWithoutMountainInput = {
    create?: XOR<LiftCheckCreateWithoutMountainInput, LiftCheckUncheckedCreateWithoutMountainInput> | LiftCheckCreateWithoutMountainInput[] | LiftCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutMountainInput | LiftCheckCreateOrConnectWithoutMountainInput[]
    createMany?: LiftCheckCreateManyMountainInputEnvelope
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
  }

  export type TrailCheckCreateNestedManyWithoutMountainInput = {
    create?: XOR<TrailCheckCreateWithoutMountainInput, TrailCheckUncheckedCreateWithoutMountainInput> | TrailCheckCreateWithoutMountainInput[] | TrailCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutMountainInput | TrailCheckCreateOrConnectWithoutMountainInput[]
    createMany?: TrailCheckCreateManyMountainInputEnvelope
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
  }

  export type EquipmentCheckCreateNestedManyWithoutMountainInput = {
    create?: XOR<EquipmentCheckCreateWithoutMountainInput, EquipmentCheckUncheckedCreateWithoutMountainInput> | EquipmentCheckCreateWithoutMountainInput[] | EquipmentCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutMountainInput | EquipmentCheckCreateOrConnectWithoutMountainInput[]
    createMany?: EquipmentCheckCreateManyMountainInputEnvelope
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
  }

  export type IncidentCreateNestedManyWithoutMountainInput = {
    create?: XOR<IncidentCreateWithoutMountainInput, IncidentUncheckedCreateWithoutMountainInput> | IncidentCreateWithoutMountainInput[] | IncidentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutMountainInput | IncidentCreateOrConnectWithoutMountainInput[]
    createMany?: IncidentCreateManyMountainInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type EquipmentCreateNestedManyWithoutMountainInput = {
    create?: XOR<EquipmentCreateWithoutMountainInput, EquipmentUncheckedCreateWithoutMountainInput> | EquipmentCreateWithoutMountainInput[] | EquipmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutMountainInput | EquipmentCreateOrConnectWithoutMountainInput[]
    createMany?: EquipmentCreateManyMountainInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type EmployeeMountainAssignmentCreateNestedManyWithoutMountainInput = {
    create?: XOR<EmployeeMountainAssignmentCreateWithoutMountainInput, EmployeeMountainAssignmentUncheckedCreateWithoutMountainInput> | EmployeeMountainAssignmentCreateWithoutMountainInput[] | EmployeeMountainAssignmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EmployeeMountainAssignmentCreateOrConnectWithoutMountainInput | EmployeeMountainAssignmentCreateOrConnectWithoutMountainInput[]
    createMany?: EmployeeMountainAssignmentCreateManyMountainInputEnvelope
    connect?: EmployeeMountainAssignmentWhereUniqueInput | EmployeeMountainAssignmentWhereUniqueInput[]
  }

  export type DispatcherAssignmentCreateNestedManyWithoutMountainInput = {
    create?: XOR<DispatcherAssignmentCreateWithoutMountainInput, DispatcherAssignmentUncheckedCreateWithoutMountainInput> | DispatcherAssignmentCreateWithoutMountainInput[] | DispatcherAssignmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: DispatcherAssignmentCreateOrConnectWithoutMountainInput | DispatcherAssignmentCreateOrConnectWithoutMountainInput[]
    createMany?: DispatcherAssignmentCreateManyMountainInputEnvelope
    connect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
  }

  export type IncidentEquipmentUsageLogCreateNestedManyWithoutMountainInput = {
    create?: XOR<IncidentEquipmentUsageLogCreateWithoutMountainInput, IncidentEquipmentUsageLogUncheckedCreateWithoutMountainInput> | IncidentEquipmentUsageLogCreateWithoutMountainInput[] | IncidentEquipmentUsageLogUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: IncidentEquipmentUsageLogCreateOrConnectWithoutMountainInput | IncidentEquipmentUsageLogCreateOrConnectWithoutMountainInput[]
    createMany?: IncidentEquipmentUsageLogCreateManyMountainInputEnvelope
    connect?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
  }

  export type EquipmentServiceLogCreateNestedManyWithoutMountainInput = {
    create?: XOR<EquipmentServiceLogCreateWithoutMountainInput, EquipmentServiceLogUncheckedCreateWithoutMountainInput> | EquipmentServiceLogCreateWithoutMountainInput[] | EquipmentServiceLogUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EquipmentServiceLogCreateOrConnectWithoutMountainInput | EquipmentServiceLogCreateOrConnectWithoutMountainInput[]
    createMany?: EquipmentServiceLogCreateManyMountainInputEnvelope
    connect?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
  }

  export type WeatherUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<WeatherCreateWithoutMountainInput, WeatherUncheckedCreateWithoutMountainInput> | WeatherCreateWithoutMountainInput[] | WeatherUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: WeatherCreateOrConnectWithoutMountainInput | WeatherCreateOrConnectWithoutMountainInput[]
    createMany?: WeatherCreateManyMountainInputEnvelope
    connect?: WeatherWhereUniqueInput | WeatherWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<LocationCreateWithoutMountainInput, LocationUncheckedCreateWithoutMountainInput> | LocationCreateWithoutMountainInput[] | LocationUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutMountainInput | LocationCreateOrConnectWithoutMountainInput[]
    createMany?: LocationCreateManyMountainInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type AreaUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<AreaCreateWithoutMountainInput, AreaUncheckedCreateWithoutMountainInput> | AreaCreateWithoutMountainInput[] | AreaUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: AreaCreateOrConnectWithoutMountainInput | AreaCreateOrConnectWithoutMountainInput[]
    createMany?: AreaCreateManyMountainInputEnvelope
    connect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
  }

  export type AidRoomUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<AidRoomCreateWithoutMountainInput, AidRoomUncheckedCreateWithoutMountainInput> | AidRoomCreateWithoutMountainInput[] | AidRoomUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: AidRoomCreateOrConnectWithoutMountainInput | AidRoomCreateOrConnectWithoutMountainInput[]
    createMany?: AidRoomCreateManyMountainInputEnvelope
    connect?: AidRoomWhereUniqueInput | AidRoomWhereUniqueInput[]
  }

  export type HutUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<HutCreateWithoutMountainInput, HutUncheckedCreateWithoutMountainInput> | HutCreateWithoutMountainInput[] | HutUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: HutCreateOrConnectWithoutMountainInput | HutCreateOrConnectWithoutMountainInput[]
    createMany?: HutCreateManyMountainInputEnvelope
    connect?: HutWhereUniqueInput | HutWhereUniqueInput[]
  }

  export type LodgeUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<LodgeCreateWithoutMountainInput, LodgeUncheckedCreateWithoutMountainInput> | LodgeCreateWithoutMountainInput[] | LodgeUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LodgeCreateOrConnectWithoutMountainInput | LodgeCreateOrConnectWithoutMountainInput[]
    createMany?: LodgeCreateManyMountainInputEnvelope
    connect?: LodgeWhereUniqueInput | LodgeWhereUniqueInput[]
  }

  export type LiftUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<LiftCreateWithoutMountainInput, LiftUncheckedCreateWithoutMountainInput> | LiftCreateWithoutMountainInput[] | LiftUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LiftCreateOrConnectWithoutMountainInput | LiftCreateOrConnectWithoutMountainInput[]
    createMany?: LiftCreateManyMountainInputEnvelope
    connect?: LiftWhereUniqueInput | LiftWhereUniqueInput[]
  }

  export type TrailUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<TrailCreateWithoutMountainInput, TrailUncheckedCreateWithoutMountainInput> | TrailCreateWithoutMountainInput[] | TrailUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: TrailCreateOrConnectWithoutMountainInput | TrailCreateOrConnectWithoutMountainInput[]
    createMany?: TrailCreateManyMountainInputEnvelope
    connect?: TrailWhereUniqueInput | TrailWhereUniqueInput[]
  }

  export type AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<AidRoomCheckCreateWithoutMountainInput, AidRoomCheckUncheckedCreateWithoutMountainInput> | AidRoomCheckCreateWithoutMountainInput[] | AidRoomCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutMountainInput | AidRoomCheckCreateOrConnectWithoutMountainInput[]
    createMany?: AidRoomCheckCreateManyMountainInputEnvelope
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
  }

  export type HutCheckUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<HutCheckCreateWithoutMountainInput, HutCheckUncheckedCreateWithoutMountainInput> | HutCheckCreateWithoutMountainInput[] | HutCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutMountainInput | HutCheckCreateOrConnectWithoutMountainInput[]
    createMany?: HutCheckCreateManyMountainInputEnvelope
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
  }

  export type LiftCheckUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<LiftCheckCreateWithoutMountainInput, LiftCheckUncheckedCreateWithoutMountainInput> | LiftCheckCreateWithoutMountainInput[] | LiftCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutMountainInput | LiftCheckCreateOrConnectWithoutMountainInput[]
    createMany?: LiftCheckCreateManyMountainInputEnvelope
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
  }

  export type TrailCheckUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<TrailCheckCreateWithoutMountainInput, TrailCheckUncheckedCreateWithoutMountainInput> | TrailCheckCreateWithoutMountainInput[] | TrailCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutMountainInput | TrailCheckCreateOrConnectWithoutMountainInput[]
    createMany?: TrailCheckCreateManyMountainInputEnvelope
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
  }

  export type EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<EquipmentCheckCreateWithoutMountainInput, EquipmentCheckUncheckedCreateWithoutMountainInput> | EquipmentCheckCreateWithoutMountainInput[] | EquipmentCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutMountainInput | EquipmentCheckCreateOrConnectWithoutMountainInput[]
    createMany?: EquipmentCheckCreateManyMountainInputEnvelope
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
  }

  export type IncidentUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<IncidentCreateWithoutMountainInput, IncidentUncheckedCreateWithoutMountainInput> | IncidentCreateWithoutMountainInput[] | IncidentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutMountainInput | IncidentCreateOrConnectWithoutMountainInput[]
    createMany?: IncidentCreateManyMountainInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type EquipmentUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<EquipmentCreateWithoutMountainInput, EquipmentUncheckedCreateWithoutMountainInput> | EquipmentCreateWithoutMountainInput[] | EquipmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutMountainInput | EquipmentCreateOrConnectWithoutMountainInput[]
    createMany?: EquipmentCreateManyMountainInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<EmployeeMountainAssignmentCreateWithoutMountainInput, EmployeeMountainAssignmentUncheckedCreateWithoutMountainInput> | EmployeeMountainAssignmentCreateWithoutMountainInput[] | EmployeeMountainAssignmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EmployeeMountainAssignmentCreateOrConnectWithoutMountainInput | EmployeeMountainAssignmentCreateOrConnectWithoutMountainInput[]
    createMany?: EmployeeMountainAssignmentCreateManyMountainInputEnvelope
    connect?: EmployeeMountainAssignmentWhereUniqueInput | EmployeeMountainAssignmentWhereUniqueInput[]
  }

  export type DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<DispatcherAssignmentCreateWithoutMountainInput, DispatcherAssignmentUncheckedCreateWithoutMountainInput> | DispatcherAssignmentCreateWithoutMountainInput[] | DispatcherAssignmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: DispatcherAssignmentCreateOrConnectWithoutMountainInput | DispatcherAssignmentCreateOrConnectWithoutMountainInput[]
    createMany?: DispatcherAssignmentCreateManyMountainInputEnvelope
    connect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
  }

  export type IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<IncidentEquipmentUsageLogCreateWithoutMountainInput, IncidentEquipmentUsageLogUncheckedCreateWithoutMountainInput> | IncidentEquipmentUsageLogCreateWithoutMountainInput[] | IncidentEquipmentUsageLogUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: IncidentEquipmentUsageLogCreateOrConnectWithoutMountainInput | IncidentEquipmentUsageLogCreateOrConnectWithoutMountainInput[]
    createMany?: IncidentEquipmentUsageLogCreateManyMountainInputEnvelope
    connect?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
  }

  export type EquipmentServiceLogUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<EquipmentServiceLogCreateWithoutMountainInput, EquipmentServiceLogUncheckedCreateWithoutMountainInput> | EquipmentServiceLogCreateWithoutMountainInput[] | EquipmentServiceLogUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EquipmentServiceLogCreateOrConnectWithoutMountainInput | EquipmentServiceLogCreateOrConnectWithoutMountainInput[]
    createMany?: EquipmentServiceLogCreateManyMountainInputEnvelope
    connect?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WeatherUpdateManyWithoutMountainNestedInput = {
    create?: XOR<WeatherCreateWithoutMountainInput, WeatherUncheckedCreateWithoutMountainInput> | WeatherCreateWithoutMountainInput[] | WeatherUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: WeatherCreateOrConnectWithoutMountainInput | WeatherCreateOrConnectWithoutMountainInput[]
    upsert?: WeatherUpsertWithWhereUniqueWithoutMountainInput | WeatherUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: WeatherCreateManyMountainInputEnvelope
    set?: WeatherWhereUniqueInput | WeatherWhereUniqueInput[]
    disconnect?: WeatherWhereUniqueInput | WeatherWhereUniqueInput[]
    delete?: WeatherWhereUniqueInput | WeatherWhereUniqueInput[]
    connect?: WeatherWhereUniqueInput | WeatherWhereUniqueInput[]
    update?: WeatherUpdateWithWhereUniqueWithoutMountainInput | WeatherUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: WeatherUpdateManyWithWhereWithoutMountainInput | WeatherUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: WeatherScalarWhereInput | WeatherScalarWhereInput[]
  }

  export type LocationUpdateManyWithoutMountainNestedInput = {
    create?: XOR<LocationCreateWithoutMountainInput, LocationUncheckedCreateWithoutMountainInput> | LocationCreateWithoutMountainInput[] | LocationUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutMountainInput | LocationCreateOrConnectWithoutMountainInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutMountainInput | LocationUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: LocationCreateManyMountainInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutMountainInput | LocationUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutMountainInput | LocationUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type AreaUpdateManyWithoutMountainNestedInput = {
    create?: XOR<AreaCreateWithoutMountainInput, AreaUncheckedCreateWithoutMountainInput> | AreaCreateWithoutMountainInput[] | AreaUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: AreaCreateOrConnectWithoutMountainInput | AreaCreateOrConnectWithoutMountainInput[]
    upsert?: AreaUpsertWithWhereUniqueWithoutMountainInput | AreaUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: AreaCreateManyMountainInputEnvelope
    set?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    disconnect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    delete?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    connect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    update?: AreaUpdateWithWhereUniqueWithoutMountainInput | AreaUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: AreaUpdateManyWithWhereWithoutMountainInput | AreaUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: AreaScalarWhereInput | AreaScalarWhereInput[]
  }

  export type AidRoomUpdateManyWithoutMountainNestedInput = {
    create?: XOR<AidRoomCreateWithoutMountainInput, AidRoomUncheckedCreateWithoutMountainInput> | AidRoomCreateWithoutMountainInput[] | AidRoomUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: AidRoomCreateOrConnectWithoutMountainInput | AidRoomCreateOrConnectWithoutMountainInput[]
    upsert?: AidRoomUpsertWithWhereUniqueWithoutMountainInput | AidRoomUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: AidRoomCreateManyMountainInputEnvelope
    set?: AidRoomWhereUniqueInput | AidRoomWhereUniqueInput[]
    disconnect?: AidRoomWhereUniqueInput | AidRoomWhereUniqueInput[]
    delete?: AidRoomWhereUniqueInput | AidRoomWhereUniqueInput[]
    connect?: AidRoomWhereUniqueInput | AidRoomWhereUniqueInput[]
    update?: AidRoomUpdateWithWhereUniqueWithoutMountainInput | AidRoomUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: AidRoomUpdateManyWithWhereWithoutMountainInput | AidRoomUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: AidRoomScalarWhereInput | AidRoomScalarWhereInput[]
  }

  export type HutUpdateManyWithoutMountainNestedInput = {
    create?: XOR<HutCreateWithoutMountainInput, HutUncheckedCreateWithoutMountainInput> | HutCreateWithoutMountainInput[] | HutUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: HutCreateOrConnectWithoutMountainInput | HutCreateOrConnectWithoutMountainInput[]
    upsert?: HutUpsertWithWhereUniqueWithoutMountainInput | HutUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: HutCreateManyMountainInputEnvelope
    set?: HutWhereUniqueInput | HutWhereUniqueInput[]
    disconnect?: HutWhereUniqueInput | HutWhereUniqueInput[]
    delete?: HutWhereUniqueInput | HutWhereUniqueInput[]
    connect?: HutWhereUniqueInput | HutWhereUniqueInput[]
    update?: HutUpdateWithWhereUniqueWithoutMountainInput | HutUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: HutUpdateManyWithWhereWithoutMountainInput | HutUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: HutScalarWhereInput | HutScalarWhereInput[]
  }

  export type LodgeUpdateManyWithoutMountainNestedInput = {
    create?: XOR<LodgeCreateWithoutMountainInput, LodgeUncheckedCreateWithoutMountainInput> | LodgeCreateWithoutMountainInput[] | LodgeUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LodgeCreateOrConnectWithoutMountainInput | LodgeCreateOrConnectWithoutMountainInput[]
    upsert?: LodgeUpsertWithWhereUniqueWithoutMountainInput | LodgeUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: LodgeCreateManyMountainInputEnvelope
    set?: LodgeWhereUniqueInput | LodgeWhereUniqueInput[]
    disconnect?: LodgeWhereUniqueInput | LodgeWhereUniqueInput[]
    delete?: LodgeWhereUniqueInput | LodgeWhereUniqueInput[]
    connect?: LodgeWhereUniqueInput | LodgeWhereUniqueInput[]
    update?: LodgeUpdateWithWhereUniqueWithoutMountainInput | LodgeUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: LodgeUpdateManyWithWhereWithoutMountainInput | LodgeUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: LodgeScalarWhereInput | LodgeScalarWhereInput[]
  }

  export type LiftUpdateManyWithoutMountainNestedInput = {
    create?: XOR<LiftCreateWithoutMountainInput, LiftUncheckedCreateWithoutMountainInput> | LiftCreateWithoutMountainInput[] | LiftUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LiftCreateOrConnectWithoutMountainInput | LiftCreateOrConnectWithoutMountainInput[]
    upsert?: LiftUpsertWithWhereUniqueWithoutMountainInput | LiftUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: LiftCreateManyMountainInputEnvelope
    set?: LiftWhereUniqueInput | LiftWhereUniqueInput[]
    disconnect?: LiftWhereUniqueInput | LiftWhereUniqueInput[]
    delete?: LiftWhereUniqueInput | LiftWhereUniqueInput[]
    connect?: LiftWhereUniqueInput | LiftWhereUniqueInput[]
    update?: LiftUpdateWithWhereUniqueWithoutMountainInput | LiftUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: LiftUpdateManyWithWhereWithoutMountainInput | LiftUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: LiftScalarWhereInput | LiftScalarWhereInput[]
  }

  export type TrailUpdateManyWithoutMountainNestedInput = {
    create?: XOR<TrailCreateWithoutMountainInput, TrailUncheckedCreateWithoutMountainInput> | TrailCreateWithoutMountainInput[] | TrailUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: TrailCreateOrConnectWithoutMountainInput | TrailCreateOrConnectWithoutMountainInput[]
    upsert?: TrailUpsertWithWhereUniqueWithoutMountainInput | TrailUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: TrailCreateManyMountainInputEnvelope
    set?: TrailWhereUniqueInput | TrailWhereUniqueInput[]
    disconnect?: TrailWhereUniqueInput | TrailWhereUniqueInput[]
    delete?: TrailWhereUniqueInput | TrailWhereUniqueInput[]
    connect?: TrailWhereUniqueInput | TrailWhereUniqueInput[]
    update?: TrailUpdateWithWhereUniqueWithoutMountainInput | TrailUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: TrailUpdateManyWithWhereWithoutMountainInput | TrailUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: TrailScalarWhereInput | TrailScalarWhereInput[]
  }

  export type AidRoomCheckUpdateManyWithoutMountainNestedInput = {
    create?: XOR<AidRoomCheckCreateWithoutMountainInput, AidRoomCheckUncheckedCreateWithoutMountainInput> | AidRoomCheckCreateWithoutMountainInput[] | AidRoomCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutMountainInput | AidRoomCheckCreateOrConnectWithoutMountainInput[]
    upsert?: AidRoomCheckUpsertWithWhereUniqueWithoutMountainInput | AidRoomCheckUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: AidRoomCheckCreateManyMountainInputEnvelope
    set?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    disconnect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    delete?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    update?: AidRoomCheckUpdateWithWhereUniqueWithoutMountainInput | AidRoomCheckUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: AidRoomCheckUpdateManyWithWhereWithoutMountainInput | AidRoomCheckUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: AidRoomCheckScalarWhereInput | AidRoomCheckScalarWhereInput[]
  }

  export type HutCheckUpdateManyWithoutMountainNestedInput = {
    create?: XOR<HutCheckCreateWithoutMountainInput, HutCheckUncheckedCreateWithoutMountainInput> | HutCheckCreateWithoutMountainInput[] | HutCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutMountainInput | HutCheckCreateOrConnectWithoutMountainInput[]
    upsert?: HutCheckUpsertWithWhereUniqueWithoutMountainInput | HutCheckUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: HutCheckCreateManyMountainInputEnvelope
    set?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    disconnect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    delete?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    update?: HutCheckUpdateWithWhereUniqueWithoutMountainInput | HutCheckUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: HutCheckUpdateManyWithWhereWithoutMountainInput | HutCheckUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: HutCheckScalarWhereInput | HutCheckScalarWhereInput[]
  }

  export type LiftCheckUpdateManyWithoutMountainNestedInput = {
    create?: XOR<LiftCheckCreateWithoutMountainInput, LiftCheckUncheckedCreateWithoutMountainInput> | LiftCheckCreateWithoutMountainInput[] | LiftCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutMountainInput | LiftCheckCreateOrConnectWithoutMountainInput[]
    upsert?: LiftCheckUpsertWithWhereUniqueWithoutMountainInput | LiftCheckUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: LiftCheckCreateManyMountainInputEnvelope
    set?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    disconnect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    delete?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    update?: LiftCheckUpdateWithWhereUniqueWithoutMountainInput | LiftCheckUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: LiftCheckUpdateManyWithWhereWithoutMountainInput | LiftCheckUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: LiftCheckScalarWhereInput | LiftCheckScalarWhereInput[]
  }

  export type TrailCheckUpdateManyWithoutMountainNestedInput = {
    create?: XOR<TrailCheckCreateWithoutMountainInput, TrailCheckUncheckedCreateWithoutMountainInput> | TrailCheckCreateWithoutMountainInput[] | TrailCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutMountainInput | TrailCheckCreateOrConnectWithoutMountainInput[]
    upsert?: TrailCheckUpsertWithWhereUniqueWithoutMountainInput | TrailCheckUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: TrailCheckCreateManyMountainInputEnvelope
    set?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    disconnect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    delete?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    update?: TrailCheckUpdateWithWhereUniqueWithoutMountainInput | TrailCheckUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: TrailCheckUpdateManyWithWhereWithoutMountainInput | TrailCheckUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: TrailCheckScalarWhereInput | TrailCheckScalarWhereInput[]
  }

  export type EquipmentCheckUpdateManyWithoutMountainNestedInput = {
    create?: XOR<EquipmentCheckCreateWithoutMountainInput, EquipmentCheckUncheckedCreateWithoutMountainInput> | EquipmentCheckCreateWithoutMountainInput[] | EquipmentCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutMountainInput | EquipmentCheckCreateOrConnectWithoutMountainInput[]
    upsert?: EquipmentCheckUpsertWithWhereUniqueWithoutMountainInput | EquipmentCheckUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: EquipmentCheckCreateManyMountainInputEnvelope
    set?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    disconnect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    delete?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    update?: EquipmentCheckUpdateWithWhereUniqueWithoutMountainInput | EquipmentCheckUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: EquipmentCheckUpdateManyWithWhereWithoutMountainInput | EquipmentCheckUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: EquipmentCheckScalarWhereInput | EquipmentCheckScalarWhereInput[]
  }

  export type IncidentUpdateManyWithoutMountainNestedInput = {
    create?: XOR<IncidentCreateWithoutMountainInput, IncidentUncheckedCreateWithoutMountainInput> | IncidentCreateWithoutMountainInput[] | IncidentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutMountainInput | IncidentCreateOrConnectWithoutMountainInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutMountainInput | IncidentUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: IncidentCreateManyMountainInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutMountainInput | IncidentUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutMountainInput | IncidentUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type EquipmentUpdateManyWithoutMountainNestedInput = {
    create?: XOR<EquipmentCreateWithoutMountainInput, EquipmentUncheckedCreateWithoutMountainInput> | EquipmentCreateWithoutMountainInput[] | EquipmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutMountainInput | EquipmentCreateOrConnectWithoutMountainInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutMountainInput | EquipmentUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: EquipmentCreateManyMountainInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutMountainInput | EquipmentUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutMountainInput | EquipmentUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type EmployeeMountainAssignmentUpdateManyWithoutMountainNestedInput = {
    create?: XOR<EmployeeMountainAssignmentCreateWithoutMountainInput, EmployeeMountainAssignmentUncheckedCreateWithoutMountainInput> | EmployeeMountainAssignmentCreateWithoutMountainInput[] | EmployeeMountainAssignmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EmployeeMountainAssignmentCreateOrConnectWithoutMountainInput | EmployeeMountainAssignmentCreateOrConnectWithoutMountainInput[]
    upsert?: EmployeeMountainAssignmentUpsertWithWhereUniqueWithoutMountainInput | EmployeeMountainAssignmentUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: EmployeeMountainAssignmentCreateManyMountainInputEnvelope
    set?: EmployeeMountainAssignmentWhereUniqueInput | EmployeeMountainAssignmentWhereUniqueInput[]
    disconnect?: EmployeeMountainAssignmentWhereUniqueInput | EmployeeMountainAssignmentWhereUniqueInput[]
    delete?: EmployeeMountainAssignmentWhereUniqueInput | EmployeeMountainAssignmentWhereUniqueInput[]
    connect?: EmployeeMountainAssignmentWhereUniqueInput | EmployeeMountainAssignmentWhereUniqueInput[]
    update?: EmployeeMountainAssignmentUpdateWithWhereUniqueWithoutMountainInput | EmployeeMountainAssignmentUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: EmployeeMountainAssignmentUpdateManyWithWhereWithoutMountainInput | EmployeeMountainAssignmentUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: EmployeeMountainAssignmentScalarWhereInput | EmployeeMountainAssignmentScalarWhereInput[]
  }

  export type DispatcherAssignmentUpdateManyWithoutMountainNestedInput = {
    create?: XOR<DispatcherAssignmentCreateWithoutMountainInput, DispatcherAssignmentUncheckedCreateWithoutMountainInput> | DispatcherAssignmentCreateWithoutMountainInput[] | DispatcherAssignmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: DispatcherAssignmentCreateOrConnectWithoutMountainInput | DispatcherAssignmentCreateOrConnectWithoutMountainInput[]
    upsert?: DispatcherAssignmentUpsertWithWhereUniqueWithoutMountainInput | DispatcherAssignmentUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: DispatcherAssignmentCreateManyMountainInputEnvelope
    set?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    disconnect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    delete?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    connect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    update?: DispatcherAssignmentUpdateWithWhereUniqueWithoutMountainInput | DispatcherAssignmentUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: DispatcherAssignmentUpdateManyWithWhereWithoutMountainInput | DispatcherAssignmentUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: DispatcherAssignmentScalarWhereInput | DispatcherAssignmentScalarWhereInput[]
  }

  export type IncidentEquipmentUsageLogUpdateManyWithoutMountainNestedInput = {
    create?: XOR<IncidentEquipmentUsageLogCreateWithoutMountainInput, IncidentEquipmentUsageLogUncheckedCreateWithoutMountainInput> | IncidentEquipmentUsageLogCreateWithoutMountainInput[] | IncidentEquipmentUsageLogUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: IncidentEquipmentUsageLogCreateOrConnectWithoutMountainInput | IncidentEquipmentUsageLogCreateOrConnectWithoutMountainInput[]
    upsert?: IncidentEquipmentUsageLogUpsertWithWhereUniqueWithoutMountainInput | IncidentEquipmentUsageLogUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: IncidentEquipmentUsageLogCreateManyMountainInputEnvelope
    set?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    disconnect?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    delete?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    connect?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    update?: IncidentEquipmentUsageLogUpdateWithWhereUniqueWithoutMountainInput | IncidentEquipmentUsageLogUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: IncidentEquipmentUsageLogUpdateManyWithWhereWithoutMountainInput | IncidentEquipmentUsageLogUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: IncidentEquipmentUsageLogScalarWhereInput | IncidentEquipmentUsageLogScalarWhereInput[]
  }

  export type EquipmentServiceLogUpdateManyWithoutMountainNestedInput = {
    create?: XOR<EquipmentServiceLogCreateWithoutMountainInput, EquipmentServiceLogUncheckedCreateWithoutMountainInput> | EquipmentServiceLogCreateWithoutMountainInput[] | EquipmentServiceLogUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EquipmentServiceLogCreateOrConnectWithoutMountainInput | EquipmentServiceLogCreateOrConnectWithoutMountainInput[]
    upsert?: EquipmentServiceLogUpsertWithWhereUniqueWithoutMountainInput | EquipmentServiceLogUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: EquipmentServiceLogCreateManyMountainInputEnvelope
    set?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    disconnect?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    delete?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    connect?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    update?: EquipmentServiceLogUpdateWithWhereUniqueWithoutMountainInput | EquipmentServiceLogUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: EquipmentServiceLogUpdateManyWithWhereWithoutMountainInput | EquipmentServiceLogUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: EquipmentServiceLogScalarWhereInput | EquipmentServiceLogScalarWhereInput[]
  }

  export type WeatherUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<WeatherCreateWithoutMountainInput, WeatherUncheckedCreateWithoutMountainInput> | WeatherCreateWithoutMountainInput[] | WeatherUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: WeatherCreateOrConnectWithoutMountainInput | WeatherCreateOrConnectWithoutMountainInput[]
    upsert?: WeatherUpsertWithWhereUniqueWithoutMountainInput | WeatherUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: WeatherCreateManyMountainInputEnvelope
    set?: WeatherWhereUniqueInput | WeatherWhereUniqueInput[]
    disconnect?: WeatherWhereUniqueInput | WeatherWhereUniqueInput[]
    delete?: WeatherWhereUniqueInput | WeatherWhereUniqueInput[]
    connect?: WeatherWhereUniqueInput | WeatherWhereUniqueInput[]
    update?: WeatherUpdateWithWhereUniqueWithoutMountainInput | WeatherUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: WeatherUpdateManyWithWhereWithoutMountainInput | WeatherUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: WeatherScalarWhereInput | WeatherScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<LocationCreateWithoutMountainInput, LocationUncheckedCreateWithoutMountainInput> | LocationCreateWithoutMountainInput[] | LocationUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutMountainInput | LocationCreateOrConnectWithoutMountainInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutMountainInput | LocationUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: LocationCreateManyMountainInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutMountainInput | LocationUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutMountainInput | LocationUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type AreaUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<AreaCreateWithoutMountainInput, AreaUncheckedCreateWithoutMountainInput> | AreaCreateWithoutMountainInput[] | AreaUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: AreaCreateOrConnectWithoutMountainInput | AreaCreateOrConnectWithoutMountainInput[]
    upsert?: AreaUpsertWithWhereUniqueWithoutMountainInput | AreaUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: AreaCreateManyMountainInputEnvelope
    set?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    disconnect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    delete?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    connect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    update?: AreaUpdateWithWhereUniqueWithoutMountainInput | AreaUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: AreaUpdateManyWithWhereWithoutMountainInput | AreaUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: AreaScalarWhereInput | AreaScalarWhereInput[]
  }

  export type AidRoomUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<AidRoomCreateWithoutMountainInput, AidRoomUncheckedCreateWithoutMountainInput> | AidRoomCreateWithoutMountainInput[] | AidRoomUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: AidRoomCreateOrConnectWithoutMountainInput | AidRoomCreateOrConnectWithoutMountainInput[]
    upsert?: AidRoomUpsertWithWhereUniqueWithoutMountainInput | AidRoomUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: AidRoomCreateManyMountainInputEnvelope
    set?: AidRoomWhereUniqueInput | AidRoomWhereUniqueInput[]
    disconnect?: AidRoomWhereUniqueInput | AidRoomWhereUniqueInput[]
    delete?: AidRoomWhereUniqueInput | AidRoomWhereUniqueInput[]
    connect?: AidRoomWhereUniqueInput | AidRoomWhereUniqueInput[]
    update?: AidRoomUpdateWithWhereUniqueWithoutMountainInput | AidRoomUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: AidRoomUpdateManyWithWhereWithoutMountainInput | AidRoomUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: AidRoomScalarWhereInput | AidRoomScalarWhereInput[]
  }

  export type HutUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<HutCreateWithoutMountainInput, HutUncheckedCreateWithoutMountainInput> | HutCreateWithoutMountainInput[] | HutUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: HutCreateOrConnectWithoutMountainInput | HutCreateOrConnectWithoutMountainInput[]
    upsert?: HutUpsertWithWhereUniqueWithoutMountainInput | HutUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: HutCreateManyMountainInputEnvelope
    set?: HutWhereUniqueInput | HutWhereUniqueInput[]
    disconnect?: HutWhereUniqueInput | HutWhereUniqueInput[]
    delete?: HutWhereUniqueInput | HutWhereUniqueInput[]
    connect?: HutWhereUniqueInput | HutWhereUniqueInput[]
    update?: HutUpdateWithWhereUniqueWithoutMountainInput | HutUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: HutUpdateManyWithWhereWithoutMountainInput | HutUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: HutScalarWhereInput | HutScalarWhereInput[]
  }

  export type LodgeUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<LodgeCreateWithoutMountainInput, LodgeUncheckedCreateWithoutMountainInput> | LodgeCreateWithoutMountainInput[] | LodgeUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LodgeCreateOrConnectWithoutMountainInput | LodgeCreateOrConnectWithoutMountainInput[]
    upsert?: LodgeUpsertWithWhereUniqueWithoutMountainInput | LodgeUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: LodgeCreateManyMountainInputEnvelope
    set?: LodgeWhereUniqueInput | LodgeWhereUniqueInput[]
    disconnect?: LodgeWhereUniqueInput | LodgeWhereUniqueInput[]
    delete?: LodgeWhereUniqueInput | LodgeWhereUniqueInput[]
    connect?: LodgeWhereUniqueInput | LodgeWhereUniqueInput[]
    update?: LodgeUpdateWithWhereUniqueWithoutMountainInput | LodgeUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: LodgeUpdateManyWithWhereWithoutMountainInput | LodgeUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: LodgeScalarWhereInput | LodgeScalarWhereInput[]
  }

  export type LiftUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<LiftCreateWithoutMountainInput, LiftUncheckedCreateWithoutMountainInput> | LiftCreateWithoutMountainInput[] | LiftUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LiftCreateOrConnectWithoutMountainInput | LiftCreateOrConnectWithoutMountainInput[]
    upsert?: LiftUpsertWithWhereUniqueWithoutMountainInput | LiftUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: LiftCreateManyMountainInputEnvelope
    set?: LiftWhereUniqueInput | LiftWhereUniqueInput[]
    disconnect?: LiftWhereUniqueInput | LiftWhereUniqueInput[]
    delete?: LiftWhereUniqueInput | LiftWhereUniqueInput[]
    connect?: LiftWhereUniqueInput | LiftWhereUniqueInput[]
    update?: LiftUpdateWithWhereUniqueWithoutMountainInput | LiftUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: LiftUpdateManyWithWhereWithoutMountainInput | LiftUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: LiftScalarWhereInput | LiftScalarWhereInput[]
  }

  export type TrailUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<TrailCreateWithoutMountainInput, TrailUncheckedCreateWithoutMountainInput> | TrailCreateWithoutMountainInput[] | TrailUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: TrailCreateOrConnectWithoutMountainInput | TrailCreateOrConnectWithoutMountainInput[]
    upsert?: TrailUpsertWithWhereUniqueWithoutMountainInput | TrailUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: TrailCreateManyMountainInputEnvelope
    set?: TrailWhereUniqueInput | TrailWhereUniqueInput[]
    disconnect?: TrailWhereUniqueInput | TrailWhereUniqueInput[]
    delete?: TrailWhereUniqueInput | TrailWhereUniqueInput[]
    connect?: TrailWhereUniqueInput | TrailWhereUniqueInput[]
    update?: TrailUpdateWithWhereUniqueWithoutMountainInput | TrailUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: TrailUpdateManyWithWhereWithoutMountainInput | TrailUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: TrailScalarWhereInput | TrailScalarWhereInput[]
  }

  export type AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<AidRoomCheckCreateWithoutMountainInput, AidRoomCheckUncheckedCreateWithoutMountainInput> | AidRoomCheckCreateWithoutMountainInput[] | AidRoomCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutMountainInput | AidRoomCheckCreateOrConnectWithoutMountainInput[]
    upsert?: AidRoomCheckUpsertWithWhereUniqueWithoutMountainInput | AidRoomCheckUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: AidRoomCheckCreateManyMountainInputEnvelope
    set?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    disconnect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    delete?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    update?: AidRoomCheckUpdateWithWhereUniqueWithoutMountainInput | AidRoomCheckUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: AidRoomCheckUpdateManyWithWhereWithoutMountainInput | AidRoomCheckUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: AidRoomCheckScalarWhereInput | AidRoomCheckScalarWhereInput[]
  }

  export type HutCheckUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<HutCheckCreateWithoutMountainInput, HutCheckUncheckedCreateWithoutMountainInput> | HutCheckCreateWithoutMountainInput[] | HutCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutMountainInput | HutCheckCreateOrConnectWithoutMountainInput[]
    upsert?: HutCheckUpsertWithWhereUniqueWithoutMountainInput | HutCheckUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: HutCheckCreateManyMountainInputEnvelope
    set?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    disconnect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    delete?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    update?: HutCheckUpdateWithWhereUniqueWithoutMountainInput | HutCheckUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: HutCheckUpdateManyWithWhereWithoutMountainInput | HutCheckUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: HutCheckScalarWhereInput | HutCheckScalarWhereInput[]
  }

  export type LiftCheckUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<LiftCheckCreateWithoutMountainInput, LiftCheckUncheckedCreateWithoutMountainInput> | LiftCheckCreateWithoutMountainInput[] | LiftCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutMountainInput | LiftCheckCreateOrConnectWithoutMountainInput[]
    upsert?: LiftCheckUpsertWithWhereUniqueWithoutMountainInput | LiftCheckUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: LiftCheckCreateManyMountainInputEnvelope
    set?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    disconnect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    delete?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    update?: LiftCheckUpdateWithWhereUniqueWithoutMountainInput | LiftCheckUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: LiftCheckUpdateManyWithWhereWithoutMountainInput | LiftCheckUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: LiftCheckScalarWhereInput | LiftCheckScalarWhereInput[]
  }

  export type TrailCheckUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<TrailCheckCreateWithoutMountainInput, TrailCheckUncheckedCreateWithoutMountainInput> | TrailCheckCreateWithoutMountainInput[] | TrailCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutMountainInput | TrailCheckCreateOrConnectWithoutMountainInput[]
    upsert?: TrailCheckUpsertWithWhereUniqueWithoutMountainInput | TrailCheckUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: TrailCheckCreateManyMountainInputEnvelope
    set?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    disconnect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    delete?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    update?: TrailCheckUpdateWithWhereUniqueWithoutMountainInput | TrailCheckUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: TrailCheckUpdateManyWithWhereWithoutMountainInput | TrailCheckUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: TrailCheckScalarWhereInput | TrailCheckScalarWhereInput[]
  }

  export type EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<EquipmentCheckCreateWithoutMountainInput, EquipmentCheckUncheckedCreateWithoutMountainInput> | EquipmentCheckCreateWithoutMountainInput[] | EquipmentCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutMountainInput | EquipmentCheckCreateOrConnectWithoutMountainInput[]
    upsert?: EquipmentCheckUpsertWithWhereUniqueWithoutMountainInput | EquipmentCheckUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: EquipmentCheckCreateManyMountainInputEnvelope
    set?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    disconnect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    delete?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    update?: EquipmentCheckUpdateWithWhereUniqueWithoutMountainInput | EquipmentCheckUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: EquipmentCheckUpdateManyWithWhereWithoutMountainInput | EquipmentCheckUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: EquipmentCheckScalarWhereInput | EquipmentCheckScalarWhereInput[]
  }

  export type IncidentUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<IncidentCreateWithoutMountainInput, IncidentUncheckedCreateWithoutMountainInput> | IncidentCreateWithoutMountainInput[] | IncidentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutMountainInput | IncidentCreateOrConnectWithoutMountainInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutMountainInput | IncidentUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: IncidentCreateManyMountainInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutMountainInput | IncidentUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutMountainInput | IncidentUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type EquipmentUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<EquipmentCreateWithoutMountainInput, EquipmentUncheckedCreateWithoutMountainInput> | EquipmentCreateWithoutMountainInput[] | EquipmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutMountainInput | EquipmentCreateOrConnectWithoutMountainInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutMountainInput | EquipmentUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: EquipmentCreateManyMountainInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutMountainInput | EquipmentUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutMountainInput | EquipmentUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type EmployeeMountainAssignmentUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<EmployeeMountainAssignmentCreateWithoutMountainInput, EmployeeMountainAssignmentUncheckedCreateWithoutMountainInput> | EmployeeMountainAssignmentCreateWithoutMountainInput[] | EmployeeMountainAssignmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EmployeeMountainAssignmentCreateOrConnectWithoutMountainInput | EmployeeMountainAssignmentCreateOrConnectWithoutMountainInput[]
    upsert?: EmployeeMountainAssignmentUpsertWithWhereUniqueWithoutMountainInput | EmployeeMountainAssignmentUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: EmployeeMountainAssignmentCreateManyMountainInputEnvelope
    set?: EmployeeMountainAssignmentWhereUniqueInput | EmployeeMountainAssignmentWhereUniqueInput[]
    disconnect?: EmployeeMountainAssignmentWhereUniqueInput | EmployeeMountainAssignmentWhereUniqueInput[]
    delete?: EmployeeMountainAssignmentWhereUniqueInput | EmployeeMountainAssignmentWhereUniqueInput[]
    connect?: EmployeeMountainAssignmentWhereUniqueInput | EmployeeMountainAssignmentWhereUniqueInput[]
    update?: EmployeeMountainAssignmentUpdateWithWhereUniqueWithoutMountainInput | EmployeeMountainAssignmentUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: EmployeeMountainAssignmentUpdateManyWithWhereWithoutMountainInput | EmployeeMountainAssignmentUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: EmployeeMountainAssignmentScalarWhereInput | EmployeeMountainAssignmentScalarWhereInput[]
  }

  export type DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<DispatcherAssignmentCreateWithoutMountainInput, DispatcherAssignmentUncheckedCreateWithoutMountainInput> | DispatcherAssignmentCreateWithoutMountainInput[] | DispatcherAssignmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: DispatcherAssignmentCreateOrConnectWithoutMountainInput | DispatcherAssignmentCreateOrConnectWithoutMountainInput[]
    upsert?: DispatcherAssignmentUpsertWithWhereUniqueWithoutMountainInput | DispatcherAssignmentUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: DispatcherAssignmentCreateManyMountainInputEnvelope
    set?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    disconnect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    delete?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    connect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    update?: DispatcherAssignmentUpdateWithWhereUniqueWithoutMountainInput | DispatcherAssignmentUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: DispatcherAssignmentUpdateManyWithWhereWithoutMountainInput | DispatcherAssignmentUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: DispatcherAssignmentScalarWhereInput | DispatcherAssignmentScalarWhereInput[]
  }

  export type IncidentEquipmentUsageLogUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<IncidentEquipmentUsageLogCreateWithoutMountainInput, IncidentEquipmentUsageLogUncheckedCreateWithoutMountainInput> | IncidentEquipmentUsageLogCreateWithoutMountainInput[] | IncidentEquipmentUsageLogUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: IncidentEquipmentUsageLogCreateOrConnectWithoutMountainInput | IncidentEquipmentUsageLogCreateOrConnectWithoutMountainInput[]
    upsert?: IncidentEquipmentUsageLogUpsertWithWhereUniqueWithoutMountainInput | IncidentEquipmentUsageLogUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: IncidentEquipmentUsageLogCreateManyMountainInputEnvelope
    set?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    disconnect?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    delete?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    connect?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    update?: IncidentEquipmentUsageLogUpdateWithWhereUniqueWithoutMountainInput | IncidentEquipmentUsageLogUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: IncidentEquipmentUsageLogUpdateManyWithWhereWithoutMountainInput | IncidentEquipmentUsageLogUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: IncidentEquipmentUsageLogScalarWhereInput | IncidentEquipmentUsageLogScalarWhereInput[]
  }

  export type EquipmentServiceLogUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<EquipmentServiceLogCreateWithoutMountainInput, EquipmentServiceLogUncheckedCreateWithoutMountainInput> | EquipmentServiceLogCreateWithoutMountainInput[] | EquipmentServiceLogUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EquipmentServiceLogCreateOrConnectWithoutMountainInput | EquipmentServiceLogCreateOrConnectWithoutMountainInput[]
    upsert?: EquipmentServiceLogUpsertWithWhereUniqueWithoutMountainInput | EquipmentServiceLogUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: EquipmentServiceLogCreateManyMountainInputEnvelope
    set?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    disconnect?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    delete?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    connect?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    update?: EquipmentServiceLogUpdateWithWhereUniqueWithoutMountainInput | EquipmentServiceLogUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: EquipmentServiceLogUpdateManyWithWhereWithoutMountainInput | EquipmentServiceLogUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: EquipmentServiceLogScalarWhereInput | EquipmentServiceLogScalarWhereInput[]
  }

  export type MountainCreateNestedOneWithoutWeatherInput = {
    create?: XOR<MountainCreateWithoutWeatherInput, MountainUncheckedCreateWithoutWeatherInput>
    connectOrCreate?: MountainCreateOrConnectWithoutWeatherInput
    connect?: MountainWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MountainUpdateOneRequiredWithoutWeatherNestedInput = {
    create?: XOR<MountainCreateWithoutWeatherInput, MountainUncheckedCreateWithoutWeatherInput>
    connectOrCreate?: MountainCreateOrConnectWithoutWeatherInput
    upsert?: MountainUpsertWithoutWeatherInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutWeatherInput, MountainUpdateWithoutWeatherInput>, MountainUncheckedUpdateWithoutWeatherInput>
  }

  export type EmployeeCreateNestedOneWithoutMountainAssignmentsInput = {
    create?: XOR<EmployeeCreateWithoutMountainAssignmentsInput, EmployeeUncheckedCreateWithoutMountainAssignmentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutMountainAssignmentsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type MountainCreateNestedOneWithoutEmployeeAssignmentsInput = {
    create?: XOR<MountainCreateWithoutEmployeeAssignmentsInput, MountainUncheckedCreateWithoutEmployeeAssignmentsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutEmployeeAssignmentsInput
    connect?: MountainWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutMountainAssignmentsNestedInput = {
    create?: XOR<EmployeeCreateWithoutMountainAssignmentsInput, EmployeeUncheckedCreateWithoutMountainAssignmentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutMountainAssignmentsInput
    upsert?: EmployeeUpsertWithoutMountainAssignmentsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutMountainAssignmentsInput, EmployeeUpdateWithoutMountainAssignmentsInput>, EmployeeUncheckedUpdateWithoutMountainAssignmentsInput>
  }

  export type MountainUpdateOneRequiredWithoutEmployeeAssignmentsNestedInput = {
    create?: XOR<MountainCreateWithoutEmployeeAssignmentsInput, MountainUncheckedCreateWithoutEmployeeAssignmentsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutEmployeeAssignmentsInput
    upsert?: MountainUpsertWithoutEmployeeAssignmentsInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutEmployeeAssignmentsInput, MountainUpdateWithoutEmployeeAssignmentsInput>, MountainUncheckedUpdateWithoutEmployeeAssignmentsInput>
  }

  export type EmployeeCreateNestedOneWithoutDispatcherAssignmentsInput = {
    create?: XOR<EmployeeCreateWithoutDispatcherAssignmentsInput, EmployeeUncheckedCreateWithoutDispatcherAssignmentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDispatcherAssignmentsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type MountainCreateNestedOneWithoutDispatcherAssignmentsInput = {
    create?: XOR<MountainCreateWithoutDispatcherAssignmentsInput, MountainUncheckedCreateWithoutDispatcherAssignmentsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutDispatcherAssignmentsInput
    connect?: MountainWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutDispatcherAssignmentsNestedInput = {
    create?: XOR<EmployeeCreateWithoutDispatcherAssignmentsInput, EmployeeUncheckedCreateWithoutDispatcherAssignmentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDispatcherAssignmentsInput
    upsert?: EmployeeUpsertWithoutDispatcherAssignmentsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutDispatcherAssignmentsInput, EmployeeUpdateWithoutDispatcherAssignmentsInput>, EmployeeUncheckedUpdateWithoutDispatcherAssignmentsInput>
  }

  export type MountainUpdateOneRequiredWithoutDispatcherAssignmentsNestedInput = {
    create?: XOR<MountainCreateWithoutDispatcherAssignmentsInput, MountainUncheckedCreateWithoutDispatcherAssignmentsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutDispatcherAssignmentsInput
    upsert?: MountainUpsertWithoutDispatcherAssignmentsInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutDispatcherAssignmentsInput, MountainUpdateWithoutDispatcherAssignmentsInput>, MountainUncheckedUpdateWithoutDispatcherAssignmentsInput>
  }

  export type RoleCreatepermissionsInput = {
    set: string[]
  }

  export type EmployeeCreateNestedManyWithoutRoleInput = {
    create?: XOR<EmployeeCreateWithoutRoleInput, EmployeeUncheckedCreateWithoutRoleInput> | EmployeeCreateWithoutRoleInput[] | EmployeeUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutRoleInput | EmployeeCreateOrConnectWithoutRoleInput[]
    createMany?: EmployeeCreateManyRoleInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<EmployeeRoleCreateWithoutRoleInput, EmployeeRoleUncheckedCreateWithoutRoleInput> | EmployeeRoleCreateWithoutRoleInput[] | EmployeeRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: EmployeeRoleCreateOrConnectWithoutRoleInput | EmployeeRoleCreateOrConnectWithoutRoleInput[]
    createMany?: EmployeeRoleCreateManyRoleInputEnvelope
    connect?: EmployeeRoleWhereUniqueInput | EmployeeRoleWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<EmployeeCreateWithoutRoleInput, EmployeeUncheckedCreateWithoutRoleInput> | EmployeeCreateWithoutRoleInput[] | EmployeeUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutRoleInput | EmployeeCreateOrConnectWithoutRoleInput[]
    createMany?: EmployeeCreateManyRoleInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<EmployeeRoleCreateWithoutRoleInput, EmployeeRoleUncheckedCreateWithoutRoleInput> | EmployeeRoleCreateWithoutRoleInput[] | EmployeeRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: EmployeeRoleCreateOrConnectWithoutRoleInput | EmployeeRoleCreateOrConnectWithoutRoleInput[]
    createMany?: EmployeeRoleCreateManyRoleInputEnvelope
    connect?: EmployeeRoleWhereUniqueInput | EmployeeRoleWhereUniqueInput[]
  }

  export type EnumDEPARTMENTFieldUpdateOperationsInput = {
    set?: $Enums.DEPARTMENT
  }

  export type RoleUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmployeeUpdateManyWithoutRoleNestedInput = {
    create?: XOR<EmployeeCreateWithoutRoleInput, EmployeeUncheckedCreateWithoutRoleInput> | EmployeeCreateWithoutRoleInput[] | EmployeeUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutRoleInput | EmployeeCreateOrConnectWithoutRoleInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutRoleInput | EmployeeUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: EmployeeCreateManyRoleInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutRoleInput | EmployeeUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutRoleInput | EmployeeUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<EmployeeRoleCreateWithoutRoleInput, EmployeeRoleUncheckedCreateWithoutRoleInput> | EmployeeRoleCreateWithoutRoleInput[] | EmployeeRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: EmployeeRoleCreateOrConnectWithoutRoleInput | EmployeeRoleCreateOrConnectWithoutRoleInput[]
    upsert?: EmployeeRoleUpsertWithWhereUniqueWithoutRoleInput | EmployeeRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: EmployeeRoleCreateManyRoleInputEnvelope
    set?: EmployeeRoleWhereUniqueInput | EmployeeRoleWhereUniqueInput[]
    disconnect?: EmployeeRoleWhereUniqueInput | EmployeeRoleWhereUniqueInput[]
    delete?: EmployeeRoleWhereUniqueInput | EmployeeRoleWhereUniqueInput[]
    connect?: EmployeeRoleWhereUniqueInput | EmployeeRoleWhereUniqueInput[]
    update?: EmployeeRoleUpdateWithWhereUniqueWithoutRoleInput | EmployeeRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: EmployeeRoleUpdateManyWithWhereWithoutRoleInput | EmployeeRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: EmployeeRoleScalarWhereInput | EmployeeRoleScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<EmployeeCreateWithoutRoleInput, EmployeeUncheckedCreateWithoutRoleInput> | EmployeeCreateWithoutRoleInput[] | EmployeeUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutRoleInput | EmployeeCreateOrConnectWithoutRoleInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutRoleInput | EmployeeUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: EmployeeCreateManyRoleInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutRoleInput | EmployeeUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutRoleInput | EmployeeUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<EmployeeRoleCreateWithoutRoleInput, EmployeeRoleUncheckedCreateWithoutRoleInput> | EmployeeRoleCreateWithoutRoleInput[] | EmployeeRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: EmployeeRoleCreateOrConnectWithoutRoleInput | EmployeeRoleCreateOrConnectWithoutRoleInput[]
    upsert?: EmployeeRoleUpsertWithWhereUniqueWithoutRoleInput | EmployeeRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: EmployeeRoleCreateManyRoleInputEnvelope
    set?: EmployeeRoleWhereUniqueInput | EmployeeRoleWhereUniqueInput[]
    disconnect?: EmployeeRoleWhereUniqueInput | EmployeeRoleWhereUniqueInput[]
    delete?: EmployeeRoleWhereUniqueInput | EmployeeRoleWhereUniqueInput[]
    connect?: EmployeeRoleWhereUniqueInput | EmployeeRoleWhereUniqueInput[]
    update?: EmployeeRoleUpdateWithWhereUniqueWithoutRoleInput | EmployeeRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: EmployeeRoleUpdateManyWithWhereWithoutRoleInput | EmployeeRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: EmployeeRoleScalarWhereInput | EmployeeRoleScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutAdditionalRolesInput = {
    create?: XOR<EmployeeCreateWithoutAdditionalRolesInput, EmployeeUncheckedCreateWithoutAdditionalRolesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAdditionalRolesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutEmployeeRoleInput = {
    create?: XOR<RoleCreateWithoutEmployeeRoleInput, RoleUncheckedCreateWithoutEmployeeRoleInput>
    connectOrCreate?: RoleCreateOrConnectWithoutEmployeeRoleInput
    connect?: RoleWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutAdditionalRolesNestedInput = {
    create?: XOR<EmployeeCreateWithoutAdditionalRolesInput, EmployeeUncheckedCreateWithoutAdditionalRolesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAdditionalRolesInput
    upsert?: EmployeeUpsertWithoutAdditionalRolesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAdditionalRolesInput, EmployeeUpdateWithoutAdditionalRolesInput>, EmployeeUncheckedUpdateWithoutAdditionalRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutEmployeeRoleNestedInput = {
    create?: XOR<RoleCreateWithoutEmployeeRoleInput, RoleUncheckedCreateWithoutEmployeeRoleInput>
    connectOrCreate?: RoleCreateOrConnectWithoutEmployeeRoleInput
    upsert?: RoleUpsertWithoutEmployeeRoleInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutEmployeeRoleInput, RoleUpdateWithoutEmployeeRoleInput>, RoleUncheckedUpdateWithoutEmployeeRoleInput>
  }

  export type RoleCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<RoleCreateWithoutEmployeesInput, RoleUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutEmployeesInput
    connect?: RoleWhereUniqueInput
  }

  export type EmployeeRoleCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeRoleCreateWithoutEmployeeInput, EmployeeRoleUncheckedCreateWithoutEmployeeInput> | EmployeeRoleCreateWithoutEmployeeInput[] | EmployeeRoleUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeRoleCreateOrConnectWithoutEmployeeInput | EmployeeRoleCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeRoleCreateManyEmployeeInputEnvelope
    connect?: EmployeeRoleWhereUniqueInput | EmployeeRoleWhereUniqueInput[]
  }

  export type EmployeeMountainAssignmentCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeMountainAssignmentCreateWithoutEmployeeInput, EmployeeMountainAssignmentUncheckedCreateWithoutEmployeeInput> | EmployeeMountainAssignmentCreateWithoutEmployeeInput[] | EmployeeMountainAssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeMountainAssignmentCreateOrConnectWithoutEmployeeInput | EmployeeMountainAssignmentCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeMountainAssignmentCreateManyEmployeeInputEnvelope
    connect?: EmployeeMountainAssignmentWhereUniqueInput | EmployeeMountainAssignmentWhereUniqueInput[]
  }

  export type DispatcherAssignmentCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<DispatcherAssignmentCreateWithoutEmployeeInput, DispatcherAssignmentUncheckedCreateWithoutEmployeeInput> | DispatcherAssignmentCreateWithoutEmployeeInput[] | DispatcherAssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DispatcherAssignmentCreateOrConnectWithoutEmployeeInput | DispatcherAssignmentCreateOrConnectWithoutEmployeeInput[]
    createMany?: DispatcherAssignmentCreateManyEmployeeInputEnvelope
    connect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
  }

  export type IncidentCreateNestedManyWithoutEmployeesInput = {
    create?: XOR<IncidentCreateWithoutEmployeesInput, IncidentUncheckedCreateWithoutEmployeesInput> | IncidentCreateWithoutEmployeesInput[] | IncidentUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutEmployeesInput | IncidentCreateOrConnectWithoutEmployeesInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type AidRoomCheckCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AidRoomCheckCreateWithoutEmployeeInput, AidRoomCheckUncheckedCreateWithoutEmployeeInput> | AidRoomCheckCreateWithoutEmployeeInput[] | AidRoomCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutEmployeeInput | AidRoomCheckCreateOrConnectWithoutEmployeeInput[]
    createMany?: AidRoomCheckCreateManyEmployeeInputEnvelope
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
  }

  export type HutCheckCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<HutCheckCreateWithoutEmployeeInput, HutCheckUncheckedCreateWithoutEmployeeInput> | HutCheckCreateWithoutEmployeeInput[] | HutCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutEmployeeInput | HutCheckCreateOrConnectWithoutEmployeeInput[]
    createMany?: HutCheckCreateManyEmployeeInputEnvelope
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
  }

  export type LiftCheckCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LiftCheckCreateWithoutEmployeeInput, LiftCheckUncheckedCreateWithoutEmployeeInput> | LiftCheckCreateWithoutEmployeeInput[] | LiftCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutEmployeeInput | LiftCheckCreateOrConnectWithoutEmployeeInput[]
    createMany?: LiftCheckCreateManyEmployeeInputEnvelope
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
  }

  export type TrailCheckCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<TrailCheckCreateWithoutEmployeeInput, TrailCheckUncheckedCreateWithoutEmployeeInput> | TrailCheckCreateWithoutEmployeeInput[] | TrailCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutEmployeeInput | TrailCheckCreateOrConnectWithoutEmployeeInput[]
    createMany?: TrailCheckCreateManyEmployeeInputEnvelope
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
  }

  export type EquipmentCheckCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EquipmentCheckCreateWithoutEmployeeInput, EquipmentCheckUncheckedCreateWithoutEmployeeInput> | EquipmentCheckCreateWithoutEmployeeInput[] | EquipmentCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutEmployeeInput | EquipmentCheckCreateOrConnectWithoutEmployeeInput[]
    createMany?: EquipmentCheckCreateManyEmployeeInputEnvelope
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
  }

  export type EquipmentServiceLogCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EquipmentServiceLogCreateWithoutEmployeeInput, EquipmentServiceLogUncheckedCreateWithoutEmployeeInput> | EquipmentServiceLogCreateWithoutEmployeeInput[] | EquipmentServiceLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EquipmentServiceLogCreateOrConnectWithoutEmployeeInput | EquipmentServiceLogCreateOrConnectWithoutEmployeeInput[]
    createMany?: EquipmentServiceLogCreateManyEmployeeInputEnvelope
    connect?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
  }

  export type EmployeeRoleUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeRoleCreateWithoutEmployeeInput, EmployeeRoleUncheckedCreateWithoutEmployeeInput> | EmployeeRoleCreateWithoutEmployeeInput[] | EmployeeRoleUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeRoleCreateOrConnectWithoutEmployeeInput | EmployeeRoleCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeRoleCreateManyEmployeeInputEnvelope
    connect?: EmployeeRoleWhereUniqueInput | EmployeeRoleWhereUniqueInput[]
  }

  export type EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeMountainAssignmentCreateWithoutEmployeeInput, EmployeeMountainAssignmentUncheckedCreateWithoutEmployeeInput> | EmployeeMountainAssignmentCreateWithoutEmployeeInput[] | EmployeeMountainAssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeMountainAssignmentCreateOrConnectWithoutEmployeeInput | EmployeeMountainAssignmentCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeMountainAssignmentCreateManyEmployeeInputEnvelope
    connect?: EmployeeMountainAssignmentWhereUniqueInput | EmployeeMountainAssignmentWhereUniqueInput[]
  }

  export type DispatcherAssignmentUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<DispatcherAssignmentCreateWithoutEmployeeInput, DispatcherAssignmentUncheckedCreateWithoutEmployeeInput> | DispatcherAssignmentCreateWithoutEmployeeInput[] | DispatcherAssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DispatcherAssignmentCreateOrConnectWithoutEmployeeInput | DispatcherAssignmentCreateOrConnectWithoutEmployeeInput[]
    createMany?: DispatcherAssignmentCreateManyEmployeeInputEnvelope
    connect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
  }

  export type IncidentUncheckedCreateNestedManyWithoutEmployeesInput = {
    create?: XOR<IncidentCreateWithoutEmployeesInput, IncidentUncheckedCreateWithoutEmployeesInput> | IncidentCreateWithoutEmployeesInput[] | IncidentUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutEmployeesInput | IncidentCreateOrConnectWithoutEmployeesInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type AidRoomCheckUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AidRoomCheckCreateWithoutEmployeeInput, AidRoomCheckUncheckedCreateWithoutEmployeeInput> | AidRoomCheckCreateWithoutEmployeeInput[] | AidRoomCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutEmployeeInput | AidRoomCheckCreateOrConnectWithoutEmployeeInput[]
    createMany?: AidRoomCheckCreateManyEmployeeInputEnvelope
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
  }

  export type HutCheckUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<HutCheckCreateWithoutEmployeeInput, HutCheckUncheckedCreateWithoutEmployeeInput> | HutCheckCreateWithoutEmployeeInput[] | HutCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutEmployeeInput | HutCheckCreateOrConnectWithoutEmployeeInput[]
    createMany?: HutCheckCreateManyEmployeeInputEnvelope
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
  }

  export type LiftCheckUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LiftCheckCreateWithoutEmployeeInput, LiftCheckUncheckedCreateWithoutEmployeeInput> | LiftCheckCreateWithoutEmployeeInput[] | LiftCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutEmployeeInput | LiftCheckCreateOrConnectWithoutEmployeeInput[]
    createMany?: LiftCheckCreateManyEmployeeInputEnvelope
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
  }

  export type TrailCheckUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<TrailCheckCreateWithoutEmployeeInput, TrailCheckUncheckedCreateWithoutEmployeeInput> | TrailCheckCreateWithoutEmployeeInput[] | TrailCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutEmployeeInput | TrailCheckCreateOrConnectWithoutEmployeeInput[]
    createMany?: TrailCheckCreateManyEmployeeInputEnvelope
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
  }

  export type EquipmentCheckUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EquipmentCheckCreateWithoutEmployeeInput, EquipmentCheckUncheckedCreateWithoutEmployeeInput> | EquipmentCheckCreateWithoutEmployeeInput[] | EquipmentCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutEmployeeInput | EquipmentCheckCreateOrConnectWithoutEmployeeInput[]
    createMany?: EquipmentCheckCreateManyEmployeeInputEnvelope
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
  }

  export type EquipmentServiceLogUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EquipmentServiceLogCreateWithoutEmployeeInput, EquipmentServiceLogUncheckedCreateWithoutEmployeeInput> | EquipmentServiceLogCreateWithoutEmployeeInput[] | EquipmentServiceLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EquipmentServiceLogCreateOrConnectWithoutEmployeeInput | EquipmentServiceLogCreateOrConnectWithoutEmployeeInput[]
    createMany?: EquipmentServiceLogCreateManyEmployeeInputEnvelope
    connect?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
  }

  export type RoleUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<RoleCreateWithoutEmployeesInput, RoleUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutEmployeesInput
    upsert?: RoleUpsertWithoutEmployeesInput
    disconnect?: RoleWhereInput | boolean
    delete?: RoleWhereInput | boolean
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutEmployeesInput, RoleUpdateWithoutEmployeesInput>, RoleUncheckedUpdateWithoutEmployeesInput>
  }

  export type EmployeeRoleUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeRoleCreateWithoutEmployeeInput, EmployeeRoleUncheckedCreateWithoutEmployeeInput> | EmployeeRoleCreateWithoutEmployeeInput[] | EmployeeRoleUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeRoleCreateOrConnectWithoutEmployeeInput | EmployeeRoleCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeRoleUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeRoleUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeRoleCreateManyEmployeeInputEnvelope
    set?: EmployeeRoleWhereUniqueInput | EmployeeRoleWhereUniqueInput[]
    disconnect?: EmployeeRoleWhereUniqueInput | EmployeeRoleWhereUniqueInput[]
    delete?: EmployeeRoleWhereUniqueInput | EmployeeRoleWhereUniqueInput[]
    connect?: EmployeeRoleWhereUniqueInput | EmployeeRoleWhereUniqueInput[]
    update?: EmployeeRoleUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeRoleUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeRoleUpdateManyWithWhereWithoutEmployeeInput | EmployeeRoleUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeRoleScalarWhereInput | EmployeeRoleScalarWhereInput[]
  }

  export type EmployeeMountainAssignmentUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeMountainAssignmentCreateWithoutEmployeeInput, EmployeeMountainAssignmentUncheckedCreateWithoutEmployeeInput> | EmployeeMountainAssignmentCreateWithoutEmployeeInput[] | EmployeeMountainAssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeMountainAssignmentCreateOrConnectWithoutEmployeeInput | EmployeeMountainAssignmentCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeMountainAssignmentUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeMountainAssignmentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeMountainAssignmentCreateManyEmployeeInputEnvelope
    set?: EmployeeMountainAssignmentWhereUniqueInput | EmployeeMountainAssignmentWhereUniqueInput[]
    disconnect?: EmployeeMountainAssignmentWhereUniqueInput | EmployeeMountainAssignmentWhereUniqueInput[]
    delete?: EmployeeMountainAssignmentWhereUniqueInput | EmployeeMountainAssignmentWhereUniqueInput[]
    connect?: EmployeeMountainAssignmentWhereUniqueInput | EmployeeMountainAssignmentWhereUniqueInput[]
    update?: EmployeeMountainAssignmentUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeMountainAssignmentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeMountainAssignmentUpdateManyWithWhereWithoutEmployeeInput | EmployeeMountainAssignmentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeMountainAssignmentScalarWhereInput | EmployeeMountainAssignmentScalarWhereInput[]
  }

  export type DispatcherAssignmentUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<DispatcherAssignmentCreateWithoutEmployeeInput, DispatcherAssignmentUncheckedCreateWithoutEmployeeInput> | DispatcherAssignmentCreateWithoutEmployeeInput[] | DispatcherAssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DispatcherAssignmentCreateOrConnectWithoutEmployeeInput | DispatcherAssignmentCreateOrConnectWithoutEmployeeInput[]
    upsert?: DispatcherAssignmentUpsertWithWhereUniqueWithoutEmployeeInput | DispatcherAssignmentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: DispatcherAssignmentCreateManyEmployeeInputEnvelope
    set?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    disconnect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    delete?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    connect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    update?: DispatcherAssignmentUpdateWithWhereUniqueWithoutEmployeeInput | DispatcherAssignmentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: DispatcherAssignmentUpdateManyWithWhereWithoutEmployeeInput | DispatcherAssignmentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: DispatcherAssignmentScalarWhereInput | DispatcherAssignmentScalarWhereInput[]
  }

  export type IncidentUpdateManyWithoutEmployeesNestedInput = {
    create?: XOR<IncidentCreateWithoutEmployeesInput, IncidentUncheckedCreateWithoutEmployeesInput> | IncidentCreateWithoutEmployeesInput[] | IncidentUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutEmployeesInput | IncidentCreateOrConnectWithoutEmployeesInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutEmployeesInput | IncidentUpsertWithWhereUniqueWithoutEmployeesInput[]
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutEmployeesInput | IncidentUpdateWithWhereUniqueWithoutEmployeesInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutEmployeesInput | IncidentUpdateManyWithWhereWithoutEmployeesInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type AidRoomCheckUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AidRoomCheckCreateWithoutEmployeeInput, AidRoomCheckUncheckedCreateWithoutEmployeeInput> | AidRoomCheckCreateWithoutEmployeeInput[] | AidRoomCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutEmployeeInput | AidRoomCheckCreateOrConnectWithoutEmployeeInput[]
    upsert?: AidRoomCheckUpsertWithWhereUniqueWithoutEmployeeInput | AidRoomCheckUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AidRoomCheckCreateManyEmployeeInputEnvelope
    set?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    disconnect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    delete?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    update?: AidRoomCheckUpdateWithWhereUniqueWithoutEmployeeInput | AidRoomCheckUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AidRoomCheckUpdateManyWithWhereWithoutEmployeeInput | AidRoomCheckUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AidRoomCheckScalarWhereInput | AidRoomCheckScalarWhereInput[]
  }

  export type HutCheckUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<HutCheckCreateWithoutEmployeeInput, HutCheckUncheckedCreateWithoutEmployeeInput> | HutCheckCreateWithoutEmployeeInput[] | HutCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutEmployeeInput | HutCheckCreateOrConnectWithoutEmployeeInput[]
    upsert?: HutCheckUpsertWithWhereUniqueWithoutEmployeeInput | HutCheckUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: HutCheckCreateManyEmployeeInputEnvelope
    set?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    disconnect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    delete?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    update?: HutCheckUpdateWithWhereUniqueWithoutEmployeeInput | HutCheckUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: HutCheckUpdateManyWithWhereWithoutEmployeeInput | HutCheckUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: HutCheckScalarWhereInput | HutCheckScalarWhereInput[]
  }

  export type LiftCheckUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LiftCheckCreateWithoutEmployeeInput, LiftCheckUncheckedCreateWithoutEmployeeInput> | LiftCheckCreateWithoutEmployeeInput[] | LiftCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutEmployeeInput | LiftCheckCreateOrConnectWithoutEmployeeInput[]
    upsert?: LiftCheckUpsertWithWhereUniqueWithoutEmployeeInput | LiftCheckUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LiftCheckCreateManyEmployeeInputEnvelope
    set?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    disconnect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    delete?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    update?: LiftCheckUpdateWithWhereUniqueWithoutEmployeeInput | LiftCheckUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LiftCheckUpdateManyWithWhereWithoutEmployeeInput | LiftCheckUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LiftCheckScalarWhereInput | LiftCheckScalarWhereInput[]
  }

  export type TrailCheckUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<TrailCheckCreateWithoutEmployeeInput, TrailCheckUncheckedCreateWithoutEmployeeInput> | TrailCheckCreateWithoutEmployeeInput[] | TrailCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutEmployeeInput | TrailCheckCreateOrConnectWithoutEmployeeInput[]
    upsert?: TrailCheckUpsertWithWhereUniqueWithoutEmployeeInput | TrailCheckUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: TrailCheckCreateManyEmployeeInputEnvelope
    set?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    disconnect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    delete?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    update?: TrailCheckUpdateWithWhereUniqueWithoutEmployeeInput | TrailCheckUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: TrailCheckUpdateManyWithWhereWithoutEmployeeInput | TrailCheckUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: TrailCheckScalarWhereInput | TrailCheckScalarWhereInput[]
  }

  export type EquipmentCheckUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EquipmentCheckCreateWithoutEmployeeInput, EquipmentCheckUncheckedCreateWithoutEmployeeInput> | EquipmentCheckCreateWithoutEmployeeInput[] | EquipmentCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutEmployeeInput | EquipmentCheckCreateOrConnectWithoutEmployeeInput[]
    upsert?: EquipmentCheckUpsertWithWhereUniqueWithoutEmployeeInput | EquipmentCheckUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EquipmentCheckCreateManyEmployeeInputEnvelope
    set?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    disconnect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    delete?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    update?: EquipmentCheckUpdateWithWhereUniqueWithoutEmployeeInput | EquipmentCheckUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EquipmentCheckUpdateManyWithWhereWithoutEmployeeInput | EquipmentCheckUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EquipmentCheckScalarWhereInput | EquipmentCheckScalarWhereInput[]
  }

  export type EquipmentServiceLogUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EquipmentServiceLogCreateWithoutEmployeeInput, EquipmentServiceLogUncheckedCreateWithoutEmployeeInput> | EquipmentServiceLogCreateWithoutEmployeeInput[] | EquipmentServiceLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EquipmentServiceLogCreateOrConnectWithoutEmployeeInput | EquipmentServiceLogCreateOrConnectWithoutEmployeeInput[]
    upsert?: EquipmentServiceLogUpsertWithWhereUniqueWithoutEmployeeInput | EquipmentServiceLogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EquipmentServiceLogCreateManyEmployeeInputEnvelope
    set?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    disconnect?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    delete?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    connect?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    update?: EquipmentServiceLogUpdateWithWhereUniqueWithoutEmployeeInput | EquipmentServiceLogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EquipmentServiceLogUpdateManyWithWhereWithoutEmployeeInput | EquipmentServiceLogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EquipmentServiceLogScalarWhereInput | EquipmentServiceLogScalarWhereInput[]
  }

  export type EmployeeRoleUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeRoleCreateWithoutEmployeeInput, EmployeeRoleUncheckedCreateWithoutEmployeeInput> | EmployeeRoleCreateWithoutEmployeeInput[] | EmployeeRoleUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeRoleCreateOrConnectWithoutEmployeeInput | EmployeeRoleCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeRoleUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeRoleUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeRoleCreateManyEmployeeInputEnvelope
    set?: EmployeeRoleWhereUniqueInput | EmployeeRoleWhereUniqueInput[]
    disconnect?: EmployeeRoleWhereUniqueInput | EmployeeRoleWhereUniqueInput[]
    delete?: EmployeeRoleWhereUniqueInput | EmployeeRoleWhereUniqueInput[]
    connect?: EmployeeRoleWhereUniqueInput | EmployeeRoleWhereUniqueInput[]
    update?: EmployeeRoleUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeRoleUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeRoleUpdateManyWithWhereWithoutEmployeeInput | EmployeeRoleUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeRoleScalarWhereInput | EmployeeRoleScalarWhereInput[]
  }

  export type EmployeeMountainAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeMountainAssignmentCreateWithoutEmployeeInput, EmployeeMountainAssignmentUncheckedCreateWithoutEmployeeInput> | EmployeeMountainAssignmentCreateWithoutEmployeeInput[] | EmployeeMountainAssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeMountainAssignmentCreateOrConnectWithoutEmployeeInput | EmployeeMountainAssignmentCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeMountainAssignmentUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeMountainAssignmentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeMountainAssignmentCreateManyEmployeeInputEnvelope
    set?: EmployeeMountainAssignmentWhereUniqueInput | EmployeeMountainAssignmentWhereUniqueInput[]
    disconnect?: EmployeeMountainAssignmentWhereUniqueInput | EmployeeMountainAssignmentWhereUniqueInput[]
    delete?: EmployeeMountainAssignmentWhereUniqueInput | EmployeeMountainAssignmentWhereUniqueInput[]
    connect?: EmployeeMountainAssignmentWhereUniqueInput | EmployeeMountainAssignmentWhereUniqueInput[]
    update?: EmployeeMountainAssignmentUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeMountainAssignmentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeMountainAssignmentUpdateManyWithWhereWithoutEmployeeInput | EmployeeMountainAssignmentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeMountainAssignmentScalarWhereInput | EmployeeMountainAssignmentScalarWhereInput[]
  }

  export type DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<DispatcherAssignmentCreateWithoutEmployeeInput, DispatcherAssignmentUncheckedCreateWithoutEmployeeInput> | DispatcherAssignmentCreateWithoutEmployeeInput[] | DispatcherAssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DispatcherAssignmentCreateOrConnectWithoutEmployeeInput | DispatcherAssignmentCreateOrConnectWithoutEmployeeInput[]
    upsert?: DispatcherAssignmentUpsertWithWhereUniqueWithoutEmployeeInput | DispatcherAssignmentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: DispatcherAssignmentCreateManyEmployeeInputEnvelope
    set?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    disconnect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    delete?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    connect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    update?: DispatcherAssignmentUpdateWithWhereUniqueWithoutEmployeeInput | DispatcherAssignmentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: DispatcherAssignmentUpdateManyWithWhereWithoutEmployeeInput | DispatcherAssignmentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: DispatcherAssignmentScalarWhereInput | DispatcherAssignmentScalarWhereInput[]
  }

  export type IncidentUncheckedUpdateManyWithoutEmployeesNestedInput = {
    create?: XOR<IncidentCreateWithoutEmployeesInput, IncidentUncheckedCreateWithoutEmployeesInput> | IncidentCreateWithoutEmployeesInput[] | IncidentUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutEmployeesInput | IncidentCreateOrConnectWithoutEmployeesInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutEmployeesInput | IncidentUpsertWithWhereUniqueWithoutEmployeesInput[]
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutEmployeesInput | IncidentUpdateWithWhereUniqueWithoutEmployeesInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutEmployeesInput | IncidentUpdateManyWithWhereWithoutEmployeesInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type AidRoomCheckUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AidRoomCheckCreateWithoutEmployeeInput, AidRoomCheckUncheckedCreateWithoutEmployeeInput> | AidRoomCheckCreateWithoutEmployeeInput[] | AidRoomCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutEmployeeInput | AidRoomCheckCreateOrConnectWithoutEmployeeInput[]
    upsert?: AidRoomCheckUpsertWithWhereUniqueWithoutEmployeeInput | AidRoomCheckUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AidRoomCheckCreateManyEmployeeInputEnvelope
    set?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    disconnect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    delete?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    update?: AidRoomCheckUpdateWithWhereUniqueWithoutEmployeeInput | AidRoomCheckUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AidRoomCheckUpdateManyWithWhereWithoutEmployeeInput | AidRoomCheckUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AidRoomCheckScalarWhereInput | AidRoomCheckScalarWhereInput[]
  }

  export type HutCheckUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<HutCheckCreateWithoutEmployeeInput, HutCheckUncheckedCreateWithoutEmployeeInput> | HutCheckCreateWithoutEmployeeInput[] | HutCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutEmployeeInput | HutCheckCreateOrConnectWithoutEmployeeInput[]
    upsert?: HutCheckUpsertWithWhereUniqueWithoutEmployeeInput | HutCheckUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: HutCheckCreateManyEmployeeInputEnvelope
    set?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    disconnect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    delete?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    update?: HutCheckUpdateWithWhereUniqueWithoutEmployeeInput | HutCheckUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: HutCheckUpdateManyWithWhereWithoutEmployeeInput | HutCheckUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: HutCheckScalarWhereInput | HutCheckScalarWhereInput[]
  }

  export type LiftCheckUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LiftCheckCreateWithoutEmployeeInput, LiftCheckUncheckedCreateWithoutEmployeeInput> | LiftCheckCreateWithoutEmployeeInput[] | LiftCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutEmployeeInput | LiftCheckCreateOrConnectWithoutEmployeeInput[]
    upsert?: LiftCheckUpsertWithWhereUniqueWithoutEmployeeInput | LiftCheckUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LiftCheckCreateManyEmployeeInputEnvelope
    set?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    disconnect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    delete?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    update?: LiftCheckUpdateWithWhereUniqueWithoutEmployeeInput | LiftCheckUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LiftCheckUpdateManyWithWhereWithoutEmployeeInput | LiftCheckUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LiftCheckScalarWhereInput | LiftCheckScalarWhereInput[]
  }

  export type TrailCheckUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<TrailCheckCreateWithoutEmployeeInput, TrailCheckUncheckedCreateWithoutEmployeeInput> | TrailCheckCreateWithoutEmployeeInput[] | TrailCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutEmployeeInput | TrailCheckCreateOrConnectWithoutEmployeeInput[]
    upsert?: TrailCheckUpsertWithWhereUniqueWithoutEmployeeInput | TrailCheckUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: TrailCheckCreateManyEmployeeInputEnvelope
    set?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    disconnect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    delete?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    update?: TrailCheckUpdateWithWhereUniqueWithoutEmployeeInput | TrailCheckUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: TrailCheckUpdateManyWithWhereWithoutEmployeeInput | TrailCheckUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: TrailCheckScalarWhereInput | TrailCheckScalarWhereInput[]
  }

  export type EquipmentCheckUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EquipmentCheckCreateWithoutEmployeeInput, EquipmentCheckUncheckedCreateWithoutEmployeeInput> | EquipmentCheckCreateWithoutEmployeeInput[] | EquipmentCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutEmployeeInput | EquipmentCheckCreateOrConnectWithoutEmployeeInput[]
    upsert?: EquipmentCheckUpsertWithWhereUniqueWithoutEmployeeInput | EquipmentCheckUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EquipmentCheckCreateManyEmployeeInputEnvelope
    set?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    disconnect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    delete?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    update?: EquipmentCheckUpdateWithWhereUniqueWithoutEmployeeInput | EquipmentCheckUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EquipmentCheckUpdateManyWithWhereWithoutEmployeeInput | EquipmentCheckUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EquipmentCheckScalarWhereInput | EquipmentCheckScalarWhereInput[]
  }

  export type EquipmentServiceLogUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EquipmentServiceLogCreateWithoutEmployeeInput, EquipmentServiceLogUncheckedCreateWithoutEmployeeInput> | EquipmentServiceLogCreateWithoutEmployeeInput[] | EquipmentServiceLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EquipmentServiceLogCreateOrConnectWithoutEmployeeInput | EquipmentServiceLogCreateOrConnectWithoutEmployeeInput[]
    upsert?: EquipmentServiceLogUpsertWithWhereUniqueWithoutEmployeeInput | EquipmentServiceLogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EquipmentServiceLogCreateManyEmployeeInputEnvelope
    set?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    disconnect?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    delete?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    connect?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    update?: EquipmentServiceLogUpdateWithWhereUniqueWithoutEmployeeInput | EquipmentServiceLogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EquipmentServiceLogUpdateManyWithWhereWithoutEmployeeInput | EquipmentServiceLogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EquipmentServiceLogScalarWhereInput | EquipmentServiceLogScalarWhereInput[]
  }

  export type MountainCreateNestedOneWithoutLiftsInput = {
    create?: XOR<MountainCreateWithoutLiftsInput, MountainUncheckedCreateWithoutLiftsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutLiftsInput
    connect?: MountainWhereUniqueInput
  }

  export type LiftCheckCreateNestedManyWithoutLiftInput = {
    create?: XOR<LiftCheckCreateWithoutLiftInput, LiftCheckUncheckedCreateWithoutLiftInput> | LiftCheckCreateWithoutLiftInput[] | LiftCheckUncheckedCreateWithoutLiftInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutLiftInput | LiftCheckCreateOrConnectWithoutLiftInput[]
    createMany?: LiftCheckCreateManyLiftInputEnvelope
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
  }

  export type LocationCreateNestedOneWithoutLiftInput = {
    create?: XOR<LocationCreateWithoutLiftInput, LocationUncheckedCreateWithoutLiftInput>
    connectOrCreate?: LocationCreateOrConnectWithoutLiftInput
    connect?: LocationWhereUniqueInput
  }

  export type LiftCheckUncheckedCreateNestedManyWithoutLiftInput = {
    create?: XOR<LiftCheckCreateWithoutLiftInput, LiftCheckUncheckedCreateWithoutLiftInput> | LiftCheckCreateWithoutLiftInput[] | LiftCheckUncheckedCreateWithoutLiftInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutLiftInput | LiftCheckCreateOrConnectWithoutLiftInput[]
    createMany?: LiftCheckCreateManyLiftInputEnvelope
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
  }

  export type EnumLIFT_TYPEFieldUpdateOperationsInput = {
    set?: $Enums.LIFT_TYPE
  }

  export type MountainUpdateOneRequiredWithoutLiftsNestedInput = {
    create?: XOR<MountainCreateWithoutLiftsInput, MountainUncheckedCreateWithoutLiftsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutLiftsInput
    upsert?: MountainUpsertWithoutLiftsInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutLiftsInput, MountainUpdateWithoutLiftsInput>, MountainUncheckedUpdateWithoutLiftsInput>
  }

  export type LiftCheckUpdateManyWithoutLiftNestedInput = {
    create?: XOR<LiftCheckCreateWithoutLiftInput, LiftCheckUncheckedCreateWithoutLiftInput> | LiftCheckCreateWithoutLiftInput[] | LiftCheckUncheckedCreateWithoutLiftInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutLiftInput | LiftCheckCreateOrConnectWithoutLiftInput[]
    upsert?: LiftCheckUpsertWithWhereUniqueWithoutLiftInput | LiftCheckUpsertWithWhereUniqueWithoutLiftInput[]
    createMany?: LiftCheckCreateManyLiftInputEnvelope
    set?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    disconnect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    delete?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    update?: LiftCheckUpdateWithWhereUniqueWithoutLiftInput | LiftCheckUpdateWithWhereUniqueWithoutLiftInput[]
    updateMany?: LiftCheckUpdateManyWithWhereWithoutLiftInput | LiftCheckUpdateManyWithWhereWithoutLiftInput[]
    deleteMany?: LiftCheckScalarWhereInput | LiftCheckScalarWhereInput[]
  }

  export type LocationUpdateOneWithoutLiftNestedInput = {
    create?: XOR<LocationCreateWithoutLiftInput, LocationUncheckedCreateWithoutLiftInput>
    connectOrCreate?: LocationCreateOrConnectWithoutLiftInput
    upsert?: LocationUpsertWithoutLiftInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutLiftInput, LocationUpdateWithoutLiftInput>, LocationUncheckedUpdateWithoutLiftInput>
  }

  export type LiftCheckUncheckedUpdateManyWithoutLiftNestedInput = {
    create?: XOR<LiftCheckCreateWithoutLiftInput, LiftCheckUncheckedCreateWithoutLiftInput> | LiftCheckCreateWithoutLiftInput[] | LiftCheckUncheckedCreateWithoutLiftInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutLiftInput | LiftCheckCreateOrConnectWithoutLiftInput[]
    upsert?: LiftCheckUpsertWithWhereUniqueWithoutLiftInput | LiftCheckUpsertWithWhereUniqueWithoutLiftInput[]
    createMany?: LiftCheckCreateManyLiftInputEnvelope
    set?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    disconnect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    delete?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    update?: LiftCheckUpdateWithWhereUniqueWithoutLiftInput | LiftCheckUpdateWithWhereUniqueWithoutLiftInput[]
    updateMany?: LiftCheckUpdateManyWithWhereWithoutLiftInput | LiftCheckUpdateManyWithWhereWithoutLiftInput[]
    deleteMany?: LiftCheckScalarWhereInput | LiftCheckScalarWhereInput[]
  }

  export type MountainCreateNestedOneWithoutTrailsInput = {
    create?: XOR<MountainCreateWithoutTrailsInput, MountainUncheckedCreateWithoutTrailsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutTrailsInput
    connect?: MountainWhereUniqueInput
  }

  export type TrailCheckCreateNestedManyWithoutTrailInput = {
    create?: XOR<TrailCheckCreateWithoutTrailInput, TrailCheckUncheckedCreateWithoutTrailInput> | TrailCheckCreateWithoutTrailInput[] | TrailCheckUncheckedCreateWithoutTrailInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutTrailInput | TrailCheckCreateOrConnectWithoutTrailInput[]
    createMany?: TrailCheckCreateManyTrailInputEnvelope
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
  }

  export type LocationCreateNestedOneWithoutTrailInput = {
    create?: XOR<LocationCreateWithoutTrailInput, LocationUncheckedCreateWithoutTrailInput>
    connectOrCreate?: LocationCreateOrConnectWithoutTrailInput
    connect?: LocationWhereUniqueInput
  }

  export type TrailCheckUncheckedCreateNestedManyWithoutTrailInput = {
    create?: XOR<TrailCheckCreateWithoutTrailInput, TrailCheckUncheckedCreateWithoutTrailInput> | TrailCheckCreateWithoutTrailInput[] | TrailCheckUncheckedCreateWithoutTrailInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutTrailInput | TrailCheckCreateOrConnectWithoutTrailInput[]
    createMany?: TrailCheckCreateManyTrailInputEnvelope
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
  }

  export type EnumTRAIL_DIFFICULTYFieldUpdateOperationsInput = {
    set?: $Enums.TRAIL_DIFFICULTY
  }

  export type EnumTRAIL_CONDITIONFieldUpdateOperationsInput = {
    set?: $Enums.TRAIL_CONDITION
  }

  export type MountainUpdateOneRequiredWithoutTrailsNestedInput = {
    create?: XOR<MountainCreateWithoutTrailsInput, MountainUncheckedCreateWithoutTrailsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutTrailsInput
    upsert?: MountainUpsertWithoutTrailsInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutTrailsInput, MountainUpdateWithoutTrailsInput>, MountainUncheckedUpdateWithoutTrailsInput>
  }

  export type TrailCheckUpdateManyWithoutTrailNestedInput = {
    create?: XOR<TrailCheckCreateWithoutTrailInput, TrailCheckUncheckedCreateWithoutTrailInput> | TrailCheckCreateWithoutTrailInput[] | TrailCheckUncheckedCreateWithoutTrailInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutTrailInput | TrailCheckCreateOrConnectWithoutTrailInput[]
    upsert?: TrailCheckUpsertWithWhereUniqueWithoutTrailInput | TrailCheckUpsertWithWhereUniqueWithoutTrailInput[]
    createMany?: TrailCheckCreateManyTrailInputEnvelope
    set?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    disconnect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    delete?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    update?: TrailCheckUpdateWithWhereUniqueWithoutTrailInput | TrailCheckUpdateWithWhereUniqueWithoutTrailInput[]
    updateMany?: TrailCheckUpdateManyWithWhereWithoutTrailInput | TrailCheckUpdateManyWithWhereWithoutTrailInput[]
    deleteMany?: TrailCheckScalarWhereInput | TrailCheckScalarWhereInput[]
  }

  export type LocationUpdateOneWithoutTrailNestedInput = {
    create?: XOR<LocationCreateWithoutTrailInput, LocationUncheckedCreateWithoutTrailInput>
    connectOrCreate?: LocationCreateOrConnectWithoutTrailInput
    upsert?: LocationUpsertWithoutTrailInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutTrailInput, LocationUpdateWithoutTrailInput>, LocationUncheckedUpdateWithoutTrailInput>
  }

  export type TrailCheckUncheckedUpdateManyWithoutTrailNestedInput = {
    create?: XOR<TrailCheckCreateWithoutTrailInput, TrailCheckUncheckedCreateWithoutTrailInput> | TrailCheckCreateWithoutTrailInput[] | TrailCheckUncheckedCreateWithoutTrailInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutTrailInput | TrailCheckCreateOrConnectWithoutTrailInput[]
    upsert?: TrailCheckUpsertWithWhereUniqueWithoutTrailInput | TrailCheckUpsertWithWhereUniqueWithoutTrailInput[]
    createMany?: TrailCheckCreateManyTrailInputEnvelope
    set?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    disconnect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    delete?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    update?: TrailCheckUpdateWithWhereUniqueWithoutTrailInput | TrailCheckUpdateWithWhereUniqueWithoutTrailInput[]
    updateMany?: TrailCheckUpdateManyWithWhereWithoutTrailInput | TrailCheckUpdateManyWithWhereWithoutTrailInput[]
    deleteMany?: TrailCheckScalarWhereInput | TrailCheckScalarWhereInput[]
  }

  export type MountainCreateNestedOneWithoutLodgesInput = {
    create?: XOR<MountainCreateWithoutLodgesInput, MountainUncheckedCreateWithoutLodgesInput>
    connectOrCreate?: MountainCreateOrConnectWithoutLodgesInput
    connect?: MountainWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutLodgeInput = {
    create?: XOR<LocationCreateWithoutLodgeInput, LocationUncheckedCreateWithoutLodgeInput>
    connectOrCreate?: LocationCreateOrConnectWithoutLodgeInput
    connect?: LocationWhereUniqueInput
  }

  export type MountainUpdateOneRequiredWithoutLodgesNestedInput = {
    create?: XOR<MountainCreateWithoutLodgesInput, MountainUncheckedCreateWithoutLodgesInput>
    connectOrCreate?: MountainCreateOrConnectWithoutLodgesInput
    upsert?: MountainUpsertWithoutLodgesInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutLodgesInput, MountainUpdateWithoutLodgesInput>, MountainUncheckedUpdateWithoutLodgesInput>
  }

  export type LocationUpdateOneWithoutLodgeNestedInput = {
    create?: XOR<LocationCreateWithoutLodgeInput, LocationUncheckedCreateWithoutLodgeInput>
    connectOrCreate?: LocationCreateOrConnectWithoutLodgeInput
    upsert?: LocationUpsertWithoutLodgeInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutLodgeInput, LocationUpdateWithoutLodgeInput>, LocationUncheckedUpdateWithoutLodgeInput>
  }

  export type MountainCreateNestedOneWithoutHutsInput = {
    create?: XOR<MountainCreateWithoutHutsInput, MountainUncheckedCreateWithoutHutsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutHutsInput
    connect?: MountainWhereUniqueInput
  }

  export type HutCheckCreateNestedManyWithoutHutInput = {
    create?: XOR<HutCheckCreateWithoutHutInput, HutCheckUncheckedCreateWithoutHutInput> | HutCheckCreateWithoutHutInput[] | HutCheckUncheckedCreateWithoutHutInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutHutInput | HutCheckCreateOrConnectWithoutHutInput[]
    createMany?: HutCheckCreateManyHutInputEnvelope
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
  }

  export type LocationCreateNestedOneWithoutHutInput = {
    create?: XOR<LocationCreateWithoutHutInput, LocationUncheckedCreateWithoutHutInput>
    connectOrCreate?: LocationCreateOrConnectWithoutHutInput
    connect?: LocationWhereUniqueInput
  }

  export type HutCheckUncheckedCreateNestedManyWithoutHutInput = {
    create?: XOR<HutCheckCreateWithoutHutInput, HutCheckUncheckedCreateWithoutHutInput> | HutCheckCreateWithoutHutInput[] | HutCheckUncheckedCreateWithoutHutInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutHutInput | HutCheckCreateOrConnectWithoutHutInput[]
    createMany?: HutCheckCreateManyHutInputEnvelope
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
  }

  export type MountainUpdateOneRequiredWithoutHutsNestedInput = {
    create?: XOR<MountainCreateWithoutHutsInput, MountainUncheckedCreateWithoutHutsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutHutsInput
    upsert?: MountainUpsertWithoutHutsInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutHutsInput, MountainUpdateWithoutHutsInput>, MountainUncheckedUpdateWithoutHutsInput>
  }

  export type HutCheckUpdateManyWithoutHutNestedInput = {
    create?: XOR<HutCheckCreateWithoutHutInput, HutCheckUncheckedCreateWithoutHutInput> | HutCheckCreateWithoutHutInput[] | HutCheckUncheckedCreateWithoutHutInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutHutInput | HutCheckCreateOrConnectWithoutHutInput[]
    upsert?: HutCheckUpsertWithWhereUniqueWithoutHutInput | HutCheckUpsertWithWhereUniqueWithoutHutInput[]
    createMany?: HutCheckCreateManyHutInputEnvelope
    set?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    disconnect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    delete?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    update?: HutCheckUpdateWithWhereUniqueWithoutHutInput | HutCheckUpdateWithWhereUniqueWithoutHutInput[]
    updateMany?: HutCheckUpdateManyWithWhereWithoutHutInput | HutCheckUpdateManyWithWhereWithoutHutInput[]
    deleteMany?: HutCheckScalarWhereInput | HutCheckScalarWhereInput[]
  }

  export type LocationUpdateOneWithoutHutNestedInput = {
    create?: XOR<LocationCreateWithoutHutInput, LocationUncheckedCreateWithoutHutInput>
    connectOrCreate?: LocationCreateOrConnectWithoutHutInput
    upsert?: LocationUpsertWithoutHutInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutHutInput, LocationUpdateWithoutHutInput>, LocationUncheckedUpdateWithoutHutInput>
  }

  export type HutCheckUncheckedUpdateManyWithoutHutNestedInput = {
    create?: XOR<HutCheckCreateWithoutHutInput, HutCheckUncheckedCreateWithoutHutInput> | HutCheckCreateWithoutHutInput[] | HutCheckUncheckedCreateWithoutHutInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutHutInput | HutCheckCreateOrConnectWithoutHutInput[]
    upsert?: HutCheckUpsertWithWhereUniqueWithoutHutInput | HutCheckUpsertWithWhereUniqueWithoutHutInput[]
    createMany?: HutCheckCreateManyHutInputEnvelope
    set?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    disconnect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    delete?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    update?: HutCheckUpdateWithWhereUniqueWithoutHutInput | HutCheckUpdateWithWhereUniqueWithoutHutInput[]
    updateMany?: HutCheckUpdateManyWithWhereWithoutHutInput | HutCheckUpdateManyWithWhereWithoutHutInput[]
    deleteMany?: HutCheckScalarWhereInput | HutCheckScalarWhereInput[]
  }

  export type MountainCreateNestedOneWithoutAidRoomsInput = {
    create?: XOR<MountainCreateWithoutAidRoomsInput, MountainUncheckedCreateWithoutAidRoomsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutAidRoomsInput
    connect?: MountainWhereUniqueInput
  }

  export type AidRoomCheckCreateNestedManyWithoutAidRoomInput = {
    create?: XOR<AidRoomCheckCreateWithoutAidRoomInput, AidRoomCheckUncheckedCreateWithoutAidRoomInput> | AidRoomCheckCreateWithoutAidRoomInput[] | AidRoomCheckUncheckedCreateWithoutAidRoomInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutAidRoomInput | AidRoomCheckCreateOrConnectWithoutAidRoomInput[]
    createMany?: AidRoomCheckCreateManyAidRoomInputEnvelope
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
  }

  export type LocationCreateNestedOneWithoutAidRoomInput = {
    create?: XOR<LocationCreateWithoutAidRoomInput, LocationUncheckedCreateWithoutAidRoomInput>
    connectOrCreate?: LocationCreateOrConnectWithoutAidRoomInput
    connect?: LocationWhereUniqueInput
  }

  export type AidRoomCheckUncheckedCreateNestedManyWithoutAidRoomInput = {
    create?: XOR<AidRoomCheckCreateWithoutAidRoomInput, AidRoomCheckUncheckedCreateWithoutAidRoomInput> | AidRoomCheckCreateWithoutAidRoomInput[] | AidRoomCheckUncheckedCreateWithoutAidRoomInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutAidRoomInput | AidRoomCheckCreateOrConnectWithoutAidRoomInput[]
    createMany?: AidRoomCheckCreateManyAidRoomInputEnvelope
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
  }

  export type MountainUpdateOneRequiredWithoutAidRoomsNestedInput = {
    create?: XOR<MountainCreateWithoutAidRoomsInput, MountainUncheckedCreateWithoutAidRoomsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutAidRoomsInput
    upsert?: MountainUpsertWithoutAidRoomsInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutAidRoomsInput, MountainUpdateWithoutAidRoomsInput>, MountainUncheckedUpdateWithoutAidRoomsInput>
  }

  export type AidRoomCheckUpdateManyWithoutAidRoomNestedInput = {
    create?: XOR<AidRoomCheckCreateWithoutAidRoomInput, AidRoomCheckUncheckedCreateWithoutAidRoomInput> | AidRoomCheckCreateWithoutAidRoomInput[] | AidRoomCheckUncheckedCreateWithoutAidRoomInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutAidRoomInput | AidRoomCheckCreateOrConnectWithoutAidRoomInput[]
    upsert?: AidRoomCheckUpsertWithWhereUniqueWithoutAidRoomInput | AidRoomCheckUpsertWithWhereUniqueWithoutAidRoomInput[]
    createMany?: AidRoomCheckCreateManyAidRoomInputEnvelope
    set?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    disconnect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    delete?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    update?: AidRoomCheckUpdateWithWhereUniqueWithoutAidRoomInput | AidRoomCheckUpdateWithWhereUniqueWithoutAidRoomInput[]
    updateMany?: AidRoomCheckUpdateManyWithWhereWithoutAidRoomInput | AidRoomCheckUpdateManyWithWhereWithoutAidRoomInput[]
    deleteMany?: AidRoomCheckScalarWhereInput | AidRoomCheckScalarWhereInput[]
  }

  export type LocationUpdateOneWithoutAidRoomNestedInput = {
    create?: XOR<LocationCreateWithoutAidRoomInput, LocationUncheckedCreateWithoutAidRoomInput>
    connectOrCreate?: LocationCreateOrConnectWithoutAidRoomInput
    upsert?: LocationUpsertWithoutAidRoomInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutAidRoomInput, LocationUpdateWithoutAidRoomInput>, LocationUncheckedUpdateWithoutAidRoomInput>
  }

  export type AidRoomCheckUncheckedUpdateManyWithoutAidRoomNestedInput = {
    create?: XOR<AidRoomCheckCreateWithoutAidRoomInput, AidRoomCheckUncheckedCreateWithoutAidRoomInput> | AidRoomCheckCreateWithoutAidRoomInput[] | AidRoomCheckUncheckedCreateWithoutAidRoomInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutAidRoomInput | AidRoomCheckCreateOrConnectWithoutAidRoomInput[]
    upsert?: AidRoomCheckUpsertWithWhereUniqueWithoutAidRoomInput | AidRoomCheckUpsertWithWhereUniqueWithoutAidRoomInput[]
    createMany?: AidRoomCheckCreateManyAidRoomInputEnvelope
    set?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    disconnect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    delete?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    update?: AidRoomCheckUpdateWithWhereUniqueWithoutAidRoomInput | AidRoomCheckUpdateWithWhereUniqueWithoutAidRoomInput[]
    updateMany?: AidRoomCheckUpdateManyWithWhereWithoutAidRoomInput | AidRoomCheckUpdateManyWithWhereWithoutAidRoomInput[]
    deleteMany?: AidRoomCheckScalarWhereInput | AidRoomCheckScalarWhereInput[]
  }

  export type MountainCreateNestedOneWithoutEquipmentServiceLogsInput = {
    create?: XOR<MountainCreateWithoutEquipmentServiceLogsInput, MountainUncheckedCreateWithoutEquipmentServiceLogsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutEquipmentServiceLogsInput
    connect?: MountainWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutEquipmentServiceLogsInput = {
    create?: XOR<EmployeeCreateWithoutEquipmentServiceLogsInput, EmployeeUncheckedCreateWithoutEquipmentServiceLogsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEquipmentServiceLogsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EquipmentCreateNestedOneWithoutEquipmentServiceLogsInput = {
    create?: XOR<EquipmentCreateWithoutEquipmentServiceLogsInput, EquipmentUncheckedCreateWithoutEquipmentServiceLogsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutEquipmentServiceLogsInput
    connect?: EquipmentWhereUniqueInput
  }

  export type EnumEQUIPMENT_STATUSFieldUpdateOperationsInput = {
    set?: $Enums.EQUIPMENT_STATUS
  }

  export type MountainUpdateOneRequiredWithoutEquipmentServiceLogsNestedInput = {
    create?: XOR<MountainCreateWithoutEquipmentServiceLogsInput, MountainUncheckedCreateWithoutEquipmentServiceLogsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutEquipmentServiceLogsInput
    upsert?: MountainUpsertWithoutEquipmentServiceLogsInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutEquipmentServiceLogsInput, MountainUpdateWithoutEquipmentServiceLogsInput>, MountainUncheckedUpdateWithoutEquipmentServiceLogsInput>
  }

  export type EmployeeUpdateOneWithoutEquipmentServiceLogsNestedInput = {
    create?: XOR<EmployeeCreateWithoutEquipmentServiceLogsInput, EmployeeUncheckedCreateWithoutEquipmentServiceLogsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEquipmentServiceLogsInput
    upsert?: EmployeeUpsertWithoutEquipmentServiceLogsInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutEquipmentServiceLogsInput, EmployeeUpdateWithoutEquipmentServiceLogsInput>, EmployeeUncheckedUpdateWithoutEquipmentServiceLogsInput>
  }

  export type EquipmentUpdateOneRequiredWithoutEquipmentServiceLogsNestedInput = {
    create?: XOR<EquipmentCreateWithoutEquipmentServiceLogsInput, EquipmentUncheckedCreateWithoutEquipmentServiceLogsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutEquipmentServiceLogsInput
    upsert?: EquipmentUpsertWithoutEquipmentServiceLogsInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutEquipmentServiceLogsInput, EquipmentUpdateWithoutEquipmentServiceLogsInput>, EquipmentUncheckedUpdateWithoutEquipmentServiceLogsInput>
  }

  export type MountainCreateNestedOneWithoutEquipmentInput = {
    create?: XOR<MountainCreateWithoutEquipmentInput, MountainUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: MountainCreateOrConnectWithoutEquipmentInput
    connect?: MountainWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutEquipmentInput = {
    create?: XOR<LocationCreateWithoutEquipmentInput, LocationUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: LocationCreateOrConnectWithoutEquipmentInput
    connect?: LocationWhereUniqueInput
  }

  export type IncidentEquipmentUsageLogCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<IncidentEquipmentUsageLogCreateWithoutEquipmentInput, IncidentEquipmentUsageLogUncheckedCreateWithoutEquipmentInput> | IncidentEquipmentUsageLogCreateWithoutEquipmentInput[] | IncidentEquipmentUsageLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: IncidentEquipmentUsageLogCreateOrConnectWithoutEquipmentInput | IncidentEquipmentUsageLogCreateOrConnectWithoutEquipmentInput[]
    createMany?: IncidentEquipmentUsageLogCreateManyEquipmentInputEnvelope
    connect?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
  }

  export type EquipmentCheckCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<EquipmentCheckCreateWithoutEquipmentInput, EquipmentCheckUncheckedCreateWithoutEquipmentInput> | EquipmentCheckCreateWithoutEquipmentInput[] | EquipmentCheckUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutEquipmentInput | EquipmentCheckCreateOrConnectWithoutEquipmentInput[]
    createMany?: EquipmentCheckCreateManyEquipmentInputEnvelope
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
  }

  export type EquipmentServiceLogCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<EquipmentServiceLogCreateWithoutEquipmentInput, EquipmentServiceLogUncheckedCreateWithoutEquipmentInput> | EquipmentServiceLogCreateWithoutEquipmentInput[] | EquipmentServiceLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentServiceLogCreateOrConnectWithoutEquipmentInput | EquipmentServiceLogCreateOrConnectWithoutEquipmentInput[]
    createMany?: EquipmentServiceLogCreateManyEquipmentInputEnvelope
    connect?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
  }

  export type IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<IncidentEquipmentUsageLogCreateWithoutEquipmentInput, IncidentEquipmentUsageLogUncheckedCreateWithoutEquipmentInput> | IncidentEquipmentUsageLogCreateWithoutEquipmentInput[] | IncidentEquipmentUsageLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: IncidentEquipmentUsageLogCreateOrConnectWithoutEquipmentInput | IncidentEquipmentUsageLogCreateOrConnectWithoutEquipmentInput[]
    createMany?: IncidentEquipmentUsageLogCreateManyEquipmentInputEnvelope
    connect?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
  }

  export type EquipmentCheckUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<EquipmentCheckCreateWithoutEquipmentInput, EquipmentCheckUncheckedCreateWithoutEquipmentInput> | EquipmentCheckCreateWithoutEquipmentInput[] | EquipmentCheckUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutEquipmentInput | EquipmentCheckCreateOrConnectWithoutEquipmentInput[]
    createMany?: EquipmentCheckCreateManyEquipmentInputEnvelope
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
  }

  export type EquipmentServiceLogUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<EquipmentServiceLogCreateWithoutEquipmentInput, EquipmentServiceLogUncheckedCreateWithoutEquipmentInput> | EquipmentServiceLogCreateWithoutEquipmentInput[] | EquipmentServiceLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentServiceLogCreateOrConnectWithoutEquipmentInput | EquipmentServiceLogCreateOrConnectWithoutEquipmentInput[]
    createMany?: EquipmentServiceLogCreateManyEquipmentInputEnvelope
    connect?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
  }

  export type MountainUpdateOneWithoutEquipmentNestedInput = {
    create?: XOR<MountainCreateWithoutEquipmentInput, MountainUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: MountainCreateOrConnectWithoutEquipmentInput
    upsert?: MountainUpsertWithoutEquipmentInput
    disconnect?: MountainWhereInput | boolean
    delete?: MountainWhereInput | boolean
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutEquipmentInput, MountainUpdateWithoutEquipmentInput>, MountainUncheckedUpdateWithoutEquipmentInput>
  }

  export type LocationUpdateOneWithoutEquipmentNestedInput = {
    create?: XOR<LocationCreateWithoutEquipmentInput, LocationUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: LocationCreateOrConnectWithoutEquipmentInput
    upsert?: LocationUpsertWithoutEquipmentInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutEquipmentInput, LocationUpdateWithoutEquipmentInput>, LocationUncheckedUpdateWithoutEquipmentInput>
  }

  export type IncidentEquipmentUsageLogUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<IncidentEquipmentUsageLogCreateWithoutEquipmentInput, IncidentEquipmentUsageLogUncheckedCreateWithoutEquipmentInput> | IncidentEquipmentUsageLogCreateWithoutEquipmentInput[] | IncidentEquipmentUsageLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: IncidentEquipmentUsageLogCreateOrConnectWithoutEquipmentInput | IncidentEquipmentUsageLogCreateOrConnectWithoutEquipmentInput[]
    upsert?: IncidentEquipmentUsageLogUpsertWithWhereUniqueWithoutEquipmentInput | IncidentEquipmentUsageLogUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: IncidentEquipmentUsageLogCreateManyEquipmentInputEnvelope
    set?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    disconnect?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    delete?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    connect?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    update?: IncidentEquipmentUsageLogUpdateWithWhereUniqueWithoutEquipmentInput | IncidentEquipmentUsageLogUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: IncidentEquipmentUsageLogUpdateManyWithWhereWithoutEquipmentInput | IncidentEquipmentUsageLogUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: IncidentEquipmentUsageLogScalarWhereInput | IncidentEquipmentUsageLogScalarWhereInput[]
  }

  export type EquipmentCheckUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<EquipmentCheckCreateWithoutEquipmentInput, EquipmentCheckUncheckedCreateWithoutEquipmentInput> | EquipmentCheckCreateWithoutEquipmentInput[] | EquipmentCheckUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutEquipmentInput | EquipmentCheckCreateOrConnectWithoutEquipmentInput[]
    upsert?: EquipmentCheckUpsertWithWhereUniqueWithoutEquipmentInput | EquipmentCheckUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: EquipmentCheckCreateManyEquipmentInputEnvelope
    set?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    disconnect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    delete?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    update?: EquipmentCheckUpdateWithWhereUniqueWithoutEquipmentInput | EquipmentCheckUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: EquipmentCheckUpdateManyWithWhereWithoutEquipmentInput | EquipmentCheckUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: EquipmentCheckScalarWhereInput | EquipmentCheckScalarWhereInput[]
  }

  export type EquipmentServiceLogUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<EquipmentServiceLogCreateWithoutEquipmentInput, EquipmentServiceLogUncheckedCreateWithoutEquipmentInput> | EquipmentServiceLogCreateWithoutEquipmentInput[] | EquipmentServiceLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentServiceLogCreateOrConnectWithoutEquipmentInput | EquipmentServiceLogCreateOrConnectWithoutEquipmentInput[]
    upsert?: EquipmentServiceLogUpsertWithWhereUniqueWithoutEquipmentInput | EquipmentServiceLogUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: EquipmentServiceLogCreateManyEquipmentInputEnvelope
    set?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    disconnect?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    delete?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    connect?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    update?: EquipmentServiceLogUpdateWithWhereUniqueWithoutEquipmentInput | EquipmentServiceLogUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: EquipmentServiceLogUpdateManyWithWhereWithoutEquipmentInput | EquipmentServiceLogUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: EquipmentServiceLogScalarWhereInput | EquipmentServiceLogScalarWhereInput[]
  }

  export type IncidentEquipmentUsageLogUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<IncidentEquipmentUsageLogCreateWithoutEquipmentInput, IncidentEquipmentUsageLogUncheckedCreateWithoutEquipmentInput> | IncidentEquipmentUsageLogCreateWithoutEquipmentInput[] | IncidentEquipmentUsageLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: IncidentEquipmentUsageLogCreateOrConnectWithoutEquipmentInput | IncidentEquipmentUsageLogCreateOrConnectWithoutEquipmentInput[]
    upsert?: IncidentEquipmentUsageLogUpsertWithWhereUniqueWithoutEquipmentInput | IncidentEquipmentUsageLogUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: IncidentEquipmentUsageLogCreateManyEquipmentInputEnvelope
    set?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    disconnect?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    delete?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    connect?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    update?: IncidentEquipmentUsageLogUpdateWithWhereUniqueWithoutEquipmentInput | IncidentEquipmentUsageLogUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: IncidentEquipmentUsageLogUpdateManyWithWhereWithoutEquipmentInput | IncidentEquipmentUsageLogUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: IncidentEquipmentUsageLogScalarWhereInput | IncidentEquipmentUsageLogScalarWhereInput[]
  }

  export type EquipmentCheckUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<EquipmentCheckCreateWithoutEquipmentInput, EquipmentCheckUncheckedCreateWithoutEquipmentInput> | EquipmentCheckCreateWithoutEquipmentInput[] | EquipmentCheckUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutEquipmentInput | EquipmentCheckCreateOrConnectWithoutEquipmentInput[]
    upsert?: EquipmentCheckUpsertWithWhereUniqueWithoutEquipmentInput | EquipmentCheckUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: EquipmentCheckCreateManyEquipmentInputEnvelope
    set?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    disconnect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    delete?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    update?: EquipmentCheckUpdateWithWhereUniqueWithoutEquipmentInput | EquipmentCheckUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: EquipmentCheckUpdateManyWithWhereWithoutEquipmentInput | EquipmentCheckUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: EquipmentCheckScalarWhereInput | EquipmentCheckScalarWhereInput[]
  }

  export type EquipmentServiceLogUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<EquipmentServiceLogCreateWithoutEquipmentInput, EquipmentServiceLogUncheckedCreateWithoutEquipmentInput> | EquipmentServiceLogCreateWithoutEquipmentInput[] | EquipmentServiceLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentServiceLogCreateOrConnectWithoutEquipmentInput | EquipmentServiceLogCreateOrConnectWithoutEquipmentInput[]
    upsert?: EquipmentServiceLogUpsertWithWhereUniqueWithoutEquipmentInput | EquipmentServiceLogUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: EquipmentServiceLogCreateManyEquipmentInputEnvelope
    set?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    disconnect?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    delete?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    connect?: EquipmentServiceLogWhereUniqueInput | EquipmentServiceLogWhereUniqueInput[]
    update?: EquipmentServiceLogUpdateWithWhereUniqueWithoutEquipmentInput | EquipmentServiceLogUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: EquipmentServiceLogUpdateManyWithWhereWithoutEquipmentInput | EquipmentServiceLogUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: EquipmentServiceLogScalarWhereInput | EquipmentServiceLogScalarWhereInput[]
  }

  export type MountainCreateNestedOneWithoutIncidentsInput = {
    create?: XOR<MountainCreateWithoutIncidentsInput, MountainUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutIncidentsInput
    connect?: MountainWhereUniqueInput
  }

  export type IncidentEquipmentUsageLogCreateNestedManyWithoutIncidentInput = {
    create?: XOR<IncidentEquipmentUsageLogCreateWithoutIncidentInput, IncidentEquipmentUsageLogUncheckedCreateWithoutIncidentInput> | IncidentEquipmentUsageLogCreateWithoutIncidentInput[] | IncidentEquipmentUsageLogUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentEquipmentUsageLogCreateOrConnectWithoutIncidentInput | IncidentEquipmentUsageLogCreateOrConnectWithoutIncidentInput[]
    createMany?: IncidentEquipmentUsageLogCreateManyIncidentInputEnvelope
    connect?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
  }

  export type LocationCreateNestedOneWithoutIncidentsInput = {
    create?: XOR<LocationCreateWithoutIncidentsInput, LocationUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutIncidentsInput
    connect?: LocationWhereUniqueInput
  }

  export type EmployeeCreateNestedManyWithoutIncidentsInput = {
    create?: XOR<EmployeeCreateWithoutIncidentsInput, EmployeeUncheckedCreateWithoutIncidentsInput> | EmployeeCreateWithoutIncidentsInput[] | EmployeeUncheckedCreateWithoutIncidentsInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutIncidentsInput | EmployeeCreateOrConnectWithoutIncidentsInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutIncidentInput = {
    create?: XOR<IncidentEquipmentUsageLogCreateWithoutIncidentInput, IncidentEquipmentUsageLogUncheckedCreateWithoutIncidentInput> | IncidentEquipmentUsageLogCreateWithoutIncidentInput[] | IncidentEquipmentUsageLogUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentEquipmentUsageLogCreateOrConnectWithoutIncidentInput | IncidentEquipmentUsageLogCreateOrConnectWithoutIncidentInput[]
    createMany?: IncidentEquipmentUsageLogCreateManyIncidentInputEnvelope
    connect?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutIncidentsInput = {
    create?: XOR<EmployeeCreateWithoutIncidentsInput, EmployeeUncheckedCreateWithoutIncidentsInput> | EmployeeCreateWithoutIncidentsInput[] | EmployeeUncheckedCreateWithoutIncidentsInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutIncidentsInput | EmployeeCreateOrConnectWithoutIncidentsInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EnumINCIDENT_STATUSFieldUpdateOperationsInput = {
    set?: $Enums.INCIDENT_STATUS
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type MountainUpdateOneRequiredWithoutIncidentsNestedInput = {
    create?: XOR<MountainCreateWithoutIncidentsInput, MountainUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutIncidentsInput
    upsert?: MountainUpsertWithoutIncidentsInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutIncidentsInput, MountainUpdateWithoutIncidentsInput>, MountainUncheckedUpdateWithoutIncidentsInput>
  }

  export type IncidentEquipmentUsageLogUpdateManyWithoutIncidentNestedInput = {
    create?: XOR<IncidentEquipmentUsageLogCreateWithoutIncidentInput, IncidentEquipmentUsageLogUncheckedCreateWithoutIncidentInput> | IncidentEquipmentUsageLogCreateWithoutIncidentInput[] | IncidentEquipmentUsageLogUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentEquipmentUsageLogCreateOrConnectWithoutIncidentInput | IncidentEquipmentUsageLogCreateOrConnectWithoutIncidentInput[]
    upsert?: IncidentEquipmentUsageLogUpsertWithWhereUniqueWithoutIncidentInput | IncidentEquipmentUsageLogUpsertWithWhereUniqueWithoutIncidentInput[]
    createMany?: IncidentEquipmentUsageLogCreateManyIncidentInputEnvelope
    set?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    disconnect?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    delete?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    connect?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    update?: IncidentEquipmentUsageLogUpdateWithWhereUniqueWithoutIncidentInput | IncidentEquipmentUsageLogUpdateWithWhereUniqueWithoutIncidentInput[]
    updateMany?: IncidentEquipmentUsageLogUpdateManyWithWhereWithoutIncidentInput | IncidentEquipmentUsageLogUpdateManyWithWhereWithoutIncidentInput[]
    deleteMany?: IncidentEquipmentUsageLogScalarWhereInput | IncidentEquipmentUsageLogScalarWhereInput[]
  }

  export type LocationUpdateOneRequiredWithoutIncidentsNestedInput = {
    create?: XOR<LocationCreateWithoutIncidentsInput, LocationUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutIncidentsInput
    upsert?: LocationUpsertWithoutIncidentsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutIncidentsInput, LocationUpdateWithoutIncidentsInput>, LocationUncheckedUpdateWithoutIncidentsInput>
  }

  export type EmployeeUpdateManyWithoutIncidentsNestedInput = {
    create?: XOR<EmployeeCreateWithoutIncidentsInput, EmployeeUncheckedCreateWithoutIncidentsInput> | EmployeeCreateWithoutIncidentsInput[] | EmployeeUncheckedCreateWithoutIncidentsInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutIncidentsInput | EmployeeCreateOrConnectWithoutIncidentsInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutIncidentsInput | EmployeeUpsertWithWhereUniqueWithoutIncidentsInput[]
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutIncidentsInput | EmployeeUpdateWithWhereUniqueWithoutIncidentsInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutIncidentsInput | EmployeeUpdateManyWithWhereWithoutIncidentsInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type IncidentEquipmentUsageLogUncheckedUpdateManyWithoutIncidentNestedInput = {
    create?: XOR<IncidentEquipmentUsageLogCreateWithoutIncidentInput, IncidentEquipmentUsageLogUncheckedCreateWithoutIncidentInput> | IncidentEquipmentUsageLogCreateWithoutIncidentInput[] | IncidentEquipmentUsageLogUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentEquipmentUsageLogCreateOrConnectWithoutIncidentInput | IncidentEquipmentUsageLogCreateOrConnectWithoutIncidentInput[]
    upsert?: IncidentEquipmentUsageLogUpsertWithWhereUniqueWithoutIncidentInput | IncidentEquipmentUsageLogUpsertWithWhereUniqueWithoutIncidentInput[]
    createMany?: IncidentEquipmentUsageLogCreateManyIncidentInputEnvelope
    set?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    disconnect?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    delete?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    connect?: IncidentEquipmentUsageLogWhereUniqueInput | IncidentEquipmentUsageLogWhereUniqueInput[]
    update?: IncidentEquipmentUsageLogUpdateWithWhereUniqueWithoutIncidentInput | IncidentEquipmentUsageLogUpdateWithWhereUniqueWithoutIncidentInput[]
    updateMany?: IncidentEquipmentUsageLogUpdateManyWithWhereWithoutIncidentInput | IncidentEquipmentUsageLogUpdateManyWithWhereWithoutIncidentInput[]
    deleteMany?: IncidentEquipmentUsageLogScalarWhereInput | IncidentEquipmentUsageLogScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutIncidentsNestedInput = {
    create?: XOR<EmployeeCreateWithoutIncidentsInput, EmployeeUncheckedCreateWithoutIncidentsInput> | EmployeeCreateWithoutIncidentsInput[] | EmployeeUncheckedCreateWithoutIncidentsInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutIncidentsInput | EmployeeCreateOrConnectWithoutIncidentsInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutIncidentsInput | EmployeeUpsertWithWhereUniqueWithoutIncidentsInput[]
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutIncidentsInput | EmployeeUpdateWithWhereUniqueWithoutIncidentsInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutIncidentsInput | EmployeeUpdateManyWithWhereWithoutIncidentsInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type MountainCreateNestedOneWithoutIncidentEquipmentUsageLogInput = {
    create?: XOR<MountainCreateWithoutIncidentEquipmentUsageLogInput, MountainUncheckedCreateWithoutIncidentEquipmentUsageLogInput>
    connectOrCreate?: MountainCreateOrConnectWithoutIncidentEquipmentUsageLogInput
    connect?: MountainWhereUniqueInput
  }

  export type IncidentCreateNestedOneWithoutIncidentEquipmentUsageLogInput = {
    create?: XOR<IncidentCreateWithoutIncidentEquipmentUsageLogInput, IncidentUncheckedCreateWithoutIncidentEquipmentUsageLogInput>
    connectOrCreate?: IncidentCreateOrConnectWithoutIncidentEquipmentUsageLogInput
    connect?: IncidentWhereUniqueInput
  }

  export type EquipmentCreateNestedOneWithoutIncidentEquipmentUsageLogsInput = {
    create?: XOR<EquipmentCreateWithoutIncidentEquipmentUsageLogsInput, EquipmentUncheckedCreateWithoutIncidentEquipmentUsageLogsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutIncidentEquipmentUsageLogsInput
    connect?: EquipmentWhereUniqueInput
  }

  export type MountainUpdateOneRequiredWithoutIncidentEquipmentUsageLogNestedInput = {
    create?: XOR<MountainCreateWithoutIncidentEquipmentUsageLogInput, MountainUncheckedCreateWithoutIncidentEquipmentUsageLogInput>
    connectOrCreate?: MountainCreateOrConnectWithoutIncidentEquipmentUsageLogInput
    upsert?: MountainUpsertWithoutIncidentEquipmentUsageLogInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutIncidentEquipmentUsageLogInput, MountainUpdateWithoutIncidentEquipmentUsageLogInput>, MountainUncheckedUpdateWithoutIncidentEquipmentUsageLogInput>
  }

  export type IncidentUpdateOneRequiredWithoutIncidentEquipmentUsageLogNestedInput = {
    create?: XOR<IncidentCreateWithoutIncidentEquipmentUsageLogInput, IncidentUncheckedCreateWithoutIncidentEquipmentUsageLogInput>
    connectOrCreate?: IncidentCreateOrConnectWithoutIncidentEquipmentUsageLogInput
    upsert?: IncidentUpsertWithoutIncidentEquipmentUsageLogInput
    connect?: IncidentWhereUniqueInput
    update?: XOR<XOR<IncidentUpdateToOneWithWhereWithoutIncidentEquipmentUsageLogInput, IncidentUpdateWithoutIncidentEquipmentUsageLogInput>, IncidentUncheckedUpdateWithoutIncidentEquipmentUsageLogInput>
  }

  export type EquipmentUpdateOneRequiredWithoutIncidentEquipmentUsageLogsNestedInput = {
    create?: XOR<EquipmentCreateWithoutIncidentEquipmentUsageLogsInput, EquipmentUncheckedCreateWithoutIncidentEquipmentUsageLogsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutIncidentEquipmentUsageLogsInput
    upsert?: EquipmentUpsertWithoutIncidentEquipmentUsageLogsInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutIncidentEquipmentUsageLogsInput, EquipmentUpdateWithoutIncidentEquipmentUsageLogsInput>, EquipmentUncheckedUpdateWithoutIncidentEquipmentUsageLogsInput>
  }

  export type EmployeeCreateNestedOneWithoutLiftChecksInput = {
    create?: XOR<EmployeeCreateWithoutLiftChecksInput, EmployeeUncheckedCreateWithoutLiftChecksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLiftChecksInput
    connect?: EmployeeWhereUniqueInput
  }

  export type MountainCreateNestedOneWithoutLiftChecksInput = {
    create?: XOR<MountainCreateWithoutLiftChecksInput, MountainUncheckedCreateWithoutLiftChecksInput>
    connectOrCreate?: MountainCreateOrConnectWithoutLiftChecksInput
    connect?: MountainWhereUniqueInput
  }

  export type LiftCreateNestedOneWithoutLiftChecksInput = {
    create?: XOR<LiftCreateWithoutLiftChecksInput, LiftUncheckedCreateWithoutLiftChecksInput>
    connectOrCreate?: LiftCreateOrConnectWithoutLiftChecksInput
    connect?: LiftWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutLiftChecksNestedInput = {
    create?: XOR<EmployeeCreateWithoutLiftChecksInput, EmployeeUncheckedCreateWithoutLiftChecksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLiftChecksInput
    upsert?: EmployeeUpsertWithoutLiftChecksInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutLiftChecksInput, EmployeeUpdateWithoutLiftChecksInput>, EmployeeUncheckedUpdateWithoutLiftChecksInput>
  }

  export type MountainUpdateOneRequiredWithoutLiftChecksNestedInput = {
    create?: XOR<MountainCreateWithoutLiftChecksInput, MountainUncheckedCreateWithoutLiftChecksInput>
    connectOrCreate?: MountainCreateOrConnectWithoutLiftChecksInput
    upsert?: MountainUpsertWithoutLiftChecksInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutLiftChecksInput, MountainUpdateWithoutLiftChecksInput>, MountainUncheckedUpdateWithoutLiftChecksInput>
  }

  export type LiftUpdateOneRequiredWithoutLiftChecksNestedInput = {
    create?: XOR<LiftCreateWithoutLiftChecksInput, LiftUncheckedCreateWithoutLiftChecksInput>
    connectOrCreate?: LiftCreateOrConnectWithoutLiftChecksInput
    upsert?: LiftUpsertWithoutLiftChecksInput
    connect?: LiftWhereUniqueInput
    update?: XOR<XOR<LiftUpdateToOneWithWhereWithoutLiftChecksInput, LiftUpdateWithoutLiftChecksInput>, LiftUncheckedUpdateWithoutLiftChecksInput>
  }

  export type EmployeeCreateNestedOneWithoutTrailChecksInput = {
    create?: XOR<EmployeeCreateWithoutTrailChecksInput, EmployeeUncheckedCreateWithoutTrailChecksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutTrailChecksInput
    connect?: EmployeeWhereUniqueInput
  }

  export type MountainCreateNestedOneWithoutTrailChecksInput = {
    create?: XOR<MountainCreateWithoutTrailChecksInput, MountainUncheckedCreateWithoutTrailChecksInput>
    connectOrCreate?: MountainCreateOrConnectWithoutTrailChecksInput
    connect?: MountainWhereUniqueInput
  }

  export type TrailCreateNestedOneWithoutTrailChecksInput = {
    create?: XOR<TrailCreateWithoutTrailChecksInput, TrailUncheckedCreateWithoutTrailChecksInput>
    connectOrCreate?: TrailCreateOrConnectWithoutTrailChecksInput
    connect?: TrailWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutTrailChecksNestedInput = {
    create?: XOR<EmployeeCreateWithoutTrailChecksInput, EmployeeUncheckedCreateWithoutTrailChecksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutTrailChecksInput
    upsert?: EmployeeUpsertWithoutTrailChecksInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutTrailChecksInput, EmployeeUpdateWithoutTrailChecksInput>, EmployeeUncheckedUpdateWithoutTrailChecksInput>
  }

  export type MountainUpdateOneRequiredWithoutTrailChecksNestedInput = {
    create?: XOR<MountainCreateWithoutTrailChecksInput, MountainUncheckedCreateWithoutTrailChecksInput>
    connectOrCreate?: MountainCreateOrConnectWithoutTrailChecksInput
    upsert?: MountainUpsertWithoutTrailChecksInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutTrailChecksInput, MountainUpdateWithoutTrailChecksInput>, MountainUncheckedUpdateWithoutTrailChecksInput>
  }

  export type TrailUpdateOneRequiredWithoutTrailChecksNestedInput = {
    create?: XOR<TrailCreateWithoutTrailChecksInput, TrailUncheckedCreateWithoutTrailChecksInput>
    connectOrCreate?: TrailCreateOrConnectWithoutTrailChecksInput
    upsert?: TrailUpsertWithoutTrailChecksInput
    connect?: TrailWhereUniqueInput
    update?: XOR<XOR<TrailUpdateToOneWithWhereWithoutTrailChecksInput, TrailUpdateWithoutTrailChecksInput>, TrailUncheckedUpdateWithoutTrailChecksInput>
  }

  export type EmployeeCreateNestedOneWithoutHutChecksInput = {
    create?: XOR<EmployeeCreateWithoutHutChecksInput, EmployeeUncheckedCreateWithoutHutChecksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutHutChecksInput
    connect?: EmployeeWhereUniqueInput
  }

  export type MountainCreateNestedOneWithoutHutChecksInput = {
    create?: XOR<MountainCreateWithoutHutChecksInput, MountainUncheckedCreateWithoutHutChecksInput>
    connectOrCreate?: MountainCreateOrConnectWithoutHutChecksInput
    connect?: MountainWhereUniqueInput
  }

  export type HutCreateNestedOneWithoutHutChecksInput = {
    create?: XOR<HutCreateWithoutHutChecksInput, HutUncheckedCreateWithoutHutChecksInput>
    connectOrCreate?: HutCreateOrConnectWithoutHutChecksInput
    connect?: HutWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutHutChecksNestedInput = {
    create?: XOR<EmployeeCreateWithoutHutChecksInput, EmployeeUncheckedCreateWithoutHutChecksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutHutChecksInput
    upsert?: EmployeeUpsertWithoutHutChecksInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutHutChecksInput, EmployeeUpdateWithoutHutChecksInput>, EmployeeUncheckedUpdateWithoutHutChecksInput>
  }

  export type MountainUpdateOneRequiredWithoutHutChecksNestedInput = {
    create?: XOR<MountainCreateWithoutHutChecksInput, MountainUncheckedCreateWithoutHutChecksInput>
    connectOrCreate?: MountainCreateOrConnectWithoutHutChecksInput
    upsert?: MountainUpsertWithoutHutChecksInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutHutChecksInput, MountainUpdateWithoutHutChecksInput>, MountainUncheckedUpdateWithoutHutChecksInput>
  }

  export type HutUpdateOneRequiredWithoutHutChecksNestedInput = {
    create?: XOR<HutCreateWithoutHutChecksInput, HutUncheckedCreateWithoutHutChecksInput>
    connectOrCreate?: HutCreateOrConnectWithoutHutChecksInput
    upsert?: HutUpsertWithoutHutChecksInput
    connect?: HutWhereUniqueInput
    update?: XOR<XOR<HutUpdateToOneWithWhereWithoutHutChecksInput, HutUpdateWithoutHutChecksInput>, HutUncheckedUpdateWithoutHutChecksInput>
  }

  export type EmployeeCreateNestedOneWithoutAidRoomChecksInput = {
    create?: XOR<EmployeeCreateWithoutAidRoomChecksInput, EmployeeUncheckedCreateWithoutAidRoomChecksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAidRoomChecksInput
    connect?: EmployeeWhereUniqueInput
  }

  export type MountainCreateNestedOneWithoutAidRoomChecksInput = {
    create?: XOR<MountainCreateWithoutAidRoomChecksInput, MountainUncheckedCreateWithoutAidRoomChecksInput>
    connectOrCreate?: MountainCreateOrConnectWithoutAidRoomChecksInput
    connect?: MountainWhereUniqueInput
  }

  export type AidRoomCreateNestedOneWithoutAidRoomChecksInput = {
    create?: XOR<AidRoomCreateWithoutAidRoomChecksInput, AidRoomUncheckedCreateWithoutAidRoomChecksInput>
    connectOrCreate?: AidRoomCreateOrConnectWithoutAidRoomChecksInput
    connect?: AidRoomWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutAidRoomChecksNestedInput = {
    create?: XOR<EmployeeCreateWithoutAidRoomChecksInput, EmployeeUncheckedCreateWithoutAidRoomChecksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAidRoomChecksInput
    upsert?: EmployeeUpsertWithoutAidRoomChecksInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAidRoomChecksInput, EmployeeUpdateWithoutAidRoomChecksInput>, EmployeeUncheckedUpdateWithoutAidRoomChecksInput>
  }

  export type MountainUpdateOneRequiredWithoutAidRoomChecksNestedInput = {
    create?: XOR<MountainCreateWithoutAidRoomChecksInput, MountainUncheckedCreateWithoutAidRoomChecksInput>
    connectOrCreate?: MountainCreateOrConnectWithoutAidRoomChecksInput
    upsert?: MountainUpsertWithoutAidRoomChecksInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutAidRoomChecksInput, MountainUpdateWithoutAidRoomChecksInput>, MountainUncheckedUpdateWithoutAidRoomChecksInput>
  }

  export type AidRoomUpdateOneRequiredWithoutAidRoomChecksNestedInput = {
    create?: XOR<AidRoomCreateWithoutAidRoomChecksInput, AidRoomUncheckedCreateWithoutAidRoomChecksInput>
    connectOrCreate?: AidRoomCreateOrConnectWithoutAidRoomChecksInput
    upsert?: AidRoomUpsertWithoutAidRoomChecksInput
    connect?: AidRoomWhereUniqueInput
    update?: XOR<XOR<AidRoomUpdateToOneWithWhereWithoutAidRoomChecksInput, AidRoomUpdateWithoutAidRoomChecksInput>, AidRoomUncheckedUpdateWithoutAidRoomChecksInput>
  }

  export type EmployeeCreateNestedOneWithoutEquipmentChecksInput = {
    create?: XOR<EmployeeCreateWithoutEquipmentChecksInput, EmployeeUncheckedCreateWithoutEquipmentChecksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEquipmentChecksInput
    connect?: EmployeeWhereUniqueInput
  }

  export type MountainCreateNestedOneWithoutEquipmentChecksInput = {
    create?: XOR<MountainCreateWithoutEquipmentChecksInput, MountainUncheckedCreateWithoutEquipmentChecksInput>
    connectOrCreate?: MountainCreateOrConnectWithoutEquipmentChecksInput
    connect?: MountainWhereUniqueInput
  }

  export type EquipmentCreateNestedOneWithoutEquipmentChecksInput = {
    create?: XOR<EquipmentCreateWithoutEquipmentChecksInput, EquipmentUncheckedCreateWithoutEquipmentChecksInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutEquipmentChecksInput
    connect?: EquipmentWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutEquipmentChecksNestedInput = {
    create?: XOR<EmployeeCreateWithoutEquipmentChecksInput, EmployeeUncheckedCreateWithoutEquipmentChecksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEquipmentChecksInput
    upsert?: EmployeeUpsertWithoutEquipmentChecksInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutEquipmentChecksInput, EmployeeUpdateWithoutEquipmentChecksInput>, EmployeeUncheckedUpdateWithoutEquipmentChecksInput>
  }

  export type MountainUpdateOneRequiredWithoutEquipmentChecksNestedInput = {
    create?: XOR<MountainCreateWithoutEquipmentChecksInput, MountainUncheckedCreateWithoutEquipmentChecksInput>
    connectOrCreate?: MountainCreateOrConnectWithoutEquipmentChecksInput
    upsert?: MountainUpsertWithoutEquipmentChecksInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutEquipmentChecksInput, MountainUpdateWithoutEquipmentChecksInput>, MountainUncheckedUpdateWithoutEquipmentChecksInput>
  }

  export type EquipmentUpdateOneRequiredWithoutEquipmentChecksNestedInput = {
    create?: XOR<EquipmentCreateWithoutEquipmentChecksInput, EquipmentUncheckedCreateWithoutEquipmentChecksInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutEquipmentChecksInput
    upsert?: EquipmentUpsertWithoutEquipmentChecksInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutEquipmentChecksInput, EquipmentUpdateWithoutEquipmentChecksInput>, EquipmentUncheckedUpdateWithoutEquipmentChecksInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumAREA_TYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.AREA_TYPE | EnumAREA_TYPEFieldRefInput<$PrismaModel>
    in?: $Enums.AREA_TYPE[] | ListEnumAREA_TYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.AREA_TYPE[] | ListEnumAREA_TYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumAREA_TYPEFilter<$PrismaModel> | $Enums.AREA_TYPE
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumAREA_TYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AREA_TYPE | EnumAREA_TYPEFieldRefInput<$PrismaModel>
    in?: $Enums.AREA_TYPE[] | ListEnumAREA_TYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.AREA_TYPE[] | ListEnumAREA_TYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumAREA_TYPEWithAggregatesFilter<$PrismaModel> | $Enums.AREA_TYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAREA_TYPEFilter<$PrismaModel>
    _max?: NestedEnumAREA_TYPEFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumLOCATION_TYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.LOCATION_TYPE | EnumLOCATION_TYPEFieldRefInput<$PrismaModel>
    in?: $Enums.LOCATION_TYPE[] | ListEnumLOCATION_TYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.LOCATION_TYPE[] | ListEnumLOCATION_TYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumLOCATION_TYPEFilter<$PrismaModel> | $Enums.LOCATION_TYPE
  }

  export type NestedEnumLOCATION_TYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LOCATION_TYPE | EnumLOCATION_TYPEFieldRefInput<$PrismaModel>
    in?: $Enums.LOCATION_TYPE[] | ListEnumLOCATION_TYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.LOCATION_TYPE[] | ListEnumLOCATION_TYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumLOCATION_TYPEWithAggregatesFilter<$PrismaModel> | $Enums.LOCATION_TYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLOCATION_TYPEFilter<$PrismaModel>
    _max?: NestedEnumLOCATION_TYPEFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSTATUSFilter<$PrismaModel = never> = {
    equals?: $Enums.STATUS | EnumSTATUSFieldRefInput<$PrismaModel>
    in?: $Enums.STATUS[] | ListEnumSTATUSFieldRefInput<$PrismaModel>
    notIn?: $Enums.STATUS[] | ListEnumSTATUSFieldRefInput<$PrismaModel>
    not?: NestedEnumSTATUSFilter<$PrismaModel> | $Enums.STATUS
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumSTATUSWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.STATUS | EnumSTATUSFieldRefInput<$PrismaModel>
    in?: $Enums.STATUS[] | ListEnumSTATUSFieldRefInput<$PrismaModel>
    notIn?: $Enums.STATUS[] | ListEnumSTATUSFieldRefInput<$PrismaModel>
    not?: NestedEnumSTATUSWithAggregatesFilter<$PrismaModel> | $Enums.STATUS
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSTATUSFilter<$PrismaModel>
    _max?: NestedEnumSTATUSFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumDEPARTMENTFilter<$PrismaModel = never> = {
    equals?: $Enums.DEPARTMENT | EnumDEPARTMENTFieldRefInput<$PrismaModel>
    in?: $Enums.DEPARTMENT[] | ListEnumDEPARTMENTFieldRefInput<$PrismaModel>
    notIn?: $Enums.DEPARTMENT[] | ListEnumDEPARTMENTFieldRefInput<$PrismaModel>
    not?: NestedEnumDEPARTMENTFilter<$PrismaModel> | $Enums.DEPARTMENT
  }

  export type NestedEnumDEPARTMENTWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DEPARTMENT | EnumDEPARTMENTFieldRefInput<$PrismaModel>
    in?: $Enums.DEPARTMENT[] | ListEnumDEPARTMENTFieldRefInput<$PrismaModel>
    notIn?: $Enums.DEPARTMENT[] | ListEnumDEPARTMENTFieldRefInput<$PrismaModel>
    not?: NestedEnumDEPARTMENTWithAggregatesFilter<$PrismaModel> | $Enums.DEPARTMENT
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDEPARTMENTFilter<$PrismaModel>
    _max?: NestedEnumDEPARTMENTFilter<$PrismaModel>
  }

  export type NestedEnumLIFT_TYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.LIFT_TYPE | EnumLIFT_TYPEFieldRefInput<$PrismaModel>
    in?: $Enums.LIFT_TYPE[] | ListEnumLIFT_TYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.LIFT_TYPE[] | ListEnumLIFT_TYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumLIFT_TYPEFilter<$PrismaModel> | $Enums.LIFT_TYPE
  }

  export type NestedEnumLIFT_TYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LIFT_TYPE | EnumLIFT_TYPEFieldRefInput<$PrismaModel>
    in?: $Enums.LIFT_TYPE[] | ListEnumLIFT_TYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.LIFT_TYPE[] | ListEnumLIFT_TYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumLIFT_TYPEWithAggregatesFilter<$PrismaModel> | $Enums.LIFT_TYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLIFT_TYPEFilter<$PrismaModel>
    _max?: NestedEnumLIFT_TYPEFilter<$PrismaModel>
  }

  export type NestedEnumTRAIL_DIFFICULTYFilter<$PrismaModel = never> = {
    equals?: $Enums.TRAIL_DIFFICULTY | EnumTRAIL_DIFFICULTYFieldRefInput<$PrismaModel>
    in?: $Enums.TRAIL_DIFFICULTY[] | ListEnumTRAIL_DIFFICULTYFieldRefInput<$PrismaModel>
    notIn?: $Enums.TRAIL_DIFFICULTY[] | ListEnumTRAIL_DIFFICULTYFieldRefInput<$PrismaModel>
    not?: NestedEnumTRAIL_DIFFICULTYFilter<$PrismaModel> | $Enums.TRAIL_DIFFICULTY
  }

  export type NestedEnumTRAIL_CONDITIONFilter<$PrismaModel = never> = {
    equals?: $Enums.TRAIL_CONDITION | EnumTRAIL_CONDITIONFieldRefInput<$PrismaModel>
    in?: $Enums.TRAIL_CONDITION[] | ListEnumTRAIL_CONDITIONFieldRefInput<$PrismaModel>
    notIn?: $Enums.TRAIL_CONDITION[] | ListEnumTRAIL_CONDITIONFieldRefInput<$PrismaModel>
    not?: NestedEnumTRAIL_CONDITIONFilter<$PrismaModel> | $Enums.TRAIL_CONDITION
  }

  export type NestedEnumTRAIL_DIFFICULTYWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TRAIL_DIFFICULTY | EnumTRAIL_DIFFICULTYFieldRefInput<$PrismaModel>
    in?: $Enums.TRAIL_DIFFICULTY[] | ListEnumTRAIL_DIFFICULTYFieldRefInput<$PrismaModel>
    notIn?: $Enums.TRAIL_DIFFICULTY[] | ListEnumTRAIL_DIFFICULTYFieldRefInput<$PrismaModel>
    not?: NestedEnumTRAIL_DIFFICULTYWithAggregatesFilter<$PrismaModel> | $Enums.TRAIL_DIFFICULTY
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTRAIL_DIFFICULTYFilter<$PrismaModel>
    _max?: NestedEnumTRAIL_DIFFICULTYFilter<$PrismaModel>
  }

  export type NestedEnumTRAIL_CONDITIONWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TRAIL_CONDITION | EnumTRAIL_CONDITIONFieldRefInput<$PrismaModel>
    in?: $Enums.TRAIL_CONDITION[] | ListEnumTRAIL_CONDITIONFieldRefInput<$PrismaModel>
    notIn?: $Enums.TRAIL_CONDITION[] | ListEnumTRAIL_CONDITIONFieldRefInput<$PrismaModel>
    not?: NestedEnumTRAIL_CONDITIONWithAggregatesFilter<$PrismaModel> | $Enums.TRAIL_CONDITION
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTRAIL_CONDITIONFilter<$PrismaModel>
    _max?: NestedEnumTRAIL_CONDITIONFilter<$PrismaModel>
  }

  export type NestedEnumEQUIPMENT_STATUSFilter<$PrismaModel = never> = {
    equals?: $Enums.EQUIPMENT_STATUS | EnumEQUIPMENT_STATUSFieldRefInput<$PrismaModel>
    in?: $Enums.EQUIPMENT_STATUS[] | ListEnumEQUIPMENT_STATUSFieldRefInput<$PrismaModel>
    notIn?: $Enums.EQUIPMENT_STATUS[] | ListEnumEQUIPMENT_STATUSFieldRefInput<$PrismaModel>
    not?: NestedEnumEQUIPMENT_STATUSFilter<$PrismaModel> | $Enums.EQUIPMENT_STATUS
  }

  export type NestedEnumEQUIPMENT_STATUSWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EQUIPMENT_STATUS | EnumEQUIPMENT_STATUSFieldRefInput<$PrismaModel>
    in?: $Enums.EQUIPMENT_STATUS[] | ListEnumEQUIPMENT_STATUSFieldRefInput<$PrismaModel>
    notIn?: $Enums.EQUIPMENT_STATUS[] | ListEnumEQUIPMENT_STATUSFieldRefInput<$PrismaModel>
    not?: NestedEnumEQUIPMENT_STATUSWithAggregatesFilter<$PrismaModel> | $Enums.EQUIPMENT_STATUS
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEQUIPMENT_STATUSFilter<$PrismaModel>
    _max?: NestedEnumEQUIPMENT_STATUSFilter<$PrismaModel>
  }

  export type NestedEnumINCIDENT_STATUSFilter<$PrismaModel = never> = {
    equals?: $Enums.INCIDENT_STATUS | EnumINCIDENT_STATUSFieldRefInput<$PrismaModel>
    in?: $Enums.INCIDENT_STATUS[] | ListEnumINCIDENT_STATUSFieldRefInput<$PrismaModel>
    notIn?: $Enums.INCIDENT_STATUS[] | ListEnumINCIDENT_STATUSFieldRefInput<$PrismaModel>
    not?: NestedEnumINCIDENT_STATUSFilter<$PrismaModel> | $Enums.INCIDENT_STATUS
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumINCIDENT_STATUSWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.INCIDENT_STATUS | EnumINCIDENT_STATUSFieldRefInput<$PrismaModel>
    in?: $Enums.INCIDENT_STATUS[] | ListEnumINCIDENT_STATUSFieldRefInput<$PrismaModel>
    notIn?: $Enums.INCIDENT_STATUS[] | ListEnumINCIDENT_STATUSFieldRefInput<$PrismaModel>
    not?: NestedEnumINCIDENT_STATUSWithAggregatesFilter<$PrismaModel> | $Enums.INCIDENT_STATUS
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumINCIDENT_STATUSFilter<$PrismaModel>
    _max?: NestedEnumINCIDENT_STATUSFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type MountainCreateWithoutAreasInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherCreateNestedManyWithoutMountainInput
    locations?: LocationCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    lifts?: LiftCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutAreasInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
    locations?: LocationUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutAreasInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutAreasInput, MountainUncheckedCreateWithoutAreasInput>
  }

  export type LocationCreateWithoutAreaInput = {
    id?: string
    name: string
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    mountain: MountainCreateNestedOneWithoutLocationsInput
    lift?: LiftCreateNestedOneWithoutLocationInput
    trail?: TrailCreateNestedOneWithoutLocationInput
    hut?: HutCreateNestedOneWithoutLocationInput
    lodge?: LodgeCreateNestedOneWithoutLocationInput
    aidRoom?: AidRoomCreateNestedOneWithoutLocationInput
    hours?: HoursCreateNestedManyWithoutLocationInput
    equipment?: EquipmentCreateNestedManyWithoutLocationInput
    incidents?: IncidentCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutAreaInput = {
    id?: string
    mountainId: string
    name: string
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    lift?: LiftUncheckedCreateNestedOneWithoutLocationInput
    trail?: TrailUncheckedCreateNestedOneWithoutLocationInput
    hut?: HutUncheckedCreateNestedOneWithoutLocationInput
    lodge?: LodgeUncheckedCreateNestedOneWithoutLocationInput
    aidRoom?: AidRoomUncheckedCreateNestedOneWithoutLocationInput
    hours?: HoursUncheckedCreateNestedManyWithoutLocationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutLocationInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutAreaInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutAreaInput, LocationUncheckedCreateWithoutAreaInput>
  }

  export type LocationCreateManyAreaInputEnvelope = {
    data: LocationCreateManyAreaInput | LocationCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type MountainUpsertWithoutAreasInput = {
    update: XOR<MountainUpdateWithoutAreasInput, MountainUncheckedUpdateWithoutAreasInput>
    create: XOR<MountainCreateWithoutAreasInput, MountainUncheckedCreateWithoutAreasInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutAreasInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutAreasInput, MountainUncheckedUpdateWithoutAreasInput>
  }

  export type MountainUpdateWithoutAreasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUpdateManyWithoutMountainNestedInput
    locations?: LocationUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutAreasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type LocationUpsertWithWhereUniqueWithoutAreaInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutAreaInput, LocationUncheckedUpdateWithoutAreaInput>
    create: XOR<LocationCreateWithoutAreaInput, LocationUncheckedCreateWithoutAreaInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutAreaInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutAreaInput, LocationUncheckedUpdateWithoutAreaInput>
  }

  export type LocationUpdateManyWithWhereWithoutAreaInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutAreaInput>
  }

  export type LocationScalarWhereInput = {
    AND?: LocationScalarWhereInput | LocationScalarWhereInput[]
    OR?: LocationScalarWhereInput[]
    NOT?: LocationScalarWhereInput | LocationScalarWhereInput[]
    id?: StringFilter<"Location"> | string
    mountainId?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    areaId?: StringNullableFilter<"Location"> | string | null
    entityId?: StringFilter<"Location"> | string
    entityType?: EnumLOCATION_TYPEFilter<"Location"> | $Enums.LOCATION_TYPE
  }

  export type AreaCreateWithoutLocationsInput = {
    id?: string
    name: string
    type: $Enums.AREA_TYPE
    description?: string | null
    mountain: MountainCreateNestedOneWithoutAreasInput
  }

  export type AreaUncheckedCreateWithoutLocationsInput = {
    id?: string
    mountainId: string
    name: string
    type: $Enums.AREA_TYPE
    description?: string | null
  }

  export type AreaCreateOrConnectWithoutLocationsInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutLocationsInput, AreaUncheckedCreateWithoutLocationsInput>
  }

  export type MountainCreateWithoutLocationsInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherCreateNestedManyWithoutMountainInput
    areas?: AreaCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    lifts?: LiftCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutLocationsInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
    areas?: AreaUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutLocationsInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutLocationsInput, MountainUncheckedCreateWithoutLocationsInput>
  }

  export type LiftCreateWithoutLocationInput = {
    id?: string
    name: string
    type: $Enums.LIFT_TYPE
    status?: $Enums.STATUS
    capacity: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    mountain: MountainCreateNestedOneWithoutLiftsInput
    liftChecks?: LiftCheckCreateNestedManyWithoutLiftInput
  }

  export type LiftUncheckedCreateWithoutLocationInput = {
    id?: string
    mountainId: string
    name: string
    type: $Enums.LIFT_TYPE
    status?: $Enums.STATUS
    capacity: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutLiftInput
  }

  export type LiftCreateOrConnectWithoutLocationInput = {
    where: LiftWhereUniqueInput
    create: XOR<LiftCreateWithoutLocationInput, LiftUncheckedCreateWithoutLocationInput>
  }

  export type TrailCreateWithoutLocationInput = {
    id?: string
    name: string
    difficulty: $Enums.TRAIL_DIFFICULTY
    status?: $Enums.STATUS
    length: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    condition?: $Enums.TRAIL_CONDITION
    mountain: MountainCreateNestedOneWithoutTrailsInput
    trailChecks?: TrailCheckCreateNestedManyWithoutTrailInput
  }

  export type TrailUncheckedCreateWithoutLocationInput = {
    id?: string
    mountainId: string
    name: string
    difficulty: $Enums.TRAIL_DIFFICULTY
    status?: $Enums.STATUS
    length: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    condition?: $Enums.TRAIL_CONDITION
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutTrailInput
  }

  export type TrailCreateOrConnectWithoutLocationInput = {
    where: TrailWhereUniqueInput
    create: XOR<TrailCreateWithoutLocationInput, TrailUncheckedCreateWithoutLocationInput>
  }

  export type HutCreateWithoutLocationInput = {
    id?: string
    name: string
    status?: $Enums.STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    mountain: MountainCreateNestedOneWithoutHutsInput
    hutChecks?: HutCheckCreateNestedManyWithoutHutInput
  }

  export type HutUncheckedCreateWithoutLocationInput = {
    id?: string
    mountainId: string
    name: string
    status?: $Enums.STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutHutInput
  }

  export type HutCreateOrConnectWithoutLocationInput = {
    where: HutWhereUniqueInput
    create: XOR<HutCreateWithoutLocationInput, HutUncheckedCreateWithoutLocationInput>
  }

  export type LodgeCreateWithoutLocationInput = {
    id?: string
    name: string
    capacity: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.STATUS
    mountain: MountainCreateNestedOneWithoutLodgesInput
  }

  export type LodgeUncheckedCreateWithoutLocationInput = {
    id?: string
    mountainId: string
    name: string
    capacity: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.STATUS
  }

  export type LodgeCreateOrConnectWithoutLocationInput = {
    where: LodgeWhereUniqueInput
    create: XOR<LodgeCreateWithoutLocationInput, LodgeUncheckedCreateWithoutLocationInput>
  }

  export type AidRoomCreateWithoutLocationInput = {
    id?: string
    name: string
    status?: $Enums.STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    mountain: MountainCreateNestedOneWithoutAidRoomsInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutAidRoomInput
  }

  export type AidRoomUncheckedCreateWithoutLocationInput = {
    id?: string
    mountainId: string
    name: string
    status?: $Enums.STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutAidRoomInput
  }

  export type AidRoomCreateOrConnectWithoutLocationInput = {
    where: AidRoomWhereUniqueInput
    create: XOR<AidRoomCreateWithoutLocationInput, AidRoomUncheckedCreateWithoutLocationInput>
  }

  export type HoursCreateWithoutLocationInput = {
    id?: string
    dayOfWeek?: number | null
    date?: Date | string | null
    openTime?: Date | string | null
    closeTime?: Date | string | null
    status?: $Enums.STATUS
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HoursUncheckedCreateWithoutLocationInput = {
    id?: string
    dayOfWeek?: number | null
    date?: Date | string | null
    openTime?: Date | string | null
    closeTime?: Date | string | null
    status?: $Enums.STATUS
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HoursCreateOrConnectWithoutLocationInput = {
    where: HoursWhereUniqueInput
    create: XOR<HoursCreateWithoutLocationInput, HoursUncheckedCreateWithoutLocationInput>
  }

  export type HoursCreateManyLocationInputEnvelope = {
    data: HoursCreateManyLocationInput | HoursCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCreateWithoutLocationInput = {
    id?: string
    name: string
    type: string
    status?: $Enums.EQUIPMENT_STATUS
    number?: number | null
    description?: string | null
    picture?: string | null
    cost?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    dateAdded?: Date | string
    mountain?: MountainCreateNestedOneWithoutEquipmentInput
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogCreateNestedManyWithoutEquipmentInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEquipmentInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutLocationInput = {
    id?: string
    name: string
    type: string
    status?: $Enums.EQUIPMENT_STATUS
    number?: number | null
    description?: string | null
    picture?: string | null
    cost?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    mountainId?: string | null
    dateAdded?: Date | string
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutEquipmentInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEquipmentInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutLocationInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutLocationInput, EquipmentUncheckedCreateWithoutLocationInput>
  }

  export type EquipmentCreateManyLocationInputEnvelope = {
    data: EquipmentCreateManyLocationInput | EquipmentCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type IncidentCreateWithoutLocationInput = {
    id?: string
    description: string
    status?: $Enums.INCIDENT_STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    startTime?: Date | string
    endTime?: Date | string | null
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    emptyRun?: boolean
    emptyRunAt?: Date | string | null
    mountain: MountainCreateNestedOneWithoutIncidentsInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutIncidentInput
    employees?: EmployeeCreateNestedManyWithoutIncidentsInput
  }

  export type IncidentUncheckedCreateWithoutLocationInput = {
    id?: string
    description: string
    status?: $Enums.INCIDENT_STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    mountainId: string
    startTime?: Date | string
    endTime?: Date | string | null
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    emptyRun?: boolean
    emptyRunAt?: Date | string | null
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutIncidentInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutIncidentsInput
  }

  export type IncidentCreateOrConnectWithoutLocationInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutLocationInput, IncidentUncheckedCreateWithoutLocationInput>
  }

  export type IncidentCreateManyLocationInputEnvelope = {
    data: IncidentCreateManyLocationInput | IncidentCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type AreaUpsertWithoutLocationsInput = {
    update: XOR<AreaUpdateWithoutLocationsInput, AreaUncheckedUpdateWithoutLocationsInput>
    create: XOR<AreaCreateWithoutLocationsInput, AreaUncheckedCreateWithoutLocationsInput>
    where?: AreaWhereInput
  }

  export type AreaUpdateToOneWithWhereWithoutLocationsInput = {
    where?: AreaWhereInput
    data: XOR<AreaUpdateWithoutLocationsInput, AreaUncheckedUpdateWithoutLocationsInput>
  }

  export type AreaUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAREA_TYPEFieldUpdateOperationsInput | $Enums.AREA_TYPE
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mountain?: MountainUpdateOneRequiredWithoutAreasNestedInput
  }

  export type AreaUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAREA_TYPEFieldUpdateOperationsInput | $Enums.AREA_TYPE
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MountainUpsertWithoutLocationsInput = {
    update: XOR<MountainUpdateWithoutLocationsInput, MountainUncheckedUpdateWithoutLocationsInput>
    create: XOR<MountainCreateWithoutLocationsInput, MountainUncheckedCreateWithoutLocationsInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutLocationsInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutLocationsInput, MountainUncheckedUpdateWithoutLocationsInput>
  }

  export type MountainUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUpdateManyWithoutMountainNestedInput
    areas?: AreaUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
    areas?: AreaUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type LiftUpsertWithoutLocationInput = {
    update: XOR<LiftUpdateWithoutLocationInput, LiftUncheckedUpdateWithoutLocationInput>
    create: XOR<LiftCreateWithoutLocationInput, LiftUncheckedCreateWithoutLocationInput>
    where?: LiftWhereInput
  }

  export type LiftUpdateToOneWithWhereWithoutLocationInput = {
    where?: LiftWhereInput
    data: XOR<LiftUpdateWithoutLocationInput, LiftUncheckedUpdateWithoutLocationInput>
  }

  export type LiftUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLIFT_TYPEFieldUpdateOperationsInput | $Enums.LIFT_TYPE
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    capacity?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountain?: MountainUpdateOneRequiredWithoutLiftsNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutLiftNestedInput
  }

  export type LiftUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLIFT_TYPEFieldUpdateOperationsInput | $Enums.LIFT_TYPE
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    capacity?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutLiftNestedInput
  }

  export type TrailUpsertWithoutLocationInput = {
    update: XOR<TrailUpdateWithoutLocationInput, TrailUncheckedUpdateWithoutLocationInput>
    create: XOR<TrailCreateWithoutLocationInput, TrailUncheckedCreateWithoutLocationInput>
    where?: TrailWhereInput
  }

  export type TrailUpdateToOneWithWhereWithoutLocationInput = {
    where?: TrailWhereInput
    data: XOR<TrailUpdateWithoutLocationInput, TrailUncheckedUpdateWithoutLocationInput>
  }

  export type TrailUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumTRAIL_DIFFICULTYFieldUpdateOperationsInput | $Enums.TRAIL_DIFFICULTY
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    length?: FloatFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition?: EnumTRAIL_CONDITIONFieldUpdateOperationsInput | $Enums.TRAIL_CONDITION
    mountain?: MountainUpdateOneRequiredWithoutTrailsNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutTrailNestedInput
  }

  export type TrailUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumTRAIL_DIFFICULTYFieldUpdateOperationsInput | $Enums.TRAIL_DIFFICULTY
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    length?: FloatFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition?: EnumTRAIL_CONDITIONFieldUpdateOperationsInput | $Enums.TRAIL_CONDITION
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutTrailNestedInput
  }

  export type HutUpsertWithoutLocationInput = {
    update: XOR<HutUpdateWithoutLocationInput, HutUncheckedUpdateWithoutLocationInput>
    create: XOR<HutCreateWithoutLocationInput, HutUncheckedCreateWithoutLocationInput>
    where?: HutWhereInput
  }

  export type HutUpdateToOneWithWhereWithoutLocationInput = {
    where?: HutWhereInput
    data: XOR<HutUpdateWithoutLocationInput, HutUncheckedUpdateWithoutLocationInput>
  }

  export type HutUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountain?: MountainUpdateOneRequiredWithoutHutsNestedInput
    hutChecks?: HutCheckUpdateManyWithoutHutNestedInput
  }

  export type HutUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hutChecks?: HutCheckUncheckedUpdateManyWithoutHutNestedInput
  }

  export type LodgeUpsertWithoutLocationInput = {
    update: XOR<LodgeUpdateWithoutLocationInput, LodgeUncheckedUpdateWithoutLocationInput>
    create: XOR<LodgeCreateWithoutLocationInput, LodgeUncheckedCreateWithoutLocationInput>
    where?: LodgeWhereInput
  }

  export type LodgeUpdateToOneWithWhereWithoutLocationInput = {
    where?: LodgeWhereInput
    data: XOR<LodgeUpdateWithoutLocationInput, LodgeUncheckedUpdateWithoutLocationInput>
  }

  export type LodgeUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    mountain?: MountainUpdateOneRequiredWithoutLodgesNestedInput
  }

  export type LodgeUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
  }

  export type AidRoomUpsertWithoutLocationInput = {
    update: XOR<AidRoomUpdateWithoutLocationInput, AidRoomUncheckedUpdateWithoutLocationInput>
    create: XOR<AidRoomCreateWithoutLocationInput, AidRoomUncheckedCreateWithoutLocationInput>
    where?: AidRoomWhereInput
  }

  export type AidRoomUpdateToOneWithWhereWithoutLocationInput = {
    where?: AidRoomWhereInput
    data: XOR<AidRoomUpdateWithoutLocationInput, AidRoomUncheckedUpdateWithoutLocationInput>
  }

  export type AidRoomUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountain?: MountainUpdateOneRequiredWithoutAidRoomsNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutAidRoomNestedInput
  }

  export type AidRoomUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutAidRoomNestedInput
  }

  export type HoursUpsertWithWhereUniqueWithoutLocationInput = {
    where: HoursWhereUniqueInput
    update: XOR<HoursUpdateWithoutLocationInput, HoursUncheckedUpdateWithoutLocationInput>
    create: XOR<HoursCreateWithoutLocationInput, HoursUncheckedCreateWithoutLocationInput>
  }

  export type HoursUpdateWithWhereUniqueWithoutLocationInput = {
    where: HoursWhereUniqueInput
    data: XOR<HoursUpdateWithoutLocationInput, HoursUncheckedUpdateWithoutLocationInput>
  }

  export type HoursUpdateManyWithWhereWithoutLocationInput = {
    where: HoursScalarWhereInput
    data: XOR<HoursUpdateManyMutationInput, HoursUncheckedUpdateManyWithoutLocationInput>
  }

  export type HoursScalarWhereInput = {
    AND?: HoursScalarWhereInput | HoursScalarWhereInput[]
    OR?: HoursScalarWhereInput[]
    NOT?: HoursScalarWhereInput | HoursScalarWhereInput[]
    id?: StringFilter<"Hours"> | string
    locationId?: StringFilter<"Hours"> | string
    dayOfWeek?: IntNullableFilter<"Hours"> | number | null
    date?: DateTimeNullableFilter<"Hours"> | Date | string | null
    openTime?: DateTimeNullableFilter<"Hours"> | Date | string | null
    closeTime?: DateTimeNullableFilter<"Hours"> | Date | string | null
    status?: EnumSTATUSFilter<"Hours"> | $Enums.STATUS
    createdAt?: DateTimeFilter<"Hours"> | Date | string
    updatedAt?: DateTimeFilter<"Hours"> | Date | string
  }

  export type EquipmentUpsertWithWhereUniqueWithoutLocationInput = {
    where: EquipmentWhereUniqueInput
    update: XOR<EquipmentUpdateWithoutLocationInput, EquipmentUncheckedUpdateWithoutLocationInput>
    create: XOR<EquipmentCreateWithoutLocationInput, EquipmentUncheckedCreateWithoutLocationInput>
  }

  export type EquipmentUpdateWithWhereUniqueWithoutLocationInput = {
    where: EquipmentWhereUniqueInput
    data: XOR<EquipmentUpdateWithoutLocationInput, EquipmentUncheckedUpdateWithoutLocationInput>
  }

  export type EquipmentUpdateManyWithWhereWithoutLocationInput = {
    where: EquipmentScalarWhereInput
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyWithoutLocationInput>
  }

  export type EquipmentScalarWhereInput = {
    AND?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
    OR?: EquipmentScalarWhereInput[]
    NOT?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
    id?: StringFilter<"Equipment"> | string
    name?: StringFilter<"Equipment"> | string
    type?: StringFilter<"Equipment"> | string
    status?: EnumEQUIPMENT_STATUSFilter<"Equipment"> | $Enums.EQUIPMENT_STATUS
    number?: IntNullableFilter<"Equipment"> | number | null
    description?: StringNullableFilter<"Equipment"> | string | null
    picture?: StringNullableFilter<"Equipment"> | string | null
    cost?: FloatNullableFilter<"Equipment"> | number | null
    latitude?: DecimalNullableFilter<"Equipment"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Equipment"> | Decimal | DecimalJsLike | number | string | null
    mountainId?: StringNullableFilter<"Equipment"> | string | null
    locationId?: StringNullableFilter<"Equipment"> | string | null
    dateAdded?: DateTimeFilter<"Equipment"> | Date | string
  }

  export type IncidentUpsertWithWhereUniqueWithoutLocationInput = {
    where: IncidentWhereUniqueInput
    update: XOR<IncidentUpdateWithoutLocationInput, IncidentUncheckedUpdateWithoutLocationInput>
    create: XOR<IncidentCreateWithoutLocationInput, IncidentUncheckedCreateWithoutLocationInput>
  }

  export type IncidentUpdateWithWhereUniqueWithoutLocationInput = {
    where: IncidentWhereUniqueInput
    data: XOR<IncidentUpdateWithoutLocationInput, IncidentUncheckedUpdateWithoutLocationInput>
  }

  export type IncidentUpdateManyWithWhereWithoutLocationInput = {
    where: IncidentScalarWhereInput
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyWithoutLocationInput>
  }

  export type IncidentScalarWhereInput = {
    AND?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
    OR?: IncidentScalarWhereInput[]
    NOT?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
    id?: StringFilter<"Incident"> | string
    description?: StringFilter<"Incident"> | string
    status?: EnumINCIDENT_STATUSFilter<"Incident"> | $Enums.INCIDENT_STATUS
    latitude?: DecimalNullableFilter<"Incident"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Incident"> | Decimal | DecimalJsLike | number | string | null
    mountainId?: StringFilter<"Incident"> | string
    startTime?: DateTimeFilter<"Incident"> | Date | string
    endTime?: DateTimeNullableFilter<"Incident"> | Date | string | null
    onSceneTime?: DateTimeNullableFilter<"Incident"> | Date | string | null
    stableTime?: DateTimeNullableFilter<"Incident"> | Date | string | null
    transportTime?: DateTimeNullableFilter<"Incident"> | Date | string | null
    emptyRun?: BoolFilter<"Incident"> | boolean
    emptyRunAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    locationId?: StringFilter<"Incident"> | string
  }

  export type LocationCreateWithoutHoursInput = {
    id?: string
    name: string
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    area?: AreaCreateNestedOneWithoutLocationsInput
    mountain: MountainCreateNestedOneWithoutLocationsInput
    lift?: LiftCreateNestedOneWithoutLocationInput
    trail?: TrailCreateNestedOneWithoutLocationInput
    hut?: HutCreateNestedOneWithoutLocationInput
    lodge?: LodgeCreateNestedOneWithoutLocationInput
    aidRoom?: AidRoomCreateNestedOneWithoutLocationInput
    equipment?: EquipmentCreateNestedManyWithoutLocationInput
    incidents?: IncidentCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutHoursInput = {
    id?: string
    mountainId: string
    name: string
    areaId?: string | null
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    lift?: LiftUncheckedCreateNestedOneWithoutLocationInput
    trail?: TrailUncheckedCreateNestedOneWithoutLocationInput
    hut?: HutUncheckedCreateNestedOneWithoutLocationInput
    lodge?: LodgeUncheckedCreateNestedOneWithoutLocationInput
    aidRoom?: AidRoomUncheckedCreateNestedOneWithoutLocationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutLocationInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutHoursInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutHoursInput, LocationUncheckedCreateWithoutHoursInput>
  }

  export type LocationUpsertWithoutHoursInput = {
    update: XOR<LocationUpdateWithoutHoursInput, LocationUncheckedUpdateWithoutHoursInput>
    create: XOR<LocationCreateWithoutHoursInput, LocationUncheckedCreateWithoutHoursInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutHoursInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutHoursInput, LocationUncheckedUpdateWithoutHoursInput>
  }

  export type LocationUpdateWithoutHoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
    area?: AreaUpdateOneWithoutLocationsNestedInput
    mountain?: MountainUpdateOneRequiredWithoutLocationsNestedInput
    lift?: LiftUpdateOneWithoutLocationNestedInput
    trail?: TrailUpdateOneWithoutLocationNestedInput
    hut?: HutUpdateOneWithoutLocationNestedInput
    lodge?: LodgeUpdateOneWithoutLocationNestedInput
    aidRoom?: AidRoomUpdateOneWithoutLocationNestedInput
    equipment?: EquipmentUpdateManyWithoutLocationNestedInput
    incidents?: IncidentUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutHoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
    lift?: LiftUncheckedUpdateOneWithoutLocationNestedInput
    trail?: TrailUncheckedUpdateOneWithoutLocationNestedInput
    hut?: HutUncheckedUpdateOneWithoutLocationNestedInput
    lodge?: LodgeUncheckedUpdateOneWithoutLocationNestedInput
    aidRoom?: AidRoomUncheckedUpdateOneWithoutLocationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutLocationNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type WeatherCreateWithoutMountainInput = {
    id?: string
    date?: Date | string
    temperature: number
    windSpeed: number
    windDirection?: string | null
    visibility?: number | null
    conditions: string
    snowfallRecent?: number | null
    snowfall24h?: number | null
    snowfall7d?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeatherUncheckedCreateWithoutMountainInput = {
    id?: string
    date?: Date | string
    temperature: number
    windSpeed: number
    windDirection?: string | null
    visibility?: number | null
    conditions: string
    snowfallRecent?: number | null
    snowfall24h?: number | null
    snowfall7d?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeatherCreateOrConnectWithoutMountainInput = {
    where: WeatherWhereUniqueInput
    create: XOR<WeatherCreateWithoutMountainInput, WeatherUncheckedCreateWithoutMountainInput>
  }

  export type WeatherCreateManyMountainInputEnvelope = {
    data: WeatherCreateManyMountainInput | WeatherCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type LocationCreateWithoutMountainInput = {
    id?: string
    name: string
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    area?: AreaCreateNestedOneWithoutLocationsInput
    lift?: LiftCreateNestedOneWithoutLocationInput
    trail?: TrailCreateNestedOneWithoutLocationInput
    hut?: HutCreateNestedOneWithoutLocationInput
    lodge?: LodgeCreateNestedOneWithoutLocationInput
    aidRoom?: AidRoomCreateNestedOneWithoutLocationInput
    hours?: HoursCreateNestedManyWithoutLocationInput
    equipment?: EquipmentCreateNestedManyWithoutLocationInput
    incidents?: IncidentCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutMountainInput = {
    id?: string
    name: string
    areaId?: string | null
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    lift?: LiftUncheckedCreateNestedOneWithoutLocationInput
    trail?: TrailUncheckedCreateNestedOneWithoutLocationInput
    hut?: HutUncheckedCreateNestedOneWithoutLocationInput
    lodge?: LodgeUncheckedCreateNestedOneWithoutLocationInput
    aidRoom?: AidRoomUncheckedCreateNestedOneWithoutLocationInput
    hours?: HoursUncheckedCreateNestedManyWithoutLocationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutLocationInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutMountainInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutMountainInput, LocationUncheckedCreateWithoutMountainInput>
  }

  export type LocationCreateManyMountainInputEnvelope = {
    data: LocationCreateManyMountainInput | LocationCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type AreaCreateWithoutMountainInput = {
    id?: string
    name: string
    type: $Enums.AREA_TYPE
    description?: string | null
    locations?: LocationCreateNestedManyWithoutAreaInput
  }

  export type AreaUncheckedCreateWithoutMountainInput = {
    id?: string
    name: string
    type: $Enums.AREA_TYPE
    description?: string | null
    locations?: LocationUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreaCreateOrConnectWithoutMountainInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutMountainInput, AreaUncheckedCreateWithoutMountainInput>
  }

  export type AreaCreateManyMountainInputEnvelope = {
    data: AreaCreateManyMountainInput | AreaCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type AidRoomCreateWithoutMountainInput = {
    id?: string
    name: string
    status?: $Enums.STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutAidRoomInput
    location?: LocationCreateNestedOneWithoutAidRoomInput
  }

  export type AidRoomUncheckedCreateWithoutMountainInput = {
    id?: string
    name: string
    status?: $Enums.STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    locationId?: string | null
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutAidRoomInput
  }

  export type AidRoomCreateOrConnectWithoutMountainInput = {
    where: AidRoomWhereUniqueInput
    create: XOR<AidRoomCreateWithoutMountainInput, AidRoomUncheckedCreateWithoutMountainInput>
  }

  export type AidRoomCreateManyMountainInputEnvelope = {
    data: AidRoomCreateManyMountainInput | AidRoomCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type HutCreateWithoutMountainInput = {
    id?: string
    name: string
    status?: $Enums.STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    hutChecks?: HutCheckCreateNestedManyWithoutHutInput
    location?: LocationCreateNestedOneWithoutHutInput
  }

  export type HutUncheckedCreateWithoutMountainInput = {
    id?: string
    name: string
    status?: $Enums.STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    locationId?: string | null
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutHutInput
  }

  export type HutCreateOrConnectWithoutMountainInput = {
    where: HutWhereUniqueInput
    create: XOR<HutCreateWithoutMountainInput, HutUncheckedCreateWithoutMountainInput>
  }

  export type HutCreateManyMountainInputEnvelope = {
    data: HutCreateManyMountainInput | HutCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type LodgeCreateWithoutMountainInput = {
    id?: string
    name: string
    capacity: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.STATUS
    location?: LocationCreateNestedOneWithoutLodgeInput
  }

  export type LodgeUncheckedCreateWithoutMountainInput = {
    id?: string
    name: string
    capacity: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.STATUS
    locationId?: string | null
  }

  export type LodgeCreateOrConnectWithoutMountainInput = {
    where: LodgeWhereUniqueInput
    create: XOR<LodgeCreateWithoutMountainInput, LodgeUncheckedCreateWithoutMountainInput>
  }

  export type LodgeCreateManyMountainInputEnvelope = {
    data: LodgeCreateManyMountainInput | LodgeCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type LiftCreateWithoutMountainInput = {
    id?: string
    name: string
    type: $Enums.LIFT_TYPE
    status?: $Enums.STATUS
    capacity: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    liftChecks?: LiftCheckCreateNestedManyWithoutLiftInput
    location?: LocationCreateNestedOneWithoutLiftInput
  }

  export type LiftUncheckedCreateWithoutMountainInput = {
    id?: string
    name: string
    type: $Enums.LIFT_TYPE
    status?: $Enums.STATUS
    capacity: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    locationId?: string | null
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutLiftInput
  }

  export type LiftCreateOrConnectWithoutMountainInput = {
    where: LiftWhereUniqueInput
    create: XOR<LiftCreateWithoutMountainInput, LiftUncheckedCreateWithoutMountainInput>
  }

  export type LiftCreateManyMountainInputEnvelope = {
    data: LiftCreateManyMountainInput | LiftCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type TrailCreateWithoutMountainInput = {
    id?: string
    name: string
    difficulty: $Enums.TRAIL_DIFFICULTY
    status?: $Enums.STATUS
    length: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    condition?: $Enums.TRAIL_CONDITION
    trailChecks?: TrailCheckCreateNestedManyWithoutTrailInput
    location?: LocationCreateNestedOneWithoutTrailInput
  }

  export type TrailUncheckedCreateWithoutMountainInput = {
    id?: string
    name: string
    difficulty: $Enums.TRAIL_DIFFICULTY
    status?: $Enums.STATUS
    length: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    condition?: $Enums.TRAIL_CONDITION
    locationId?: string | null
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutTrailInput
  }

  export type TrailCreateOrConnectWithoutMountainInput = {
    where: TrailWhereUniqueInput
    create: XOR<TrailCreateWithoutMountainInput, TrailUncheckedCreateWithoutMountainInput>
  }

  export type TrailCreateManyMountainInputEnvelope = {
    data: TrailCreateManyMountainInput | TrailCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type AidRoomCheckCreateWithoutMountainInput = {
    id?: string
    recordedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutAidRoomChecksInput
    aidRoom: AidRoomCreateNestedOneWithoutAidRoomChecksInput
  }

  export type AidRoomCheckUncheckedCreateWithoutMountainInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    aidRoomId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AidRoomCheckCreateOrConnectWithoutMountainInput = {
    where: AidRoomCheckWhereUniqueInput
    create: XOR<AidRoomCheckCreateWithoutMountainInput, AidRoomCheckUncheckedCreateWithoutMountainInput>
  }

  export type AidRoomCheckCreateManyMountainInputEnvelope = {
    data: AidRoomCheckCreateManyMountainInput | AidRoomCheckCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type HutCheckCreateWithoutMountainInput = {
    id?: string
    recordedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutHutChecksInput
    hut: HutCreateNestedOneWithoutHutChecksInput
  }

  export type HutCheckUncheckedCreateWithoutMountainInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    hutId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HutCheckCreateOrConnectWithoutMountainInput = {
    where: HutCheckWhereUniqueInput
    create: XOR<HutCheckCreateWithoutMountainInput, HutCheckUncheckedCreateWithoutMountainInput>
  }

  export type HutCheckCreateManyMountainInputEnvelope = {
    data: HutCheckCreateManyMountainInput | HutCheckCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type LiftCheckCreateWithoutMountainInput = {
    id?: string
    recordedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutLiftChecksInput
    lift: LiftCreateNestedOneWithoutLiftChecksInput
  }

  export type LiftCheckUncheckedCreateWithoutMountainInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    liftId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiftCheckCreateOrConnectWithoutMountainInput = {
    where: LiftCheckWhereUniqueInput
    create: XOR<LiftCheckCreateWithoutMountainInput, LiftCheckUncheckedCreateWithoutMountainInput>
  }

  export type LiftCheckCreateManyMountainInputEnvelope = {
    data: LiftCheckCreateManyMountainInput | LiftCheckCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type TrailCheckCreateWithoutMountainInput = {
    id?: string
    recordedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutTrailChecksInput
    trail: TrailCreateNestedOneWithoutTrailChecksInput
  }

  export type TrailCheckUncheckedCreateWithoutMountainInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    trailId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrailCheckCreateOrConnectWithoutMountainInput = {
    where: TrailCheckWhereUniqueInput
    create: XOR<TrailCheckCreateWithoutMountainInput, TrailCheckUncheckedCreateWithoutMountainInput>
  }

  export type TrailCheckCreateManyMountainInputEnvelope = {
    data: TrailCheckCreateManyMountainInput | TrailCheckCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCheckCreateWithoutMountainInput = {
    id?: string
    recordedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutEquipmentChecksInput
    equipment: EquipmentCreateNestedOneWithoutEquipmentChecksInput
  }

  export type EquipmentCheckUncheckedCreateWithoutMountainInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    equipmentId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentCheckCreateOrConnectWithoutMountainInput = {
    where: EquipmentCheckWhereUniqueInput
    create: XOR<EquipmentCheckCreateWithoutMountainInput, EquipmentCheckUncheckedCreateWithoutMountainInput>
  }

  export type EquipmentCheckCreateManyMountainInputEnvelope = {
    data: EquipmentCheckCreateManyMountainInput | EquipmentCheckCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type IncidentCreateWithoutMountainInput = {
    id?: string
    description: string
    status?: $Enums.INCIDENT_STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    startTime?: Date | string
    endTime?: Date | string | null
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    emptyRun?: boolean
    emptyRunAt?: Date | string | null
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutIncidentInput
    location: LocationCreateNestedOneWithoutIncidentsInput
    employees?: EmployeeCreateNestedManyWithoutIncidentsInput
  }

  export type IncidentUncheckedCreateWithoutMountainInput = {
    id?: string
    description: string
    status?: $Enums.INCIDENT_STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    startTime?: Date | string
    endTime?: Date | string | null
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    emptyRun?: boolean
    emptyRunAt?: Date | string | null
    locationId: string
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutIncidentInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutIncidentsInput
  }

  export type IncidentCreateOrConnectWithoutMountainInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutMountainInput, IncidentUncheckedCreateWithoutMountainInput>
  }

  export type IncidentCreateManyMountainInputEnvelope = {
    data: IncidentCreateManyMountainInput | IncidentCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCreateWithoutMountainInput = {
    id?: string
    name: string
    type: string
    status?: $Enums.EQUIPMENT_STATUS
    number?: number | null
    description?: string | null
    picture?: string | null
    cost?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    dateAdded?: Date | string
    location?: LocationCreateNestedOneWithoutEquipmentInput
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogCreateNestedManyWithoutEquipmentInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEquipmentInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutMountainInput = {
    id?: string
    name: string
    type: string
    status?: $Enums.EQUIPMENT_STATUS
    number?: number | null
    description?: string | null
    picture?: string | null
    cost?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    locationId?: string | null
    dateAdded?: Date | string
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutEquipmentInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEquipmentInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutMountainInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutMountainInput, EquipmentUncheckedCreateWithoutMountainInput>
  }

  export type EquipmentCreateManyMountainInputEnvelope = {
    data: EquipmentCreateManyMountainInput | EquipmentCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeMountainAssignmentCreateWithoutMountainInput = {
    id?: string
    assignedAt: Date | string
    employee: EmployeeCreateNestedOneWithoutMountainAssignmentsInput
  }

  export type EmployeeMountainAssignmentUncheckedCreateWithoutMountainInput = {
    id?: string
    employeeId: string
    assignedAt: Date | string
  }

  export type EmployeeMountainAssignmentCreateOrConnectWithoutMountainInput = {
    where: EmployeeMountainAssignmentWhereUniqueInput
    create: XOR<EmployeeMountainAssignmentCreateWithoutMountainInput, EmployeeMountainAssignmentUncheckedCreateWithoutMountainInput>
  }

  export type EmployeeMountainAssignmentCreateManyMountainInputEnvelope = {
    data: EmployeeMountainAssignmentCreateManyMountainInput | EmployeeMountainAssignmentCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type DispatcherAssignmentCreateWithoutMountainInput = {
    id?: string
    assignedAt: Date | string
    employee: EmployeeCreateNestedOneWithoutDispatcherAssignmentsInput
  }

  export type DispatcherAssignmentUncheckedCreateWithoutMountainInput = {
    id?: string
    employeeId: string
    assignedAt: Date | string
  }

  export type DispatcherAssignmentCreateOrConnectWithoutMountainInput = {
    where: DispatcherAssignmentWhereUniqueInput
    create: XOR<DispatcherAssignmentCreateWithoutMountainInput, DispatcherAssignmentUncheckedCreateWithoutMountainInput>
  }

  export type DispatcherAssignmentCreateManyMountainInputEnvelope = {
    data: DispatcherAssignmentCreateManyMountainInput | DispatcherAssignmentCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type IncidentEquipmentUsageLogCreateWithoutMountainInput = {
    id?: string
    usedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    incident: IncidentCreateNestedOneWithoutIncidentEquipmentUsageLogInput
    equipment: EquipmentCreateNestedOneWithoutIncidentEquipmentUsageLogsInput
  }

  export type IncidentEquipmentUsageLogUncheckedCreateWithoutMountainInput = {
    id?: string
    usedAt?: Date | string
    notes?: string | null
    equipmentId: string
    incidentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentEquipmentUsageLogCreateOrConnectWithoutMountainInput = {
    where: IncidentEquipmentUsageLogWhereUniqueInput
    create: XOR<IncidentEquipmentUsageLogCreateWithoutMountainInput, IncidentEquipmentUsageLogUncheckedCreateWithoutMountainInput>
  }

  export type IncidentEquipmentUsageLogCreateManyMountainInputEnvelope = {
    data: IncidentEquipmentUsageLogCreateManyMountainInput | IncidentEquipmentUsageLogCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentServiceLogCreateWithoutMountainInput = {
    id?: string
    status?: $Enums.EQUIPMENT_STATUS
    changedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutEquipmentServiceLogsInput
    equipment: EquipmentCreateNestedOneWithoutEquipmentServiceLogsInput
  }

  export type EquipmentServiceLogUncheckedCreateWithoutMountainInput = {
    id?: string
    equipmentId: string
    employeeId?: string | null
    status?: $Enums.EQUIPMENT_STATUS
    changedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentServiceLogCreateOrConnectWithoutMountainInput = {
    where: EquipmentServiceLogWhereUniqueInput
    create: XOR<EquipmentServiceLogCreateWithoutMountainInput, EquipmentServiceLogUncheckedCreateWithoutMountainInput>
  }

  export type EquipmentServiceLogCreateManyMountainInputEnvelope = {
    data: EquipmentServiceLogCreateManyMountainInput | EquipmentServiceLogCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type WeatherUpsertWithWhereUniqueWithoutMountainInput = {
    where: WeatherWhereUniqueInput
    update: XOR<WeatherUpdateWithoutMountainInput, WeatherUncheckedUpdateWithoutMountainInput>
    create: XOR<WeatherCreateWithoutMountainInput, WeatherUncheckedCreateWithoutMountainInput>
  }

  export type WeatherUpdateWithWhereUniqueWithoutMountainInput = {
    where: WeatherWhereUniqueInput
    data: XOR<WeatherUpdateWithoutMountainInput, WeatherUncheckedUpdateWithoutMountainInput>
  }

  export type WeatherUpdateManyWithWhereWithoutMountainInput = {
    where: WeatherScalarWhereInput
    data: XOR<WeatherUpdateManyMutationInput, WeatherUncheckedUpdateManyWithoutMountainInput>
  }

  export type WeatherScalarWhereInput = {
    AND?: WeatherScalarWhereInput | WeatherScalarWhereInput[]
    OR?: WeatherScalarWhereInput[]
    NOT?: WeatherScalarWhereInput | WeatherScalarWhereInput[]
    id?: StringFilter<"Weather"> | string
    mountainId?: StringFilter<"Weather"> | string
    date?: DateTimeFilter<"Weather"> | Date | string
    temperature?: FloatFilter<"Weather"> | number
    windSpeed?: FloatFilter<"Weather"> | number
    windDirection?: StringNullableFilter<"Weather"> | string | null
    visibility?: FloatNullableFilter<"Weather"> | number | null
    conditions?: StringFilter<"Weather"> | string
    snowfallRecent?: FloatNullableFilter<"Weather"> | number | null
    snowfall24h?: FloatNullableFilter<"Weather"> | number | null
    snowfall7d?: FloatNullableFilter<"Weather"> | number | null
    createdAt?: DateTimeFilter<"Weather"> | Date | string
    updatedAt?: DateTimeFilter<"Weather"> | Date | string
  }

  export type LocationUpsertWithWhereUniqueWithoutMountainInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutMountainInput, LocationUncheckedUpdateWithoutMountainInput>
    create: XOR<LocationCreateWithoutMountainInput, LocationUncheckedCreateWithoutMountainInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutMountainInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutMountainInput, LocationUncheckedUpdateWithoutMountainInput>
  }

  export type LocationUpdateManyWithWhereWithoutMountainInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutMountainInput>
  }

  export type AreaUpsertWithWhereUniqueWithoutMountainInput = {
    where: AreaWhereUniqueInput
    update: XOR<AreaUpdateWithoutMountainInput, AreaUncheckedUpdateWithoutMountainInput>
    create: XOR<AreaCreateWithoutMountainInput, AreaUncheckedCreateWithoutMountainInput>
  }

  export type AreaUpdateWithWhereUniqueWithoutMountainInput = {
    where: AreaWhereUniqueInput
    data: XOR<AreaUpdateWithoutMountainInput, AreaUncheckedUpdateWithoutMountainInput>
  }

  export type AreaUpdateManyWithWhereWithoutMountainInput = {
    where: AreaScalarWhereInput
    data: XOR<AreaUpdateManyMutationInput, AreaUncheckedUpdateManyWithoutMountainInput>
  }

  export type AreaScalarWhereInput = {
    AND?: AreaScalarWhereInput | AreaScalarWhereInput[]
    OR?: AreaScalarWhereInput[]
    NOT?: AreaScalarWhereInput | AreaScalarWhereInput[]
    id?: StringFilter<"Area"> | string
    mountainId?: StringFilter<"Area"> | string
    name?: StringFilter<"Area"> | string
    type?: EnumAREA_TYPEFilter<"Area"> | $Enums.AREA_TYPE
    description?: StringNullableFilter<"Area"> | string | null
  }

  export type AidRoomUpsertWithWhereUniqueWithoutMountainInput = {
    where: AidRoomWhereUniqueInput
    update: XOR<AidRoomUpdateWithoutMountainInput, AidRoomUncheckedUpdateWithoutMountainInput>
    create: XOR<AidRoomCreateWithoutMountainInput, AidRoomUncheckedCreateWithoutMountainInput>
  }

  export type AidRoomUpdateWithWhereUniqueWithoutMountainInput = {
    where: AidRoomWhereUniqueInput
    data: XOR<AidRoomUpdateWithoutMountainInput, AidRoomUncheckedUpdateWithoutMountainInput>
  }

  export type AidRoomUpdateManyWithWhereWithoutMountainInput = {
    where: AidRoomScalarWhereInput
    data: XOR<AidRoomUpdateManyMutationInput, AidRoomUncheckedUpdateManyWithoutMountainInput>
  }

  export type AidRoomScalarWhereInput = {
    AND?: AidRoomScalarWhereInput | AidRoomScalarWhereInput[]
    OR?: AidRoomScalarWhereInput[]
    NOT?: AidRoomScalarWhereInput | AidRoomScalarWhereInput[]
    id?: StringFilter<"AidRoom"> | string
    mountainId?: StringFilter<"AidRoom"> | string
    name?: StringFilter<"AidRoom"> | string
    status?: EnumSTATUSFilter<"AidRoom"> | $Enums.STATUS
    latitude?: DecimalNullableFilter<"AidRoom"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"AidRoom"> | Decimal | DecimalJsLike | number | string | null
    locationId?: StringNullableFilter<"AidRoom"> | string | null
  }

  export type HutUpsertWithWhereUniqueWithoutMountainInput = {
    where: HutWhereUniqueInput
    update: XOR<HutUpdateWithoutMountainInput, HutUncheckedUpdateWithoutMountainInput>
    create: XOR<HutCreateWithoutMountainInput, HutUncheckedCreateWithoutMountainInput>
  }

  export type HutUpdateWithWhereUniqueWithoutMountainInput = {
    where: HutWhereUniqueInput
    data: XOR<HutUpdateWithoutMountainInput, HutUncheckedUpdateWithoutMountainInput>
  }

  export type HutUpdateManyWithWhereWithoutMountainInput = {
    where: HutScalarWhereInput
    data: XOR<HutUpdateManyMutationInput, HutUncheckedUpdateManyWithoutMountainInput>
  }

  export type HutScalarWhereInput = {
    AND?: HutScalarWhereInput | HutScalarWhereInput[]
    OR?: HutScalarWhereInput[]
    NOT?: HutScalarWhereInput | HutScalarWhereInput[]
    id?: StringFilter<"Hut"> | string
    mountainId?: StringFilter<"Hut"> | string
    name?: StringFilter<"Hut"> | string
    status?: EnumSTATUSFilter<"Hut"> | $Enums.STATUS
    latitude?: DecimalNullableFilter<"Hut"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Hut"> | Decimal | DecimalJsLike | number | string | null
    locationId?: StringNullableFilter<"Hut"> | string | null
  }

  export type LodgeUpsertWithWhereUniqueWithoutMountainInput = {
    where: LodgeWhereUniqueInput
    update: XOR<LodgeUpdateWithoutMountainInput, LodgeUncheckedUpdateWithoutMountainInput>
    create: XOR<LodgeCreateWithoutMountainInput, LodgeUncheckedCreateWithoutMountainInput>
  }

  export type LodgeUpdateWithWhereUniqueWithoutMountainInput = {
    where: LodgeWhereUniqueInput
    data: XOR<LodgeUpdateWithoutMountainInput, LodgeUncheckedUpdateWithoutMountainInput>
  }

  export type LodgeUpdateManyWithWhereWithoutMountainInput = {
    where: LodgeScalarWhereInput
    data: XOR<LodgeUpdateManyMutationInput, LodgeUncheckedUpdateManyWithoutMountainInput>
  }

  export type LodgeScalarWhereInput = {
    AND?: LodgeScalarWhereInput | LodgeScalarWhereInput[]
    OR?: LodgeScalarWhereInput[]
    NOT?: LodgeScalarWhereInput | LodgeScalarWhereInput[]
    id?: StringFilter<"Lodge"> | string
    mountainId?: StringFilter<"Lodge"> | string
    name?: StringFilter<"Lodge"> | string
    capacity?: IntFilter<"Lodge"> | number
    latitude?: DecimalNullableFilter<"Lodge"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Lodge"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumSTATUSFilter<"Lodge"> | $Enums.STATUS
    locationId?: StringNullableFilter<"Lodge"> | string | null
  }

  export type LiftUpsertWithWhereUniqueWithoutMountainInput = {
    where: LiftWhereUniqueInput
    update: XOR<LiftUpdateWithoutMountainInput, LiftUncheckedUpdateWithoutMountainInput>
    create: XOR<LiftCreateWithoutMountainInput, LiftUncheckedCreateWithoutMountainInput>
  }

  export type LiftUpdateWithWhereUniqueWithoutMountainInput = {
    where: LiftWhereUniqueInput
    data: XOR<LiftUpdateWithoutMountainInput, LiftUncheckedUpdateWithoutMountainInput>
  }

  export type LiftUpdateManyWithWhereWithoutMountainInput = {
    where: LiftScalarWhereInput
    data: XOR<LiftUpdateManyMutationInput, LiftUncheckedUpdateManyWithoutMountainInput>
  }

  export type LiftScalarWhereInput = {
    AND?: LiftScalarWhereInput | LiftScalarWhereInput[]
    OR?: LiftScalarWhereInput[]
    NOT?: LiftScalarWhereInput | LiftScalarWhereInput[]
    id?: StringFilter<"Lift"> | string
    mountainId?: StringFilter<"Lift"> | string
    name?: StringFilter<"Lift"> | string
    type?: EnumLIFT_TYPEFilter<"Lift"> | $Enums.LIFT_TYPE
    status?: EnumSTATUSFilter<"Lift"> | $Enums.STATUS
    capacity?: IntFilter<"Lift"> | number
    latitude?: DecimalNullableFilter<"Lift"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Lift"> | Decimal | DecimalJsLike | number | string | null
    locationId?: StringNullableFilter<"Lift"> | string | null
  }

  export type TrailUpsertWithWhereUniqueWithoutMountainInput = {
    where: TrailWhereUniqueInput
    update: XOR<TrailUpdateWithoutMountainInput, TrailUncheckedUpdateWithoutMountainInput>
    create: XOR<TrailCreateWithoutMountainInput, TrailUncheckedCreateWithoutMountainInput>
  }

  export type TrailUpdateWithWhereUniqueWithoutMountainInput = {
    where: TrailWhereUniqueInput
    data: XOR<TrailUpdateWithoutMountainInput, TrailUncheckedUpdateWithoutMountainInput>
  }

  export type TrailUpdateManyWithWhereWithoutMountainInput = {
    where: TrailScalarWhereInput
    data: XOR<TrailUpdateManyMutationInput, TrailUncheckedUpdateManyWithoutMountainInput>
  }

  export type TrailScalarWhereInput = {
    AND?: TrailScalarWhereInput | TrailScalarWhereInput[]
    OR?: TrailScalarWhereInput[]
    NOT?: TrailScalarWhereInput | TrailScalarWhereInput[]
    id?: StringFilter<"Trail"> | string
    mountainId?: StringFilter<"Trail"> | string
    name?: StringFilter<"Trail"> | string
    difficulty?: EnumTRAIL_DIFFICULTYFilter<"Trail"> | $Enums.TRAIL_DIFFICULTY
    status?: EnumSTATUSFilter<"Trail"> | $Enums.STATUS
    length?: FloatFilter<"Trail"> | number
    latitude?: DecimalNullableFilter<"Trail"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Trail"> | Decimal | DecimalJsLike | number | string | null
    condition?: EnumTRAIL_CONDITIONFilter<"Trail"> | $Enums.TRAIL_CONDITION
    locationId?: StringNullableFilter<"Trail"> | string | null
  }

  export type AidRoomCheckUpsertWithWhereUniqueWithoutMountainInput = {
    where: AidRoomCheckWhereUniqueInput
    update: XOR<AidRoomCheckUpdateWithoutMountainInput, AidRoomCheckUncheckedUpdateWithoutMountainInput>
    create: XOR<AidRoomCheckCreateWithoutMountainInput, AidRoomCheckUncheckedCreateWithoutMountainInput>
  }

  export type AidRoomCheckUpdateWithWhereUniqueWithoutMountainInput = {
    where: AidRoomCheckWhereUniqueInput
    data: XOR<AidRoomCheckUpdateWithoutMountainInput, AidRoomCheckUncheckedUpdateWithoutMountainInput>
  }

  export type AidRoomCheckUpdateManyWithWhereWithoutMountainInput = {
    where: AidRoomCheckScalarWhereInput
    data: XOR<AidRoomCheckUpdateManyMutationInput, AidRoomCheckUncheckedUpdateManyWithoutMountainInput>
  }

  export type AidRoomCheckScalarWhereInput = {
    AND?: AidRoomCheckScalarWhereInput | AidRoomCheckScalarWhereInput[]
    OR?: AidRoomCheckScalarWhereInput[]
    NOT?: AidRoomCheckScalarWhereInput | AidRoomCheckScalarWhereInput[]
    id?: StringFilter<"AidRoomCheck"> | string
    recordedAt?: DateTimeFilter<"AidRoomCheck"> | Date | string
    employeeId?: StringFilter<"AidRoomCheck"> | string
    mountainId?: StringFilter<"AidRoomCheck"> | string
    aidRoomId?: StringFilter<"AidRoomCheck"> | string
    notes?: StringNullableFilter<"AidRoomCheck"> | string | null
    createdAt?: DateTimeFilter<"AidRoomCheck"> | Date | string
    updatedAt?: DateTimeFilter<"AidRoomCheck"> | Date | string
  }

  export type HutCheckUpsertWithWhereUniqueWithoutMountainInput = {
    where: HutCheckWhereUniqueInput
    update: XOR<HutCheckUpdateWithoutMountainInput, HutCheckUncheckedUpdateWithoutMountainInput>
    create: XOR<HutCheckCreateWithoutMountainInput, HutCheckUncheckedCreateWithoutMountainInput>
  }

  export type HutCheckUpdateWithWhereUniqueWithoutMountainInput = {
    where: HutCheckWhereUniqueInput
    data: XOR<HutCheckUpdateWithoutMountainInput, HutCheckUncheckedUpdateWithoutMountainInput>
  }

  export type HutCheckUpdateManyWithWhereWithoutMountainInput = {
    where: HutCheckScalarWhereInput
    data: XOR<HutCheckUpdateManyMutationInput, HutCheckUncheckedUpdateManyWithoutMountainInput>
  }

  export type HutCheckScalarWhereInput = {
    AND?: HutCheckScalarWhereInput | HutCheckScalarWhereInput[]
    OR?: HutCheckScalarWhereInput[]
    NOT?: HutCheckScalarWhereInput | HutCheckScalarWhereInput[]
    id?: StringFilter<"HutCheck"> | string
    recordedAt?: DateTimeFilter<"HutCheck"> | Date | string
    employeeId?: StringFilter<"HutCheck"> | string
    mountainId?: StringFilter<"HutCheck"> | string
    hutId?: StringFilter<"HutCheck"> | string
    notes?: StringNullableFilter<"HutCheck"> | string | null
    createdAt?: DateTimeFilter<"HutCheck"> | Date | string
    updatedAt?: DateTimeFilter<"HutCheck"> | Date | string
  }

  export type LiftCheckUpsertWithWhereUniqueWithoutMountainInput = {
    where: LiftCheckWhereUniqueInput
    update: XOR<LiftCheckUpdateWithoutMountainInput, LiftCheckUncheckedUpdateWithoutMountainInput>
    create: XOR<LiftCheckCreateWithoutMountainInput, LiftCheckUncheckedCreateWithoutMountainInput>
  }

  export type LiftCheckUpdateWithWhereUniqueWithoutMountainInput = {
    where: LiftCheckWhereUniqueInput
    data: XOR<LiftCheckUpdateWithoutMountainInput, LiftCheckUncheckedUpdateWithoutMountainInput>
  }

  export type LiftCheckUpdateManyWithWhereWithoutMountainInput = {
    where: LiftCheckScalarWhereInput
    data: XOR<LiftCheckUpdateManyMutationInput, LiftCheckUncheckedUpdateManyWithoutMountainInput>
  }

  export type LiftCheckScalarWhereInput = {
    AND?: LiftCheckScalarWhereInput | LiftCheckScalarWhereInput[]
    OR?: LiftCheckScalarWhereInput[]
    NOT?: LiftCheckScalarWhereInput | LiftCheckScalarWhereInput[]
    id?: StringFilter<"LiftCheck"> | string
    recordedAt?: DateTimeFilter<"LiftCheck"> | Date | string
    employeeId?: StringFilter<"LiftCheck"> | string
    mountainId?: StringFilter<"LiftCheck"> | string
    liftId?: StringFilter<"LiftCheck"> | string
    notes?: StringNullableFilter<"LiftCheck"> | string | null
    createdAt?: DateTimeFilter<"LiftCheck"> | Date | string
    updatedAt?: DateTimeFilter<"LiftCheck"> | Date | string
  }

  export type TrailCheckUpsertWithWhereUniqueWithoutMountainInput = {
    where: TrailCheckWhereUniqueInput
    update: XOR<TrailCheckUpdateWithoutMountainInput, TrailCheckUncheckedUpdateWithoutMountainInput>
    create: XOR<TrailCheckCreateWithoutMountainInput, TrailCheckUncheckedCreateWithoutMountainInput>
  }

  export type TrailCheckUpdateWithWhereUniqueWithoutMountainInput = {
    where: TrailCheckWhereUniqueInput
    data: XOR<TrailCheckUpdateWithoutMountainInput, TrailCheckUncheckedUpdateWithoutMountainInput>
  }

  export type TrailCheckUpdateManyWithWhereWithoutMountainInput = {
    where: TrailCheckScalarWhereInput
    data: XOR<TrailCheckUpdateManyMutationInput, TrailCheckUncheckedUpdateManyWithoutMountainInput>
  }

  export type TrailCheckScalarWhereInput = {
    AND?: TrailCheckScalarWhereInput | TrailCheckScalarWhereInput[]
    OR?: TrailCheckScalarWhereInput[]
    NOT?: TrailCheckScalarWhereInput | TrailCheckScalarWhereInput[]
    id?: StringFilter<"TrailCheck"> | string
    recordedAt?: DateTimeFilter<"TrailCheck"> | Date | string
    employeeId?: StringFilter<"TrailCheck"> | string
    mountainId?: StringFilter<"TrailCheck"> | string
    trailId?: StringFilter<"TrailCheck"> | string
    notes?: StringNullableFilter<"TrailCheck"> | string | null
    createdAt?: DateTimeFilter<"TrailCheck"> | Date | string
    updatedAt?: DateTimeFilter<"TrailCheck"> | Date | string
  }

  export type EquipmentCheckUpsertWithWhereUniqueWithoutMountainInput = {
    where: EquipmentCheckWhereUniqueInput
    update: XOR<EquipmentCheckUpdateWithoutMountainInput, EquipmentCheckUncheckedUpdateWithoutMountainInput>
    create: XOR<EquipmentCheckCreateWithoutMountainInput, EquipmentCheckUncheckedCreateWithoutMountainInput>
  }

  export type EquipmentCheckUpdateWithWhereUniqueWithoutMountainInput = {
    where: EquipmentCheckWhereUniqueInput
    data: XOR<EquipmentCheckUpdateWithoutMountainInput, EquipmentCheckUncheckedUpdateWithoutMountainInput>
  }

  export type EquipmentCheckUpdateManyWithWhereWithoutMountainInput = {
    where: EquipmentCheckScalarWhereInput
    data: XOR<EquipmentCheckUpdateManyMutationInput, EquipmentCheckUncheckedUpdateManyWithoutMountainInput>
  }

  export type EquipmentCheckScalarWhereInput = {
    AND?: EquipmentCheckScalarWhereInput | EquipmentCheckScalarWhereInput[]
    OR?: EquipmentCheckScalarWhereInput[]
    NOT?: EquipmentCheckScalarWhereInput | EquipmentCheckScalarWhereInput[]
    id?: StringFilter<"EquipmentCheck"> | string
    recordedAt?: DateTimeFilter<"EquipmentCheck"> | Date | string
    employeeId?: StringFilter<"EquipmentCheck"> | string
    mountainId?: StringFilter<"EquipmentCheck"> | string
    equipmentId?: StringFilter<"EquipmentCheck"> | string
    notes?: StringNullableFilter<"EquipmentCheck"> | string | null
    createdAt?: DateTimeFilter<"EquipmentCheck"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentCheck"> | Date | string
  }

  export type IncidentUpsertWithWhereUniqueWithoutMountainInput = {
    where: IncidentWhereUniqueInput
    update: XOR<IncidentUpdateWithoutMountainInput, IncidentUncheckedUpdateWithoutMountainInput>
    create: XOR<IncidentCreateWithoutMountainInput, IncidentUncheckedCreateWithoutMountainInput>
  }

  export type IncidentUpdateWithWhereUniqueWithoutMountainInput = {
    where: IncidentWhereUniqueInput
    data: XOR<IncidentUpdateWithoutMountainInput, IncidentUncheckedUpdateWithoutMountainInput>
  }

  export type IncidentUpdateManyWithWhereWithoutMountainInput = {
    where: IncidentScalarWhereInput
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyWithoutMountainInput>
  }

  export type EquipmentUpsertWithWhereUniqueWithoutMountainInput = {
    where: EquipmentWhereUniqueInput
    update: XOR<EquipmentUpdateWithoutMountainInput, EquipmentUncheckedUpdateWithoutMountainInput>
    create: XOR<EquipmentCreateWithoutMountainInput, EquipmentUncheckedCreateWithoutMountainInput>
  }

  export type EquipmentUpdateWithWhereUniqueWithoutMountainInput = {
    where: EquipmentWhereUniqueInput
    data: XOR<EquipmentUpdateWithoutMountainInput, EquipmentUncheckedUpdateWithoutMountainInput>
  }

  export type EquipmentUpdateManyWithWhereWithoutMountainInput = {
    where: EquipmentScalarWhereInput
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyWithoutMountainInput>
  }

  export type EmployeeMountainAssignmentUpsertWithWhereUniqueWithoutMountainInput = {
    where: EmployeeMountainAssignmentWhereUniqueInput
    update: XOR<EmployeeMountainAssignmentUpdateWithoutMountainInput, EmployeeMountainAssignmentUncheckedUpdateWithoutMountainInput>
    create: XOR<EmployeeMountainAssignmentCreateWithoutMountainInput, EmployeeMountainAssignmentUncheckedCreateWithoutMountainInput>
  }

  export type EmployeeMountainAssignmentUpdateWithWhereUniqueWithoutMountainInput = {
    where: EmployeeMountainAssignmentWhereUniqueInput
    data: XOR<EmployeeMountainAssignmentUpdateWithoutMountainInput, EmployeeMountainAssignmentUncheckedUpdateWithoutMountainInput>
  }

  export type EmployeeMountainAssignmentUpdateManyWithWhereWithoutMountainInput = {
    where: EmployeeMountainAssignmentScalarWhereInput
    data: XOR<EmployeeMountainAssignmentUpdateManyMutationInput, EmployeeMountainAssignmentUncheckedUpdateManyWithoutMountainInput>
  }

  export type EmployeeMountainAssignmentScalarWhereInput = {
    AND?: EmployeeMountainAssignmentScalarWhereInput | EmployeeMountainAssignmentScalarWhereInput[]
    OR?: EmployeeMountainAssignmentScalarWhereInput[]
    NOT?: EmployeeMountainAssignmentScalarWhereInput | EmployeeMountainAssignmentScalarWhereInput[]
    id?: StringFilter<"EmployeeMountainAssignment"> | string
    employeeId?: StringFilter<"EmployeeMountainAssignment"> | string
    mountainId?: StringFilter<"EmployeeMountainAssignment"> | string
    assignedAt?: DateTimeFilter<"EmployeeMountainAssignment"> | Date | string
  }

  export type DispatcherAssignmentUpsertWithWhereUniqueWithoutMountainInput = {
    where: DispatcherAssignmentWhereUniqueInput
    update: XOR<DispatcherAssignmentUpdateWithoutMountainInput, DispatcherAssignmentUncheckedUpdateWithoutMountainInput>
    create: XOR<DispatcherAssignmentCreateWithoutMountainInput, DispatcherAssignmentUncheckedCreateWithoutMountainInput>
  }

  export type DispatcherAssignmentUpdateWithWhereUniqueWithoutMountainInput = {
    where: DispatcherAssignmentWhereUniqueInput
    data: XOR<DispatcherAssignmentUpdateWithoutMountainInput, DispatcherAssignmentUncheckedUpdateWithoutMountainInput>
  }

  export type DispatcherAssignmentUpdateManyWithWhereWithoutMountainInput = {
    where: DispatcherAssignmentScalarWhereInput
    data: XOR<DispatcherAssignmentUpdateManyMutationInput, DispatcherAssignmentUncheckedUpdateManyWithoutMountainInput>
  }

  export type DispatcherAssignmentScalarWhereInput = {
    AND?: DispatcherAssignmentScalarWhereInput | DispatcherAssignmentScalarWhereInput[]
    OR?: DispatcherAssignmentScalarWhereInput[]
    NOT?: DispatcherAssignmentScalarWhereInput | DispatcherAssignmentScalarWhereInput[]
    id?: StringFilter<"DispatcherAssignment"> | string
    employeeId?: StringFilter<"DispatcherAssignment"> | string
    mountainId?: StringFilter<"DispatcherAssignment"> | string
    assignedAt?: DateTimeFilter<"DispatcherAssignment"> | Date | string
  }

  export type IncidentEquipmentUsageLogUpsertWithWhereUniqueWithoutMountainInput = {
    where: IncidentEquipmentUsageLogWhereUniqueInput
    update: XOR<IncidentEquipmentUsageLogUpdateWithoutMountainInput, IncidentEquipmentUsageLogUncheckedUpdateWithoutMountainInput>
    create: XOR<IncidentEquipmentUsageLogCreateWithoutMountainInput, IncidentEquipmentUsageLogUncheckedCreateWithoutMountainInput>
  }

  export type IncidentEquipmentUsageLogUpdateWithWhereUniqueWithoutMountainInput = {
    where: IncidentEquipmentUsageLogWhereUniqueInput
    data: XOR<IncidentEquipmentUsageLogUpdateWithoutMountainInput, IncidentEquipmentUsageLogUncheckedUpdateWithoutMountainInput>
  }

  export type IncidentEquipmentUsageLogUpdateManyWithWhereWithoutMountainInput = {
    where: IncidentEquipmentUsageLogScalarWhereInput
    data: XOR<IncidentEquipmentUsageLogUpdateManyMutationInput, IncidentEquipmentUsageLogUncheckedUpdateManyWithoutMountainInput>
  }

  export type IncidentEquipmentUsageLogScalarWhereInput = {
    AND?: IncidentEquipmentUsageLogScalarWhereInput | IncidentEquipmentUsageLogScalarWhereInput[]
    OR?: IncidentEquipmentUsageLogScalarWhereInput[]
    NOT?: IncidentEquipmentUsageLogScalarWhereInput | IncidentEquipmentUsageLogScalarWhereInput[]
    id?: StringFilter<"IncidentEquipmentUsageLog"> | string
    usedAt?: DateTimeFilter<"IncidentEquipmentUsageLog"> | Date | string
    notes?: StringNullableFilter<"IncidentEquipmentUsageLog"> | string | null
    mountainId?: StringFilter<"IncidentEquipmentUsageLog"> | string
    equipmentId?: StringFilter<"IncidentEquipmentUsageLog"> | string
    incidentId?: StringFilter<"IncidentEquipmentUsageLog"> | string
    createdAt?: DateTimeFilter<"IncidentEquipmentUsageLog"> | Date | string
    updatedAt?: DateTimeFilter<"IncidentEquipmentUsageLog"> | Date | string
  }

  export type EquipmentServiceLogUpsertWithWhereUniqueWithoutMountainInput = {
    where: EquipmentServiceLogWhereUniqueInput
    update: XOR<EquipmentServiceLogUpdateWithoutMountainInput, EquipmentServiceLogUncheckedUpdateWithoutMountainInput>
    create: XOR<EquipmentServiceLogCreateWithoutMountainInput, EquipmentServiceLogUncheckedCreateWithoutMountainInput>
  }

  export type EquipmentServiceLogUpdateWithWhereUniqueWithoutMountainInput = {
    where: EquipmentServiceLogWhereUniqueInput
    data: XOR<EquipmentServiceLogUpdateWithoutMountainInput, EquipmentServiceLogUncheckedUpdateWithoutMountainInput>
  }

  export type EquipmentServiceLogUpdateManyWithWhereWithoutMountainInput = {
    where: EquipmentServiceLogScalarWhereInput
    data: XOR<EquipmentServiceLogUpdateManyMutationInput, EquipmentServiceLogUncheckedUpdateManyWithoutMountainInput>
  }

  export type EquipmentServiceLogScalarWhereInput = {
    AND?: EquipmentServiceLogScalarWhereInput | EquipmentServiceLogScalarWhereInput[]
    OR?: EquipmentServiceLogScalarWhereInput[]
    NOT?: EquipmentServiceLogScalarWhereInput | EquipmentServiceLogScalarWhereInput[]
    id?: StringFilter<"EquipmentServiceLog"> | string
    mountainId?: StringFilter<"EquipmentServiceLog"> | string
    equipmentId?: StringFilter<"EquipmentServiceLog"> | string
    employeeId?: StringNullableFilter<"EquipmentServiceLog"> | string | null
    status?: EnumEQUIPMENT_STATUSFilter<"EquipmentServiceLog"> | $Enums.EQUIPMENT_STATUS
    changedAt?: DateTimeFilter<"EquipmentServiceLog"> | Date | string
    notes?: StringNullableFilter<"EquipmentServiceLog"> | string | null
    createdAt?: DateTimeFilter<"EquipmentServiceLog"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentServiceLog"> | Date | string
  }

  export type MountainCreateWithoutWeatherInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    locations?: LocationCreateNestedManyWithoutMountainInput
    areas?: AreaCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    lifts?: LiftCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutWeatherInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    locations?: LocationUncheckedCreateNestedManyWithoutMountainInput
    areas?: AreaUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutWeatherInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutWeatherInput, MountainUncheckedCreateWithoutWeatherInput>
  }

  export type MountainUpsertWithoutWeatherInput = {
    update: XOR<MountainUpdateWithoutWeatherInput, MountainUncheckedUpdateWithoutWeatherInput>
    create: XOR<MountainCreateWithoutWeatherInput, MountainUncheckedCreateWithoutWeatherInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutWeatherInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutWeatherInput, MountainUncheckedUpdateWithoutWeatherInput>
  }

  export type MountainUpdateWithoutWeatherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locations?: LocationUpdateManyWithoutMountainNestedInput
    areas?: AreaUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutWeatherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locations?: LocationUncheckedUpdateManyWithoutMountainNestedInput
    areas?: AreaUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type EmployeeCreateWithoutMountainAssignmentsInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    role?: RoleCreateNestedOneWithoutEmployeesInput
    additionalRoles?: EmployeeRoleCreateNestedManyWithoutEmployeeInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutEmployeeInput
    incidents?: IncidentCreateNestedManyWithoutEmployeesInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEmployeeInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutMountainAssignmentsInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    roleId?: string | null
    additionalRoles?: EmployeeRoleUncheckedCreateNestedManyWithoutEmployeeInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutEmployeesInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutMountainAssignmentsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutMountainAssignmentsInput, EmployeeUncheckedCreateWithoutMountainAssignmentsInput>
  }

  export type MountainCreateWithoutEmployeeAssignmentsInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherCreateNestedManyWithoutMountainInput
    locations?: LocationCreateNestedManyWithoutMountainInput
    areas?: AreaCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    lifts?: LiftCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutEmployeeAssignmentsInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
    locations?: LocationUncheckedCreateNestedManyWithoutMountainInput
    areas?: AreaUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutEmployeeAssignmentsInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutEmployeeAssignmentsInput, MountainUncheckedCreateWithoutEmployeeAssignmentsInput>
  }

  export type EmployeeUpsertWithoutMountainAssignmentsInput = {
    update: XOR<EmployeeUpdateWithoutMountainAssignmentsInput, EmployeeUncheckedUpdateWithoutMountainAssignmentsInput>
    create: XOR<EmployeeCreateWithoutMountainAssignmentsInput, EmployeeUncheckedCreateWithoutMountainAssignmentsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutMountainAssignmentsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutMountainAssignmentsInput, EmployeeUncheckedUpdateWithoutMountainAssignmentsInput>
  }

  export type EmployeeUpdateWithoutMountainAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: RoleUpdateOneWithoutEmployeesNestedInput
    additionalRoles?: EmployeeRoleUpdateManyWithoutEmployeeNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutEmployeeNestedInput
    incidents?: IncidentUpdateManyWithoutEmployeesNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEmployeeNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutMountainAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalRoles?: EmployeeRoleUncheckedUpdateManyWithoutEmployeeNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutEmployeesNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type MountainUpsertWithoutEmployeeAssignmentsInput = {
    update: XOR<MountainUpdateWithoutEmployeeAssignmentsInput, MountainUncheckedUpdateWithoutEmployeeAssignmentsInput>
    create: XOR<MountainCreateWithoutEmployeeAssignmentsInput, MountainUncheckedCreateWithoutEmployeeAssignmentsInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutEmployeeAssignmentsInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutEmployeeAssignmentsInput, MountainUncheckedUpdateWithoutEmployeeAssignmentsInput>
  }

  export type MountainUpdateWithoutEmployeeAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUpdateManyWithoutMountainNestedInput
    locations?: LocationUpdateManyWithoutMountainNestedInput
    areas?: AreaUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutEmployeeAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMountainNestedInput
    areas?: AreaUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type EmployeeCreateWithoutDispatcherAssignmentsInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    role?: RoleCreateNestedOneWithoutEmployeesInput
    additionalRoles?: EmployeeRoleCreateNestedManyWithoutEmployeeInput
    mountainAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutEmployeeInput
    incidents?: IncidentCreateNestedManyWithoutEmployeesInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEmployeeInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutDispatcherAssignmentsInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    roleId?: string | null
    additionalRoles?: EmployeeRoleUncheckedCreateNestedManyWithoutEmployeeInput
    mountainAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutEmployeesInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutDispatcherAssignmentsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDispatcherAssignmentsInput, EmployeeUncheckedCreateWithoutDispatcherAssignmentsInput>
  }

  export type MountainCreateWithoutDispatcherAssignmentsInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherCreateNestedManyWithoutMountainInput
    locations?: LocationCreateNestedManyWithoutMountainInput
    areas?: AreaCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    lifts?: LiftCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutDispatcherAssignmentsInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
    locations?: LocationUncheckedCreateNestedManyWithoutMountainInput
    areas?: AreaUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutDispatcherAssignmentsInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutDispatcherAssignmentsInput, MountainUncheckedCreateWithoutDispatcherAssignmentsInput>
  }

  export type EmployeeUpsertWithoutDispatcherAssignmentsInput = {
    update: XOR<EmployeeUpdateWithoutDispatcherAssignmentsInput, EmployeeUncheckedUpdateWithoutDispatcherAssignmentsInput>
    create: XOR<EmployeeCreateWithoutDispatcherAssignmentsInput, EmployeeUncheckedCreateWithoutDispatcherAssignmentsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutDispatcherAssignmentsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutDispatcherAssignmentsInput, EmployeeUncheckedUpdateWithoutDispatcherAssignmentsInput>
  }

  export type EmployeeUpdateWithoutDispatcherAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: RoleUpdateOneWithoutEmployeesNestedInput
    additionalRoles?: EmployeeRoleUpdateManyWithoutEmployeeNestedInput
    mountainAssignments?: EmployeeMountainAssignmentUpdateManyWithoutEmployeeNestedInput
    incidents?: IncidentUpdateManyWithoutEmployeesNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEmployeeNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDispatcherAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalRoles?: EmployeeRoleUncheckedUpdateManyWithoutEmployeeNestedInput
    mountainAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutEmployeesNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type MountainUpsertWithoutDispatcherAssignmentsInput = {
    update: XOR<MountainUpdateWithoutDispatcherAssignmentsInput, MountainUncheckedUpdateWithoutDispatcherAssignmentsInput>
    create: XOR<MountainCreateWithoutDispatcherAssignmentsInput, MountainUncheckedCreateWithoutDispatcherAssignmentsInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutDispatcherAssignmentsInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutDispatcherAssignmentsInput, MountainUncheckedUpdateWithoutDispatcherAssignmentsInput>
  }

  export type MountainUpdateWithoutDispatcherAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUpdateManyWithoutMountainNestedInput
    locations?: LocationUpdateManyWithoutMountainNestedInput
    areas?: AreaUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutDispatcherAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMountainNestedInput
    areas?: AreaUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type EmployeeCreateWithoutRoleInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    additionalRoles?: EmployeeRoleCreateNestedManyWithoutEmployeeInput
    mountainAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutEmployeeInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutEmployeeInput
    incidents?: IncidentCreateNestedManyWithoutEmployeesInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEmployeeInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutRoleInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    additionalRoles?: EmployeeRoleUncheckedCreateNestedManyWithoutEmployeeInput
    mountainAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutEmployeesInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutRoleInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutRoleInput, EmployeeUncheckedCreateWithoutRoleInput>
  }

  export type EmployeeCreateManyRoleInputEnvelope = {
    data: EmployeeCreateManyRoleInput | EmployeeCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeRoleCreateWithoutRoleInput = {
    id?: string
    employee: EmployeeCreateNestedOneWithoutAdditionalRolesInput
  }

  export type EmployeeRoleUncheckedCreateWithoutRoleInput = {
    id?: string
    employeeId: string
  }

  export type EmployeeRoleCreateOrConnectWithoutRoleInput = {
    where: EmployeeRoleWhereUniqueInput
    create: XOR<EmployeeRoleCreateWithoutRoleInput, EmployeeRoleUncheckedCreateWithoutRoleInput>
  }

  export type EmployeeRoleCreateManyRoleInputEnvelope = {
    data: EmployeeRoleCreateManyRoleInput | EmployeeRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithWhereUniqueWithoutRoleInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutRoleInput, EmployeeUncheckedUpdateWithoutRoleInput>
    create: XOR<EmployeeCreateWithoutRoleInput, EmployeeUncheckedCreateWithoutRoleInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutRoleInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutRoleInput, EmployeeUncheckedUpdateWithoutRoleInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutRoleInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutRoleInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: StringFilter<"Employee"> | string
    employeeIdNumber?: IntFilter<"Employee"> | number
    email?: StringFilter<"Employee"> | string
    phoneNumber?: StringFilter<"Employee"> | string
    name?: StringFilter<"Employee"> | string
    roleId?: StringNullableFilter<"Employee"> | string | null
  }

  export type EmployeeRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: EmployeeRoleWhereUniqueInput
    update: XOR<EmployeeRoleUpdateWithoutRoleInput, EmployeeRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<EmployeeRoleCreateWithoutRoleInput, EmployeeRoleUncheckedCreateWithoutRoleInput>
  }

  export type EmployeeRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: EmployeeRoleWhereUniqueInput
    data: XOR<EmployeeRoleUpdateWithoutRoleInput, EmployeeRoleUncheckedUpdateWithoutRoleInput>
  }

  export type EmployeeRoleUpdateManyWithWhereWithoutRoleInput = {
    where: EmployeeRoleScalarWhereInput
    data: XOR<EmployeeRoleUpdateManyMutationInput, EmployeeRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type EmployeeRoleScalarWhereInput = {
    AND?: EmployeeRoleScalarWhereInput | EmployeeRoleScalarWhereInput[]
    OR?: EmployeeRoleScalarWhereInput[]
    NOT?: EmployeeRoleScalarWhereInput | EmployeeRoleScalarWhereInput[]
    id?: StringFilter<"EmployeeRole"> | string
    employeeId?: StringFilter<"EmployeeRole"> | string
    roleId?: StringFilter<"EmployeeRole"> | string
  }

  export type EmployeeCreateWithoutAdditionalRolesInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    role?: RoleCreateNestedOneWithoutEmployeesInput
    mountainAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutEmployeeInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutEmployeeInput
    incidents?: IncidentCreateNestedManyWithoutEmployeesInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEmployeeInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAdditionalRolesInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    roleId?: string | null
    mountainAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutEmployeesInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAdditionalRolesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAdditionalRolesInput, EmployeeUncheckedCreateWithoutAdditionalRolesInput>
  }

  export type RoleCreateWithoutEmployeeRoleInput = {
    id?: string
    department: $Enums.DEPARTMENT
    name: string
    title: string
    position: string
    level?: number | null
    permissions?: RoleCreatepermissionsInput | string[]
    employees?: EmployeeCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutEmployeeRoleInput = {
    id?: string
    department: $Enums.DEPARTMENT
    name: string
    title: string
    position: string
    level?: number | null
    permissions?: RoleCreatepermissionsInput | string[]
    employees?: EmployeeUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutEmployeeRoleInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutEmployeeRoleInput, RoleUncheckedCreateWithoutEmployeeRoleInput>
  }

  export type EmployeeUpsertWithoutAdditionalRolesInput = {
    update: XOR<EmployeeUpdateWithoutAdditionalRolesInput, EmployeeUncheckedUpdateWithoutAdditionalRolesInput>
    create: XOR<EmployeeCreateWithoutAdditionalRolesInput, EmployeeUncheckedCreateWithoutAdditionalRolesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAdditionalRolesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAdditionalRolesInput, EmployeeUncheckedUpdateWithoutAdditionalRolesInput>
  }

  export type EmployeeUpdateWithoutAdditionalRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: RoleUpdateOneWithoutEmployeesNestedInput
    mountainAssignments?: EmployeeMountainAssignmentUpdateManyWithoutEmployeeNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutEmployeeNestedInput
    incidents?: IncidentUpdateManyWithoutEmployeesNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEmployeeNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAdditionalRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    mountainAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutEmployeesNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type RoleUpsertWithoutEmployeeRoleInput = {
    update: XOR<RoleUpdateWithoutEmployeeRoleInput, RoleUncheckedUpdateWithoutEmployeeRoleInput>
    create: XOR<RoleCreateWithoutEmployeeRoleInput, RoleUncheckedCreateWithoutEmployeeRoleInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutEmployeeRoleInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutEmployeeRoleInput, RoleUncheckedUpdateWithoutEmployeeRoleInput>
  }

  export type RoleUpdateWithoutEmployeeRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: EnumDEPARTMENTFieldUpdateOperationsInput | $Enums.DEPARTMENT
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    permissions?: RoleUpdatepermissionsInput | string[]
    employees?: EmployeeUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutEmployeeRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: EnumDEPARTMENTFieldUpdateOperationsInput | $Enums.DEPARTMENT
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    permissions?: RoleUpdatepermissionsInput | string[]
    employees?: EmployeeUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateWithoutEmployeesInput = {
    id?: string
    department: $Enums.DEPARTMENT
    name: string
    title: string
    position: string
    level?: number | null
    permissions?: RoleCreatepermissionsInput | string[]
    employeeRole?: EmployeeRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutEmployeesInput = {
    id?: string
    department: $Enums.DEPARTMENT
    name: string
    title: string
    position: string
    level?: number | null
    permissions?: RoleCreatepermissionsInput | string[]
    employeeRole?: EmployeeRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutEmployeesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutEmployeesInput, RoleUncheckedCreateWithoutEmployeesInput>
  }

  export type EmployeeRoleCreateWithoutEmployeeInput = {
    id?: string
    role: RoleCreateNestedOneWithoutEmployeeRoleInput
  }

  export type EmployeeRoleUncheckedCreateWithoutEmployeeInput = {
    id?: string
    roleId: string
  }

  export type EmployeeRoleCreateOrConnectWithoutEmployeeInput = {
    where: EmployeeRoleWhereUniqueInput
    create: XOR<EmployeeRoleCreateWithoutEmployeeInput, EmployeeRoleUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeRoleCreateManyEmployeeInputEnvelope = {
    data: EmployeeRoleCreateManyEmployeeInput | EmployeeRoleCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeMountainAssignmentCreateWithoutEmployeeInput = {
    id?: string
    assignedAt: Date | string
    mountain: MountainCreateNestedOneWithoutEmployeeAssignmentsInput
  }

  export type EmployeeMountainAssignmentUncheckedCreateWithoutEmployeeInput = {
    id?: string
    mountainId: string
    assignedAt: Date | string
  }

  export type EmployeeMountainAssignmentCreateOrConnectWithoutEmployeeInput = {
    where: EmployeeMountainAssignmentWhereUniqueInput
    create: XOR<EmployeeMountainAssignmentCreateWithoutEmployeeInput, EmployeeMountainAssignmentUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeMountainAssignmentCreateManyEmployeeInputEnvelope = {
    data: EmployeeMountainAssignmentCreateManyEmployeeInput | EmployeeMountainAssignmentCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type DispatcherAssignmentCreateWithoutEmployeeInput = {
    id?: string
    assignedAt: Date | string
    mountain: MountainCreateNestedOneWithoutDispatcherAssignmentsInput
  }

  export type DispatcherAssignmentUncheckedCreateWithoutEmployeeInput = {
    id?: string
    mountainId: string
    assignedAt: Date | string
  }

  export type DispatcherAssignmentCreateOrConnectWithoutEmployeeInput = {
    where: DispatcherAssignmentWhereUniqueInput
    create: XOR<DispatcherAssignmentCreateWithoutEmployeeInput, DispatcherAssignmentUncheckedCreateWithoutEmployeeInput>
  }

  export type DispatcherAssignmentCreateManyEmployeeInputEnvelope = {
    data: DispatcherAssignmentCreateManyEmployeeInput | DispatcherAssignmentCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type IncidentCreateWithoutEmployeesInput = {
    id?: string
    description: string
    status?: $Enums.INCIDENT_STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    startTime?: Date | string
    endTime?: Date | string | null
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    emptyRun?: boolean
    emptyRunAt?: Date | string | null
    mountain: MountainCreateNestedOneWithoutIncidentsInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutIncidentInput
    location: LocationCreateNestedOneWithoutIncidentsInput
  }

  export type IncidentUncheckedCreateWithoutEmployeesInput = {
    id?: string
    description: string
    status?: $Enums.INCIDENT_STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    mountainId: string
    startTime?: Date | string
    endTime?: Date | string | null
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    emptyRun?: boolean
    emptyRunAt?: Date | string | null
    locationId: string
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutIncidentInput
  }

  export type IncidentCreateOrConnectWithoutEmployeesInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutEmployeesInput, IncidentUncheckedCreateWithoutEmployeesInput>
  }

  export type AidRoomCheckCreateWithoutEmployeeInput = {
    id?: string
    recordedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mountain: MountainCreateNestedOneWithoutAidRoomChecksInput
    aidRoom: AidRoomCreateNestedOneWithoutAidRoomChecksInput
  }

  export type AidRoomCheckUncheckedCreateWithoutEmployeeInput = {
    id?: string
    recordedAt?: Date | string
    mountainId: string
    aidRoomId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AidRoomCheckCreateOrConnectWithoutEmployeeInput = {
    where: AidRoomCheckWhereUniqueInput
    create: XOR<AidRoomCheckCreateWithoutEmployeeInput, AidRoomCheckUncheckedCreateWithoutEmployeeInput>
  }

  export type AidRoomCheckCreateManyEmployeeInputEnvelope = {
    data: AidRoomCheckCreateManyEmployeeInput | AidRoomCheckCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type HutCheckCreateWithoutEmployeeInput = {
    id?: string
    recordedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mountain: MountainCreateNestedOneWithoutHutChecksInput
    hut: HutCreateNestedOneWithoutHutChecksInput
  }

  export type HutCheckUncheckedCreateWithoutEmployeeInput = {
    id?: string
    recordedAt?: Date | string
    mountainId: string
    hutId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HutCheckCreateOrConnectWithoutEmployeeInput = {
    where: HutCheckWhereUniqueInput
    create: XOR<HutCheckCreateWithoutEmployeeInput, HutCheckUncheckedCreateWithoutEmployeeInput>
  }

  export type HutCheckCreateManyEmployeeInputEnvelope = {
    data: HutCheckCreateManyEmployeeInput | HutCheckCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type LiftCheckCreateWithoutEmployeeInput = {
    id?: string
    recordedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mountain: MountainCreateNestedOneWithoutLiftChecksInput
    lift: LiftCreateNestedOneWithoutLiftChecksInput
  }

  export type LiftCheckUncheckedCreateWithoutEmployeeInput = {
    id?: string
    recordedAt?: Date | string
    mountainId: string
    liftId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiftCheckCreateOrConnectWithoutEmployeeInput = {
    where: LiftCheckWhereUniqueInput
    create: XOR<LiftCheckCreateWithoutEmployeeInput, LiftCheckUncheckedCreateWithoutEmployeeInput>
  }

  export type LiftCheckCreateManyEmployeeInputEnvelope = {
    data: LiftCheckCreateManyEmployeeInput | LiftCheckCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type TrailCheckCreateWithoutEmployeeInput = {
    id?: string
    recordedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mountain: MountainCreateNestedOneWithoutTrailChecksInput
    trail: TrailCreateNestedOneWithoutTrailChecksInput
  }

  export type TrailCheckUncheckedCreateWithoutEmployeeInput = {
    id?: string
    recordedAt?: Date | string
    mountainId: string
    trailId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrailCheckCreateOrConnectWithoutEmployeeInput = {
    where: TrailCheckWhereUniqueInput
    create: XOR<TrailCheckCreateWithoutEmployeeInput, TrailCheckUncheckedCreateWithoutEmployeeInput>
  }

  export type TrailCheckCreateManyEmployeeInputEnvelope = {
    data: TrailCheckCreateManyEmployeeInput | TrailCheckCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCheckCreateWithoutEmployeeInput = {
    id?: string
    recordedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mountain: MountainCreateNestedOneWithoutEquipmentChecksInput
    equipment: EquipmentCreateNestedOneWithoutEquipmentChecksInput
  }

  export type EquipmentCheckUncheckedCreateWithoutEmployeeInput = {
    id?: string
    recordedAt?: Date | string
    mountainId: string
    equipmentId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentCheckCreateOrConnectWithoutEmployeeInput = {
    where: EquipmentCheckWhereUniqueInput
    create: XOR<EquipmentCheckCreateWithoutEmployeeInput, EquipmentCheckUncheckedCreateWithoutEmployeeInput>
  }

  export type EquipmentCheckCreateManyEmployeeInputEnvelope = {
    data: EquipmentCheckCreateManyEmployeeInput | EquipmentCheckCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentServiceLogCreateWithoutEmployeeInput = {
    id?: string
    status?: $Enums.EQUIPMENT_STATUS
    changedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mountain: MountainCreateNestedOneWithoutEquipmentServiceLogsInput
    equipment: EquipmentCreateNestedOneWithoutEquipmentServiceLogsInput
  }

  export type EquipmentServiceLogUncheckedCreateWithoutEmployeeInput = {
    id?: string
    mountainId: string
    equipmentId: string
    status?: $Enums.EQUIPMENT_STATUS
    changedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentServiceLogCreateOrConnectWithoutEmployeeInput = {
    where: EquipmentServiceLogWhereUniqueInput
    create: XOR<EquipmentServiceLogCreateWithoutEmployeeInput, EquipmentServiceLogUncheckedCreateWithoutEmployeeInput>
  }

  export type EquipmentServiceLogCreateManyEmployeeInputEnvelope = {
    data: EquipmentServiceLogCreateManyEmployeeInput | EquipmentServiceLogCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithoutEmployeesInput = {
    update: XOR<RoleUpdateWithoutEmployeesInput, RoleUncheckedUpdateWithoutEmployeesInput>
    create: XOR<RoleCreateWithoutEmployeesInput, RoleUncheckedCreateWithoutEmployeesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutEmployeesInput, RoleUncheckedUpdateWithoutEmployeesInput>
  }

  export type RoleUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: EnumDEPARTMENTFieldUpdateOperationsInput | $Enums.DEPARTMENT
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    permissions?: RoleUpdatepermissionsInput | string[]
    employeeRole?: EmployeeRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: EnumDEPARTMENTFieldUpdateOperationsInput | $Enums.DEPARTMENT
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    permissions?: RoleUpdatepermissionsInput | string[]
    employeeRole?: EmployeeRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type EmployeeRoleUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeRoleWhereUniqueInput
    update: XOR<EmployeeRoleUpdateWithoutEmployeeInput, EmployeeRoleUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeeRoleCreateWithoutEmployeeInput, EmployeeRoleUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeRoleUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeRoleWhereUniqueInput
    data: XOR<EmployeeRoleUpdateWithoutEmployeeInput, EmployeeRoleUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeRoleUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmployeeRoleScalarWhereInput
    data: XOR<EmployeeRoleUpdateManyMutationInput, EmployeeRoleUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeMountainAssignmentUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeMountainAssignmentWhereUniqueInput
    update: XOR<EmployeeMountainAssignmentUpdateWithoutEmployeeInput, EmployeeMountainAssignmentUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeeMountainAssignmentCreateWithoutEmployeeInput, EmployeeMountainAssignmentUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeMountainAssignmentUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeMountainAssignmentWhereUniqueInput
    data: XOR<EmployeeMountainAssignmentUpdateWithoutEmployeeInput, EmployeeMountainAssignmentUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeMountainAssignmentUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmployeeMountainAssignmentScalarWhereInput
    data: XOR<EmployeeMountainAssignmentUpdateManyMutationInput, EmployeeMountainAssignmentUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type DispatcherAssignmentUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: DispatcherAssignmentWhereUniqueInput
    update: XOR<DispatcherAssignmentUpdateWithoutEmployeeInput, DispatcherAssignmentUncheckedUpdateWithoutEmployeeInput>
    create: XOR<DispatcherAssignmentCreateWithoutEmployeeInput, DispatcherAssignmentUncheckedCreateWithoutEmployeeInput>
  }

  export type DispatcherAssignmentUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: DispatcherAssignmentWhereUniqueInput
    data: XOR<DispatcherAssignmentUpdateWithoutEmployeeInput, DispatcherAssignmentUncheckedUpdateWithoutEmployeeInput>
  }

  export type DispatcherAssignmentUpdateManyWithWhereWithoutEmployeeInput = {
    where: DispatcherAssignmentScalarWhereInput
    data: XOR<DispatcherAssignmentUpdateManyMutationInput, DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type IncidentUpsertWithWhereUniqueWithoutEmployeesInput = {
    where: IncidentWhereUniqueInput
    update: XOR<IncidentUpdateWithoutEmployeesInput, IncidentUncheckedUpdateWithoutEmployeesInput>
    create: XOR<IncidentCreateWithoutEmployeesInput, IncidentUncheckedCreateWithoutEmployeesInput>
  }

  export type IncidentUpdateWithWhereUniqueWithoutEmployeesInput = {
    where: IncidentWhereUniqueInput
    data: XOR<IncidentUpdateWithoutEmployeesInput, IncidentUncheckedUpdateWithoutEmployeesInput>
  }

  export type IncidentUpdateManyWithWhereWithoutEmployeesInput = {
    where: IncidentScalarWhereInput
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyWithoutEmployeesInput>
  }

  export type AidRoomCheckUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AidRoomCheckWhereUniqueInput
    update: XOR<AidRoomCheckUpdateWithoutEmployeeInput, AidRoomCheckUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AidRoomCheckCreateWithoutEmployeeInput, AidRoomCheckUncheckedCreateWithoutEmployeeInput>
  }

  export type AidRoomCheckUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AidRoomCheckWhereUniqueInput
    data: XOR<AidRoomCheckUpdateWithoutEmployeeInput, AidRoomCheckUncheckedUpdateWithoutEmployeeInput>
  }

  export type AidRoomCheckUpdateManyWithWhereWithoutEmployeeInput = {
    where: AidRoomCheckScalarWhereInput
    data: XOR<AidRoomCheckUpdateManyMutationInput, AidRoomCheckUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type HutCheckUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: HutCheckWhereUniqueInput
    update: XOR<HutCheckUpdateWithoutEmployeeInput, HutCheckUncheckedUpdateWithoutEmployeeInput>
    create: XOR<HutCheckCreateWithoutEmployeeInput, HutCheckUncheckedCreateWithoutEmployeeInput>
  }

  export type HutCheckUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: HutCheckWhereUniqueInput
    data: XOR<HutCheckUpdateWithoutEmployeeInput, HutCheckUncheckedUpdateWithoutEmployeeInput>
  }

  export type HutCheckUpdateManyWithWhereWithoutEmployeeInput = {
    where: HutCheckScalarWhereInput
    data: XOR<HutCheckUpdateManyMutationInput, HutCheckUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type LiftCheckUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: LiftCheckWhereUniqueInput
    update: XOR<LiftCheckUpdateWithoutEmployeeInput, LiftCheckUncheckedUpdateWithoutEmployeeInput>
    create: XOR<LiftCheckCreateWithoutEmployeeInput, LiftCheckUncheckedCreateWithoutEmployeeInput>
  }

  export type LiftCheckUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: LiftCheckWhereUniqueInput
    data: XOR<LiftCheckUpdateWithoutEmployeeInput, LiftCheckUncheckedUpdateWithoutEmployeeInput>
  }

  export type LiftCheckUpdateManyWithWhereWithoutEmployeeInput = {
    where: LiftCheckScalarWhereInput
    data: XOR<LiftCheckUpdateManyMutationInput, LiftCheckUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type TrailCheckUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: TrailCheckWhereUniqueInput
    update: XOR<TrailCheckUpdateWithoutEmployeeInput, TrailCheckUncheckedUpdateWithoutEmployeeInput>
    create: XOR<TrailCheckCreateWithoutEmployeeInput, TrailCheckUncheckedCreateWithoutEmployeeInput>
  }

  export type TrailCheckUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: TrailCheckWhereUniqueInput
    data: XOR<TrailCheckUpdateWithoutEmployeeInput, TrailCheckUncheckedUpdateWithoutEmployeeInput>
  }

  export type TrailCheckUpdateManyWithWhereWithoutEmployeeInput = {
    where: TrailCheckScalarWhereInput
    data: XOR<TrailCheckUpdateManyMutationInput, TrailCheckUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EquipmentCheckUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EquipmentCheckWhereUniqueInput
    update: XOR<EquipmentCheckUpdateWithoutEmployeeInput, EquipmentCheckUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EquipmentCheckCreateWithoutEmployeeInput, EquipmentCheckUncheckedCreateWithoutEmployeeInput>
  }

  export type EquipmentCheckUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EquipmentCheckWhereUniqueInput
    data: XOR<EquipmentCheckUpdateWithoutEmployeeInput, EquipmentCheckUncheckedUpdateWithoutEmployeeInput>
  }

  export type EquipmentCheckUpdateManyWithWhereWithoutEmployeeInput = {
    where: EquipmentCheckScalarWhereInput
    data: XOR<EquipmentCheckUpdateManyMutationInput, EquipmentCheckUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EquipmentServiceLogUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EquipmentServiceLogWhereUniqueInput
    update: XOR<EquipmentServiceLogUpdateWithoutEmployeeInput, EquipmentServiceLogUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EquipmentServiceLogCreateWithoutEmployeeInput, EquipmentServiceLogUncheckedCreateWithoutEmployeeInput>
  }

  export type EquipmentServiceLogUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EquipmentServiceLogWhereUniqueInput
    data: XOR<EquipmentServiceLogUpdateWithoutEmployeeInput, EquipmentServiceLogUncheckedUpdateWithoutEmployeeInput>
  }

  export type EquipmentServiceLogUpdateManyWithWhereWithoutEmployeeInput = {
    where: EquipmentServiceLogScalarWhereInput
    data: XOR<EquipmentServiceLogUpdateManyMutationInput, EquipmentServiceLogUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type MountainCreateWithoutLiftsInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherCreateNestedManyWithoutMountainInput
    locations?: LocationCreateNestedManyWithoutMountainInput
    areas?: AreaCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutLiftsInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
    locations?: LocationUncheckedCreateNestedManyWithoutMountainInput
    areas?: AreaUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutLiftsInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutLiftsInput, MountainUncheckedCreateWithoutLiftsInput>
  }

  export type LiftCheckCreateWithoutLiftInput = {
    id?: string
    recordedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutLiftChecksInput
    mountain: MountainCreateNestedOneWithoutLiftChecksInput
  }

  export type LiftCheckUncheckedCreateWithoutLiftInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    mountainId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiftCheckCreateOrConnectWithoutLiftInput = {
    where: LiftCheckWhereUniqueInput
    create: XOR<LiftCheckCreateWithoutLiftInput, LiftCheckUncheckedCreateWithoutLiftInput>
  }

  export type LiftCheckCreateManyLiftInputEnvelope = {
    data: LiftCheckCreateManyLiftInput | LiftCheckCreateManyLiftInput[]
    skipDuplicates?: boolean
  }

  export type LocationCreateWithoutLiftInput = {
    id?: string
    name: string
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    area?: AreaCreateNestedOneWithoutLocationsInput
    mountain: MountainCreateNestedOneWithoutLocationsInput
    trail?: TrailCreateNestedOneWithoutLocationInput
    hut?: HutCreateNestedOneWithoutLocationInput
    lodge?: LodgeCreateNestedOneWithoutLocationInput
    aidRoom?: AidRoomCreateNestedOneWithoutLocationInput
    hours?: HoursCreateNestedManyWithoutLocationInput
    equipment?: EquipmentCreateNestedManyWithoutLocationInput
    incidents?: IncidentCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutLiftInput = {
    id?: string
    mountainId: string
    name: string
    areaId?: string | null
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    trail?: TrailUncheckedCreateNestedOneWithoutLocationInput
    hut?: HutUncheckedCreateNestedOneWithoutLocationInput
    lodge?: LodgeUncheckedCreateNestedOneWithoutLocationInput
    aidRoom?: AidRoomUncheckedCreateNestedOneWithoutLocationInput
    hours?: HoursUncheckedCreateNestedManyWithoutLocationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutLocationInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutLiftInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutLiftInput, LocationUncheckedCreateWithoutLiftInput>
  }

  export type MountainUpsertWithoutLiftsInput = {
    update: XOR<MountainUpdateWithoutLiftsInput, MountainUncheckedUpdateWithoutLiftsInput>
    create: XOR<MountainCreateWithoutLiftsInput, MountainUncheckedCreateWithoutLiftsInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutLiftsInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutLiftsInput, MountainUncheckedUpdateWithoutLiftsInput>
  }

  export type MountainUpdateWithoutLiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUpdateManyWithoutMountainNestedInput
    locations?: LocationUpdateManyWithoutMountainNestedInput
    areas?: AreaUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutLiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMountainNestedInput
    areas?: AreaUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type LiftCheckUpsertWithWhereUniqueWithoutLiftInput = {
    where: LiftCheckWhereUniqueInput
    update: XOR<LiftCheckUpdateWithoutLiftInput, LiftCheckUncheckedUpdateWithoutLiftInput>
    create: XOR<LiftCheckCreateWithoutLiftInput, LiftCheckUncheckedCreateWithoutLiftInput>
  }

  export type LiftCheckUpdateWithWhereUniqueWithoutLiftInput = {
    where: LiftCheckWhereUniqueInput
    data: XOR<LiftCheckUpdateWithoutLiftInput, LiftCheckUncheckedUpdateWithoutLiftInput>
  }

  export type LiftCheckUpdateManyWithWhereWithoutLiftInput = {
    where: LiftCheckScalarWhereInput
    data: XOR<LiftCheckUpdateManyMutationInput, LiftCheckUncheckedUpdateManyWithoutLiftInput>
  }

  export type LocationUpsertWithoutLiftInput = {
    update: XOR<LocationUpdateWithoutLiftInput, LocationUncheckedUpdateWithoutLiftInput>
    create: XOR<LocationCreateWithoutLiftInput, LocationUncheckedCreateWithoutLiftInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutLiftInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutLiftInput, LocationUncheckedUpdateWithoutLiftInput>
  }

  export type LocationUpdateWithoutLiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
    area?: AreaUpdateOneWithoutLocationsNestedInput
    mountain?: MountainUpdateOneRequiredWithoutLocationsNestedInput
    trail?: TrailUpdateOneWithoutLocationNestedInput
    hut?: HutUpdateOneWithoutLocationNestedInput
    lodge?: LodgeUpdateOneWithoutLocationNestedInput
    aidRoom?: AidRoomUpdateOneWithoutLocationNestedInput
    hours?: HoursUpdateManyWithoutLocationNestedInput
    equipment?: EquipmentUpdateManyWithoutLocationNestedInput
    incidents?: IncidentUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutLiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
    trail?: TrailUncheckedUpdateOneWithoutLocationNestedInput
    hut?: HutUncheckedUpdateOneWithoutLocationNestedInput
    lodge?: LodgeUncheckedUpdateOneWithoutLocationNestedInput
    aidRoom?: AidRoomUncheckedUpdateOneWithoutLocationNestedInput
    hours?: HoursUncheckedUpdateManyWithoutLocationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutLocationNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type MountainCreateWithoutTrailsInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherCreateNestedManyWithoutMountainInput
    locations?: LocationCreateNestedManyWithoutMountainInput
    areas?: AreaCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    lifts?: LiftCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutTrailsInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
    locations?: LocationUncheckedCreateNestedManyWithoutMountainInput
    areas?: AreaUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutTrailsInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutTrailsInput, MountainUncheckedCreateWithoutTrailsInput>
  }

  export type TrailCheckCreateWithoutTrailInput = {
    id?: string
    recordedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutTrailChecksInput
    mountain: MountainCreateNestedOneWithoutTrailChecksInput
  }

  export type TrailCheckUncheckedCreateWithoutTrailInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    mountainId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrailCheckCreateOrConnectWithoutTrailInput = {
    where: TrailCheckWhereUniqueInput
    create: XOR<TrailCheckCreateWithoutTrailInput, TrailCheckUncheckedCreateWithoutTrailInput>
  }

  export type TrailCheckCreateManyTrailInputEnvelope = {
    data: TrailCheckCreateManyTrailInput | TrailCheckCreateManyTrailInput[]
    skipDuplicates?: boolean
  }

  export type LocationCreateWithoutTrailInput = {
    id?: string
    name: string
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    area?: AreaCreateNestedOneWithoutLocationsInput
    mountain: MountainCreateNestedOneWithoutLocationsInput
    lift?: LiftCreateNestedOneWithoutLocationInput
    hut?: HutCreateNestedOneWithoutLocationInput
    lodge?: LodgeCreateNestedOneWithoutLocationInput
    aidRoom?: AidRoomCreateNestedOneWithoutLocationInput
    hours?: HoursCreateNestedManyWithoutLocationInput
    equipment?: EquipmentCreateNestedManyWithoutLocationInput
    incidents?: IncidentCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutTrailInput = {
    id?: string
    mountainId: string
    name: string
    areaId?: string | null
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    lift?: LiftUncheckedCreateNestedOneWithoutLocationInput
    hut?: HutUncheckedCreateNestedOneWithoutLocationInput
    lodge?: LodgeUncheckedCreateNestedOneWithoutLocationInput
    aidRoom?: AidRoomUncheckedCreateNestedOneWithoutLocationInput
    hours?: HoursUncheckedCreateNestedManyWithoutLocationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutLocationInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutTrailInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutTrailInput, LocationUncheckedCreateWithoutTrailInput>
  }

  export type MountainUpsertWithoutTrailsInput = {
    update: XOR<MountainUpdateWithoutTrailsInput, MountainUncheckedUpdateWithoutTrailsInput>
    create: XOR<MountainCreateWithoutTrailsInput, MountainUncheckedCreateWithoutTrailsInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutTrailsInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutTrailsInput, MountainUncheckedUpdateWithoutTrailsInput>
  }

  export type MountainUpdateWithoutTrailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUpdateManyWithoutMountainNestedInput
    locations?: LocationUpdateManyWithoutMountainNestedInput
    areas?: AreaUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutTrailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMountainNestedInput
    areas?: AreaUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type TrailCheckUpsertWithWhereUniqueWithoutTrailInput = {
    where: TrailCheckWhereUniqueInput
    update: XOR<TrailCheckUpdateWithoutTrailInput, TrailCheckUncheckedUpdateWithoutTrailInput>
    create: XOR<TrailCheckCreateWithoutTrailInput, TrailCheckUncheckedCreateWithoutTrailInput>
  }

  export type TrailCheckUpdateWithWhereUniqueWithoutTrailInput = {
    where: TrailCheckWhereUniqueInput
    data: XOR<TrailCheckUpdateWithoutTrailInput, TrailCheckUncheckedUpdateWithoutTrailInput>
  }

  export type TrailCheckUpdateManyWithWhereWithoutTrailInput = {
    where: TrailCheckScalarWhereInput
    data: XOR<TrailCheckUpdateManyMutationInput, TrailCheckUncheckedUpdateManyWithoutTrailInput>
  }

  export type LocationUpsertWithoutTrailInput = {
    update: XOR<LocationUpdateWithoutTrailInput, LocationUncheckedUpdateWithoutTrailInput>
    create: XOR<LocationCreateWithoutTrailInput, LocationUncheckedCreateWithoutTrailInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutTrailInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutTrailInput, LocationUncheckedUpdateWithoutTrailInput>
  }

  export type LocationUpdateWithoutTrailInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
    area?: AreaUpdateOneWithoutLocationsNestedInput
    mountain?: MountainUpdateOneRequiredWithoutLocationsNestedInput
    lift?: LiftUpdateOneWithoutLocationNestedInput
    hut?: HutUpdateOneWithoutLocationNestedInput
    lodge?: LodgeUpdateOneWithoutLocationNestedInput
    aidRoom?: AidRoomUpdateOneWithoutLocationNestedInput
    hours?: HoursUpdateManyWithoutLocationNestedInput
    equipment?: EquipmentUpdateManyWithoutLocationNestedInput
    incidents?: IncidentUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutTrailInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
    lift?: LiftUncheckedUpdateOneWithoutLocationNestedInput
    hut?: HutUncheckedUpdateOneWithoutLocationNestedInput
    lodge?: LodgeUncheckedUpdateOneWithoutLocationNestedInput
    aidRoom?: AidRoomUncheckedUpdateOneWithoutLocationNestedInput
    hours?: HoursUncheckedUpdateManyWithoutLocationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutLocationNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type MountainCreateWithoutLodgesInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherCreateNestedManyWithoutMountainInput
    locations?: LocationCreateNestedManyWithoutMountainInput
    areas?: AreaCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    lifts?: LiftCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutLodgesInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
    locations?: LocationUncheckedCreateNestedManyWithoutMountainInput
    areas?: AreaUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutLodgesInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutLodgesInput, MountainUncheckedCreateWithoutLodgesInput>
  }

  export type LocationCreateWithoutLodgeInput = {
    id?: string
    name: string
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    area?: AreaCreateNestedOneWithoutLocationsInput
    mountain: MountainCreateNestedOneWithoutLocationsInput
    lift?: LiftCreateNestedOneWithoutLocationInput
    trail?: TrailCreateNestedOneWithoutLocationInput
    hut?: HutCreateNestedOneWithoutLocationInput
    aidRoom?: AidRoomCreateNestedOneWithoutLocationInput
    hours?: HoursCreateNestedManyWithoutLocationInput
    equipment?: EquipmentCreateNestedManyWithoutLocationInput
    incidents?: IncidentCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutLodgeInput = {
    id?: string
    mountainId: string
    name: string
    areaId?: string | null
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    lift?: LiftUncheckedCreateNestedOneWithoutLocationInput
    trail?: TrailUncheckedCreateNestedOneWithoutLocationInput
    hut?: HutUncheckedCreateNestedOneWithoutLocationInput
    aidRoom?: AidRoomUncheckedCreateNestedOneWithoutLocationInput
    hours?: HoursUncheckedCreateNestedManyWithoutLocationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutLocationInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutLodgeInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutLodgeInput, LocationUncheckedCreateWithoutLodgeInput>
  }

  export type MountainUpsertWithoutLodgesInput = {
    update: XOR<MountainUpdateWithoutLodgesInput, MountainUncheckedUpdateWithoutLodgesInput>
    create: XOR<MountainCreateWithoutLodgesInput, MountainUncheckedCreateWithoutLodgesInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutLodgesInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutLodgesInput, MountainUncheckedUpdateWithoutLodgesInput>
  }

  export type MountainUpdateWithoutLodgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUpdateManyWithoutMountainNestedInput
    locations?: LocationUpdateManyWithoutMountainNestedInput
    areas?: AreaUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutLodgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMountainNestedInput
    areas?: AreaUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type LocationUpsertWithoutLodgeInput = {
    update: XOR<LocationUpdateWithoutLodgeInput, LocationUncheckedUpdateWithoutLodgeInput>
    create: XOR<LocationCreateWithoutLodgeInput, LocationUncheckedCreateWithoutLodgeInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutLodgeInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutLodgeInput, LocationUncheckedUpdateWithoutLodgeInput>
  }

  export type LocationUpdateWithoutLodgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
    area?: AreaUpdateOneWithoutLocationsNestedInput
    mountain?: MountainUpdateOneRequiredWithoutLocationsNestedInput
    lift?: LiftUpdateOneWithoutLocationNestedInput
    trail?: TrailUpdateOneWithoutLocationNestedInput
    hut?: HutUpdateOneWithoutLocationNestedInput
    aidRoom?: AidRoomUpdateOneWithoutLocationNestedInput
    hours?: HoursUpdateManyWithoutLocationNestedInput
    equipment?: EquipmentUpdateManyWithoutLocationNestedInput
    incidents?: IncidentUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutLodgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
    lift?: LiftUncheckedUpdateOneWithoutLocationNestedInput
    trail?: TrailUncheckedUpdateOneWithoutLocationNestedInput
    hut?: HutUncheckedUpdateOneWithoutLocationNestedInput
    aidRoom?: AidRoomUncheckedUpdateOneWithoutLocationNestedInput
    hours?: HoursUncheckedUpdateManyWithoutLocationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutLocationNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type MountainCreateWithoutHutsInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherCreateNestedManyWithoutMountainInput
    locations?: LocationCreateNestedManyWithoutMountainInput
    areas?: AreaCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    lifts?: LiftCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutHutsInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
    locations?: LocationUncheckedCreateNestedManyWithoutMountainInput
    areas?: AreaUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutHutsInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutHutsInput, MountainUncheckedCreateWithoutHutsInput>
  }

  export type HutCheckCreateWithoutHutInput = {
    id?: string
    recordedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutHutChecksInput
    mountain: MountainCreateNestedOneWithoutHutChecksInput
  }

  export type HutCheckUncheckedCreateWithoutHutInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    mountainId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HutCheckCreateOrConnectWithoutHutInput = {
    where: HutCheckWhereUniqueInput
    create: XOR<HutCheckCreateWithoutHutInput, HutCheckUncheckedCreateWithoutHutInput>
  }

  export type HutCheckCreateManyHutInputEnvelope = {
    data: HutCheckCreateManyHutInput | HutCheckCreateManyHutInput[]
    skipDuplicates?: boolean
  }

  export type LocationCreateWithoutHutInput = {
    id?: string
    name: string
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    area?: AreaCreateNestedOneWithoutLocationsInput
    mountain: MountainCreateNestedOneWithoutLocationsInput
    lift?: LiftCreateNestedOneWithoutLocationInput
    trail?: TrailCreateNestedOneWithoutLocationInput
    lodge?: LodgeCreateNestedOneWithoutLocationInput
    aidRoom?: AidRoomCreateNestedOneWithoutLocationInput
    hours?: HoursCreateNestedManyWithoutLocationInput
    equipment?: EquipmentCreateNestedManyWithoutLocationInput
    incidents?: IncidentCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutHutInput = {
    id?: string
    mountainId: string
    name: string
    areaId?: string | null
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    lift?: LiftUncheckedCreateNestedOneWithoutLocationInput
    trail?: TrailUncheckedCreateNestedOneWithoutLocationInput
    lodge?: LodgeUncheckedCreateNestedOneWithoutLocationInput
    aidRoom?: AidRoomUncheckedCreateNestedOneWithoutLocationInput
    hours?: HoursUncheckedCreateNestedManyWithoutLocationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutLocationInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutHutInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutHutInput, LocationUncheckedCreateWithoutHutInput>
  }

  export type MountainUpsertWithoutHutsInput = {
    update: XOR<MountainUpdateWithoutHutsInput, MountainUncheckedUpdateWithoutHutsInput>
    create: XOR<MountainCreateWithoutHutsInput, MountainUncheckedCreateWithoutHutsInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutHutsInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutHutsInput, MountainUncheckedUpdateWithoutHutsInput>
  }

  export type MountainUpdateWithoutHutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUpdateManyWithoutMountainNestedInput
    locations?: LocationUpdateManyWithoutMountainNestedInput
    areas?: AreaUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutHutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMountainNestedInput
    areas?: AreaUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type HutCheckUpsertWithWhereUniqueWithoutHutInput = {
    where: HutCheckWhereUniqueInput
    update: XOR<HutCheckUpdateWithoutHutInput, HutCheckUncheckedUpdateWithoutHutInput>
    create: XOR<HutCheckCreateWithoutHutInput, HutCheckUncheckedCreateWithoutHutInput>
  }

  export type HutCheckUpdateWithWhereUniqueWithoutHutInput = {
    where: HutCheckWhereUniqueInput
    data: XOR<HutCheckUpdateWithoutHutInput, HutCheckUncheckedUpdateWithoutHutInput>
  }

  export type HutCheckUpdateManyWithWhereWithoutHutInput = {
    where: HutCheckScalarWhereInput
    data: XOR<HutCheckUpdateManyMutationInput, HutCheckUncheckedUpdateManyWithoutHutInput>
  }

  export type LocationUpsertWithoutHutInput = {
    update: XOR<LocationUpdateWithoutHutInput, LocationUncheckedUpdateWithoutHutInput>
    create: XOR<LocationCreateWithoutHutInput, LocationUncheckedCreateWithoutHutInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutHutInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutHutInput, LocationUncheckedUpdateWithoutHutInput>
  }

  export type LocationUpdateWithoutHutInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
    area?: AreaUpdateOneWithoutLocationsNestedInput
    mountain?: MountainUpdateOneRequiredWithoutLocationsNestedInput
    lift?: LiftUpdateOneWithoutLocationNestedInput
    trail?: TrailUpdateOneWithoutLocationNestedInput
    lodge?: LodgeUpdateOneWithoutLocationNestedInput
    aidRoom?: AidRoomUpdateOneWithoutLocationNestedInput
    hours?: HoursUpdateManyWithoutLocationNestedInput
    equipment?: EquipmentUpdateManyWithoutLocationNestedInput
    incidents?: IncidentUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutHutInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
    lift?: LiftUncheckedUpdateOneWithoutLocationNestedInput
    trail?: TrailUncheckedUpdateOneWithoutLocationNestedInput
    lodge?: LodgeUncheckedUpdateOneWithoutLocationNestedInput
    aidRoom?: AidRoomUncheckedUpdateOneWithoutLocationNestedInput
    hours?: HoursUncheckedUpdateManyWithoutLocationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutLocationNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type MountainCreateWithoutAidRoomsInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherCreateNestedManyWithoutMountainInput
    locations?: LocationCreateNestedManyWithoutMountainInput
    areas?: AreaCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    lifts?: LiftCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutAidRoomsInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
    locations?: LocationUncheckedCreateNestedManyWithoutMountainInput
    areas?: AreaUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutAidRoomsInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutAidRoomsInput, MountainUncheckedCreateWithoutAidRoomsInput>
  }

  export type AidRoomCheckCreateWithoutAidRoomInput = {
    id?: string
    recordedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutAidRoomChecksInput
    mountain: MountainCreateNestedOneWithoutAidRoomChecksInput
  }

  export type AidRoomCheckUncheckedCreateWithoutAidRoomInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    mountainId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AidRoomCheckCreateOrConnectWithoutAidRoomInput = {
    where: AidRoomCheckWhereUniqueInput
    create: XOR<AidRoomCheckCreateWithoutAidRoomInput, AidRoomCheckUncheckedCreateWithoutAidRoomInput>
  }

  export type AidRoomCheckCreateManyAidRoomInputEnvelope = {
    data: AidRoomCheckCreateManyAidRoomInput | AidRoomCheckCreateManyAidRoomInput[]
    skipDuplicates?: boolean
  }

  export type LocationCreateWithoutAidRoomInput = {
    id?: string
    name: string
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    area?: AreaCreateNestedOneWithoutLocationsInput
    mountain: MountainCreateNestedOneWithoutLocationsInput
    lift?: LiftCreateNestedOneWithoutLocationInput
    trail?: TrailCreateNestedOneWithoutLocationInput
    hut?: HutCreateNestedOneWithoutLocationInput
    lodge?: LodgeCreateNestedOneWithoutLocationInput
    hours?: HoursCreateNestedManyWithoutLocationInput
    equipment?: EquipmentCreateNestedManyWithoutLocationInput
    incidents?: IncidentCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutAidRoomInput = {
    id?: string
    mountainId: string
    name: string
    areaId?: string | null
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    lift?: LiftUncheckedCreateNestedOneWithoutLocationInput
    trail?: TrailUncheckedCreateNestedOneWithoutLocationInput
    hut?: HutUncheckedCreateNestedOneWithoutLocationInput
    lodge?: LodgeUncheckedCreateNestedOneWithoutLocationInput
    hours?: HoursUncheckedCreateNestedManyWithoutLocationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutLocationInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutAidRoomInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutAidRoomInput, LocationUncheckedCreateWithoutAidRoomInput>
  }

  export type MountainUpsertWithoutAidRoomsInput = {
    update: XOR<MountainUpdateWithoutAidRoomsInput, MountainUncheckedUpdateWithoutAidRoomsInput>
    create: XOR<MountainCreateWithoutAidRoomsInput, MountainUncheckedCreateWithoutAidRoomsInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutAidRoomsInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutAidRoomsInput, MountainUncheckedUpdateWithoutAidRoomsInput>
  }

  export type MountainUpdateWithoutAidRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUpdateManyWithoutMountainNestedInput
    locations?: LocationUpdateManyWithoutMountainNestedInput
    areas?: AreaUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutAidRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMountainNestedInput
    areas?: AreaUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type AidRoomCheckUpsertWithWhereUniqueWithoutAidRoomInput = {
    where: AidRoomCheckWhereUniqueInput
    update: XOR<AidRoomCheckUpdateWithoutAidRoomInput, AidRoomCheckUncheckedUpdateWithoutAidRoomInput>
    create: XOR<AidRoomCheckCreateWithoutAidRoomInput, AidRoomCheckUncheckedCreateWithoutAidRoomInput>
  }

  export type AidRoomCheckUpdateWithWhereUniqueWithoutAidRoomInput = {
    where: AidRoomCheckWhereUniqueInput
    data: XOR<AidRoomCheckUpdateWithoutAidRoomInput, AidRoomCheckUncheckedUpdateWithoutAidRoomInput>
  }

  export type AidRoomCheckUpdateManyWithWhereWithoutAidRoomInput = {
    where: AidRoomCheckScalarWhereInput
    data: XOR<AidRoomCheckUpdateManyMutationInput, AidRoomCheckUncheckedUpdateManyWithoutAidRoomInput>
  }

  export type LocationUpsertWithoutAidRoomInput = {
    update: XOR<LocationUpdateWithoutAidRoomInput, LocationUncheckedUpdateWithoutAidRoomInput>
    create: XOR<LocationCreateWithoutAidRoomInput, LocationUncheckedCreateWithoutAidRoomInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutAidRoomInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutAidRoomInput, LocationUncheckedUpdateWithoutAidRoomInput>
  }

  export type LocationUpdateWithoutAidRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
    area?: AreaUpdateOneWithoutLocationsNestedInput
    mountain?: MountainUpdateOneRequiredWithoutLocationsNestedInput
    lift?: LiftUpdateOneWithoutLocationNestedInput
    trail?: TrailUpdateOneWithoutLocationNestedInput
    hut?: HutUpdateOneWithoutLocationNestedInput
    lodge?: LodgeUpdateOneWithoutLocationNestedInput
    hours?: HoursUpdateManyWithoutLocationNestedInput
    equipment?: EquipmentUpdateManyWithoutLocationNestedInput
    incidents?: IncidentUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutAidRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
    lift?: LiftUncheckedUpdateOneWithoutLocationNestedInput
    trail?: TrailUncheckedUpdateOneWithoutLocationNestedInput
    hut?: HutUncheckedUpdateOneWithoutLocationNestedInput
    lodge?: LodgeUncheckedUpdateOneWithoutLocationNestedInput
    hours?: HoursUncheckedUpdateManyWithoutLocationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutLocationNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type MountainCreateWithoutEquipmentServiceLogsInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherCreateNestedManyWithoutMountainInput
    locations?: LocationCreateNestedManyWithoutMountainInput
    areas?: AreaCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    lifts?: LiftCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutEquipmentServiceLogsInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
    locations?: LocationUncheckedCreateNestedManyWithoutMountainInput
    areas?: AreaUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutEquipmentServiceLogsInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutEquipmentServiceLogsInput, MountainUncheckedCreateWithoutEquipmentServiceLogsInput>
  }

  export type EmployeeCreateWithoutEquipmentServiceLogsInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    role?: RoleCreateNestedOneWithoutEmployeesInput
    additionalRoles?: EmployeeRoleCreateNestedManyWithoutEmployeeInput
    mountainAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutEmployeeInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutEmployeeInput
    incidents?: IncidentCreateNestedManyWithoutEmployeesInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutEquipmentServiceLogsInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    roleId?: string | null
    additionalRoles?: EmployeeRoleUncheckedCreateNestedManyWithoutEmployeeInput
    mountainAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutEmployeesInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutEquipmentServiceLogsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutEquipmentServiceLogsInput, EmployeeUncheckedCreateWithoutEquipmentServiceLogsInput>
  }

  export type EquipmentCreateWithoutEquipmentServiceLogsInput = {
    id?: string
    name: string
    type: string
    status?: $Enums.EQUIPMENT_STATUS
    number?: number | null
    description?: string | null
    picture?: string | null
    cost?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    dateAdded?: Date | string
    mountain?: MountainCreateNestedOneWithoutEquipmentInput
    location?: LocationCreateNestedOneWithoutEquipmentInput
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogCreateNestedManyWithoutEquipmentInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutEquipmentServiceLogsInput = {
    id?: string
    name: string
    type: string
    status?: $Enums.EQUIPMENT_STATUS
    number?: number | null
    description?: string | null
    picture?: string | null
    cost?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    mountainId?: string | null
    locationId?: string | null
    dateAdded?: Date | string
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutEquipmentInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutEquipmentServiceLogsInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutEquipmentServiceLogsInput, EquipmentUncheckedCreateWithoutEquipmentServiceLogsInput>
  }

  export type MountainUpsertWithoutEquipmentServiceLogsInput = {
    update: XOR<MountainUpdateWithoutEquipmentServiceLogsInput, MountainUncheckedUpdateWithoutEquipmentServiceLogsInput>
    create: XOR<MountainCreateWithoutEquipmentServiceLogsInput, MountainUncheckedCreateWithoutEquipmentServiceLogsInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutEquipmentServiceLogsInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutEquipmentServiceLogsInput, MountainUncheckedUpdateWithoutEquipmentServiceLogsInput>
  }

  export type MountainUpdateWithoutEquipmentServiceLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUpdateManyWithoutMountainNestedInput
    locations?: LocationUpdateManyWithoutMountainNestedInput
    areas?: AreaUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutEquipmentServiceLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMountainNestedInput
    areas?: AreaUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type EmployeeUpsertWithoutEquipmentServiceLogsInput = {
    update: XOR<EmployeeUpdateWithoutEquipmentServiceLogsInput, EmployeeUncheckedUpdateWithoutEquipmentServiceLogsInput>
    create: XOR<EmployeeCreateWithoutEquipmentServiceLogsInput, EmployeeUncheckedCreateWithoutEquipmentServiceLogsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutEquipmentServiceLogsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutEquipmentServiceLogsInput, EmployeeUncheckedUpdateWithoutEquipmentServiceLogsInput>
  }

  export type EmployeeUpdateWithoutEquipmentServiceLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: RoleUpdateOneWithoutEmployeesNestedInput
    additionalRoles?: EmployeeRoleUpdateManyWithoutEmployeeNestedInput
    mountainAssignments?: EmployeeMountainAssignmentUpdateManyWithoutEmployeeNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutEmployeeNestedInput
    incidents?: IncidentUpdateManyWithoutEmployeesNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutEquipmentServiceLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalRoles?: EmployeeRoleUncheckedUpdateManyWithoutEmployeeNestedInput
    mountainAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutEmployeesNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EquipmentUpsertWithoutEquipmentServiceLogsInput = {
    update: XOR<EquipmentUpdateWithoutEquipmentServiceLogsInput, EquipmentUncheckedUpdateWithoutEquipmentServiceLogsInput>
    create: XOR<EquipmentCreateWithoutEquipmentServiceLogsInput, EquipmentUncheckedCreateWithoutEquipmentServiceLogsInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutEquipmentServiceLogsInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutEquipmentServiceLogsInput, EquipmentUncheckedUpdateWithoutEquipmentServiceLogsInput>
  }

  export type EquipmentUpdateWithoutEquipmentServiceLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    number?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateAdded?: DateTimeFieldUpdateOperationsInput | Date | string
    mountain?: MountainUpdateOneWithoutEquipmentNestedInput
    location?: LocationUpdateOneWithoutEquipmentNestedInput
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogUpdateManyWithoutEquipmentNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutEquipmentServiceLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    number?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountainId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    dateAdded?: DateTimeFieldUpdateOperationsInput | Date | string
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutEquipmentNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type MountainCreateWithoutEquipmentInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherCreateNestedManyWithoutMountainInput
    locations?: LocationCreateNestedManyWithoutMountainInput
    areas?: AreaCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    lifts?: LiftCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutEquipmentInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
    locations?: LocationUncheckedCreateNestedManyWithoutMountainInput
    areas?: AreaUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutEquipmentInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutEquipmentInput, MountainUncheckedCreateWithoutEquipmentInput>
  }

  export type LocationCreateWithoutEquipmentInput = {
    id?: string
    name: string
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    area?: AreaCreateNestedOneWithoutLocationsInput
    mountain: MountainCreateNestedOneWithoutLocationsInput
    lift?: LiftCreateNestedOneWithoutLocationInput
    trail?: TrailCreateNestedOneWithoutLocationInput
    hut?: HutCreateNestedOneWithoutLocationInput
    lodge?: LodgeCreateNestedOneWithoutLocationInput
    aidRoom?: AidRoomCreateNestedOneWithoutLocationInput
    hours?: HoursCreateNestedManyWithoutLocationInput
    incidents?: IncidentCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutEquipmentInput = {
    id?: string
    mountainId: string
    name: string
    areaId?: string | null
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    lift?: LiftUncheckedCreateNestedOneWithoutLocationInput
    trail?: TrailUncheckedCreateNestedOneWithoutLocationInput
    hut?: HutUncheckedCreateNestedOneWithoutLocationInput
    lodge?: LodgeUncheckedCreateNestedOneWithoutLocationInput
    aidRoom?: AidRoomUncheckedCreateNestedOneWithoutLocationInput
    hours?: HoursUncheckedCreateNestedManyWithoutLocationInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutEquipmentInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutEquipmentInput, LocationUncheckedCreateWithoutEquipmentInput>
  }

  export type IncidentEquipmentUsageLogCreateWithoutEquipmentInput = {
    id?: string
    usedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mountain: MountainCreateNestedOneWithoutIncidentEquipmentUsageLogInput
    incident: IncidentCreateNestedOneWithoutIncidentEquipmentUsageLogInput
  }

  export type IncidentEquipmentUsageLogUncheckedCreateWithoutEquipmentInput = {
    id?: string
    usedAt?: Date | string
    notes?: string | null
    mountainId: string
    incidentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentEquipmentUsageLogCreateOrConnectWithoutEquipmentInput = {
    where: IncidentEquipmentUsageLogWhereUniqueInput
    create: XOR<IncidentEquipmentUsageLogCreateWithoutEquipmentInput, IncidentEquipmentUsageLogUncheckedCreateWithoutEquipmentInput>
  }

  export type IncidentEquipmentUsageLogCreateManyEquipmentInputEnvelope = {
    data: IncidentEquipmentUsageLogCreateManyEquipmentInput | IncidentEquipmentUsageLogCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCheckCreateWithoutEquipmentInput = {
    id?: string
    recordedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutEquipmentChecksInput
    mountain: MountainCreateNestedOneWithoutEquipmentChecksInput
  }

  export type EquipmentCheckUncheckedCreateWithoutEquipmentInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    mountainId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentCheckCreateOrConnectWithoutEquipmentInput = {
    where: EquipmentCheckWhereUniqueInput
    create: XOR<EquipmentCheckCreateWithoutEquipmentInput, EquipmentCheckUncheckedCreateWithoutEquipmentInput>
  }

  export type EquipmentCheckCreateManyEquipmentInputEnvelope = {
    data: EquipmentCheckCreateManyEquipmentInput | EquipmentCheckCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentServiceLogCreateWithoutEquipmentInput = {
    id?: string
    status?: $Enums.EQUIPMENT_STATUS
    changedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mountain: MountainCreateNestedOneWithoutEquipmentServiceLogsInput
    employee?: EmployeeCreateNestedOneWithoutEquipmentServiceLogsInput
  }

  export type EquipmentServiceLogUncheckedCreateWithoutEquipmentInput = {
    id?: string
    mountainId: string
    employeeId?: string | null
    status?: $Enums.EQUIPMENT_STATUS
    changedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentServiceLogCreateOrConnectWithoutEquipmentInput = {
    where: EquipmentServiceLogWhereUniqueInput
    create: XOR<EquipmentServiceLogCreateWithoutEquipmentInput, EquipmentServiceLogUncheckedCreateWithoutEquipmentInput>
  }

  export type EquipmentServiceLogCreateManyEquipmentInputEnvelope = {
    data: EquipmentServiceLogCreateManyEquipmentInput | EquipmentServiceLogCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type MountainUpsertWithoutEquipmentInput = {
    update: XOR<MountainUpdateWithoutEquipmentInput, MountainUncheckedUpdateWithoutEquipmentInput>
    create: XOR<MountainCreateWithoutEquipmentInput, MountainUncheckedCreateWithoutEquipmentInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutEquipmentInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutEquipmentInput, MountainUncheckedUpdateWithoutEquipmentInput>
  }

  export type MountainUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUpdateManyWithoutMountainNestedInput
    locations?: LocationUpdateManyWithoutMountainNestedInput
    areas?: AreaUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMountainNestedInput
    areas?: AreaUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type LocationUpsertWithoutEquipmentInput = {
    update: XOR<LocationUpdateWithoutEquipmentInput, LocationUncheckedUpdateWithoutEquipmentInput>
    create: XOR<LocationCreateWithoutEquipmentInput, LocationUncheckedCreateWithoutEquipmentInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutEquipmentInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutEquipmentInput, LocationUncheckedUpdateWithoutEquipmentInput>
  }

  export type LocationUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
    area?: AreaUpdateOneWithoutLocationsNestedInput
    mountain?: MountainUpdateOneRequiredWithoutLocationsNestedInput
    lift?: LiftUpdateOneWithoutLocationNestedInput
    trail?: TrailUpdateOneWithoutLocationNestedInput
    hut?: HutUpdateOneWithoutLocationNestedInput
    lodge?: LodgeUpdateOneWithoutLocationNestedInput
    aidRoom?: AidRoomUpdateOneWithoutLocationNestedInput
    hours?: HoursUpdateManyWithoutLocationNestedInput
    incidents?: IncidentUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
    lift?: LiftUncheckedUpdateOneWithoutLocationNestedInput
    trail?: TrailUncheckedUpdateOneWithoutLocationNestedInput
    hut?: HutUncheckedUpdateOneWithoutLocationNestedInput
    lodge?: LodgeUncheckedUpdateOneWithoutLocationNestedInput
    aidRoom?: AidRoomUncheckedUpdateOneWithoutLocationNestedInput
    hours?: HoursUncheckedUpdateManyWithoutLocationNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type IncidentEquipmentUsageLogUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: IncidentEquipmentUsageLogWhereUniqueInput
    update: XOR<IncidentEquipmentUsageLogUpdateWithoutEquipmentInput, IncidentEquipmentUsageLogUncheckedUpdateWithoutEquipmentInput>
    create: XOR<IncidentEquipmentUsageLogCreateWithoutEquipmentInput, IncidentEquipmentUsageLogUncheckedCreateWithoutEquipmentInput>
  }

  export type IncidentEquipmentUsageLogUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: IncidentEquipmentUsageLogWhereUniqueInput
    data: XOR<IncidentEquipmentUsageLogUpdateWithoutEquipmentInput, IncidentEquipmentUsageLogUncheckedUpdateWithoutEquipmentInput>
  }

  export type IncidentEquipmentUsageLogUpdateManyWithWhereWithoutEquipmentInput = {
    where: IncidentEquipmentUsageLogScalarWhereInput
    data: XOR<IncidentEquipmentUsageLogUpdateManyMutationInput, IncidentEquipmentUsageLogUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type EquipmentCheckUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: EquipmentCheckWhereUniqueInput
    update: XOR<EquipmentCheckUpdateWithoutEquipmentInput, EquipmentCheckUncheckedUpdateWithoutEquipmentInput>
    create: XOR<EquipmentCheckCreateWithoutEquipmentInput, EquipmentCheckUncheckedCreateWithoutEquipmentInput>
  }

  export type EquipmentCheckUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: EquipmentCheckWhereUniqueInput
    data: XOR<EquipmentCheckUpdateWithoutEquipmentInput, EquipmentCheckUncheckedUpdateWithoutEquipmentInput>
  }

  export type EquipmentCheckUpdateManyWithWhereWithoutEquipmentInput = {
    where: EquipmentCheckScalarWhereInput
    data: XOR<EquipmentCheckUpdateManyMutationInput, EquipmentCheckUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type EquipmentServiceLogUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: EquipmentServiceLogWhereUniqueInput
    update: XOR<EquipmentServiceLogUpdateWithoutEquipmentInput, EquipmentServiceLogUncheckedUpdateWithoutEquipmentInput>
    create: XOR<EquipmentServiceLogCreateWithoutEquipmentInput, EquipmentServiceLogUncheckedCreateWithoutEquipmentInput>
  }

  export type EquipmentServiceLogUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: EquipmentServiceLogWhereUniqueInput
    data: XOR<EquipmentServiceLogUpdateWithoutEquipmentInput, EquipmentServiceLogUncheckedUpdateWithoutEquipmentInput>
  }

  export type EquipmentServiceLogUpdateManyWithWhereWithoutEquipmentInput = {
    where: EquipmentServiceLogScalarWhereInput
    data: XOR<EquipmentServiceLogUpdateManyMutationInput, EquipmentServiceLogUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type MountainCreateWithoutIncidentsInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherCreateNestedManyWithoutMountainInput
    locations?: LocationCreateNestedManyWithoutMountainInput
    areas?: AreaCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    lifts?: LiftCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutIncidentsInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
    locations?: LocationUncheckedCreateNestedManyWithoutMountainInput
    areas?: AreaUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutIncidentsInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutIncidentsInput, MountainUncheckedCreateWithoutIncidentsInput>
  }

  export type IncidentEquipmentUsageLogCreateWithoutIncidentInput = {
    id?: string
    usedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mountain: MountainCreateNestedOneWithoutIncidentEquipmentUsageLogInput
    equipment: EquipmentCreateNestedOneWithoutIncidentEquipmentUsageLogsInput
  }

  export type IncidentEquipmentUsageLogUncheckedCreateWithoutIncidentInput = {
    id?: string
    usedAt?: Date | string
    notes?: string | null
    mountainId: string
    equipmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentEquipmentUsageLogCreateOrConnectWithoutIncidentInput = {
    where: IncidentEquipmentUsageLogWhereUniqueInput
    create: XOR<IncidentEquipmentUsageLogCreateWithoutIncidentInput, IncidentEquipmentUsageLogUncheckedCreateWithoutIncidentInput>
  }

  export type IncidentEquipmentUsageLogCreateManyIncidentInputEnvelope = {
    data: IncidentEquipmentUsageLogCreateManyIncidentInput | IncidentEquipmentUsageLogCreateManyIncidentInput[]
    skipDuplicates?: boolean
  }

  export type LocationCreateWithoutIncidentsInput = {
    id?: string
    name: string
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    area?: AreaCreateNestedOneWithoutLocationsInput
    mountain: MountainCreateNestedOneWithoutLocationsInput
    lift?: LiftCreateNestedOneWithoutLocationInput
    trail?: TrailCreateNestedOneWithoutLocationInput
    hut?: HutCreateNestedOneWithoutLocationInput
    lodge?: LodgeCreateNestedOneWithoutLocationInput
    aidRoom?: AidRoomCreateNestedOneWithoutLocationInput
    hours?: HoursCreateNestedManyWithoutLocationInput
    equipment?: EquipmentCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutIncidentsInput = {
    id?: string
    mountainId: string
    name: string
    areaId?: string | null
    entityId: string
    entityType: $Enums.LOCATION_TYPE
    lift?: LiftUncheckedCreateNestedOneWithoutLocationInput
    trail?: TrailUncheckedCreateNestedOneWithoutLocationInput
    hut?: HutUncheckedCreateNestedOneWithoutLocationInput
    lodge?: LodgeUncheckedCreateNestedOneWithoutLocationInput
    aidRoom?: AidRoomUncheckedCreateNestedOneWithoutLocationInput
    hours?: HoursUncheckedCreateNestedManyWithoutLocationInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutIncidentsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutIncidentsInput, LocationUncheckedCreateWithoutIncidentsInput>
  }

  export type EmployeeCreateWithoutIncidentsInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    role?: RoleCreateNestedOneWithoutEmployeesInput
    additionalRoles?: EmployeeRoleCreateNestedManyWithoutEmployeeInput
    mountainAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutEmployeeInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutEmployeeInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEmployeeInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutIncidentsInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    roleId?: string | null
    additionalRoles?: EmployeeRoleUncheckedCreateNestedManyWithoutEmployeeInput
    mountainAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutIncidentsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutIncidentsInput, EmployeeUncheckedCreateWithoutIncidentsInput>
  }

  export type MountainUpsertWithoutIncidentsInput = {
    update: XOR<MountainUpdateWithoutIncidentsInput, MountainUncheckedUpdateWithoutIncidentsInput>
    create: XOR<MountainCreateWithoutIncidentsInput, MountainUncheckedCreateWithoutIncidentsInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutIncidentsInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutIncidentsInput, MountainUncheckedUpdateWithoutIncidentsInput>
  }

  export type MountainUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUpdateManyWithoutMountainNestedInput
    locations?: LocationUpdateManyWithoutMountainNestedInput
    areas?: AreaUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMountainNestedInput
    areas?: AreaUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type IncidentEquipmentUsageLogUpsertWithWhereUniqueWithoutIncidentInput = {
    where: IncidentEquipmentUsageLogWhereUniqueInput
    update: XOR<IncidentEquipmentUsageLogUpdateWithoutIncidentInput, IncidentEquipmentUsageLogUncheckedUpdateWithoutIncidentInput>
    create: XOR<IncidentEquipmentUsageLogCreateWithoutIncidentInput, IncidentEquipmentUsageLogUncheckedCreateWithoutIncidentInput>
  }

  export type IncidentEquipmentUsageLogUpdateWithWhereUniqueWithoutIncidentInput = {
    where: IncidentEquipmentUsageLogWhereUniqueInput
    data: XOR<IncidentEquipmentUsageLogUpdateWithoutIncidentInput, IncidentEquipmentUsageLogUncheckedUpdateWithoutIncidentInput>
  }

  export type IncidentEquipmentUsageLogUpdateManyWithWhereWithoutIncidentInput = {
    where: IncidentEquipmentUsageLogScalarWhereInput
    data: XOR<IncidentEquipmentUsageLogUpdateManyMutationInput, IncidentEquipmentUsageLogUncheckedUpdateManyWithoutIncidentInput>
  }

  export type LocationUpsertWithoutIncidentsInput = {
    update: XOR<LocationUpdateWithoutIncidentsInput, LocationUncheckedUpdateWithoutIncidentsInput>
    create: XOR<LocationCreateWithoutIncidentsInput, LocationUncheckedCreateWithoutIncidentsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutIncidentsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutIncidentsInput, LocationUncheckedUpdateWithoutIncidentsInput>
  }

  export type LocationUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
    area?: AreaUpdateOneWithoutLocationsNestedInput
    mountain?: MountainUpdateOneRequiredWithoutLocationsNestedInput
    lift?: LiftUpdateOneWithoutLocationNestedInput
    trail?: TrailUpdateOneWithoutLocationNestedInput
    hut?: HutUpdateOneWithoutLocationNestedInput
    lodge?: LodgeUpdateOneWithoutLocationNestedInput
    aidRoom?: AidRoomUpdateOneWithoutLocationNestedInput
    hours?: HoursUpdateManyWithoutLocationNestedInput
    equipment?: EquipmentUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
    lift?: LiftUncheckedUpdateOneWithoutLocationNestedInput
    trail?: TrailUncheckedUpdateOneWithoutLocationNestedInput
    hut?: HutUncheckedUpdateOneWithoutLocationNestedInput
    lodge?: LodgeUncheckedUpdateOneWithoutLocationNestedInput
    aidRoom?: AidRoomUncheckedUpdateOneWithoutLocationNestedInput
    hours?: HoursUncheckedUpdateManyWithoutLocationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type EmployeeUpsertWithWhereUniqueWithoutIncidentsInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutIncidentsInput, EmployeeUncheckedUpdateWithoutIncidentsInput>
    create: XOR<EmployeeCreateWithoutIncidentsInput, EmployeeUncheckedCreateWithoutIncidentsInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutIncidentsInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutIncidentsInput, EmployeeUncheckedUpdateWithoutIncidentsInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutIncidentsInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutIncidentsInput>
  }

  export type MountainCreateWithoutIncidentEquipmentUsageLogInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherCreateNestedManyWithoutMountainInput
    locations?: LocationCreateNestedManyWithoutMountainInput
    areas?: AreaCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    lifts?: LiftCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutIncidentEquipmentUsageLogInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
    locations?: LocationUncheckedCreateNestedManyWithoutMountainInput
    areas?: AreaUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutIncidentEquipmentUsageLogInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutIncidentEquipmentUsageLogInput, MountainUncheckedCreateWithoutIncidentEquipmentUsageLogInput>
  }

  export type IncidentCreateWithoutIncidentEquipmentUsageLogInput = {
    id?: string
    description: string
    status?: $Enums.INCIDENT_STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    startTime?: Date | string
    endTime?: Date | string | null
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    emptyRun?: boolean
    emptyRunAt?: Date | string | null
    mountain: MountainCreateNestedOneWithoutIncidentsInput
    location: LocationCreateNestedOneWithoutIncidentsInput
    employees?: EmployeeCreateNestedManyWithoutIncidentsInput
  }

  export type IncidentUncheckedCreateWithoutIncidentEquipmentUsageLogInput = {
    id?: string
    description: string
    status?: $Enums.INCIDENT_STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    mountainId: string
    startTime?: Date | string
    endTime?: Date | string | null
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    emptyRun?: boolean
    emptyRunAt?: Date | string | null
    locationId: string
    employees?: EmployeeUncheckedCreateNestedManyWithoutIncidentsInput
  }

  export type IncidentCreateOrConnectWithoutIncidentEquipmentUsageLogInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutIncidentEquipmentUsageLogInput, IncidentUncheckedCreateWithoutIncidentEquipmentUsageLogInput>
  }

  export type EquipmentCreateWithoutIncidentEquipmentUsageLogsInput = {
    id?: string
    name: string
    type: string
    status?: $Enums.EQUIPMENT_STATUS
    number?: number | null
    description?: string | null
    picture?: string | null
    cost?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    dateAdded?: Date | string
    mountain?: MountainCreateNestedOneWithoutEquipmentInput
    location?: LocationCreateNestedOneWithoutEquipmentInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEquipmentInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutIncidentEquipmentUsageLogsInput = {
    id?: string
    name: string
    type: string
    status?: $Enums.EQUIPMENT_STATUS
    number?: number | null
    description?: string | null
    picture?: string | null
    cost?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    mountainId?: string | null
    locationId?: string | null
    dateAdded?: Date | string
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEquipmentInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutIncidentEquipmentUsageLogsInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutIncidentEquipmentUsageLogsInput, EquipmentUncheckedCreateWithoutIncidentEquipmentUsageLogsInput>
  }

  export type MountainUpsertWithoutIncidentEquipmentUsageLogInput = {
    update: XOR<MountainUpdateWithoutIncidentEquipmentUsageLogInput, MountainUncheckedUpdateWithoutIncidentEquipmentUsageLogInput>
    create: XOR<MountainCreateWithoutIncidentEquipmentUsageLogInput, MountainUncheckedCreateWithoutIncidentEquipmentUsageLogInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutIncidentEquipmentUsageLogInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutIncidentEquipmentUsageLogInput, MountainUncheckedUpdateWithoutIncidentEquipmentUsageLogInput>
  }

  export type MountainUpdateWithoutIncidentEquipmentUsageLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUpdateManyWithoutMountainNestedInput
    locations?: LocationUpdateManyWithoutMountainNestedInput
    areas?: AreaUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutIncidentEquipmentUsageLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMountainNestedInput
    areas?: AreaUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type IncidentUpsertWithoutIncidentEquipmentUsageLogInput = {
    update: XOR<IncidentUpdateWithoutIncidentEquipmentUsageLogInput, IncidentUncheckedUpdateWithoutIncidentEquipmentUsageLogInput>
    create: XOR<IncidentCreateWithoutIncidentEquipmentUsageLogInput, IncidentUncheckedCreateWithoutIncidentEquipmentUsageLogInput>
    where?: IncidentWhereInput
  }

  export type IncidentUpdateToOneWithWhereWithoutIncidentEquipmentUsageLogInput = {
    where?: IncidentWhereInput
    data: XOR<IncidentUpdateWithoutIncidentEquipmentUsageLogInput, IncidentUncheckedUpdateWithoutIncidentEquipmentUsageLogInput>
  }

  export type IncidentUpdateWithoutIncidentEquipmentUsageLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumINCIDENT_STATUSFieldUpdateOperationsInput | $Enums.INCIDENT_STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emptyRun?: BoolFieldUpdateOperationsInput | boolean
    emptyRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mountain?: MountainUpdateOneRequiredWithoutIncidentsNestedInput
    location?: LocationUpdateOneRequiredWithoutIncidentsNestedInput
    employees?: EmployeeUpdateManyWithoutIncidentsNestedInput
  }

  export type IncidentUncheckedUpdateWithoutIncidentEquipmentUsageLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumINCIDENT_STATUSFieldUpdateOperationsInput | $Enums.INCIDENT_STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountainId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emptyRun?: BoolFieldUpdateOperationsInput | boolean
    emptyRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    employees?: EmployeeUncheckedUpdateManyWithoutIncidentsNestedInput
  }

  export type EquipmentUpsertWithoutIncidentEquipmentUsageLogsInput = {
    update: XOR<EquipmentUpdateWithoutIncidentEquipmentUsageLogsInput, EquipmentUncheckedUpdateWithoutIncidentEquipmentUsageLogsInput>
    create: XOR<EquipmentCreateWithoutIncidentEquipmentUsageLogsInput, EquipmentUncheckedCreateWithoutIncidentEquipmentUsageLogsInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutIncidentEquipmentUsageLogsInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutIncidentEquipmentUsageLogsInput, EquipmentUncheckedUpdateWithoutIncidentEquipmentUsageLogsInput>
  }

  export type EquipmentUpdateWithoutIncidentEquipmentUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    number?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateAdded?: DateTimeFieldUpdateOperationsInput | Date | string
    mountain?: MountainUpdateOneWithoutEquipmentNestedInput
    location?: LocationUpdateOneWithoutEquipmentNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEquipmentNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutIncidentEquipmentUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    number?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountainId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    dateAdded?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEquipmentNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EmployeeCreateWithoutLiftChecksInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    role?: RoleCreateNestedOneWithoutEmployeesInput
    additionalRoles?: EmployeeRoleCreateNestedManyWithoutEmployeeInput
    mountainAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutEmployeeInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutEmployeeInput
    incidents?: IncidentCreateNestedManyWithoutEmployeesInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEmployeeInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutLiftChecksInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    roleId?: string | null
    additionalRoles?: EmployeeRoleUncheckedCreateNestedManyWithoutEmployeeInput
    mountainAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutEmployeesInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutLiftChecksInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutLiftChecksInput, EmployeeUncheckedCreateWithoutLiftChecksInput>
  }

  export type MountainCreateWithoutLiftChecksInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherCreateNestedManyWithoutMountainInput
    locations?: LocationCreateNestedManyWithoutMountainInput
    areas?: AreaCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    lifts?: LiftCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutLiftChecksInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
    locations?: LocationUncheckedCreateNestedManyWithoutMountainInput
    areas?: AreaUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutLiftChecksInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutLiftChecksInput, MountainUncheckedCreateWithoutLiftChecksInput>
  }

  export type LiftCreateWithoutLiftChecksInput = {
    id?: string
    name: string
    type: $Enums.LIFT_TYPE
    status?: $Enums.STATUS
    capacity: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    mountain: MountainCreateNestedOneWithoutLiftsInput
    location?: LocationCreateNestedOneWithoutLiftInput
  }

  export type LiftUncheckedCreateWithoutLiftChecksInput = {
    id?: string
    mountainId: string
    name: string
    type: $Enums.LIFT_TYPE
    status?: $Enums.STATUS
    capacity: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    locationId?: string | null
  }

  export type LiftCreateOrConnectWithoutLiftChecksInput = {
    where: LiftWhereUniqueInput
    create: XOR<LiftCreateWithoutLiftChecksInput, LiftUncheckedCreateWithoutLiftChecksInput>
  }

  export type EmployeeUpsertWithoutLiftChecksInput = {
    update: XOR<EmployeeUpdateWithoutLiftChecksInput, EmployeeUncheckedUpdateWithoutLiftChecksInput>
    create: XOR<EmployeeCreateWithoutLiftChecksInput, EmployeeUncheckedCreateWithoutLiftChecksInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutLiftChecksInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutLiftChecksInput, EmployeeUncheckedUpdateWithoutLiftChecksInput>
  }

  export type EmployeeUpdateWithoutLiftChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: RoleUpdateOneWithoutEmployeesNestedInput
    additionalRoles?: EmployeeRoleUpdateManyWithoutEmployeeNestedInput
    mountainAssignments?: EmployeeMountainAssignmentUpdateManyWithoutEmployeeNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutEmployeeNestedInput
    incidents?: IncidentUpdateManyWithoutEmployeesNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEmployeeNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutLiftChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalRoles?: EmployeeRoleUncheckedUpdateManyWithoutEmployeeNestedInput
    mountainAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutEmployeesNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type MountainUpsertWithoutLiftChecksInput = {
    update: XOR<MountainUpdateWithoutLiftChecksInput, MountainUncheckedUpdateWithoutLiftChecksInput>
    create: XOR<MountainCreateWithoutLiftChecksInput, MountainUncheckedCreateWithoutLiftChecksInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutLiftChecksInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutLiftChecksInput, MountainUncheckedUpdateWithoutLiftChecksInput>
  }

  export type MountainUpdateWithoutLiftChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUpdateManyWithoutMountainNestedInput
    locations?: LocationUpdateManyWithoutMountainNestedInput
    areas?: AreaUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutLiftChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMountainNestedInput
    areas?: AreaUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type LiftUpsertWithoutLiftChecksInput = {
    update: XOR<LiftUpdateWithoutLiftChecksInput, LiftUncheckedUpdateWithoutLiftChecksInput>
    create: XOR<LiftCreateWithoutLiftChecksInput, LiftUncheckedCreateWithoutLiftChecksInput>
    where?: LiftWhereInput
  }

  export type LiftUpdateToOneWithWhereWithoutLiftChecksInput = {
    where?: LiftWhereInput
    data: XOR<LiftUpdateWithoutLiftChecksInput, LiftUncheckedUpdateWithoutLiftChecksInput>
  }

  export type LiftUpdateWithoutLiftChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLIFT_TYPEFieldUpdateOperationsInput | $Enums.LIFT_TYPE
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    capacity?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountain?: MountainUpdateOneRequiredWithoutLiftsNestedInput
    location?: LocationUpdateOneWithoutLiftNestedInput
  }

  export type LiftUncheckedUpdateWithoutLiftChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLIFT_TYPEFieldUpdateOperationsInput | $Enums.LIFT_TYPE
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    capacity?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeCreateWithoutTrailChecksInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    role?: RoleCreateNestedOneWithoutEmployeesInput
    additionalRoles?: EmployeeRoleCreateNestedManyWithoutEmployeeInput
    mountainAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutEmployeeInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutEmployeeInput
    incidents?: IncidentCreateNestedManyWithoutEmployeesInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEmployeeInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutTrailChecksInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    roleId?: string | null
    additionalRoles?: EmployeeRoleUncheckedCreateNestedManyWithoutEmployeeInput
    mountainAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutEmployeesInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutTrailChecksInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutTrailChecksInput, EmployeeUncheckedCreateWithoutTrailChecksInput>
  }

  export type MountainCreateWithoutTrailChecksInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherCreateNestedManyWithoutMountainInput
    locations?: LocationCreateNestedManyWithoutMountainInput
    areas?: AreaCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    lifts?: LiftCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutTrailChecksInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
    locations?: LocationUncheckedCreateNestedManyWithoutMountainInput
    areas?: AreaUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutTrailChecksInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutTrailChecksInput, MountainUncheckedCreateWithoutTrailChecksInput>
  }

  export type TrailCreateWithoutTrailChecksInput = {
    id?: string
    name: string
    difficulty: $Enums.TRAIL_DIFFICULTY
    status?: $Enums.STATUS
    length: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    condition?: $Enums.TRAIL_CONDITION
    mountain: MountainCreateNestedOneWithoutTrailsInput
    location?: LocationCreateNestedOneWithoutTrailInput
  }

  export type TrailUncheckedCreateWithoutTrailChecksInput = {
    id?: string
    mountainId: string
    name: string
    difficulty: $Enums.TRAIL_DIFFICULTY
    status?: $Enums.STATUS
    length: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    condition?: $Enums.TRAIL_CONDITION
    locationId?: string | null
  }

  export type TrailCreateOrConnectWithoutTrailChecksInput = {
    where: TrailWhereUniqueInput
    create: XOR<TrailCreateWithoutTrailChecksInput, TrailUncheckedCreateWithoutTrailChecksInput>
  }

  export type EmployeeUpsertWithoutTrailChecksInput = {
    update: XOR<EmployeeUpdateWithoutTrailChecksInput, EmployeeUncheckedUpdateWithoutTrailChecksInput>
    create: XOR<EmployeeCreateWithoutTrailChecksInput, EmployeeUncheckedCreateWithoutTrailChecksInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutTrailChecksInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutTrailChecksInput, EmployeeUncheckedUpdateWithoutTrailChecksInput>
  }

  export type EmployeeUpdateWithoutTrailChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: RoleUpdateOneWithoutEmployeesNestedInput
    additionalRoles?: EmployeeRoleUpdateManyWithoutEmployeeNestedInput
    mountainAssignments?: EmployeeMountainAssignmentUpdateManyWithoutEmployeeNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutEmployeeNestedInput
    incidents?: IncidentUpdateManyWithoutEmployeesNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEmployeeNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutTrailChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalRoles?: EmployeeRoleUncheckedUpdateManyWithoutEmployeeNestedInput
    mountainAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutEmployeesNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type MountainUpsertWithoutTrailChecksInput = {
    update: XOR<MountainUpdateWithoutTrailChecksInput, MountainUncheckedUpdateWithoutTrailChecksInput>
    create: XOR<MountainCreateWithoutTrailChecksInput, MountainUncheckedCreateWithoutTrailChecksInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutTrailChecksInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutTrailChecksInput, MountainUncheckedUpdateWithoutTrailChecksInput>
  }

  export type MountainUpdateWithoutTrailChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUpdateManyWithoutMountainNestedInput
    locations?: LocationUpdateManyWithoutMountainNestedInput
    areas?: AreaUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutTrailChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMountainNestedInput
    areas?: AreaUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type TrailUpsertWithoutTrailChecksInput = {
    update: XOR<TrailUpdateWithoutTrailChecksInput, TrailUncheckedUpdateWithoutTrailChecksInput>
    create: XOR<TrailCreateWithoutTrailChecksInput, TrailUncheckedCreateWithoutTrailChecksInput>
    where?: TrailWhereInput
  }

  export type TrailUpdateToOneWithWhereWithoutTrailChecksInput = {
    where?: TrailWhereInput
    data: XOR<TrailUpdateWithoutTrailChecksInput, TrailUncheckedUpdateWithoutTrailChecksInput>
  }

  export type TrailUpdateWithoutTrailChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumTRAIL_DIFFICULTYFieldUpdateOperationsInput | $Enums.TRAIL_DIFFICULTY
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    length?: FloatFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition?: EnumTRAIL_CONDITIONFieldUpdateOperationsInput | $Enums.TRAIL_CONDITION
    mountain?: MountainUpdateOneRequiredWithoutTrailsNestedInput
    location?: LocationUpdateOneWithoutTrailNestedInput
  }

  export type TrailUncheckedUpdateWithoutTrailChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumTRAIL_DIFFICULTYFieldUpdateOperationsInput | $Enums.TRAIL_DIFFICULTY
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    length?: FloatFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition?: EnumTRAIL_CONDITIONFieldUpdateOperationsInput | $Enums.TRAIL_CONDITION
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeCreateWithoutHutChecksInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    role?: RoleCreateNestedOneWithoutEmployeesInput
    additionalRoles?: EmployeeRoleCreateNestedManyWithoutEmployeeInput
    mountainAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutEmployeeInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutEmployeeInput
    incidents?: IncidentCreateNestedManyWithoutEmployeesInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEmployeeInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutHutChecksInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    roleId?: string | null
    additionalRoles?: EmployeeRoleUncheckedCreateNestedManyWithoutEmployeeInput
    mountainAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutEmployeesInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutHutChecksInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutHutChecksInput, EmployeeUncheckedCreateWithoutHutChecksInput>
  }

  export type MountainCreateWithoutHutChecksInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherCreateNestedManyWithoutMountainInput
    locations?: LocationCreateNestedManyWithoutMountainInput
    areas?: AreaCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    lifts?: LiftCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutHutChecksInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
    locations?: LocationUncheckedCreateNestedManyWithoutMountainInput
    areas?: AreaUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutHutChecksInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutHutChecksInput, MountainUncheckedCreateWithoutHutChecksInput>
  }

  export type HutCreateWithoutHutChecksInput = {
    id?: string
    name: string
    status?: $Enums.STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    mountain: MountainCreateNestedOneWithoutHutsInput
    location?: LocationCreateNestedOneWithoutHutInput
  }

  export type HutUncheckedCreateWithoutHutChecksInput = {
    id?: string
    mountainId: string
    name: string
    status?: $Enums.STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    locationId?: string | null
  }

  export type HutCreateOrConnectWithoutHutChecksInput = {
    where: HutWhereUniqueInput
    create: XOR<HutCreateWithoutHutChecksInput, HutUncheckedCreateWithoutHutChecksInput>
  }

  export type EmployeeUpsertWithoutHutChecksInput = {
    update: XOR<EmployeeUpdateWithoutHutChecksInput, EmployeeUncheckedUpdateWithoutHutChecksInput>
    create: XOR<EmployeeCreateWithoutHutChecksInput, EmployeeUncheckedCreateWithoutHutChecksInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutHutChecksInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutHutChecksInput, EmployeeUncheckedUpdateWithoutHutChecksInput>
  }

  export type EmployeeUpdateWithoutHutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: RoleUpdateOneWithoutEmployeesNestedInput
    additionalRoles?: EmployeeRoleUpdateManyWithoutEmployeeNestedInput
    mountainAssignments?: EmployeeMountainAssignmentUpdateManyWithoutEmployeeNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutEmployeeNestedInput
    incidents?: IncidentUpdateManyWithoutEmployeesNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEmployeeNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutHutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalRoles?: EmployeeRoleUncheckedUpdateManyWithoutEmployeeNestedInput
    mountainAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutEmployeesNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type MountainUpsertWithoutHutChecksInput = {
    update: XOR<MountainUpdateWithoutHutChecksInput, MountainUncheckedUpdateWithoutHutChecksInput>
    create: XOR<MountainCreateWithoutHutChecksInput, MountainUncheckedCreateWithoutHutChecksInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutHutChecksInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutHutChecksInput, MountainUncheckedUpdateWithoutHutChecksInput>
  }

  export type MountainUpdateWithoutHutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUpdateManyWithoutMountainNestedInput
    locations?: LocationUpdateManyWithoutMountainNestedInput
    areas?: AreaUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutHutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMountainNestedInput
    areas?: AreaUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type HutUpsertWithoutHutChecksInput = {
    update: XOR<HutUpdateWithoutHutChecksInput, HutUncheckedUpdateWithoutHutChecksInput>
    create: XOR<HutCreateWithoutHutChecksInput, HutUncheckedCreateWithoutHutChecksInput>
    where?: HutWhereInput
  }

  export type HutUpdateToOneWithWhereWithoutHutChecksInput = {
    where?: HutWhereInput
    data: XOR<HutUpdateWithoutHutChecksInput, HutUncheckedUpdateWithoutHutChecksInput>
  }

  export type HutUpdateWithoutHutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountain?: MountainUpdateOneRequiredWithoutHutsNestedInput
    location?: LocationUpdateOneWithoutHutNestedInput
  }

  export type HutUncheckedUpdateWithoutHutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeCreateWithoutAidRoomChecksInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    role?: RoleCreateNestedOneWithoutEmployeesInput
    additionalRoles?: EmployeeRoleCreateNestedManyWithoutEmployeeInput
    mountainAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutEmployeeInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutEmployeeInput
    incidents?: IncidentCreateNestedManyWithoutEmployeesInput
    hutChecks?: HutCheckCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEmployeeInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAidRoomChecksInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    roleId?: string | null
    additionalRoles?: EmployeeRoleUncheckedCreateNestedManyWithoutEmployeeInput
    mountainAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutEmployeesInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAidRoomChecksInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAidRoomChecksInput, EmployeeUncheckedCreateWithoutAidRoomChecksInput>
  }

  export type MountainCreateWithoutAidRoomChecksInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherCreateNestedManyWithoutMountainInput
    locations?: LocationCreateNestedManyWithoutMountainInput
    areas?: AreaCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    lifts?: LiftCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutAidRoomChecksInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
    locations?: LocationUncheckedCreateNestedManyWithoutMountainInput
    areas?: AreaUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutAidRoomChecksInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutAidRoomChecksInput, MountainUncheckedCreateWithoutAidRoomChecksInput>
  }

  export type AidRoomCreateWithoutAidRoomChecksInput = {
    id?: string
    name: string
    status?: $Enums.STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    mountain: MountainCreateNestedOneWithoutAidRoomsInput
    location?: LocationCreateNestedOneWithoutAidRoomInput
  }

  export type AidRoomUncheckedCreateWithoutAidRoomChecksInput = {
    id?: string
    mountainId: string
    name: string
    status?: $Enums.STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    locationId?: string | null
  }

  export type AidRoomCreateOrConnectWithoutAidRoomChecksInput = {
    where: AidRoomWhereUniqueInput
    create: XOR<AidRoomCreateWithoutAidRoomChecksInput, AidRoomUncheckedCreateWithoutAidRoomChecksInput>
  }

  export type EmployeeUpsertWithoutAidRoomChecksInput = {
    update: XOR<EmployeeUpdateWithoutAidRoomChecksInput, EmployeeUncheckedUpdateWithoutAidRoomChecksInput>
    create: XOR<EmployeeCreateWithoutAidRoomChecksInput, EmployeeUncheckedCreateWithoutAidRoomChecksInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAidRoomChecksInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAidRoomChecksInput, EmployeeUncheckedUpdateWithoutAidRoomChecksInput>
  }

  export type EmployeeUpdateWithoutAidRoomChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: RoleUpdateOneWithoutEmployeesNestedInput
    additionalRoles?: EmployeeRoleUpdateManyWithoutEmployeeNestedInput
    mountainAssignments?: EmployeeMountainAssignmentUpdateManyWithoutEmployeeNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutEmployeeNestedInput
    incidents?: IncidentUpdateManyWithoutEmployeesNestedInput
    hutChecks?: HutCheckUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEmployeeNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAidRoomChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalRoles?: EmployeeRoleUncheckedUpdateManyWithoutEmployeeNestedInput
    mountainAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutEmployeesNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type MountainUpsertWithoutAidRoomChecksInput = {
    update: XOR<MountainUpdateWithoutAidRoomChecksInput, MountainUncheckedUpdateWithoutAidRoomChecksInput>
    create: XOR<MountainCreateWithoutAidRoomChecksInput, MountainUncheckedCreateWithoutAidRoomChecksInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutAidRoomChecksInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutAidRoomChecksInput, MountainUncheckedUpdateWithoutAidRoomChecksInput>
  }

  export type MountainUpdateWithoutAidRoomChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUpdateManyWithoutMountainNestedInput
    locations?: LocationUpdateManyWithoutMountainNestedInput
    areas?: AreaUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutAidRoomChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMountainNestedInput
    areas?: AreaUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type AidRoomUpsertWithoutAidRoomChecksInput = {
    update: XOR<AidRoomUpdateWithoutAidRoomChecksInput, AidRoomUncheckedUpdateWithoutAidRoomChecksInput>
    create: XOR<AidRoomCreateWithoutAidRoomChecksInput, AidRoomUncheckedCreateWithoutAidRoomChecksInput>
    where?: AidRoomWhereInput
  }

  export type AidRoomUpdateToOneWithWhereWithoutAidRoomChecksInput = {
    where?: AidRoomWhereInput
    data: XOR<AidRoomUpdateWithoutAidRoomChecksInput, AidRoomUncheckedUpdateWithoutAidRoomChecksInput>
  }

  export type AidRoomUpdateWithoutAidRoomChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountain?: MountainUpdateOneRequiredWithoutAidRoomsNestedInput
    location?: LocationUpdateOneWithoutAidRoomNestedInput
  }

  export type AidRoomUncheckedUpdateWithoutAidRoomChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeCreateWithoutEquipmentChecksInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    role?: RoleCreateNestedOneWithoutEmployeesInput
    additionalRoles?: EmployeeRoleCreateNestedManyWithoutEmployeeInput
    mountainAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutEmployeeInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutEmployeeInput
    incidents?: IncidentCreateNestedManyWithoutEmployeesInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckCreateNestedManyWithoutEmployeeInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutEquipmentChecksInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
    roleId?: string | null
    additionalRoles?: EmployeeRoleUncheckedCreateNestedManyWithoutEmployeeInput
    mountainAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutEmployeesInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutEquipmentChecksInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutEquipmentChecksInput, EmployeeUncheckedCreateWithoutEquipmentChecksInput>
  }

  export type MountainCreateWithoutEquipmentChecksInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherCreateNestedManyWithoutMountainInput
    locations?: LocationCreateNestedManyWithoutMountainInput
    areas?: AreaCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    lifts?: LiftCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutEquipmentChecksInput = {
    id?: string
    name: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    height: number
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
    locations?: LocationUncheckedCreateNestedManyWithoutMountainInput
    areas?: AreaUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutMountainInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutEquipmentChecksInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutEquipmentChecksInput, MountainUncheckedCreateWithoutEquipmentChecksInput>
  }

  export type EquipmentCreateWithoutEquipmentChecksInput = {
    id?: string
    name: string
    type: string
    status?: $Enums.EQUIPMENT_STATUS
    number?: number | null
    description?: string | null
    picture?: string | null
    cost?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    dateAdded?: Date | string
    mountain?: MountainCreateNestedOneWithoutEquipmentInput
    location?: LocationCreateNestedOneWithoutEquipmentInput
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogCreateNestedManyWithoutEquipmentInput
    equipmentServiceLogs?: EquipmentServiceLogCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutEquipmentChecksInput = {
    id?: string
    name: string
    type: string
    status?: $Enums.EQUIPMENT_STATUS
    number?: number | null
    description?: string | null
    picture?: string | null
    cost?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    mountainId?: string | null
    locationId?: string | null
    dateAdded?: Date | string
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogUncheckedCreateNestedManyWithoutEquipmentInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutEquipmentChecksInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutEquipmentChecksInput, EquipmentUncheckedCreateWithoutEquipmentChecksInput>
  }

  export type EmployeeUpsertWithoutEquipmentChecksInput = {
    update: XOR<EmployeeUpdateWithoutEquipmentChecksInput, EmployeeUncheckedUpdateWithoutEquipmentChecksInput>
    create: XOR<EmployeeCreateWithoutEquipmentChecksInput, EmployeeUncheckedCreateWithoutEquipmentChecksInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutEquipmentChecksInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutEquipmentChecksInput, EmployeeUncheckedUpdateWithoutEquipmentChecksInput>
  }

  export type EmployeeUpdateWithoutEquipmentChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: RoleUpdateOneWithoutEmployeesNestedInput
    additionalRoles?: EmployeeRoleUpdateManyWithoutEmployeeNestedInput
    mountainAssignments?: EmployeeMountainAssignmentUpdateManyWithoutEmployeeNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutEmployeeNestedInput
    incidents?: IncidentUpdateManyWithoutEmployeesNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutEmployeeNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutEquipmentChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalRoles?: EmployeeRoleUncheckedUpdateManyWithoutEmployeeNestedInput
    mountainAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutEmployeesNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type MountainUpsertWithoutEquipmentChecksInput = {
    update: XOR<MountainUpdateWithoutEquipmentChecksInput, MountainUncheckedUpdateWithoutEquipmentChecksInput>
    create: XOR<MountainCreateWithoutEquipmentChecksInput, MountainUncheckedCreateWithoutEquipmentChecksInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutEquipmentChecksInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutEquipmentChecksInput, MountainUncheckedUpdateWithoutEquipmentChecksInput>
  }

  export type MountainUpdateWithoutEquipmentChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUpdateManyWithoutMountainNestedInput
    locations?: LocationUpdateManyWithoutMountainNestedInput
    areas?: AreaUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutEquipmentChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    height?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
    locations?: LocationUncheckedUpdateManyWithoutMountainNestedInput
    areas?: AreaUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    employeeAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutMountainNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type EquipmentUpsertWithoutEquipmentChecksInput = {
    update: XOR<EquipmentUpdateWithoutEquipmentChecksInput, EquipmentUncheckedUpdateWithoutEquipmentChecksInput>
    create: XOR<EquipmentCreateWithoutEquipmentChecksInput, EquipmentUncheckedCreateWithoutEquipmentChecksInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutEquipmentChecksInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutEquipmentChecksInput, EquipmentUncheckedUpdateWithoutEquipmentChecksInput>
  }

  export type EquipmentUpdateWithoutEquipmentChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    number?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateAdded?: DateTimeFieldUpdateOperationsInput | Date | string
    mountain?: MountainUpdateOneWithoutEquipmentNestedInput
    location?: LocationUpdateOneWithoutEquipmentNestedInput
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogUpdateManyWithoutEquipmentNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutEquipmentChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    number?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountainId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    dateAdded?: DateTimeFieldUpdateOperationsInput | Date | string
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutEquipmentNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type LocationCreateManyAreaInput = {
    id?: string
    mountainId: string
    name: string
    entityId: string
    entityType: $Enums.LOCATION_TYPE
  }

  export type LocationUpdateWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
    mountain?: MountainUpdateOneRequiredWithoutLocationsNestedInput
    lift?: LiftUpdateOneWithoutLocationNestedInput
    trail?: TrailUpdateOneWithoutLocationNestedInput
    hut?: HutUpdateOneWithoutLocationNestedInput
    lodge?: LodgeUpdateOneWithoutLocationNestedInput
    aidRoom?: AidRoomUpdateOneWithoutLocationNestedInput
    hours?: HoursUpdateManyWithoutLocationNestedInput
    equipment?: EquipmentUpdateManyWithoutLocationNestedInput
    incidents?: IncidentUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
    lift?: LiftUncheckedUpdateOneWithoutLocationNestedInput
    trail?: TrailUncheckedUpdateOneWithoutLocationNestedInput
    hut?: HutUncheckedUpdateOneWithoutLocationNestedInput
    lodge?: LodgeUncheckedUpdateOneWithoutLocationNestedInput
    aidRoom?: AidRoomUncheckedUpdateOneWithoutLocationNestedInput
    hours?: HoursUncheckedUpdateManyWithoutLocationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutLocationNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
  }

  export type HoursCreateManyLocationInput = {
    id?: string
    dayOfWeek?: number | null
    date?: Date | string | null
    openTime?: Date | string | null
    closeTime?: Date | string | null
    status?: $Enums.STATUS
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentCreateManyLocationInput = {
    id?: string
    name: string
    type: string
    status?: $Enums.EQUIPMENT_STATUS
    number?: number | null
    description?: string | null
    picture?: string | null
    cost?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    mountainId?: string | null
    dateAdded?: Date | string
  }

  export type IncidentCreateManyLocationInput = {
    id?: string
    description: string
    status?: $Enums.INCIDENT_STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    mountainId: string
    startTime?: Date | string
    endTime?: Date | string | null
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    emptyRun?: boolean
    emptyRunAt?: Date | string | null
  }

  export type HoursUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoursUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoursUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    number?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateAdded?: DateTimeFieldUpdateOperationsInput | Date | string
    mountain?: MountainUpdateOneWithoutEquipmentNestedInput
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogUpdateManyWithoutEquipmentNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEquipmentNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    number?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountainId?: NullableStringFieldUpdateOperationsInput | string | null
    dateAdded?: DateTimeFieldUpdateOperationsInput | Date | string
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutEquipmentNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEquipmentNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    number?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountainId?: NullableStringFieldUpdateOperationsInput | string | null
    dateAdded?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumINCIDENT_STATUSFieldUpdateOperationsInput | $Enums.INCIDENT_STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emptyRun?: BoolFieldUpdateOperationsInput | boolean
    emptyRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mountain?: MountainUpdateOneRequiredWithoutIncidentsNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutIncidentNestedInput
    employees?: EmployeeUpdateManyWithoutIncidentsNestedInput
  }

  export type IncidentUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumINCIDENT_STATUSFieldUpdateOperationsInput | $Enums.INCIDENT_STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountainId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emptyRun?: BoolFieldUpdateOperationsInput | boolean
    emptyRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutIncidentNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutIncidentsNestedInput
  }

  export type IncidentUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumINCIDENT_STATUSFieldUpdateOperationsInput | $Enums.INCIDENT_STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountainId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emptyRun?: BoolFieldUpdateOperationsInput | boolean
    emptyRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WeatherCreateManyMountainInput = {
    id?: string
    date?: Date | string
    temperature: number
    windSpeed: number
    windDirection?: string | null
    visibility?: number | null
    conditions: string
    snowfallRecent?: number | null
    snowfall24h?: number | null
    snowfall7d?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationCreateManyMountainInput = {
    id?: string
    name: string
    areaId?: string | null
    entityId: string
    entityType: $Enums.LOCATION_TYPE
  }

  export type AreaCreateManyMountainInput = {
    id?: string
    name: string
    type: $Enums.AREA_TYPE
    description?: string | null
  }

  export type AidRoomCreateManyMountainInput = {
    id?: string
    name: string
    status?: $Enums.STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    locationId?: string | null
  }

  export type HutCreateManyMountainInput = {
    id?: string
    name: string
    status?: $Enums.STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    locationId?: string | null
  }

  export type LodgeCreateManyMountainInput = {
    id?: string
    name: string
    capacity: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.STATUS
    locationId?: string | null
  }

  export type LiftCreateManyMountainInput = {
    id?: string
    name: string
    type: $Enums.LIFT_TYPE
    status?: $Enums.STATUS
    capacity: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    locationId?: string | null
  }

  export type TrailCreateManyMountainInput = {
    id?: string
    name: string
    difficulty: $Enums.TRAIL_DIFFICULTY
    status?: $Enums.STATUS
    length: number
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    condition?: $Enums.TRAIL_CONDITION
    locationId?: string | null
  }

  export type AidRoomCheckCreateManyMountainInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    aidRoomId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HutCheckCreateManyMountainInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    hutId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiftCheckCreateManyMountainInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    liftId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrailCheckCreateManyMountainInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    trailId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentCheckCreateManyMountainInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    equipmentId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentCreateManyMountainInput = {
    id?: string
    description: string
    status?: $Enums.INCIDENT_STATUS
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    startTime?: Date | string
    endTime?: Date | string | null
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    emptyRun?: boolean
    emptyRunAt?: Date | string | null
    locationId: string
  }

  export type EquipmentCreateManyMountainInput = {
    id?: string
    name: string
    type: string
    status?: $Enums.EQUIPMENT_STATUS
    number?: number | null
    description?: string | null
    picture?: string | null
    cost?: number | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    locationId?: string | null
    dateAdded?: Date | string
  }

  export type EmployeeMountainAssignmentCreateManyMountainInput = {
    id?: string
    employeeId: string
    assignedAt: Date | string
  }

  export type DispatcherAssignmentCreateManyMountainInput = {
    id?: string
    employeeId: string
    assignedAt: Date | string
  }

  export type IncidentEquipmentUsageLogCreateManyMountainInput = {
    id?: string
    usedAt?: Date | string
    notes?: string | null
    equipmentId: string
    incidentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentServiceLogCreateManyMountainInput = {
    id?: string
    equipmentId: string
    employeeId?: string | null
    status?: $Enums.EQUIPMENT_STATUS
    changedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeatherUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    windSpeed?: FloatFieldUpdateOperationsInput | number
    windDirection?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: NullableFloatFieldUpdateOperationsInput | number | null
    conditions?: StringFieldUpdateOperationsInput | string
    snowfallRecent?: NullableFloatFieldUpdateOperationsInput | number | null
    snowfall24h?: NullableFloatFieldUpdateOperationsInput | number | null
    snowfall7d?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    windSpeed?: FloatFieldUpdateOperationsInput | number
    windDirection?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: NullableFloatFieldUpdateOperationsInput | number | null
    conditions?: StringFieldUpdateOperationsInput | string
    snowfallRecent?: NullableFloatFieldUpdateOperationsInput | number | null
    snowfall24h?: NullableFloatFieldUpdateOperationsInput | number | null
    snowfall7d?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    windSpeed?: FloatFieldUpdateOperationsInput | number
    windDirection?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: NullableFloatFieldUpdateOperationsInput | number | null
    conditions?: StringFieldUpdateOperationsInput | string
    snowfallRecent?: NullableFloatFieldUpdateOperationsInput | number | null
    snowfall24h?: NullableFloatFieldUpdateOperationsInput | number | null
    snowfall7d?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
    area?: AreaUpdateOneWithoutLocationsNestedInput
    lift?: LiftUpdateOneWithoutLocationNestedInput
    trail?: TrailUpdateOneWithoutLocationNestedInput
    hut?: HutUpdateOneWithoutLocationNestedInput
    lodge?: LodgeUpdateOneWithoutLocationNestedInput
    aidRoom?: AidRoomUpdateOneWithoutLocationNestedInput
    hours?: HoursUpdateManyWithoutLocationNestedInput
    equipment?: EquipmentUpdateManyWithoutLocationNestedInput
    incidents?: IncidentUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
    lift?: LiftUncheckedUpdateOneWithoutLocationNestedInput
    trail?: TrailUncheckedUpdateOneWithoutLocationNestedInput
    hut?: HutUncheckedUpdateOneWithoutLocationNestedInput
    lodge?: LodgeUncheckedUpdateOneWithoutLocationNestedInput
    aidRoom?: AidRoomUncheckedUpdateOneWithoutLocationNestedInput
    hours?: HoursUncheckedUpdateManyWithoutLocationNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutLocationNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumLOCATION_TYPEFieldUpdateOperationsInput | $Enums.LOCATION_TYPE
  }

  export type AreaUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAREA_TYPEFieldUpdateOperationsInput | $Enums.AREA_TYPE
    description?: NullableStringFieldUpdateOperationsInput | string | null
    locations?: LocationUpdateManyWithoutAreaNestedInput
  }

  export type AreaUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAREA_TYPEFieldUpdateOperationsInput | $Enums.AREA_TYPE
    description?: NullableStringFieldUpdateOperationsInput | string | null
    locations?: LocationUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type AreaUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAREA_TYPEFieldUpdateOperationsInput | $Enums.AREA_TYPE
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AidRoomUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutAidRoomNestedInput
    location?: LocationUpdateOneWithoutAidRoomNestedInput
  }

  export type AidRoomUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutAidRoomNestedInput
  }

  export type AidRoomUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HutUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hutChecks?: HutCheckUpdateManyWithoutHutNestedInput
    location?: LocationUpdateOneWithoutHutNestedInput
  }

  export type HutUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    hutChecks?: HutCheckUncheckedUpdateManyWithoutHutNestedInput
  }

  export type HutUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LodgeUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    location?: LocationUpdateOneWithoutLodgeNestedInput
  }

  export type LodgeUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LodgeUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LiftUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLIFT_TYPEFieldUpdateOperationsInput | $Enums.LIFT_TYPE
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    capacity?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    liftChecks?: LiftCheckUpdateManyWithoutLiftNestedInput
    location?: LocationUpdateOneWithoutLiftNestedInput
  }

  export type LiftUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLIFT_TYPEFieldUpdateOperationsInput | $Enums.LIFT_TYPE
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    capacity?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutLiftNestedInput
  }

  export type LiftUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLIFT_TYPEFieldUpdateOperationsInput | $Enums.LIFT_TYPE
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    capacity?: IntFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrailUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumTRAIL_DIFFICULTYFieldUpdateOperationsInput | $Enums.TRAIL_DIFFICULTY
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    length?: FloatFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition?: EnumTRAIL_CONDITIONFieldUpdateOperationsInput | $Enums.TRAIL_CONDITION
    trailChecks?: TrailCheckUpdateManyWithoutTrailNestedInput
    location?: LocationUpdateOneWithoutTrailNestedInput
  }

  export type TrailUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumTRAIL_DIFFICULTYFieldUpdateOperationsInput | $Enums.TRAIL_DIFFICULTY
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    length?: FloatFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition?: EnumTRAIL_CONDITIONFieldUpdateOperationsInput | $Enums.TRAIL_CONDITION
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutTrailNestedInput
  }

  export type TrailUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumTRAIL_DIFFICULTYFieldUpdateOperationsInput | $Enums.TRAIL_DIFFICULTY
    status?: EnumSTATUSFieldUpdateOperationsInput | $Enums.STATUS
    length?: FloatFieldUpdateOperationsInput | number
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition?: EnumTRAIL_CONDITIONFieldUpdateOperationsInput | $Enums.TRAIL_CONDITION
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AidRoomCheckUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutAidRoomChecksNestedInput
    aidRoom?: AidRoomUpdateOneRequiredWithoutAidRoomChecksNestedInput
  }

  export type AidRoomCheckUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aidRoomId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AidRoomCheckUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aidRoomId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HutCheckUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutHutChecksNestedInput
    hut?: HutUpdateOneRequiredWithoutHutChecksNestedInput
  }

  export type HutCheckUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    hutId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HutCheckUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    hutId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiftCheckUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutLiftChecksNestedInput
    lift?: LiftUpdateOneRequiredWithoutLiftChecksNestedInput
  }

  export type LiftCheckUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    liftId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiftCheckUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    liftId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrailCheckUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutTrailChecksNestedInput
    trail?: TrailUpdateOneRequiredWithoutTrailChecksNestedInput
  }

  export type TrailCheckUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    trailId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrailCheckUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    trailId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCheckUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutEquipmentChecksNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutEquipmentChecksNestedInput
  }

  export type EquipmentCheckUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCheckUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumINCIDENT_STATUSFieldUpdateOperationsInput | $Enums.INCIDENT_STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emptyRun?: BoolFieldUpdateOperationsInput | boolean
    emptyRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutIncidentNestedInput
    location?: LocationUpdateOneRequiredWithoutIncidentsNestedInput
    employees?: EmployeeUpdateManyWithoutIncidentsNestedInput
  }

  export type IncidentUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumINCIDENT_STATUSFieldUpdateOperationsInput | $Enums.INCIDENT_STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emptyRun?: BoolFieldUpdateOperationsInput | boolean
    emptyRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutIncidentNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutIncidentsNestedInput
  }

  export type IncidentUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumINCIDENT_STATUSFieldUpdateOperationsInput | $Enums.INCIDENT_STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emptyRun?: BoolFieldUpdateOperationsInput | boolean
    emptyRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
  }

  export type EquipmentUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    number?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateAdded?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutEquipmentNestedInput
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogUpdateManyWithoutEquipmentNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEquipmentNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    number?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    dateAdded?: DateTimeFieldUpdateOperationsInput | Date | string
    incidentEquipmentUsageLogs?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutEquipmentNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEquipmentNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    number?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    dateAdded?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeMountainAssignmentUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutMountainAssignmentsNestedInput
  }

  export type EmployeeMountainAssignmentUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeMountainAssignmentUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatcherAssignmentUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutDispatcherAssignmentsNestedInput
  }

  export type DispatcherAssignmentUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatcherAssignmentUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentEquipmentUsageLogUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incident?: IncidentUpdateOneRequiredWithoutIncidentEquipmentUsageLogNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutIncidentEquipmentUsageLogsNestedInput
  }

  export type IncidentEquipmentUsageLogUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentEquipmentUsageLogUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentServiceLogUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutEquipmentServiceLogsNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutEquipmentServiceLogsNestedInput
  }

  export type EquipmentServiceLogUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentServiceLogUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyRoleInput = {
    id?: string
    employeeIdNumber: number
    email: string
    phoneNumber: string
    name: string
  }

  export type EmployeeRoleCreateManyRoleInput = {
    id?: string
    employeeId: string
  }

  export type EmployeeUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    additionalRoles?: EmployeeRoleUpdateManyWithoutEmployeeNestedInput
    mountainAssignments?: EmployeeMountainAssignmentUpdateManyWithoutEmployeeNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutEmployeeNestedInput
    incidents?: IncidentUpdateManyWithoutEmployeesNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEmployeeNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    additionalRoles?: EmployeeRoleUncheckedUpdateManyWithoutEmployeeNestedInput
    mountainAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutEmployeesNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeRoleUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee?: EmployeeUpdateOneRequiredWithoutAdditionalRolesNestedInput
  }

  export type EmployeeRoleUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeRoleUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeRoleCreateManyEmployeeInput = {
    id?: string
    roleId: string
  }

  export type EmployeeMountainAssignmentCreateManyEmployeeInput = {
    id?: string
    mountainId: string
    assignedAt: Date | string
  }

  export type DispatcherAssignmentCreateManyEmployeeInput = {
    id?: string
    mountainId: string
    assignedAt: Date | string
  }

  export type AidRoomCheckCreateManyEmployeeInput = {
    id?: string
    recordedAt?: Date | string
    mountainId: string
    aidRoomId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HutCheckCreateManyEmployeeInput = {
    id?: string
    recordedAt?: Date | string
    mountainId: string
    hutId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiftCheckCreateManyEmployeeInput = {
    id?: string
    recordedAt?: Date | string
    mountainId: string
    liftId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrailCheckCreateManyEmployeeInput = {
    id?: string
    recordedAt?: Date | string
    mountainId: string
    trailId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentCheckCreateManyEmployeeInput = {
    id?: string
    recordedAt?: Date | string
    mountainId: string
    equipmentId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentServiceLogCreateManyEmployeeInput = {
    id?: string
    mountainId: string
    equipmentId: string
    status?: $Enums.EQUIPMENT_STATUS
    changedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeRoleUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: RoleUpdateOneRequiredWithoutEmployeeRoleNestedInput
  }

  export type EmployeeRoleUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeRoleUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeMountainAssignmentUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountain?: MountainUpdateOneRequiredWithoutEmployeeAssignmentsNestedInput
  }

  export type EmployeeMountainAssignmentUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeMountainAssignmentUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatcherAssignmentUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountain?: MountainUpdateOneRequiredWithoutDispatcherAssignmentsNestedInput
  }

  export type DispatcherAssignmentUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumINCIDENT_STATUSFieldUpdateOperationsInput | $Enums.INCIDENT_STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emptyRun?: BoolFieldUpdateOperationsInput | boolean
    emptyRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mountain?: MountainUpdateOneRequiredWithoutIncidentsNestedInput
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUpdateManyWithoutIncidentNestedInput
    location?: LocationUpdateOneRequiredWithoutIncidentsNestedInput
  }

  export type IncidentUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumINCIDENT_STATUSFieldUpdateOperationsInput | $Enums.INCIDENT_STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountainId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emptyRun?: BoolFieldUpdateOperationsInput | boolean
    emptyRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    incidentEquipmentUsageLog?: IncidentEquipmentUsageLogUncheckedUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateManyWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumINCIDENT_STATUSFieldUpdateOperationsInput | $Enums.INCIDENT_STATUS
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mountainId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emptyRun?: BoolFieldUpdateOperationsInput | boolean
    emptyRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
  }

  export type AidRoomCheckUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountain?: MountainUpdateOneRequiredWithoutAidRoomChecksNestedInput
    aidRoom?: AidRoomUpdateOneRequiredWithoutAidRoomChecksNestedInput
  }

  export type AidRoomCheckUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
    aidRoomId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AidRoomCheckUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
    aidRoomId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HutCheckUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountain?: MountainUpdateOneRequiredWithoutHutChecksNestedInput
    hut?: HutUpdateOneRequiredWithoutHutChecksNestedInput
  }

  export type HutCheckUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
    hutId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HutCheckUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
    hutId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiftCheckUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountain?: MountainUpdateOneRequiredWithoutLiftChecksNestedInput
    lift?: LiftUpdateOneRequiredWithoutLiftChecksNestedInput
  }

  export type LiftCheckUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
    liftId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiftCheckUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
    liftId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrailCheckUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountain?: MountainUpdateOneRequiredWithoutTrailChecksNestedInput
    trail?: TrailUpdateOneRequiredWithoutTrailChecksNestedInput
  }

  export type TrailCheckUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
    trailId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrailCheckUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
    trailId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCheckUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountain?: MountainUpdateOneRequiredWithoutEquipmentChecksNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutEquipmentChecksNestedInput
  }

  export type EquipmentCheckUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCheckUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentServiceLogUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountain?: MountainUpdateOneRequiredWithoutEquipmentServiceLogsNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutEquipmentServiceLogsNestedInput
  }

  export type EquipmentServiceLogUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentServiceLogUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiftCheckCreateManyLiftInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    mountainId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiftCheckUpdateWithoutLiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutLiftChecksNestedInput
    mountain?: MountainUpdateOneRequiredWithoutLiftChecksNestedInput
  }

  export type LiftCheckUncheckedUpdateWithoutLiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiftCheckUncheckedUpdateManyWithoutLiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrailCheckCreateManyTrailInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    mountainId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrailCheckUpdateWithoutTrailInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutTrailChecksNestedInput
    mountain?: MountainUpdateOneRequiredWithoutTrailChecksNestedInput
  }

  export type TrailCheckUncheckedUpdateWithoutTrailInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrailCheckUncheckedUpdateManyWithoutTrailInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HutCheckCreateManyHutInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    mountainId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HutCheckUpdateWithoutHutInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutHutChecksNestedInput
    mountain?: MountainUpdateOneRequiredWithoutHutChecksNestedInput
  }

  export type HutCheckUncheckedUpdateWithoutHutInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HutCheckUncheckedUpdateManyWithoutHutInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AidRoomCheckCreateManyAidRoomInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    mountainId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AidRoomCheckUpdateWithoutAidRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutAidRoomChecksNestedInput
    mountain?: MountainUpdateOneRequiredWithoutAidRoomChecksNestedInput
  }

  export type AidRoomCheckUncheckedUpdateWithoutAidRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AidRoomCheckUncheckedUpdateManyWithoutAidRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentEquipmentUsageLogCreateManyEquipmentInput = {
    id?: string
    usedAt?: Date | string
    notes?: string | null
    mountainId: string
    incidentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentCheckCreateManyEquipmentInput = {
    id?: string
    recordedAt?: Date | string
    employeeId: string
    mountainId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentServiceLogCreateManyEquipmentInput = {
    id?: string
    mountainId: string
    employeeId?: string | null
    status?: $Enums.EQUIPMENT_STATUS
    changedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentEquipmentUsageLogUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountain?: MountainUpdateOneRequiredWithoutIncidentEquipmentUsageLogNestedInput
    incident?: IncidentUpdateOneRequiredWithoutIncidentEquipmentUsageLogNestedInput
  }

  export type IncidentEquipmentUsageLogUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mountainId?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentEquipmentUsageLogUncheckedUpdateManyWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mountainId?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCheckUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutEquipmentChecksNestedInput
    mountain?: MountainUpdateOneRequiredWithoutEquipmentChecksNestedInput
  }

  export type EquipmentCheckUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCheckUncheckedUpdateManyWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentServiceLogUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountain?: MountainUpdateOneRequiredWithoutEquipmentServiceLogsNestedInput
    employee?: EmployeeUpdateOneWithoutEquipmentServiceLogsNestedInput
  }

  export type EquipmentServiceLogUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentServiceLogUncheckedUpdateManyWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEQUIPMENT_STATUSFieldUpdateOperationsInput | $Enums.EQUIPMENT_STATUS
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentEquipmentUsageLogCreateManyIncidentInput = {
    id?: string
    usedAt?: Date | string
    notes?: string | null
    mountainId: string
    equipmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentEquipmentUsageLogUpdateWithoutIncidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountain?: MountainUpdateOneRequiredWithoutIncidentEquipmentUsageLogNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutIncidentEquipmentUsageLogsNestedInput
  }

  export type IncidentEquipmentUsageLogUncheckedUpdateWithoutIncidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mountainId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentEquipmentUsageLogUncheckedUpdateManyWithoutIncidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mountainId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: RoleUpdateOneWithoutEmployeesNestedInput
    additionalRoles?: EmployeeRoleUpdateManyWithoutEmployeeNestedInput
    mountainAssignments?: EmployeeMountainAssignmentUpdateManyWithoutEmployeeNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutEmployeeNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEmployeeNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalRoles?: EmployeeRoleUncheckedUpdateManyWithoutEmployeeNestedInput
    mountainAssignments?: EmployeeMountainAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentServiceLogs?: EquipmentServiceLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeIdNumber?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}