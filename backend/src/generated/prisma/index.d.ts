
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Mountain
 * 
 */
export type Mountain = $Result.DefaultSelection<Prisma.$MountainPayload>
/**
 * Model Weather
 * 
 */
export type Weather = $Result.DefaultSelection<Prisma.$WeatherPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model DispatcherAssignment
 * 
 */
export type DispatcherAssignment = $Result.DefaultSelection<Prisma.$DispatcherAssignmentPayload>
/**
 * Model Lift
 * 
 */
export type Lift = $Result.DefaultSelection<Prisma.$LiftPayload>
/**
 * Model Trail
 * 
 */
export type Trail = $Result.DefaultSelection<Prisma.$TrailPayload>
/**
 * Model Lodge
 * 
 */
export type Lodge = $Result.DefaultSelection<Prisma.$LodgePayload>
/**
 * Model Hut
 * 
 */
export type Hut = $Result.DefaultSelection<Prisma.$HutPayload>
/**
 * Model AidRoom
 * 
 */
export type AidRoom = $Result.DefaultSelection<Prisma.$AidRoomPayload>
/**
 * Model Equipment
 * 
 */
export type Equipment = $Result.DefaultSelection<Prisma.$EquipmentPayload>
/**
 * Model Incident
 * 
 */
export type Incident = $Result.DefaultSelection<Prisma.$IncidentPayload>
/**
 * Model IncidentLog
 * 
 */
export type IncidentLog = $Result.DefaultSelection<Prisma.$IncidentLogPayload>
/**
 * Model IncidentLogEquipment
 * 
 */
export type IncidentLogEquipment = $Result.DefaultSelection<Prisma.$IncidentLogEquipmentPayload>
/**
 * Model LiftCheck
 * 
 */
export type LiftCheck = $Result.DefaultSelection<Prisma.$LiftCheckPayload>
/**
 * Model TrailCheck
 * 
 */
export type TrailCheck = $Result.DefaultSelection<Prisma.$TrailCheckPayload>
/**
 * Model HutCheck
 * 
 */
export type HutCheck = $Result.DefaultSelection<Prisma.$HutCheckPayload>
/**
 * Model AidRoomCheck
 * 
 */
export type AidRoomCheck = $Result.DefaultSelection<Prisma.$AidRoomCheckPayload>
/**
 * Model EquipmentCheck
 * 
 */
export type EquipmentCheck = $Result.DefaultSelection<Prisma.$EquipmentCheckPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Status: {
  OPEN: 'OPEN',
  CLOSED: 'CLOSED',
  UNKNOWN: 'UNKNOWN'
};

export type Status = (typeof Status)[keyof typeof Status]


export const Department: {
  PATROL: 'PATROL',
  LIFT_OPERATIONS: 'LIFT_OPERATIONS',
  DISPATCH: 'DISPATCH',
  MAINTENANCE: 'MAINTENANCE',
  ADMINISTRATION: 'ADMINISTRATION',
  OTHER: 'OTHER'
};

export type Department = (typeof Department)[keyof typeof Department]


export const TrailCondition: {
  MACHINE_GROOMED: 'MACHINE_GROOMED',
  PACKED_POWDER: 'PACKED_POWDER',
  POWDER: 'POWDER',
  HARD_PACK: 'HARD_PACK',
  GROOMED: 'GROOMED',
  MOGULS: 'MOGULS',
  CLOSED: 'CLOSED'
};

export type TrailCondition = (typeof TrailCondition)[keyof typeof TrailCondition]


export const TrailDifficulty: {
  GREEN_CIRCLE: 'GREEN_CIRCLE',
  BLUE_SQUARE: 'BLUE_SQUARE',
  BLACK_DIAMOND: 'BLACK_DIAMOND',
  DOUBLE_BLACK_DIAMOND: 'DOUBLE_BLACK_DIAMOND',
  TERRAIN_PARK: 'TERRAIN_PARK',
  RACE_COURSE: 'RACE_COURSE'
};

export type TrailDifficulty = (typeof TrailDifficulty)[keyof typeof TrailDifficulty]


export const EquipmentService: {
  IN_SERVICE: 'IN_SERVICE',
  OUT_OF_SERVICE: 'OUT_OF_SERVICE',
  NEEDS_INSPECTION: 'NEEDS_INSPECTION',
  PENDING_REPAIR: 'PENDING_REPAIR',
  UNDER_MAINTENANCE: 'UNDER_MAINTENANCE',
  CLEANING: 'CLEANING'
};

export type EquipmentService = (typeof EquipmentService)[keyof typeof EquipmentService]


export const EquipmentStatus: {
  AVAILABLE: 'AVAILABLE',
  STANDBY: 'STANDBY',
  IN_USE: 'IN_USE',
  RETIRED: 'RETIRED',
  LOST: 'LOST'
};

export type EquipmentStatus = (typeof EquipmentStatus)[keyof typeof EquipmentStatus]


export const LocationType: {
  AID_ROOM: 'AID_ROOM',
  HUT: 'HUT',
  LODGE: 'LODGE',
  TRAIL: 'TRAIL',
  LIFT: 'LIFT',
  OTHER: 'OTHER'
};

export type LocationType = (typeof LocationType)[keyof typeof LocationType]

}

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type Department = $Enums.Department

export const Department: typeof $Enums.Department

export type TrailCondition = $Enums.TrailCondition

export const TrailCondition: typeof $Enums.TrailCondition

export type TrailDifficulty = $Enums.TrailDifficulty

export const TrailDifficulty: typeof $Enums.TrailDifficulty

export type EquipmentService = $Enums.EquipmentService

export const EquipmentService: typeof $Enums.EquipmentService

export type EquipmentStatus = $Enums.EquipmentStatus

export const EquipmentStatus: typeof $Enums.EquipmentStatus

export type LocationType = $Enums.LocationType

export const LocationType: typeof $Enums.LocationType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Mountains
 * const mountains = await prisma.mountain.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Mountains
   * const mountains = await prisma.mountain.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.mountain`: Exposes CRUD operations for the **Mountain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mountains
    * const mountains = await prisma.mountain.findMany()
    * ```
    */
  get mountain(): Prisma.MountainDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weather`: Exposes CRUD operations for the **Weather** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weathers
    * const weathers = await prisma.weather.findMany()
    * ```
    */
  get weather(): Prisma.WeatherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dispatcherAssignment`: Exposes CRUD operations for the **DispatcherAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DispatcherAssignments
    * const dispatcherAssignments = await prisma.dispatcherAssignment.findMany()
    * ```
    */
  get dispatcherAssignment(): Prisma.DispatcherAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lift`: Exposes CRUD operations for the **Lift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lifts
    * const lifts = await prisma.lift.findMany()
    * ```
    */
  get lift(): Prisma.LiftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trail`: Exposes CRUD operations for the **Trail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trails
    * const trails = await prisma.trail.findMany()
    * ```
    */
  get trail(): Prisma.TrailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lodge`: Exposes CRUD operations for the **Lodge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lodges
    * const lodges = await prisma.lodge.findMany()
    * ```
    */
  get lodge(): Prisma.LodgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hut`: Exposes CRUD operations for the **Hut** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Huts
    * const huts = await prisma.hut.findMany()
    * ```
    */
  get hut(): Prisma.HutDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aidRoom`: Exposes CRUD operations for the **AidRoom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AidRooms
    * const aidRooms = await prisma.aidRoom.findMany()
    * ```
    */
  get aidRoom(): Prisma.AidRoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipment`: Exposes CRUD operations for the **Equipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment
    * const equipment = await prisma.equipment.findMany()
    * ```
    */
  get equipment(): Prisma.EquipmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.incident`: Exposes CRUD operations for the **Incident** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Incidents
    * const incidents = await prisma.incident.findMany()
    * ```
    */
  get incident(): Prisma.IncidentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.incidentLog`: Exposes CRUD operations for the **IncidentLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IncidentLogs
    * const incidentLogs = await prisma.incidentLog.findMany()
    * ```
    */
  get incidentLog(): Prisma.IncidentLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.incidentLogEquipment`: Exposes CRUD operations for the **IncidentLogEquipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IncidentLogEquipments
    * const incidentLogEquipments = await prisma.incidentLogEquipment.findMany()
    * ```
    */
  get incidentLogEquipment(): Prisma.IncidentLogEquipmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.liftCheck`: Exposes CRUD operations for the **LiftCheck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LiftChecks
    * const liftChecks = await prisma.liftCheck.findMany()
    * ```
    */
  get liftCheck(): Prisma.LiftCheckDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trailCheck`: Exposes CRUD operations for the **TrailCheck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrailChecks
    * const trailChecks = await prisma.trailCheck.findMany()
    * ```
    */
  get trailCheck(): Prisma.TrailCheckDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hutCheck`: Exposes CRUD operations for the **HutCheck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HutChecks
    * const hutChecks = await prisma.hutCheck.findMany()
    * ```
    */
  get hutCheck(): Prisma.HutCheckDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aidRoomCheck`: Exposes CRUD operations for the **AidRoomCheck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AidRoomChecks
    * const aidRoomChecks = await prisma.aidRoomCheck.findMany()
    * ```
    */
  get aidRoomCheck(): Prisma.AidRoomCheckDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipmentCheck`: Exposes CRUD operations for the **EquipmentCheck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipmentChecks
    * const equipmentChecks = await prisma.equipmentCheck.findMany()
    * ```
    */
  get equipmentCheck(): Prisma.EquipmentCheckDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Mountain: 'Mountain',
    Weather: 'Weather',
    Employee: 'Employee',
    DispatcherAssignment: 'DispatcherAssignment',
    Lift: 'Lift',
    Trail: 'Trail',
    Lodge: 'Lodge',
    Hut: 'Hut',
    AidRoom: 'AidRoom',
    Equipment: 'Equipment',
    Incident: 'Incident',
    IncidentLog: 'IncidentLog',
    IncidentLogEquipment: 'IncidentLogEquipment',
    LiftCheck: 'LiftCheck',
    TrailCheck: 'TrailCheck',
    HutCheck: 'HutCheck',
    AidRoomCheck: 'AidRoomCheck',
    EquipmentCheck: 'EquipmentCheck'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "mountain" | "weather" | "employee" | "dispatcherAssignment" | "lift" | "trail" | "lodge" | "hut" | "aidRoom" | "equipment" | "incident" | "incidentLog" | "incidentLogEquipment" | "liftCheck" | "trailCheck" | "hutCheck" | "aidRoomCheck" | "equipmentCheck"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Mountain: {
        payload: Prisma.$MountainPayload<ExtArgs>
        fields: Prisma.MountainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MountainFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MountainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MountainFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MountainPayload>
          }
          findFirst: {
            args: Prisma.MountainFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MountainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MountainFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MountainPayload>
          }
          findMany: {
            args: Prisma.MountainFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MountainPayload>[]
          }
          create: {
            args: Prisma.MountainCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MountainPayload>
          }
          createMany: {
            args: Prisma.MountainCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MountainCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MountainPayload>[]
          }
          delete: {
            args: Prisma.MountainDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MountainPayload>
          }
          update: {
            args: Prisma.MountainUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MountainPayload>
          }
          deleteMany: {
            args: Prisma.MountainDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MountainUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MountainUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MountainPayload>[]
          }
          upsert: {
            args: Prisma.MountainUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MountainPayload>
          }
          aggregate: {
            args: Prisma.MountainAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMountain>
          }
          groupBy: {
            args: Prisma.MountainGroupByArgs<ExtArgs>
            result: $Utils.Optional<MountainGroupByOutputType>[]
          }
          count: {
            args: Prisma.MountainCountArgs<ExtArgs>
            result: $Utils.Optional<MountainCountAggregateOutputType> | number
          }
        }
      }
      Weather: {
        payload: Prisma.$WeatherPayload<ExtArgs>
        fields: Prisma.WeatherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeatherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeatherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          findFirst: {
            args: Prisma.WeatherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeatherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          findMany: {
            args: Prisma.WeatherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>[]
          }
          create: {
            args: Prisma.WeatherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          createMany: {
            args: Prisma.WeatherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeatherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>[]
          }
          delete: {
            args: Prisma.WeatherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          update: {
            args: Prisma.WeatherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          deleteMany: {
            args: Prisma.WeatherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeatherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeatherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>[]
          }
          upsert: {
            args: Prisma.WeatherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          aggregate: {
            args: Prisma.WeatherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeather>
          }
          groupBy: {
            args: Prisma.WeatherGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeatherGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeatherCountArgs<ExtArgs>
            result: $Utils.Optional<WeatherCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      DispatcherAssignment: {
        payload: Prisma.$DispatcherAssignmentPayload<ExtArgs>
        fields: Prisma.DispatcherAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DispatcherAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatcherAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DispatcherAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatcherAssignmentPayload>
          }
          findFirst: {
            args: Prisma.DispatcherAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatcherAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DispatcherAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatcherAssignmentPayload>
          }
          findMany: {
            args: Prisma.DispatcherAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatcherAssignmentPayload>[]
          }
          create: {
            args: Prisma.DispatcherAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatcherAssignmentPayload>
          }
          createMany: {
            args: Prisma.DispatcherAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DispatcherAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatcherAssignmentPayload>[]
          }
          delete: {
            args: Prisma.DispatcherAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatcherAssignmentPayload>
          }
          update: {
            args: Prisma.DispatcherAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatcherAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.DispatcherAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DispatcherAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DispatcherAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatcherAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.DispatcherAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatcherAssignmentPayload>
          }
          aggregate: {
            args: Prisma.DispatcherAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDispatcherAssignment>
          }
          groupBy: {
            args: Prisma.DispatcherAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DispatcherAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DispatcherAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<DispatcherAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Lift: {
        payload: Prisma.$LiftPayload<ExtArgs>
        fields: Prisma.LiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftPayload>
          }
          findFirst: {
            args: Prisma.LiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftPayload>
          }
          findMany: {
            args: Prisma.LiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftPayload>[]
          }
          create: {
            args: Prisma.LiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftPayload>
          }
          createMany: {
            args: Prisma.LiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LiftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftPayload>[]
          }
          delete: {
            args: Prisma.LiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftPayload>
          }
          update: {
            args: Prisma.LiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftPayload>
          }
          deleteMany: {
            args: Prisma.LiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LiftUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftPayload>[]
          }
          upsert: {
            args: Prisma.LiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftPayload>
          }
          aggregate: {
            args: Prisma.LiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLift>
          }
          groupBy: {
            args: Prisma.LiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<LiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.LiftCountArgs<ExtArgs>
            result: $Utils.Optional<LiftCountAggregateOutputType> | number
          }
        }
      }
      Trail: {
        payload: Prisma.$TrailPayload<ExtArgs>
        fields: Prisma.TrailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailPayload>
          }
          findFirst: {
            args: Prisma.TrailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailPayload>
          }
          findMany: {
            args: Prisma.TrailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailPayload>[]
          }
          create: {
            args: Prisma.TrailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailPayload>
          }
          createMany: {
            args: Prisma.TrailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailPayload>[]
          }
          delete: {
            args: Prisma.TrailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailPayload>
          }
          update: {
            args: Prisma.TrailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailPayload>
          }
          deleteMany: {
            args: Prisma.TrailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailPayload>[]
          }
          upsert: {
            args: Prisma.TrailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailPayload>
          }
          aggregate: {
            args: Prisma.TrailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrail>
          }
          groupBy: {
            args: Prisma.TrailGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrailGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrailCountArgs<ExtArgs>
            result: $Utils.Optional<TrailCountAggregateOutputType> | number
          }
        }
      }
      Lodge: {
        payload: Prisma.$LodgePayload<ExtArgs>
        fields: Prisma.LodgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LodgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LodgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LodgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LodgePayload>
          }
          findFirst: {
            args: Prisma.LodgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LodgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LodgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LodgePayload>
          }
          findMany: {
            args: Prisma.LodgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LodgePayload>[]
          }
          create: {
            args: Prisma.LodgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LodgePayload>
          }
          createMany: {
            args: Prisma.LodgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LodgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LodgePayload>[]
          }
          delete: {
            args: Prisma.LodgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LodgePayload>
          }
          update: {
            args: Prisma.LodgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LodgePayload>
          }
          deleteMany: {
            args: Prisma.LodgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LodgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LodgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LodgePayload>[]
          }
          upsert: {
            args: Prisma.LodgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LodgePayload>
          }
          aggregate: {
            args: Prisma.LodgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLodge>
          }
          groupBy: {
            args: Prisma.LodgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LodgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LodgeCountArgs<ExtArgs>
            result: $Utils.Optional<LodgeCountAggregateOutputType> | number
          }
        }
      }
      Hut: {
        payload: Prisma.$HutPayload<ExtArgs>
        fields: Prisma.HutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutPayload>
          }
          findFirst: {
            args: Prisma.HutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutPayload>
          }
          findMany: {
            args: Prisma.HutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutPayload>[]
          }
          create: {
            args: Prisma.HutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutPayload>
          }
          createMany: {
            args: Prisma.HutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HutCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutPayload>[]
          }
          delete: {
            args: Prisma.HutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutPayload>
          }
          update: {
            args: Prisma.HutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutPayload>
          }
          deleteMany: {
            args: Prisma.HutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HutUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutPayload>[]
          }
          upsert: {
            args: Prisma.HutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutPayload>
          }
          aggregate: {
            args: Prisma.HutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHut>
          }
          groupBy: {
            args: Prisma.HutGroupByArgs<ExtArgs>
            result: $Utils.Optional<HutGroupByOutputType>[]
          }
          count: {
            args: Prisma.HutCountArgs<ExtArgs>
            result: $Utils.Optional<HutCountAggregateOutputType> | number
          }
        }
      }
      AidRoom: {
        payload: Prisma.$AidRoomPayload<ExtArgs>
        fields: Prisma.AidRoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AidRoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AidRoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomPayload>
          }
          findFirst: {
            args: Prisma.AidRoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AidRoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomPayload>
          }
          findMany: {
            args: Prisma.AidRoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomPayload>[]
          }
          create: {
            args: Prisma.AidRoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomPayload>
          }
          createMany: {
            args: Prisma.AidRoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AidRoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomPayload>[]
          }
          delete: {
            args: Prisma.AidRoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomPayload>
          }
          update: {
            args: Prisma.AidRoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomPayload>
          }
          deleteMany: {
            args: Prisma.AidRoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AidRoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AidRoomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomPayload>[]
          }
          upsert: {
            args: Prisma.AidRoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomPayload>
          }
          aggregate: {
            args: Prisma.AidRoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAidRoom>
          }
          groupBy: {
            args: Prisma.AidRoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<AidRoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.AidRoomCountArgs<ExtArgs>
            result: $Utils.Optional<AidRoomCountAggregateOutputType> | number
          }
        }
      }
      Equipment: {
        payload: Prisma.$EquipmentPayload<ExtArgs>
        fields: Prisma.EquipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findFirst: {
            args: Prisma.EquipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findMany: {
            args: Prisma.EquipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          create: {
            args: Prisma.EquipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          createMany: {
            args: Prisma.EquipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          delete: {
            args: Prisma.EquipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          update: {
            args: Prisma.EquipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EquipmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          upsert: {
            args: Prisma.EquipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          aggregate: {
            args: Prisma.EquipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipment>
          }
          groupBy: {
            args: Prisma.EquipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentCountAggregateOutputType> | number
          }
        }
      }
      Incident: {
        payload: Prisma.$IncidentPayload<ExtArgs>
        fields: Prisma.IncidentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncidentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncidentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          findFirst: {
            args: Prisma.IncidentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncidentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          findMany: {
            args: Prisma.IncidentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>[]
          }
          create: {
            args: Prisma.IncidentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          createMany: {
            args: Prisma.IncidentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncidentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>[]
          }
          delete: {
            args: Prisma.IncidentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          update: {
            args: Prisma.IncidentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          deleteMany: {
            args: Prisma.IncidentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncidentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IncidentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>[]
          }
          upsert: {
            args: Prisma.IncidentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          aggregate: {
            args: Prisma.IncidentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncident>
          }
          groupBy: {
            args: Prisma.IncidentGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncidentGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncidentCountArgs<ExtArgs>
            result: $Utils.Optional<IncidentCountAggregateOutputType> | number
          }
        }
      }
      IncidentLog: {
        payload: Prisma.$IncidentLogPayload<ExtArgs>
        fields: Prisma.IncidentLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncidentLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncidentLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentLogPayload>
          }
          findFirst: {
            args: Prisma.IncidentLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncidentLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentLogPayload>
          }
          findMany: {
            args: Prisma.IncidentLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentLogPayload>[]
          }
          create: {
            args: Prisma.IncidentLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentLogPayload>
          }
          createMany: {
            args: Prisma.IncidentLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncidentLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentLogPayload>[]
          }
          delete: {
            args: Prisma.IncidentLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentLogPayload>
          }
          update: {
            args: Prisma.IncidentLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentLogPayload>
          }
          deleteMany: {
            args: Prisma.IncidentLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncidentLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IncidentLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentLogPayload>[]
          }
          upsert: {
            args: Prisma.IncidentLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentLogPayload>
          }
          aggregate: {
            args: Prisma.IncidentLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncidentLog>
          }
          groupBy: {
            args: Prisma.IncidentLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncidentLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncidentLogCountArgs<ExtArgs>
            result: $Utils.Optional<IncidentLogCountAggregateOutputType> | number
          }
        }
      }
      IncidentLogEquipment: {
        payload: Prisma.$IncidentLogEquipmentPayload<ExtArgs>
        fields: Prisma.IncidentLogEquipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncidentLogEquipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentLogEquipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncidentLogEquipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentLogEquipmentPayload>
          }
          findFirst: {
            args: Prisma.IncidentLogEquipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentLogEquipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncidentLogEquipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentLogEquipmentPayload>
          }
          findMany: {
            args: Prisma.IncidentLogEquipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentLogEquipmentPayload>[]
          }
          create: {
            args: Prisma.IncidentLogEquipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentLogEquipmentPayload>
          }
          createMany: {
            args: Prisma.IncidentLogEquipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncidentLogEquipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentLogEquipmentPayload>[]
          }
          delete: {
            args: Prisma.IncidentLogEquipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentLogEquipmentPayload>
          }
          update: {
            args: Prisma.IncidentLogEquipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentLogEquipmentPayload>
          }
          deleteMany: {
            args: Prisma.IncidentLogEquipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncidentLogEquipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IncidentLogEquipmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentLogEquipmentPayload>[]
          }
          upsert: {
            args: Prisma.IncidentLogEquipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentLogEquipmentPayload>
          }
          aggregate: {
            args: Prisma.IncidentLogEquipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncidentLogEquipment>
          }
          groupBy: {
            args: Prisma.IncidentLogEquipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncidentLogEquipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncidentLogEquipmentCountArgs<ExtArgs>
            result: $Utils.Optional<IncidentLogEquipmentCountAggregateOutputType> | number
          }
        }
      }
      LiftCheck: {
        payload: Prisma.$LiftCheckPayload<ExtArgs>
        fields: Prisma.LiftCheckFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LiftCheckFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftCheckPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LiftCheckFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftCheckPayload>
          }
          findFirst: {
            args: Prisma.LiftCheckFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftCheckPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LiftCheckFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftCheckPayload>
          }
          findMany: {
            args: Prisma.LiftCheckFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftCheckPayload>[]
          }
          create: {
            args: Prisma.LiftCheckCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftCheckPayload>
          }
          createMany: {
            args: Prisma.LiftCheckCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LiftCheckCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftCheckPayload>[]
          }
          delete: {
            args: Prisma.LiftCheckDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftCheckPayload>
          }
          update: {
            args: Prisma.LiftCheckUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftCheckPayload>
          }
          deleteMany: {
            args: Prisma.LiftCheckDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LiftCheckUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LiftCheckUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftCheckPayload>[]
          }
          upsert: {
            args: Prisma.LiftCheckUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiftCheckPayload>
          }
          aggregate: {
            args: Prisma.LiftCheckAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLiftCheck>
          }
          groupBy: {
            args: Prisma.LiftCheckGroupByArgs<ExtArgs>
            result: $Utils.Optional<LiftCheckGroupByOutputType>[]
          }
          count: {
            args: Prisma.LiftCheckCountArgs<ExtArgs>
            result: $Utils.Optional<LiftCheckCountAggregateOutputType> | number
          }
        }
      }
      TrailCheck: {
        payload: Prisma.$TrailCheckPayload<ExtArgs>
        fields: Prisma.TrailCheckFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrailCheckFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailCheckPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrailCheckFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailCheckPayload>
          }
          findFirst: {
            args: Prisma.TrailCheckFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailCheckPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrailCheckFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailCheckPayload>
          }
          findMany: {
            args: Prisma.TrailCheckFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailCheckPayload>[]
          }
          create: {
            args: Prisma.TrailCheckCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailCheckPayload>
          }
          createMany: {
            args: Prisma.TrailCheckCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrailCheckCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailCheckPayload>[]
          }
          delete: {
            args: Prisma.TrailCheckDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailCheckPayload>
          }
          update: {
            args: Prisma.TrailCheckUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailCheckPayload>
          }
          deleteMany: {
            args: Prisma.TrailCheckDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrailCheckUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrailCheckUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailCheckPayload>[]
          }
          upsert: {
            args: Prisma.TrailCheckUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrailCheckPayload>
          }
          aggregate: {
            args: Prisma.TrailCheckAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrailCheck>
          }
          groupBy: {
            args: Prisma.TrailCheckGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrailCheckGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrailCheckCountArgs<ExtArgs>
            result: $Utils.Optional<TrailCheckCountAggregateOutputType> | number
          }
        }
      }
      HutCheck: {
        payload: Prisma.$HutCheckPayload<ExtArgs>
        fields: Prisma.HutCheckFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HutCheckFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutCheckPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HutCheckFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutCheckPayload>
          }
          findFirst: {
            args: Prisma.HutCheckFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutCheckPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HutCheckFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutCheckPayload>
          }
          findMany: {
            args: Prisma.HutCheckFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutCheckPayload>[]
          }
          create: {
            args: Prisma.HutCheckCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutCheckPayload>
          }
          createMany: {
            args: Prisma.HutCheckCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HutCheckCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutCheckPayload>[]
          }
          delete: {
            args: Prisma.HutCheckDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutCheckPayload>
          }
          update: {
            args: Prisma.HutCheckUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutCheckPayload>
          }
          deleteMany: {
            args: Prisma.HutCheckDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HutCheckUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HutCheckUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutCheckPayload>[]
          }
          upsert: {
            args: Prisma.HutCheckUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HutCheckPayload>
          }
          aggregate: {
            args: Prisma.HutCheckAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHutCheck>
          }
          groupBy: {
            args: Prisma.HutCheckGroupByArgs<ExtArgs>
            result: $Utils.Optional<HutCheckGroupByOutputType>[]
          }
          count: {
            args: Prisma.HutCheckCountArgs<ExtArgs>
            result: $Utils.Optional<HutCheckCountAggregateOutputType> | number
          }
        }
      }
      AidRoomCheck: {
        payload: Prisma.$AidRoomCheckPayload<ExtArgs>
        fields: Prisma.AidRoomCheckFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AidRoomCheckFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomCheckPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AidRoomCheckFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomCheckPayload>
          }
          findFirst: {
            args: Prisma.AidRoomCheckFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomCheckPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AidRoomCheckFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomCheckPayload>
          }
          findMany: {
            args: Prisma.AidRoomCheckFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomCheckPayload>[]
          }
          create: {
            args: Prisma.AidRoomCheckCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomCheckPayload>
          }
          createMany: {
            args: Prisma.AidRoomCheckCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AidRoomCheckCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomCheckPayload>[]
          }
          delete: {
            args: Prisma.AidRoomCheckDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomCheckPayload>
          }
          update: {
            args: Prisma.AidRoomCheckUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomCheckPayload>
          }
          deleteMany: {
            args: Prisma.AidRoomCheckDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AidRoomCheckUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AidRoomCheckUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomCheckPayload>[]
          }
          upsert: {
            args: Prisma.AidRoomCheckUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AidRoomCheckPayload>
          }
          aggregate: {
            args: Prisma.AidRoomCheckAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAidRoomCheck>
          }
          groupBy: {
            args: Prisma.AidRoomCheckGroupByArgs<ExtArgs>
            result: $Utils.Optional<AidRoomCheckGroupByOutputType>[]
          }
          count: {
            args: Prisma.AidRoomCheckCountArgs<ExtArgs>
            result: $Utils.Optional<AidRoomCheckCountAggregateOutputType> | number
          }
        }
      }
      EquipmentCheck: {
        payload: Prisma.$EquipmentCheckPayload<ExtArgs>
        fields: Prisma.EquipmentCheckFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentCheckFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCheckPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentCheckFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCheckPayload>
          }
          findFirst: {
            args: Prisma.EquipmentCheckFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCheckPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentCheckFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCheckPayload>
          }
          findMany: {
            args: Prisma.EquipmentCheckFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCheckPayload>[]
          }
          create: {
            args: Prisma.EquipmentCheckCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCheckPayload>
          }
          createMany: {
            args: Prisma.EquipmentCheckCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipmentCheckCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCheckPayload>[]
          }
          delete: {
            args: Prisma.EquipmentCheckDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCheckPayload>
          }
          update: {
            args: Prisma.EquipmentCheckUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCheckPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentCheckDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentCheckUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EquipmentCheckUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCheckPayload>[]
          }
          upsert: {
            args: Prisma.EquipmentCheckUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCheckPayload>
          }
          aggregate: {
            args: Prisma.EquipmentCheckAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipmentCheck>
          }
          groupBy: {
            args: Prisma.EquipmentCheckGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentCheckGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentCheckCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentCheckCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    mountain?: MountainOmit
    weather?: WeatherOmit
    employee?: EmployeeOmit
    dispatcherAssignment?: DispatcherAssignmentOmit
    lift?: LiftOmit
    trail?: TrailOmit
    lodge?: LodgeOmit
    hut?: HutOmit
    aidRoom?: AidRoomOmit
    equipment?: EquipmentOmit
    incident?: IncidentOmit
    incidentLog?: IncidentLogOmit
    incidentLogEquipment?: IncidentLogEquipmentOmit
    liftCheck?: LiftCheckOmit
    trailCheck?: TrailCheckOmit
    hutCheck?: HutCheckOmit
    aidRoomCheck?: AidRoomCheckOmit
    equipmentCheck?: EquipmentCheckOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type MountainCountOutputType
   */

  export type MountainCountOutputType = {
    lifts: number
    liftChecks: number
    trails: number
    trailChecks: number
    employees: number
    lodges: number
    huts: number
    hutChecks: number
    aidRooms: number
    aidRoomChecks: number
    equipment: number
    equipmentChecks: number
    incidents: number
    incidentLogs: number
    dispatcherAssignments: number
    incidentLogEquipment: number
    weather: number
  }

  export type MountainCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lifts?: boolean | MountainCountOutputTypeCountLiftsArgs
    liftChecks?: boolean | MountainCountOutputTypeCountLiftChecksArgs
    trails?: boolean | MountainCountOutputTypeCountTrailsArgs
    trailChecks?: boolean | MountainCountOutputTypeCountTrailChecksArgs
    employees?: boolean | MountainCountOutputTypeCountEmployeesArgs
    lodges?: boolean | MountainCountOutputTypeCountLodgesArgs
    huts?: boolean | MountainCountOutputTypeCountHutsArgs
    hutChecks?: boolean | MountainCountOutputTypeCountHutChecksArgs
    aidRooms?: boolean | MountainCountOutputTypeCountAidRoomsArgs
    aidRoomChecks?: boolean | MountainCountOutputTypeCountAidRoomChecksArgs
    equipment?: boolean | MountainCountOutputTypeCountEquipmentArgs
    equipmentChecks?: boolean | MountainCountOutputTypeCountEquipmentChecksArgs
    incidents?: boolean | MountainCountOutputTypeCountIncidentsArgs
    incidentLogs?: boolean | MountainCountOutputTypeCountIncidentLogsArgs
    dispatcherAssignments?: boolean | MountainCountOutputTypeCountDispatcherAssignmentsArgs
    incidentLogEquipment?: boolean | MountainCountOutputTypeCountIncidentLogEquipmentArgs
    weather?: boolean | MountainCountOutputTypeCountWeatherArgs
  }

  // Custom InputTypes
  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MountainCountOutputType
     */
    select?: MountainCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountLiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiftWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountLiftChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiftCheckWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountTrailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrailWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountTrailChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrailCheckWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountLodgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LodgeWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountHutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HutWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountHutChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HutCheckWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountAidRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AidRoomWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountAidRoomChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AidRoomCheckWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountEquipmentChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentCheckWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountIncidentLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentLogWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountDispatcherAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispatcherAssignmentWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountIncidentLogEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentLogEquipmentWhereInput
  }

  /**
   * MountainCountOutputType without action
   */
  export type MountainCountOutputTypeCountWeatherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeatherWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    dispatcherAssignments: number
    logs: number
    liftChecks: number
    trailChecks: number
    hutChecks: number
    aidRoomChecks: number
    equipmentChecks: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dispatcherAssignments?: boolean | EmployeeCountOutputTypeCountDispatcherAssignmentsArgs
    logs?: boolean | EmployeeCountOutputTypeCountLogsArgs
    liftChecks?: boolean | EmployeeCountOutputTypeCountLiftChecksArgs
    trailChecks?: boolean | EmployeeCountOutputTypeCountTrailChecksArgs
    hutChecks?: boolean | EmployeeCountOutputTypeCountHutChecksArgs
    aidRoomChecks?: boolean | EmployeeCountOutputTypeCountAidRoomChecksArgs
    equipmentChecks?: boolean | EmployeeCountOutputTypeCountEquipmentChecksArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountDispatcherAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispatcherAssignmentWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentLogWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountLiftChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiftCheckWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountTrailChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrailCheckWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountHutChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HutCheckWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAidRoomChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AidRoomCheckWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountEquipmentChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentCheckWhereInput
  }


  /**
   * Count Type LiftCountOutputType
   */

  export type LiftCountOutputType = {
    incidentLogs: number
    liftChecks: number
  }

  export type LiftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incidentLogs?: boolean | LiftCountOutputTypeCountIncidentLogsArgs
    liftChecks?: boolean | LiftCountOutputTypeCountLiftChecksArgs
  }

  // Custom InputTypes
  /**
   * LiftCountOutputType without action
   */
  export type LiftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCountOutputType
     */
    select?: LiftCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LiftCountOutputType without action
   */
  export type LiftCountOutputTypeCountIncidentLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentLogWhereInput
  }

  /**
   * LiftCountOutputType without action
   */
  export type LiftCountOutputTypeCountLiftChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiftCheckWhereInput
  }


  /**
   * Count Type TrailCountOutputType
   */

  export type TrailCountOutputType = {
    incidentLogs: number
    trailChecks: number
  }

  export type TrailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incidentLogs?: boolean | TrailCountOutputTypeCountIncidentLogsArgs
    trailChecks?: boolean | TrailCountOutputTypeCountTrailChecksArgs
  }

  // Custom InputTypes
  /**
   * TrailCountOutputType without action
   */
  export type TrailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCountOutputType
     */
    select?: TrailCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrailCountOutputType without action
   */
  export type TrailCountOutputTypeCountIncidentLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentLogWhereInput
  }

  /**
   * TrailCountOutputType without action
   */
  export type TrailCountOutputTypeCountTrailChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrailCheckWhereInput
  }


  /**
   * Count Type LodgeCountOutputType
   */

  export type LodgeCountOutputType = {
    incidentLogs: number
  }

  export type LodgeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incidentLogs?: boolean | LodgeCountOutputTypeCountIncidentLogsArgs
  }

  // Custom InputTypes
  /**
   * LodgeCountOutputType without action
   */
  export type LodgeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LodgeCountOutputType
     */
    select?: LodgeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LodgeCountOutputType without action
   */
  export type LodgeCountOutputTypeCountIncidentLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentLogWhereInput
  }


  /**
   * Count Type HutCountOutputType
   */

  export type HutCountOutputType = {
    incidentLogs: number
    hutChecks: number
  }

  export type HutCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incidentLogs?: boolean | HutCountOutputTypeCountIncidentLogsArgs
    hutChecks?: boolean | HutCountOutputTypeCountHutChecksArgs
  }

  // Custom InputTypes
  /**
   * HutCountOutputType without action
   */
  export type HutCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCountOutputType
     */
    select?: HutCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HutCountOutputType without action
   */
  export type HutCountOutputTypeCountIncidentLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentLogWhereInput
  }

  /**
   * HutCountOutputType without action
   */
  export type HutCountOutputTypeCountHutChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HutCheckWhereInput
  }


  /**
   * Count Type AidRoomCountOutputType
   */

  export type AidRoomCountOutputType = {
    incidentLogs: number
    aidRoomChecks: number
  }

  export type AidRoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incidentLogs?: boolean | AidRoomCountOutputTypeCountIncidentLogsArgs
    aidRoomChecks?: boolean | AidRoomCountOutputTypeCountAidRoomChecksArgs
  }

  // Custom InputTypes
  /**
   * AidRoomCountOutputType without action
   */
  export type AidRoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCountOutputType
     */
    select?: AidRoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AidRoomCountOutputType without action
   */
  export type AidRoomCountOutputTypeCountIncidentLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentLogWhereInput
  }

  /**
   * AidRoomCountOutputType without action
   */
  export type AidRoomCountOutputTypeCountAidRoomChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AidRoomCheckWhereInput
  }


  /**
   * Count Type EquipmentCountOutputType
   */

  export type EquipmentCountOutputType = {
    usedInLogs: number
    equipmentChecks: number
  }

  export type EquipmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usedInLogs?: boolean | EquipmentCountOutputTypeCountUsedInLogsArgs
    equipmentChecks?: boolean | EquipmentCountOutputTypeCountEquipmentChecksArgs
  }

  // Custom InputTypes
  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCountOutputType
     */
    select?: EquipmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountUsedInLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentLogEquipmentWhereInput
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountEquipmentChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentCheckWhereInput
  }


  /**
   * Count Type IncidentCountOutputType
   */

  export type IncidentCountOutputType = {
    logs: number
  }

  export type IncidentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | IncidentCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * IncidentCountOutputType without action
   */
  export type IncidentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentCountOutputType
     */
    select?: IncidentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IncidentCountOutputType without action
   */
  export type IncidentCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentLogWhereInput
  }


  /**
   * Count Type IncidentLogCountOutputType
   */

  export type IncidentLogCountOutputType = {
    equipmentUsed: number
  }

  export type IncidentLogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipmentUsed?: boolean | IncidentLogCountOutputTypeCountEquipmentUsedArgs
  }

  // Custom InputTypes
  /**
   * IncidentLogCountOutputType without action
   */
  export type IncidentLogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLogCountOutputType
     */
    select?: IncidentLogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IncidentLogCountOutputType without action
   */
  export type IncidentLogCountOutputTypeCountEquipmentUsedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentLogEquipmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Mountain
   */

  export type AggregateMountain = {
    _count: MountainCountAggregateOutputType | null
    _avg: MountainAvgAggregateOutputType | null
    _sum: MountainSumAggregateOutputType | null
    _min: MountainMinAggregateOutputType | null
    _max: MountainMaxAggregateOutputType | null
  }

  export type MountainAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    height: number | null
  }

  export type MountainSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    height: number | null
  }

  export type MountainMinAggregateOutputType = {
    id: string | null
    name: string | null
    latitude: number | null
    longitude: number | null
    height: number | null
    hours: string | null
    phoneNumber: string | null
    address: string | null
    city: string | null
    state: string | null
    zipcode: string | null
    openingDate: Date | null
    closingDate: Date | null
  }

  export type MountainMaxAggregateOutputType = {
    id: string | null
    name: string | null
    latitude: number | null
    longitude: number | null
    height: number | null
    hours: string | null
    phoneNumber: string | null
    address: string | null
    city: string | null
    state: string | null
    zipcode: string | null
    openingDate: Date | null
    closingDate: Date | null
  }

  export type MountainCountAggregateOutputType = {
    id: number
    name: number
    latitude: number
    longitude: number
    height: number
    hours: number
    phoneNumber: number
    address: number
    city: number
    state: number
    zipcode: number
    openingDate: number
    closingDate: number
    _all: number
  }


  export type MountainAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    height?: true
  }

  export type MountainSumAggregateInputType = {
    latitude?: true
    longitude?: true
    height?: true
  }

  export type MountainMinAggregateInputType = {
    id?: true
    name?: true
    latitude?: true
    longitude?: true
    height?: true
    hours?: true
    phoneNumber?: true
    address?: true
    city?: true
    state?: true
    zipcode?: true
    openingDate?: true
    closingDate?: true
  }

  export type MountainMaxAggregateInputType = {
    id?: true
    name?: true
    latitude?: true
    longitude?: true
    height?: true
    hours?: true
    phoneNumber?: true
    address?: true
    city?: true
    state?: true
    zipcode?: true
    openingDate?: true
    closingDate?: true
  }

  export type MountainCountAggregateInputType = {
    id?: true
    name?: true
    latitude?: true
    longitude?: true
    height?: true
    hours?: true
    phoneNumber?: true
    address?: true
    city?: true
    state?: true
    zipcode?: true
    openingDate?: true
    closingDate?: true
    _all?: true
  }

  export type MountainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mountain to aggregate.
     */
    where?: MountainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mountains to fetch.
     */
    orderBy?: MountainOrderByWithRelationInput | MountainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MountainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mountains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mountains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mountains
    **/
    _count?: true | MountainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MountainAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MountainSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MountainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MountainMaxAggregateInputType
  }

  export type GetMountainAggregateType<T extends MountainAggregateArgs> = {
        [P in keyof T & keyof AggregateMountain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMountain[P]>
      : GetScalarType<T[P], AggregateMountain[P]>
  }




  export type MountainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MountainWhereInput
    orderBy?: MountainOrderByWithAggregationInput | MountainOrderByWithAggregationInput[]
    by: MountainScalarFieldEnum[] | MountainScalarFieldEnum
    having?: MountainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MountainCountAggregateInputType | true
    _avg?: MountainAvgAggregateInputType
    _sum?: MountainSumAggregateInputType
    _min?: MountainMinAggregateInputType
    _max?: MountainMaxAggregateInputType
  }

  export type MountainGroupByOutputType = {
    id: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate: Date | null
    closingDate: Date | null
    _count: MountainCountAggregateOutputType | null
    _avg: MountainAvgAggregateOutputType | null
    _sum: MountainSumAggregateOutputType | null
    _min: MountainMinAggregateOutputType | null
    _max: MountainMaxAggregateOutputType | null
  }

  type GetMountainGroupByPayload<T extends MountainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MountainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MountainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MountainGroupByOutputType[P]>
            : GetScalarType<T[P], MountainGroupByOutputType[P]>
        }
      >
    >


  export type MountainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    latitude?: boolean
    longitude?: boolean
    height?: boolean
    hours?: boolean
    phoneNumber?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipcode?: boolean
    openingDate?: boolean
    closingDate?: boolean
    lifts?: boolean | Mountain$liftsArgs<ExtArgs>
    liftChecks?: boolean | Mountain$liftChecksArgs<ExtArgs>
    trails?: boolean | Mountain$trailsArgs<ExtArgs>
    trailChecks?: boolean | Mountain$trailChecksArgs<ExtArgs>
    employees?: boolean | Mountain$employeesArgs<ExtArgs>
    lodges?: boolean | Mountain$lodgesArgs<ExtArgs>
    huts?: boolean | Mountain$hutsArgs<ExtArgs>
    hutChecks?: boolean | Mountain$hutChecksArgs<ExtArgs>
    aidRooms?: boolean | Mountain$aidRoomsArgs<ExtArgs>
    aidRoomChecks?: boolean | Mountain$aidRoomChecksArgs<ExtArgs>
    equipment?: boolean | Mountain$equipmentArgs<ExtArgs>
    equipmentChecks?: boolean | Mountain$equipmentChecksArgs<ExtArgs>
    incidents?: boolean | Mountain$incidentsArgs<ExtArgs>
    incidentLogs?: boolean | Mountain$incidentLogsArgs<ExtArgs>
    dispatcherAssignments?: boolean | Mountain$dispatcherAssignmentsArgs<ExtArgs>
    incidentLogEquipment?: boolean | Mountain$incidentLogEquipmentArgs<ExtArgs>
    weather?: boolean | Mountain$weatherArgs<ExtArgs>
    _count?: boolean | MountainCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mountain"]>

  export type MountainSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    latitude?: boolean
    longitude?: boolean
    height?: boolean
    hours?: boolean
    phoneNumber?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipcode?: boolean
    openingDate?: boolean
    closingDate?: boolean
  }, ExtArgs["result"]["mountain"]>

  export type MountainSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    latitude?: boolean
    longitude?: boolean
    height?: boolean
    hours?: boolean
    phoneNumber?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipcode?: boolean
    openingDate?: boolean
    closingDate?: boolean
  }, ExtArgs["result"]["mountain"]>

  export type MountainSelectScalar = {
    id?: boolean
    name?: boolean
    latitude?: boolean
    longitude?: boolean
    height?: boolean
    hours?: boolean
    phoneNumber?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipcode?: boolean
    openingDate?: boolean
    closingDate?: boolean
  }

  export type MountainOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "latitude" | "longitude" | "height" | "hours" | "phoneNumber" | "address" | "city" | "state" | "zipcode" | "openingDate" | "closingDate", ExtArgs["result"]["mountain"]>
  export type MountainInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lifts?: boolean | Mountain$liftsArgs<ExtArgs>
    liftChecks?: boolean | Mountain$liftChecksArgs<ExtArgs>
    trails?: boolean | Mountain$trailsArgs<ExtArgs>
    trailChecks?: boolean | Mountain$trailChecksArgs<ExtArgs>
    employees?: boolean | Mountain$employeesArgs<ExtArgs>
    lodges?: boolean | Mountain$lodgesArgs<ExtArgs>
    huts?: boolean | Mountain$hutsArgs<ExtArgs>
    hutChecks?: boolean | Mountain$hutChecksArgs<ExtArgs>
    aidRooms?: boolean | Mountain$aidRoomsArgs<ExtArgs>
    aidRoomChecks?: boolean | Mountain$aidRoomChecksArgs<ExtArgs>
    equipment?: boolean | Mountain$equipmentArgs<ExtArgs>
    equipmentChecks?: boolean | Mountain$equipmentChecksArgs<ExtArgs>
    incidents?: boolean | Mountain$incidentsArgs<ExtArgs>
    incidentLogs?: boolean | Mountain$incidentLogsArgs<ExtArgs>
    dispatcherAssignments?: boolean | Mountain$dispatcherAssignmentsArgs<ExtArgs>
    incidentLogEquipment?: boolean | Mountain$incidentLogEquipmentArgs<ExtArgs>
    weather?: boolean | Mountain$weatherArgs<ExtArgs>
    _count?: boolean | MountainCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MountainIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MountainIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MountainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mountain"
    objects: {
      lifts: Prisma.$LiftPayload<ExtArgs>[]
      liftChecks: Prisma.$LiftCheckPayload<ExtArgs>[]
      trails: Prisma.$TrailPayload<ExtArgs>[]
      trailChecks: Prisma.$TrailCheckPayload<ExtArgs>[]
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      lodges: Prisma.$LodgePayload<ExtArgs>[]
      huts: Prisma.$HutPayload<ExtArgs>[]
      hutChecks: Prisma.$HutCheckPayload<ExtArgs>[]
      aidRooms: Prisma.$AidRoomPayload<ExtArgs>[]
      aidRoomChecks: Prisma.$AidRoomCheckPayload<ExtArgs>[]
      equipment: Prisma.$EquipmentPayload<ExtArgs>[]
      equipmentChecks: Prisma.$EquipmentCheckPayload<ExtArgs>[]
      incidents: Prisma.$IncidentPayload<ExtArgs>[]
      incidentLogs: Prisma.$IncidentLogPayload<ExtArgs>[]
      dispatcherAssignments: Prisma.$DispatcherAssignmentPayload<ExtArgs>[]
      incidentLogEquipment: Prisma.$IncidentLogEquipmentPayload<ExtArgs>[]
      weather: Prisma.$WeatherPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      latitude: number
      longitude: number
      height: number
      hours: string
      phoneNumber: string
      address: string
      city: string
      state: string
      zipcode: string
      openingDate: Date | null
      closingDate: Date | null
    }, ExtArgs["result"]["mountain"]>
    composites: {}
  }

  type MountainGetPayload<S extends boolean | null | undefined | MountainDefaultArgs> = $Result.GetResult<Prisma.$MountainPayload, S>

  type MountainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MountainFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MountainCountAggregateInputType | true
    }

  export interface MountainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mountain'], meta: { name: 'Mountain' } }
    /**
     * Find zero or one Mountain that matches the filter.
     * @param {MountainFindUniqueArgs} args - Arguments to find a Mountain
     * @example
     * // Get one Mountain
     * const mountain = await prisma.mountain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MountainFindUniqueArgs>(args: SelectSubset<T, MountainFindUniqueArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mountain that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MountainFindUniqueOrThrowArgs} args - Arguments to find a Mountain
     * @example
     * // Get one Mountain
     * const mountain = await prisma.mountain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MountainFindUniqueOrThrowArgs>(args: SelectSubset<T, MountainFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mountain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MountainFindFirstArgs} args - Arguments to find a Mountain
     * @example
     * // Get one Mountain
     * const mountain = await prisma.mountain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MountainFindFirstArgs>(args?: SelectSubset<T, MountainFindFirstArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mountain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MountainFindFirstOrThrowArgs} args - Arguments to find a Mountain
     * @example
     * // Get one Mountain
     * const mountain = await prisma.mountain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MountainFindFirstOrThrowArgs>(args?: SelectSubset<T, MountainFindFirstOrThrowArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mountains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MountainFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mountains
     * const mountains = await prisma.mountain.findMany()
     * 
     * // Get first 10 Mountains
     * const mountains = await prisma.mountain.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mountainWithIdOnly = await prisma.mountain.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MountainFindManyArgs>(args?: SelectSubset<T, MountainFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mountain.
     * @param {MountainCreateArgs} args - Arguments to create a Mountain.
     * @example
     * // Create one Mountain
     * const Mountain = await prisma.mountain.create({
     *   data: {
     *     // ... data to create a Mountain
     *   }
     * })
     * 
     */
    create<T extends MountainCreateArgs>(args: SelectSubset<T, MountainCreateArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mountains.
     * @param {MountainCreateManyArgs} args - Arguments to create many Mountains.
     * @example
     * // Create many Mountains
     * const mountain = await prisma.mountain.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MountainCreateManyArgs>(args?: SelectSubset<T, MountainCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mountains and returns the data saved in the database.
     * @param {MountainCreateManyAndReturnArgs} args - Arguments to create many Mountains.
     * @example
     * // Create many Mountains
     * const mountain = await prisma.mountain.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mountains and only return the `id`
     * const mountainWithIdOnly = await prisma.mountain.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MountainCreateManyAndReturnArgs>(args?: SelectSubset<T, MountainCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mountain.
     * @param {MountainDeleteArgs} args - Arguments to delete one Mountain.
     * @example
     * // Delete one Mountain
     * const Mountain = await prisma.mountain.delete({
     *   where: {
     *     // ... filter to delete one Mountain
     *   }
     * })
     * 
     */
    delete<T extends MountainDeleteArgs>(args: SelectSubset<T, MountainDeleteArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mountain.
     * @param {MountainUpdateArgs} args - Arguments to update one Mountain.
     * @example
     * // Update one Mountain
     * const mountain = await prisma.mountain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MountainUpdateArgs>(args: SelectSubset<T, MountainUpdateArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mountains.
     * @param {MountainDeleteManyArgs} args - Arguments to filter Mountains to delete.
     * @example
     * // Delete a few Mountains
     * const { count } = await prisma.mountain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MountainDeleteManyArgs>(args?: SelectSubset<T, MountainDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mountains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MountainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mountains
     * const mountain = await prisma.mountain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MountainUpdateManyArgs>(args: SelectSubset<T, MountainUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mountains and returns the data updated in the database.
     * @param {MountainUpdateManyAndReturnArgs} args - Arguments to update many Mountains.
     * @example
     * // Update many Mountains
     * const mountain = await prisma.mountain.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mountains and only return the `id`
     * const mountainWithIdOnly = await prisma.mountain.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MountainUpdateManyAndReturnArgs>(args: SelectSubset<T, MountainUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mountain.
     * @param {MountainUpsertArgs} args - Arguments to update or create a Mountain.
     * @example
     * // Update or create a Mountain
     * const mountain = await prisma.mountain.upsert({
     *   create: {
     *     // ... data to create a Mountain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mountain we want to update
     *   }
     * })
     */
    upsert<T extends MountainUpsertArgs>(args: SelectSubset<T, MountainUpsertArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mountains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MountainCountArgs} args - Arguments to filter Mountains to count.
     * @example
     * // Count the number of Mountains
     * const count = await prisma.mountain.count({
     *   where: {
     *     // ... the filter for the Mountains we want to count
     *   }
     * })
    **/
    count<T extends MountainCountArgs>(
      args?: Subset<T, MountainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MountainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mountain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MountainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MountainAggregateArgs>(args: Subset<T, MountainAggregateArgs>): Prisma.PrismaPromise<GetMountainAggregateType<T>>

    /**
     * Group by Mountain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MountainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MountainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MountainGroupByArgs['orderBy'] }
        : { orderBy?: MountainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MountainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMountainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mountain model
   */
  readonly fields: MountainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mountain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MountainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lifts<T extends Mountain$liftsArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$liftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    liftChecks<T extends Mountain$liftChecksArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$liftChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trails<T extends Mountain$trailsArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$trailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trailChecks<T extends Mountain$trailChecksArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$trailChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employees<T extends Mountain$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lodges<T extends Mountain$lodgesArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$lodgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    huts<T extends Mountain$hutsArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$hutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hutChecks<T extends Mountain$hutChecksArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$hutChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aidRooms<T extends Mountain$aidRoomsArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$aidRoomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aidRoomChecks<T extends Mountain$aidRoomChecksArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$aidRoomChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipment<T extends Mountain$equipmentArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$equipmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipmentChecks<T extends Mountain$equipmentChecksArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$equipmentChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    incidents<T extends Mountain$incidentsArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$incidentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    incidentLogs<T extends Mountain$incidentLogsArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$incidentLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dispatcherAssignments<T extends Mountain$dispatcherAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$dispatcherAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    incidentLogEquipment<T extends Mountain$incidentLogEquipmentArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$incidentLogEquipmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentLogEquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    weather<T extends Mountain$weatherArgs<ExtArgs> = {}>(args?: Subset<T, Mountain$weatherArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mountain model
   */
  interface MountainFieldRefs {
    readonly id: FieldRef<"Mountain", 'String'>
    readonly name: FieldRef<"Mountain", 'String'>
    readonly latitude: FieldRef<"Mountain", 'Float'>
    readonly longitude: FieldRef<"Mountain", 'Float'>
    readonly height: FieldRef<"Mountain", 'Int'>
    readonly hours: FieldRef<"Mountain", 'String'>
    readonly phoneNumber: FieldRef<"Mountain", 'String'>
    readonly address: FieldRef<"Mountain", 'String'>
    readonly city: FieldRef<"Mountain", 'String'>
    readonly state: FieldRef<"Mountain", 'String'>
    readonly zipcode: FieldRef<"Mountain", 'String'>
    readonly openingDate: FieldRef<"Mountain", 'DateTime'>
    readonly closingDate: FieldRef<"Mountain", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Mountain findUnique
   */
  export type MountainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MountainInclude<ExtArgs> | null
    /**
     * Filter, which Mountain to fetch.
     */
    where: MountainWhereUniqueInput
  }

  /**
   * Mountain findUniqueOrThrow
   */
  export type MountainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MountainInclude<ExtArgs> | null
    /**
     * Filter, which Mountain to fetch.
     */
    where: MountainWhereUniqueInput
  }

  /**
   * Mountain findFirst
   */
  export type MountainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MountainInclude<ExtArgs> | null
    /**
     * Filter, which Mountain to fetch.
     */
    where?: MountainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mountains to fetch.
     */
    orderBy?: MountainOrderByWithRelationInput | MountainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mountains.
     */
    cursor?: MountainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mountains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mountains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mountains.
     */
    distinct?: MountainScalarFieldEnum | MountainScalarFieldEnum[]
  }

  /**
   * Mountain findFirstOrThrow
   */
  export type MountainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MountainInclude<ExtArgs> | null
    /**
     * Filter, which Mountain to fetch.
     */
    where?: MountainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mountains to fetch.
     */
    orderBy?: MountainOrderByWithRelationInput | MountainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mountains.
     */
    cursor?: MountainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mountains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mountains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mountains.
     */
    distinct?: MountainScalarFieldEnum | MountainScalarFieldEnum[]
  }

  /**
   * Mountain findMany
   */
  export type MountainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MountainInclude<ExtArgs> | null
    /**
     * Filter, which Mountains to fetch.
     */
    where?: MountainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mountains to fetch.
     */
    orderBy?: MountainOrderByWithRelationInput | MountainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mountains.
     */
    cursor?: MountainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mountains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mountains.
     */
    skip?: number
    distinct?: MountainScalarFieldEnum | MountainScalarFieldEnum[]
  }

  /**
   * Mountain create
   */
  export type MountainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MountainInclude<ExtArgs> | null
    /**
     * The data needed to create a Mountain.
     */
    data: XOR<MountainCreateInput, MountainUncheckedCreateInput>
  }

  /**
   * Mountain createMany
   */
  export type MountainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mountains.
     */
    data: MountainCreateManyInput | MountainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mountain createManyAndReturn
   */
  export type MountainCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * The data used to create many Mountains.
     */
    data: MountainCreateManyInput | MountainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mountain update
   */
  export type MountainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MountainInclude<ExtArgs> | null
    /**
     * The data needed to update a Mountain.
     */
    data: XOR<MountainUpdateInput, MountainUncheckedUpdateInput>
    /**
     * Choose, which Mountain to update.
     */
    where: MountainWhereUniqueInput
  }

  /**
   * Mountain updateMany
   */
  export type MountainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mountains.
     */
    data: XOR<MountainUpdateManyMutationInput, MountainUncheckedUpdateManyInput>
    /**
     * Filter which Mountains to update
     */
    where?: MountainWhereInput
    /**
     * Limit how many Mountains to update.
     */
    limit?: number
  }

  /**
   * Mountain updateManyAndReturn
   */
  export type MountainUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * The data used to update Mountains.
     */
    data: XOR<MountainUpdateManyMutationInput, MountainUncheckedUpdateManyInput>
    /**
     * Filter which Mountains to update
     */
    where?: MountainWhereInput
    /**
     * Limit how many Mountains to update.
     */
    limit?: number
  }

  /**
   * Mountain upsert
   */
  export type MountainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MountainInclude<ExtArgs> | null
    /**
     * The filter to search for the Mountain to update in case it exists.
     */
    where: MountainWhereUniqueInput
    /**
     * In case the Mountain found by the `where` argument doesn't exist, create a new Mountain with this data.
     */
    create: XOR<MountainCreateInput, MountainUncheckedCreateInput>
    /**
     * In case the Mountain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MountainUpdateInput, MountainUncheckedUpdateInput>
  }

  /**
   * Mountain delete
   */
  export type MountainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MountainInclude<ExtArgs> | null
    /**
     * Filter which Mountain to delete.
     */
    where: MountainWhereUniqueInput
  }

  /**
   * Mountain deleteMany
   */
  export type MountainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mountains to delete
     */
    where?: MountainWhereInput
    /**
     * Limit how many Mountains to delete.
     */
    limit?: number
  }

  /**
   * Mountain.lifts
   */
  export type Mountain$liftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
    where?: LiftWhereInput
    orderBy?: LiftOrderByWithRelationInput | LiftOrderByWithRelationInput[]
    cursor?: LiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiftScalarFieldEnum | LiftScalarFieldEnum[]
  }

  /**
   * Mountain.liftChecks
   */
  export type Mountain$liftChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    where?: LiftCheckWhereInput
    orderBy?: LiftCheckOrderByWithRelationInput | LiftCheckOrderByWithRelationInput[]
    cursor?: LiftCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiftCheckScalarFieldEnum | LiftCheckScalarFieldEnum[]
  }

  /**
   * Mountain.trails
   */
  export type Mountain$trailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
    where?: TrailWhereInput
    orderBy?: TrailOrderByWithRelationInput | TrailOrderByWithRelationInput[]
    cursor?: TrailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrailScalarFieldEnum | TrailScalarFieldEnum[]
  }

  /**
   * Mountain.trailChecks
   */
  export type Mountain$trailChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    where?: TrailCheckWhereInput
    orderBy?: TrailCheckOrderByWithRelationInput | TrailCheckOrderByWithRelationInput[]
    cursor?: TrailCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrailCheckScalarFieldEnum | TrailCheckScalarFieldEnum[]
  }

  /**
   * Mountain.employees
   */
  export type Mountain$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Mountain.lodges
   */
  export type Mountain$lodgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
    where?: LodgeWhereInput
    orderBy?: LodgeOrderByWithRelationInput | LodgeOrderByWithRelationInput[]
    cursor?: LodgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LodgeScalarFieldEnum | LodgeScalarFieldEnum[]
  }

  /**
   * Mountain.huts
   */
  export type Mountain$hutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
    where?: HutWhereInput
    orderBy?: HutOrderByWithRelationInput | HutOrderByWithRelationInput[]
    cursor?: HutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HutScalarFieldEnum | HutScalarFieldEnum[]
  }

  /**
   * Mountain.hutChecks
   */
  export type Mountain$hutChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    where?: HutCheckWhereInput
    orderBy?: HutCheckOrderByWithRelationInput | HutCheckOrderByWithRelationInput[]
    cursor?: HutCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HutCheckScalarFieldEnum | HutCheckScalarFieldEnum[]
  }

  /**
   * Mountain.aidRooms
   */
  export type Mountain$aidRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
    where?: AidRoomWhereInput
    orderBy?: AidRoomOrderByWithRelationInput | AidRoomOrderByWithRelationInput[]
    cursor?: AidRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AidRoomScalarFieldEnum | AidRoomScalarFieldEnum[]
  }

  /**
   * Mountain.aidRoomChecks
   */
  export type Mountain$aidRoomChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    where?: AidRoomCheckWhereInput
    orderBy?: AidRoomCheckOrderByWithRelationInput | AidRoomCheckOrderByWithRelationInput[]
    cursor?: AidRoomCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AidRoomCheckScalarFieldEnum | AidRoomCheckScalarFieldEnum[]
  }

  /**
   * Mountain.equipment
   */
  export type Mountain$equipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    cursor?: EquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Mountain.equipmentChecks
   */
  export type Mountain$equipmentChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    where?: EquipmentCheckWhereInput
    orderBy?: EquipmentCheckOrderByWithRelationInput | EquipmentCheckOrderByWithRelationInput[]
    cursor?: EquipmentCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentCheckScalarFieldEnum | EquipmentCheckScalarFieldEnum[]
  }

  /**
   * Mountain.incidents
   */
  export type Mountain$incidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    cursor?: IncidentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Mountain.incidentLogs
   */
  export type Mountain$incidentLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLog
     */
    select?: IncidentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLog
     */
    omit?: IncidentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogInclude<ExtArgs> | null
    where?: IncidentLogWhereInput
    orderBy?: IncidentLogOrderByWithRelationInput | IncidentLogOrderByWithRelationInput[]
    cursor?: IncidentLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentLogScalarFieldEnum | IncidentLogScalarFieldEnum[]
  }

  /**
   * Mountain.dispatcherAssignments
   */
  export type Mountain$dispatcherAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
    where?: DispatcherAssignmentWhereInput
    orderBy?: DispatcherAssignmentOrderByWithRelationInput | DispatcherAssignmentOrderByWithRelationInput[]
    cursor?: DispatcherAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DispatcherAssignmentScalarFieldEnum | DispatcherAssignmentScalarFieldEnum[]
  }

  /**
   * Mountain.incidentLogEquipment
   */
  export type Mountain$incidentLogEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLogEquipment
     */
    select?: IncidentLogEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLogEquipment
     */
    omit?: IncidentLogEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogEquipmentInclude<ExtArgs> | null
    where?: IncidentLogEquipmentWhereInput
    orderBy?: IncidentLogEquipmentOrderByWithRelationInput | IncidentLogEquipmentOrderByWithRelationInput[]
    cursor?: IncidentLogEquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentLogEquipmentScalarFieldEnum | IncidentLogEquipmentScalarFieldEnum[]
  }

  /**
   * Mountain.weather
   */
  export type Mountain$weatherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    where?: WeatherWhereInput
    orderBy?: WeatherOrderByWithRelationInput | WeatherOrderByWithRelationInput[]
    cursor?: WeatherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeatherScalarFieldEnum | WeatherScalarFieldEnum[]
  }

  /**
   * Mountain without action
   */
  export type MountainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mountain
     */
    select?: MountainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mountain
     */
    omit?: MountainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MountainInclude<ExtArgs> | null
  }


  /**
   * Model Weather
   */

  export type AggregateWeather = {
    _count: WeatherCountAggregateOutputType | null
    _avg: WeatherAvgAggregateOutputType | null
    _sum: WeatherSumAggregateOutputType | null
    _min: WeatherMinAggregateOutputType | null
    _max: WeatherMaxAggregateOutputType | null
  }

  export type WeatherAvgAggregateOutputType = {
    temperature: number | null
    windSpeed: number | null
    visibility: number | null
    snowfall24h: number | null
    snowfall7d: number | null
  }

  export type WeatherSumAggregateOutputType = {
    temperature: number | null
    windSpeed: number | null
    visibility: number | null
    snowfall24h: number | null
    snowfall7d: number | null
  }

  export type WeatherMinAggregateOutputType = {
    id: string | null
    mountainId: string | null
    date: Date | null
    temperature: number | null
    windSpeed: number | null
    windDirection: string | null
    visibility: number | null
    conditions: string | null
    snowfall24h: number | null
    snowfall7d: number | null
    updatedAt: Date | null
  }

  export type WeatherMaxAggregateOutputType = {
    id: string | null
    mountainId: string | null
    date: Date | null
    temperature: number | null
    windSpeed: number | null
    windDirection: string | null
    visibility: number | null
    conditions: string | null
    snowfall24h: number | null
    snowfall7d: number | null
    updatedAt: Date | null
  }

  export type WeatherCountAggregateOutputType = {
    id: number
    mountainId: number
    date: number
    temperature: number
    windSpeed: number
    windDirection: number
    visibility: number
    conditions: number
    snowfall24h: number
    snowfall7d: number
    updatedAt: number
    _all: number
  }


  export type WeatherAvgAggregateInputType = {
    temperature?: true
    windSpeed?: true
    visibility?: true
    snowfall24h?: true
    snowfall7d?: true
  }

  export type WeatherSumAggregateInputType = {
    temperature?: true
    windSpeed?: true
    visibility?: true
    snowfall24h?: true
    snowfall7d?: true
  }

  export type WeatherMinAggregateInputType = {
    id?: true
    mountainId?: true
    date?: true
    temperature?: true
    windSpeed?: true
    windDirection?: true
    visibility?: true
    conditions?: true
    snowfall24h?: true
    snowfall7d?: true
    updatedAt?: true
  }

  export type WeatherMaxAggregateInputType = {
    id?: true
    mountainId?: true
    date?: true
    temperature?: true
    windSpeed?: true
    windDirection?: true
    visibility?: true
    conditions?: true
    snowfall24h?: true
    snowfall7d?: true
    updatedAt?: true
  }

  export type WeatherCountAggregateInputType = {
    id?: true
    mountainId?: true
    date?: true
    temperature?: true
    windSpeed?: true
    windDirection?: true
    visibility?: true
    conditions?: true
    snowfall24h?: true
    snowfall7d?: true
    updatedAt?: true
    _all?: true
  }

  export type WeatherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weather to aggregate.
     */
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     */
    orderBy?: WeatherOrderByWithRelationInput | WeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Weathers
    **/
    _count?: true | WeatherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeatherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeatherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeatherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeatherMaxAggregateInputType
  }

  export type GetWeatherAggregateType<T extends WeatherAggregateArgs> = {
        [P in keyof T & keyof AggregateWeather]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeather[P]>
      : GetScalarType<T[P], AggregateWeather[P]>
  }




  export type WeatherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeatherWhereInput
    orderBy?: WeatherOrderByWithAggregationInput | WeatherOrderByWithAggregationInput[]
    by: WeatherScalarFieldEnum[] | WeatherScalarFieldEnum
    having?: WeatherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeatherCountAggregateInputType | true
    _avg?: WeatherAvgAggregateInputType
    _sum?: WeatherSumAggregateInputType
    _min?: WeatherMinAggregateInputType
    _max?: WeatherMaxAggregateInputType
  }

  export type WeatherGroupByOutputType = {
    id: string
    mountainId: string
    date: Date
    temperature: number
    windSpeed: number
    windDirection: string | null
    visibility: number | null
    conditions: string
    snowfall24h: number | null
    snowfall7d: number | null
    updatedAt: Date
    _count: WeatherCountAggregateOutputType | null
    _avg: WeatherAvgAggregateOutputType | null
    _sum: WeatherSumAggregateOutputType | null
    _min: WeatherMinAggregateOutputType | null
    _max: WeatherMaxAggregateOutputType | null
  }

  type GetWeatherGroupByPayload<T extends WeatherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeatherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeatherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeatherGroupByOutputType[P]>
            : GetScalarType<T[P], WeatherGroupByOutputType[P]>
        }
      >
    >


  export type WeatherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    date?: boolean
    temperature?: boolean
    windSpeed?: boolean
    windDirection?: boolean
    visibility?: boolean
    conditions?: boolean
    snowfall24h?: boolean
    snowfall7d?: boolean
    updatedAt?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weather"]>

  export type WeatherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    date?: boolean
    temperature?: boolean
    windSpeed?: boolean
    windDirection?: boolean
    visibility?: boolean
    conditions?: boolean
    snowfall24h?: boolean
    snowfall7d?: boolean
    updatedAt?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weather"]>

  export type WeatherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mountainId?: boolean
    date?: boolean
    temperature?: boolean
    windSpeed?: boolean
    windDirection?: boolean
    visibility?: boolean
    conditions?: boolean
    snowfall24h?: boolean
    snowfall7d?: boolean
    updatedAt?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weather"]>

  export type WeatherSelectScalar = {
    id?: boolean
    mountainId?: boolean
    date?: boolean
    temperature?: boolean
    windSpeed?: boolean
    windDirection?: boolean
    visibility?: boolean
    conditions?: boolean
    snowfall24h?: boolean
    snowfall7d?: boolean
    updatedAt?: boolean
  }

  export type WeatherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mountainId" | "date" | "temperature" | "windSpeed" | "windDirection" | "visibility" | "conditions" | "snowfall24h" | "snowfall7d" | "updatedAt", ExtArgs["result"]["weather"]>
  export type WeatherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }
  export type WeatherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }
  export type WeatherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }

  export type $WeatherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Weather"
    objects: {
      mountain: Prisma.$MountainPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mountainId: string
      date: Date
      temperature: number
      windSpeed: number
      windDirection: string | null
      visibility: number | null
      conditions: string
      snowfall24h: number | null
      snowfall7d: number | null
      updatedAt: Date
    }, ExtArgs["result"]["weather"]>
    composites: {}
  }

  type WeatherGetPayload<S extends boolean | null | undefined | WeatherDefaultArgs> = $Result.GetResult<Prisma.$WeatherPayload, S>

  type WeatherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeatherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeatherCountAggregateInputType | true
    }

  export interface WeatherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Weather'], meta: { name: 'Weather' } }
    /**
     * Find zero or one Weather that matches the filter.
     * @param {WeatherFindUniqueArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeatherFindUniqueArgs>(args: SelectSubset<T, WeatherFindUniqueArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Weather that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeatherFindUniqueOrThrowArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeatherFindUniqueOrThrowArgs>(args: SelectSubset<T, WeatherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weather that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherFindFirstArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeatherFindFirstArgs>(args?: SelectSubset<T, WeatherFindFirstArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weather that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherFindFirstOrThrowArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeatherFindFirstOrThrowArgs>(args?: SelectSubset<T, WeatherFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Weathers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weathers
     * const weathers = await prisma.weather.findMany()
     * 
     * // Get first 10 Weathers
     * const weathers = await prisma.weather.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weatherWithIdOnly = await prisma.weather.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeatherFindManyArgs>(args?: SelectSubset<T, WeatherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Weather.
     * @param {WeatherCreateArgs} args - Arguments to create a Weather.
     * @example
     * // Create one Weather
     * const Weather = await prisma.weather.create({
     *   data: {
     *     // ... data to create a Weather
     *   }
     * })
     * 
     */
    create<T extends WeatherCreateArgs>(args: SelectSubset<T, WeatherCreateArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Weathers.
     * @param {WeatherCreateManyArgs} args - Arguments to create many Weathers.
     * @example
     * // Create many Weathers
     * const weather = await prisma.weather.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeatherCreateManyArgs>(args?: SelectSubset<T, WeatherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Weathers and returns the data saved in the database.
     * @param {WeatherCreateManyAndReturnArgs} args - Arguments to create many Weathers.
     * @example
     * // Create many Weathers
     * const weather = await prisma.weather.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Weathers and only return the `id`
     * const weatherWithIdOnly = await prisma.weather.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeatherCreateManyAndReturnArgs>(args?: SelectSubset<T, WeatherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Weather.
     * @param {WeatherDeleteArgs} args - Arguments to delete one Weather.
     * @example
     * // Delete one Weather
     * const Weather = await prisma.weather.delete({
     *   where: {
     *     // ... filter to delete one Weather
     *   }
     * })
     * 
     */
    delete<T extends WeatherDeleteArgs>(args: SelectSubset<T, WeatherDeleteArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Weather.
     * @param {WeatherUpdateArgs} args - Arguments to update one Weather.
     * @example
     * // Update one Weather
     * const weather = await prisma.weather.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeatherUpdateArgs>(args: SelectSubset<T, WeatherUpdateArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Weathers.
     * @param {WeatherDeleteManyArgs} args - Arguments to filter Weathers to delete.
     * @example
     * // Delete a few Weathers
     * const { count } = await prisma.weather.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeatherDeleteManyArgs>(args?: SelectSubset<T, WeatherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weathers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weathers
     * const weather = await prisma.weather.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeatherUpdateManyArgs>(args: SelectSubset<T, WeatherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weathers and returns the data updated in the database.
     * @param {WeatherUpdateManyAndReturnArgs} args - Arguments to update many Weathers.
     * @example
     * // Update many Weathers
     * const weather = await prisma.weather.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Weathers and only return the `id`
     * const weatherWithIdOnly = await prisma.weather.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeatherUpdateManyAndReturnArgs>(args: SelectSubset<T, WeatherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Weather.
     * @param {WeatherUpsertArgs} args - Arguments to update or create a Weather.
     * @example
     * // Update or create a Weather
     * const weather = await prisma.weather.upsert({
     *   create: {
     *     // ... data to create a Weather
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weather we want to update
     *   }
     * })
     */
    upsert<T extends WeatherUpsertArgs>(args: SelectSubset<T, WeatherUpsertArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Weathers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherCountArgs} args - Arguments to filter Weathers to count.
     * @example
     * // Count the number of Weathers
     * const count = await prisma.weather.count({
     *   where: {
     *     // ... the filter for the Weathers we want to count
     *   }
     * })
    **/
    count<T extends WeatherCountArgs>(
      args?: Subset<T, WeatherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeatherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weather.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeatherAggregateArgs>(args: Subset<T, WeatherAggregateArgs>): Prisma.PrismaPromise<GetWeatherAggregateType<T>>

    /**
     * Group by Weather.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeatherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeatherGroupByArgs['orderBy'] }
        : { orderBy?: WeatherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeatherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeatherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Weather model
   */
  readonly fields: WeatherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Weather.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeatherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Weather model
   */
  interface WeatherFieldRefs {
    readonly id: FieldRef<"Weather", 'String'>
    readonly mountainId: FieldRef<"Weather", 'String'>
    readonly date: FieldRef<"Weather", 'DateTime'>
    readonly temperature: FieldRef<"Weather", 'Float'>
    readonly windSpeed: FieldRef<"Weather", 'Float'>
    readonly windDirection: FieldRef<"Weather", 'String'>
    readonly visibility: FieldRef<"Weather", 'Float'>
    readonly conditions: FieldRef<"Weather", 'String'>
    readonly snowfall24h: FieldRef<"Weather", 'Float'>
    readonly snowfall7d: FieldRef<"Weather", 'Float'>
    readonly updatedAt: FieldRef<"Weather", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Weather findUnique
   */
  export type WeatherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * Filter, which Weather to fetch.
     */
    where: WeatherWhereUniqueInput
  }

  /**
   * Weather findUniqueOrThrow
   */
  export type WeatherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * Filter, which Weather to fetch.
     */
    where: WeatherWhereUniqueInput
  }

  /**
   * Weather findFirst
   */
  export type WeatherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * Filter, which Weather to fetch.
     */
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     */
    orderBy?: WeatherOrderByWithRelationInput | WeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weathers.
     */
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weathers.
     */
    distinct?: WeatherScalarFieldEnum | WeatherScalarFieldEnum[]
  }

  /**
   * Weather findFirstOrThrow
   */
  export type WeatherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * Filter, which Weather to fetch.
     */
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     */
    orderBy?: WeatherOrderByWithRelationInput | WeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weathers.
     */
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weathers.
     */
    distinct?: WeatherScalarFieldEnum | WeatherScalarFieldEnum[]
  }

  /**
   * Weather findMany
   */
  export type WeatherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * Filter, which Weathers to fetch.
     */
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     */
    orderBy?: WeatherOrderByWithRelationInput | WeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Weathers.
     */
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     */
    skip?: number
    distinct?: WeatherScalarFieldEnum | WeatherScalarFieldEnum[]
  }

  /**
   * Weather create
   */
  export type WeatherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * The data needed to create a Weather.
     */
    data: XOR<WeatherCreateInput, WeatherUncheckedCreateInput>
  }

  /**
   * Weather createMany
   */
  export type WeatherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Weathers.
     */
    data: WeatherCreateManyInput | WeatherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Weather createManyAndReturn
   */
  export type WeatherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * The data used to create many Weathers.
     */
    data: WeatherCreateManyInput | WeatherCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Weather update
   */
  export type WeatherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * The data needed to update a Weather.
     */
    data: XOR<WeatherUpdateInput, WeatherUncheckedUpdateInput>
    /**
     * Choose, which Weather to update.
     */
    where: WeatherWhereUniqueInput
  }

  /**
   * Weather updateMany
   */
  export type WeatherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Weathers.
     */
    data: XOR<WeatherUpdateManyMutationInput, WeatherUncheckedUpdateManyInput>
    /**
     * Filter which Weathers to update
     */
    where?: WeatherWhereInput
    /**
     * Limit how many Weathers to update.
     */
    limit?: number
  }

  /**
   * Weather updateManyAndReturn
   */
  export type WeatherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * The data used to update Weathers.
     */
    data: XOR<WeatherUpdateManyMutationInput, WeatherUncheckedUpdateManyInput>
    /**
     * Filter which Weathers to update
     */
    where?: WeatherWhereInput
    /**
     * Limit how many Weathers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Weather upsert
   */
  export type WeatherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * The filter to search for the Weather to update in case it exists.
     */
    where: WeatherWhereUniqueInput
    /**
     * In case the Weather found by the `where` argument doesn't exist, create a new Weather with this data.
     */
    create: XOR<WeatherCreateInput, WeatherUncheckedCreateInput>
    /**
     * In case the Weather was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeatherUpdateInput, WeatherUncheckedUpdateInput>
  }

  /**
   * Weather delete
   */
  export type WeatherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
    /**
     * Filter which Weather to delete.
     */
    where: WeatherWhereUniqueInput
  }

  /**
   * Weather deleteMany
   */
  export type WeatherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weathers to delete
     */
    where?: WeatherWhereInput
    /**
     * Limit how many Weathers to delete.
     */
    limit?: number
  }

  /**
   * Weather without action
   */
  export type WeatherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    department: $Enums.Department | null
    mountainId: string | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    department: $Enums.Department | null
    mountainId: string | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    name: number
    role: number
    department: number
    mountainId: number
    _all: number
  }


  export type EmployeeMinAggregateInputType = {
    id?: true
    name?: true
    role?: true
    department?: true
    mountainId?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    name?: true
    role?: true
    department?: true
    mountainId?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    name?: true
    role?: true
    department?: true
    mountainId?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: string
    name: string
    role: string
    department: $Enums.Department
    mountainId: string
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    department?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    dispatcherAssignments?: boolean | Employee$dispatcherAssignmentsArgs<ExtArgs>
    logs?: boolean | Employee$logsArgs<ExtArgs>
    liftChecks?: boolean | Employee$liftChecksArgs<ExtArgs>
    trailChecks?: boolean | Employee$trailChecksArgs<ExtArgs>
    hutChecks?: boolean | Employee$hutChecksArgs<ExtArgs>
    aidRoomChecks?: boolean | Employee$aidRoomChecksArgs<ExtArgs>
    equipmentChecks?: boolean | Employee$equipmentChecksArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    department?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    department?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    name?: boolean
    role?: boolean
    department?: boolean
    mountainId?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "role" | "department" | "mountainId", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    dispatcherAssignments?: boolean | Employee$dispatcherAssignmentsArgs<ExtArgs>
    logs?: boolean | Employee$logsArgs<ExtArgs>
    liftChecks?: boolean | Employee$liftChecksArgs<ExtArgs>
    trailChecks?: boolean | Employee$trailChecksArgs<ExtArgs>
    hutChecks?: boolean | Employee$hutChecksArgs<ExtArgs>
    aidRoomChecks?: boolean | Employee$aidRoomChecksArgs<ExtArgs>
    equipmentChecks?: boolean | Employee$equipmentChecksArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      mountain: Prisma.$MountainPayload<ExtArgs>
      dispatcherAssignments: Prisma.$DispatcherAssignmentPayload<ExtArgs>[]
      logs: Prisma.$IncidentLogPayload<ExtArgs>[]
      liftChecks: Prisma.$LiftCheckPayload<ExtArgs>[]
      trailChecks: Prisma.$TrailCheckPayload<ExtArgs>[]
      hutChecks: Prisma.$HutCheckPayload<ExtArgs>[]
      aidRoomChecks: Prisma.$AidRoomCheckPayload<ExtArgs>[]
      equipmentChecks: Prisma.$EquipmentCheckPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      role: string
      department: $Enums.Department
      mountainId: string
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dispatcherAssignments<T extends Employee$dispatcherAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$dispatcherAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    logs<T extends Employee$logsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    liftChecks<T extends Employee$liftChecksArgs<ExtArgs> = {}>(args?: Subset<T, Employee$liftChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trailChecks<T extends Employee$trailChecksArgs<ExtArgs> = {}>(args?: Subset<T, Employee$trailChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hutChecks<T extends Employee$hutChecksArgs<ExtArgs> = {}>(args?: Subset<T, Employee$hutChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aidRoomChecks<T extends Employee$aidRoomChecksArgs<ExtArgs> = {}>(args?: Subset<T, Employee$aidRoomChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipmentChecks<T extends Employee$equipmentChecksArgs<ExtArgs> = {}>(args?: Subset<T, Employee$equipmentChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'String'>
    readonly name: FieldRef<"Employee", 'String'>
    readonly role: FieldRef<"Employee", 'String'>
    readonly department: FieldRef<"Employee", 'Department'>
    readonly mountainId: FieldRef<"Employee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.dispatcherAssignments
   */
  export type Employee$dispatcherAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
    where?: DispatcherAssignmentWhereInput
    orderBy?: DispatcherAssignmentOrderByWithRelationInput | DispatcherAssignmentOrderByWithRelationInput[]
    cursor?: DispatcherAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DispatcherAssignmentScalarFieldEnum | DispatcherAssignmentScalarFieldEnum[]
  }

  /**
   * Employee.logs
   */
  export type Employee$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLog
     */
    select?: IncidentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLog
     */
    omit?: IncidentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogInclude<ExtArgs> | null
    where?: IncidentLogWhereInput
    orderBy?: IncidentLogOrderByWithRelationInput | IncidentLogOrderByWithRelationInput[]
    cursor?: IncidentLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentLogScalarFieldEnum | IncidentLogScalarFieldEnum[]
  }

  /**
   * Employee.liftChecks
   */
  export type Employee$liftChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    where?: LiftCheckWhereInput
    orderBy?: LiftCheckOrderByWithRelationInput | LiftCheckOrderByWithRelationInput[]
    cursor?: LiftCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiftCheckScalarFieldEnum | LiftCheckScalarFieldEnum[]
  }

  /**
   * Employee.trailChecks
   */
  export type Employee$trailChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    where?: TrailCheckWhereInput
    orderBy?: TrailCheckOrderByWithRelationInput | TrailCheckOrderByWithRelationInput[]
    cursor?: TrailCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrailCheckScalarFieldEnum | TrailCheckScalarFieldEnum[]
  }

  /**
   * Employee.hutChecks
   */
  export type Employee$hutChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    where?: HutCheckWhereInput
    orderBy?: HutCheckOrderByWithRelationInput | HutCheckOrderByWithRelationInput[]
    cursor?: HutCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HutCheckScalarFieldEnum | HutCheckScalarFieldEnum[]
  }

  /**
   * Employee.aidRoomChecks
   */
  export type Employee$aidRoomChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    where?: AidRoomCheckWhereInput
    orderBy?: AidRoomCheckOrderByWithRelationInput | AidRoomCheckOrderByWithRelationInput[]
    cursor?: AidRoomCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AidRoomCheckScalarFieldEnum | AidRoomCheckScalarFieldEnum[]
  }

  /**
   * Employee.equipmentChecks
   */
  export type Employee$equipmentChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    where?: EquipmentCheckWhereInput
    orderBy?: EquipmentCheckOrderByWithRelationInput | EquipmentCheckOrderByWithRelationInput[]
    cursor?: EquipmentCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentCheckScalarFieldEnum | EquipmentCheckScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model DispatcherAssignment
   */

  export type AggregateDispatcherAssignment = {
    _count: DispatcherAssignmentCountAggregateOutputType | null
    _min: DispatcherAssignmentMinAggregateOutputType | null
    _max: DispatcherAssignmentMaxAggregateOutputType | null
  }

  export type DispatcherAssignmentMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    assignedAt: Date | null
    mountainId: string | null
  }

  export type DispatcherAssignmentMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    assignedAt: Date | null
    mountainId: string | null
  }

  export type DispatcherAssignmentCountAggregateOutputType = {
    id: number
    employeeId: number
    assignedAt: number
    mountainId: number
    _all: number
  }


  export type DispatcherAssignmentMinAggregateInputType = {
    id?: true
    employeeId?: true
    assignedAt?: true
    mountainId?: true
  }

  export type DispatcherAssignmentMaxAggregateInputType = {
    id?: true
    employeeId?: true
    assignedAt?: true
    mountainId?: true
  }

  export type DispatcherAssignmentCountAggregateInputType = {
    id?: true
    employeeId?: true
    assignedAt?: true
    mountainId?: true
    _all?: true
  }

  export type DispatcherAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DispatcherAssignment to aggregate.
     */
    where?: DispatcherAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispatcherAssignments to fetch.
     */
    orderBy?: DispatcherAssignmentOrderByWithRelationInput | DispatcherAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DispatcherAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispatcherAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispatcherAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DispatcherAssignments
    **/
    _count?: true | DispatcherAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DispatcherAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DispatcherAssignmentMaxAggregateInputType
  }

  export type GetDispatcherAssignmentAggregateType<T extends DispatcherAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDispatcherAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDispatcherAssignment[P]>
      : GetScalarType<T[P], AggregateDispatcherAssignment[P]>
  }




  export type DispatcherAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispatcherAssignmentWhereInput
    orderBy?: DispatcherAssignmentOrderByWithAggregationInput | DispatcherAssignmentOrderByWithAggregationInput[]
    by: DispatcherAssignmentScalarFieldEnum[] | DispatcherAssignmentScalarFieldEnum
    having?: DispatcherAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DispatcherAssignmentCountAggregateInputType | true
    _min?: DispatcherAssignmentMinAggregateInputType
    _max?: DispatcherAssignmentMaxAggregateInputType
  }

  export type DispatcherAssignmentGroupByOutputType = {
    id: string
    employeeId: string
    assignedAt: Date
    mountainId: string
    _count: DispatcherAssignmentCountAggregateOutputType | null
    _min: DispatcherAssignmentMinAggregateOutputType | null
    _max: DispatcherAssignmentMaxAggregateOutputType | null
  }

  type GetDispatcherAssignmentGroupByPayload<T extends DispatcherAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DispatcherAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DispatcherAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DispatcherAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], DispatcherAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type DispatcherAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    assignedAt?: boolean
    mountainId?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispatcherAssignment"]>

  export type DispatcherAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    assignedAt?: boolean
    mountainId?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispatcherAssignment"]>

  export type DispatcherAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    assignedAt?: boolean
    mountainId?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispatcherAssignment"]>

  export type DispatcherAssignmentSelectScalar = {
    id?: boolean
    employeeId?: boolean
    assignedAt?: boolean
    mountainId?: boolean
  }

  export type DispatcherAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "assignedAt" | "mountainId", ExtArgs["result"]["dispatcherAssignment"]>
  export type DispatcherAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }
  export type DispatcherAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }
  export type DispatcherAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }

  export type $DispatcherAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DispatcherAssignment"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      mountain: Prisma.$MountainPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      assignedAt: Date
      mountainId: string
    }, ExtArgs["result"]["dispatcherAssignment"]>
    composites: {}
  }

  type DispatcherAssignmentGetPayload<S extends boolean | null | undefined | DispatcherAssignmentDefaultArgs> = $Result.GetResult<Prisma.$DispatcherAssignmentPayload, S>

  type DispatcherAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DispatcherAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DispatcherAssignmentCountAggregateInputType | true
    }

  export interface DispatcherAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DispatcherAssignment'], meta: { name: 'DispatcherAssignment' } }
    /**
     * Find zero or one DispatcherAssignment that matches the filter.
     * @param {DispatcherAssignmentFindUniqueArgs} args - Arguments to find a DispatcherAssignment
     * @example
     * // Get one DispatcherAssignment
     * const dispatcherAssignment = await prisma.dispatcherAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DispatcherAssignmentFindUniqueArgs>(args: SelectSubset<T, DispatcherAssignmentFindUniqueArgs<ExtArgs>>): Prisma__DispatcherAssignmentClient<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DispatcherAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DispatcherAssignmentFindUniqueOrThrowArgs} args - Arguments to find a DispatcherAssignment
     * @example
     * // Get one DispatcherAssignment
     * const dispatcherAssignment = await prisma.dispatcherAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DispatcherAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DispatcherAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DispatcherAssignmentClient<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DispatcherAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatcherAssignmentFindFirstArgs} args - Arguments to find a DispatcherAssignment
     * @example
     * // Get one DispatcherAssignment
     * const dispatcherAssignment = await prisma.dispatcherAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DispatcherAssignmentFindFirstArgs>(args?: SelectSubset<T, DispatcherAssignmentFindFirstArgs<ExtArgs>>): Prisma__DispatcherAssignmentClient<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DispatcherAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatcherAssignmentFindFirstOrThrowArgs} args - Arguments to find a DispatcherAssignment
     * @example
     * // Get one DispatcherAssignment
     * const dispatcherAssignment = await prisma.dispatcherAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DispatcherAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DispatcherAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DispatcherAssignmentClient<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DispatcherAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatcherAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DispatcherAssignments
     * const dispatcherAssignments = await prisma.dispatcherAssignment.findMany()
     * 
     * // Get first 10 DispatcherAssignments
     * const dispatcherAssignments = await prisma.dispatcherAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dispatcherAssignmentWithIdOnly = await prisma.dispatcherAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DispatcherAssignmentFindManyArgs>(args?: SelectSubset<T, DispatcherAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DispatcherAssignment.
     * @param {DispatcherAssignmentCreateArgs} args - Arguments to create a DispatcherAssignment.
     * @example
     * // Create one DispatcherAssignment
     * const DispatcherAssignment = await prisma.dispatcherAssignment.create({
     *   data: {
     *     // ... data to create a DispatcherAssignment
     *   }
     * })
     * 
     */
    create<T extends DispatcherAssignmentCreateArgs>(args: SelectSubset<T, DispatcherAssignmentCreateArgs<ExtArgs>>): Prisma__DispatcherAssignmentClient<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DispatcherAssignments.
     * @param {DispatcherAssignmentCreateManyArgs} args - Arguments to create many DispatcherAssignments.
     * @example
     * // Create many DispatcherAssignments
     * const dispatcherAssignment = await prisma.dispatcherAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DispatcherAssignmentCreateManyArgs>(args?: SelectSubset<T, DispatcherAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DispatcherAssignments and returns the data saved in the database.
     * @param {DispatcherAssignmentCreateManyAndReturnArgs} args - Arguments to create many DispatcherAssignments.
     * @example
     * // Create many DispatcherAssignments
     * const dispatcherAssignment = await prisma.dispatcherAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DispatcherAssignments and only return the `id`
     * const dispatcherAssignmentWithIdOnly = await prisma.dispatcherAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DispatcherAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DispatcherAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DispatcherAssignment.
     * @param {DispatcherAssignmentDeleteArgs} args - Arguments to delete one DispatcherAssignment.
     * @example
     * // Delete one DispatcherAssignment
     * const DispatcherAssignment = await prisma.dispatcherAssignment.delete({
     *   where: {
     *     // ... filter to delete one DispatcherAssignment
     *   }
     * })
     * 
     */
    delete<T extends DispatcherAssignmentDeleteArgs>(args: SelectSubset<T, DispatcherAssignmentDeleteArgs<ExtArgs>>): Prisma__DispatcherAssignmentClient<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DispatcherAssignment.
     * @param {DispatcherAssignmentUpdateArgs} args - Arguments to update one DispatcherAssignment.
     * @example
     * // Update one DispatcherAssignment
     * const dispatcherAssignment = await prisma.dispatcherAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DispatcherAssignmentUpdateArgs>(args: SelectSubset<T, DispatcherAssignmentUpdateArgs<ExtArgs>>): Prisma__DispatcherAssignmentClient<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DispatcherAssignments.
     * @param {DispatcherAssignmentDeleteManyArgs} args - Arguments to filter DispatcherAssignments to delete.
     * @example
     * // Delete a few DispatcherAssignments
     * const { count } = await prisma.dispatcherAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DispatcherAssignmentDeleteManyArgs>(args?: SelectSubset<T, DispatcherAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DispatcherAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatcherAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DispatcherAssignments
     * const dispatcherAssignment = await prisma.dispatcherAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DispatcherAssignmentUpdateManyArgs>(args: SelectSubset<T, DispatcherAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DispatcherAssignments and returns the data updated in the database.
     * @param {DispatcherAssignmentUpdateManyAndReturnArgs} args - Arguments to update many DispatcherAssignments.
     * @example
     * // Update many DispatcherAssignments
     * const dispatcherAssignment = await prisma.dispatcherAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DispatcherAssignments and only return the `id`
     * const dispatcherAssignmentWithIdOnly = await prisma.dispatcherAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DispatcherAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DispatcherAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DispatcherAssignment.
     * @param {DispatcherAssignmentUpsertArgs} args - Arguments to update or create a DispatcherAssignment.
     * @example
     * // Update or create a DispatcherAssignment
     * const dispatcherAssignment = await prisma.dispatcherAssignment.upsert({
     *   create: {
     *     // ... data to create a DispatcherAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DispatcherAssignment we want to update
     *   }
     * })
     */
    upsert<T extends DispatcherAssignmentUpsertArgs>(args: SelectSubset<T, DispatcherAssignmentUpsertArgs<ExtArgs>>): Prisma__DispatcherAssignmentClient<$Result.GetResult<Prisma.$DispatcherAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DispatcherAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatcherAssignmentCountArgs} args - Arguments to filter DispatcherAssignments to count.
     * @example
     * // Count the number of DispatcherAssignments
     * const count = await prisma.dispatcherAssignment.count({
     *   where: {
     *     // ... the filter for the DispatcherAssignments we want to count
     *   }
     * })
    **/
    count<T extends DispatcherAssignmentCountArgs>(
      args?: Subset<T, DispatcherAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DispatcherAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DispatcherAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatcherAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DispatcherAssignmentAggregateArgs>(args: Subset<T, DispatcherAssignmentAggregateArgs>): Prisma.PrismaPromise<GetDispatcherAssignmentAggregateType<T>>

    /**
     * Group by DispatcherAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatcherAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DispatcherAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DispatcherAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: DispatcherAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DispatcherAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDispatcherAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DispatcherAssignment model
   */
  readonly fields: DispatcherAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DispatcherAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DispatcherAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DispatcherAssignment model
   */
  interface DispatcherAssignmentFieldRefs {
    readonly id: FieldRef<"DispatcherAssignment", 'String'>
    readonly employeeId: FieldRef<"DispatcherAssignment", 'String'>
    readonly assignedAt: FieldRef<"DispatcherAssignment", 'DateTime'>
    readonly mountainId: FieldRef<"DispatcherAssignment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DispatcherAssignment findUnique
   */
  export type DispatcherAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DispatcherAssignment to fetch.
     */
    where: DispatcherAssignmentWhereUniqueInput
  }

  /**
   * DispatcherAssignment findUniqueOrThrow
   */
  export type DispatcherAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DispatcherAssignment to fetch.
     */
    where: DispatcherAssignmentWhereUniqueInput
  }

  /**
   * DispatcherAssignment findFirst
   */
  export type DispatcherAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DispatcherAssignment to fetch.
     */
    where?: DispatcherAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispatcherAssignments to fetch.
     */
    orderBy?: DispatcherAssignmentOrderByWithRelationInput | DispatcherAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DispatcherAssignments.
     */
    cursor?: DispatcherAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispatcherAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispatcherAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DispatcherAssignments.
     */
    distinct?: DispatcherAssignmentScalarFieldEnum | DispatcherAssignmentScalarFieldEnum[]
  }

  /**
   * DispatcherAssignment findFirstOrThrow
   */
  export type DispatcherAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DispatcherAssignment to fetch.
     */
    where?: DispatcherAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispatcherAssignments to fetch.
     */
    orderBy?: DispatcherAssignmentOrderByWithRelationInput | DispatcherAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DispatcherAssignments.
     */
    cursor?: DispatcherAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispatcherAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispatcherAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DispatcherAssignments.
     */
    distinct?: DispatcherAssignmentScalarFieldEnum | DispatcherAssignmentScalarFieldEnum[]
  }

  /**
   * DispatcherAssignment findMany
   */
  export type DispatcherAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DispatcherAssignments to fetch.
     */
    where?: DispatcherAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispatcherAssignments to fetch.
     */
    orderBy?: DispatcherAssignmentOrderByWithRelationInput | DispatcherAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DispatcherAssignments.
     */
    cursor?: DispatcherAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispatcherAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispatcherAssignments.
     */
    skip?: number
    distinct?: DispatcherAssignmentScalarFieldEnum | DispatcherAssignmentScalarFieldEnum[]
  }

  /**
   * DispatcherAssignment create
   */
  export type DispatcherAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a DispatcherAssignment.
     */
    data: XOR<DispatcherAssignmentCreateInput, DispatcherAssignmentUncheckedCreateInput>
  }

  /**
   * DispatcherAssignment createMany
   */
  export type DispatcherAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DispatcherAssignments.
     */
    data: DispatcherAssignmentCreateManyInput | DispatcherAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DispatcherAssignment createManyAndReturn
   */
  export type DispatcherAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many DispatcherAssignments.
     */
    data: DispatcherAssignmentCreateManyInput | DispatcherAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DispatcherAssignment update
   */
  export type DispatcherAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a DispatcherAssignment.
     */
    data: XOR<DispatcherAssignmentUpdateInput, DispatcherAssignmentUncheckedUpdateInput>
    /**
     * Choose, which DispatcherAssignment to update.
     */
    where: DispatcherAssignmentWhereUniqueInput
  }

  /**
   * DispatcherAssignment updateMany
   */
  export type DispatcherAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DispatcherAssignments.
     */
    data: XOR<DispatcherAssignmentUpdateManyMutationInput, DispatcherAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which DispatcherAssignments to update
     */
    where?: DispatcherAssignmentWhereInput
    /**
     * Limit how many DispatcherAssignments to update.
     */
    limit?: number
  }

  /**
   * DispatcherAssignment updateManyAndReturn
   */
  export type DispatcherAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update DispatcherAssignments.
     */
    data: XOR<DispatcherAssignmentUpdateManyMutationInput, DispatcherAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which DispatcherAssignments to update
     */
    where?: DispatcherAssignmentWhereInput
    /**
     * Limit how many DispatcherAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DispatcherAssignment upsert
   */
  export type DispatcherAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the DispatcherAssignment to update in case it exists.
     */
    where: DispatcherAssignmentWhereUniqueInput
    /**
     * In case the DispatcherAssignment found by the `where` argument doesn't exist, create a new DispatcherAssignment with this data.
     */
    create: XOR<DispatcherAssignmentCreateInput, DispatcherAssignmentUncheckedCreateInput>
    /**
     * In case the DispatcherAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DispatcherAssignmentUpdateInput, DispatcherAssignmentUncheckedUpdateInput>
  }

  /**
   * DispatcherAssignment delete
   */
  export type DispatcherAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
    /**
     * Filter which DispatcherAssignment to delete.
     */
    where: DispatcherAssignmentWhereUniqueInput
  }

  /**
   * DispatcherAssignment deleteMany
   */
  export type DispatcherAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DispatcherAssignments to delete
     */
    where?: DispatcherAssignmentWhereInput
    /**
     * Limit how many DispatcherAssignments to delete.
     */
    limit?: number
  }

  /**
   * DispatcherAssignment without action
   */
  export type DispatcherAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatcherAssignment
     */
    select?: DispatcherAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatcherAssignment
     */
    omit?: DispatcherAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatcherAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Lift
   */

  export type AggregateLift = {
    _count: LiftCountAggregateOutputType | null
    _avg: LiftAvgAggregateOutputType | null
    _sum: LiftSumAggregateOutputType | null
    _min: LiftMinAggregateOutputType | null
    _max: LiftMaxAggregateOutputType | null
  }

  export type LiftAvgAggregateOutputType = {
    capacity: number | null
  }

  export type LiftSumAggregateOutputType = {
    capacity: number | null
  }

  export type LiftMinAggregateOutputType = {
    id: string | null
    name: string | null
    capacity: number | null
    status: $Enums.Status | null
    mountainId: string | null
  }

  export type LiftMaxAggregateOutputType = {
    id: string | null
    name: string | null
    capacity: number | null
    status: $Enums.Status | null
    mountainId: string | null
  }

  export type LiftCountAggregateOutputType = {
    id: number
    name: number
    capacity: number
    status: number
    mountainId: number
    _all: number
  }


  export type LiftAvgAggregateInputType = {
    capacity?: true
  }

  export type LiftSumAggregateInputType = {
    capacity?: true
  }

  export type LiftMinAggregateInputType = {
    id?: true
    name?: true
    capacity?: true
    status?: true
    mountainId?: true
  }

  export type LiftMaxAggregateInputType = {
    id?: true
    name?: true
    capacity?: true
    status?: true
    mountainId?: true
  }

  export type LiftCountAggregateInputType = {
    id?: true
    name?: true
    capacity?: true
    status?: true
    mountainId?: true
    _all?: true
  }

  export type LiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lift to aggregate.
     */
    where?: LiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lifts to fetch.
     */
    orderBy?: LiftOrderByWithRelationInput | LiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lifts
    **/
    _count?: true | LiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LiftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LiftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiftMaxAggregateInputType
  }

  export type GetLiftAggregateType<T extends LiftAggregateArgs> = {
        [P in keyof T & keyof AggregateLift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLift[P]>
      : GetScalarType<T[P], AggregateLift[P]>
  }




  export type LiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiftWhereInput
    orderBy?: LiftOrderByWithAggregationInput | LiftOrderByWithAggregationInput[]
    by: LiftScalarFieldEnum[] | LiftScalarFieldEnum
    having?: LiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiftCountAggregateInputType | true
    _avg?: LiftAvgAggregateInputType
    _sum?: LiftSumAggregateInputType
    _min?: LiftMinAggregateInputType
    _max?: LiftMaxAggregateInputType
  }

  export type LiftGroupByOutputType = {
    id: string
    name: string
    capacity: number
    status: $Enums.Status
    mountainId: string
    _count: LiftCountAggregateOutputType | null
    _avg: LiftAvgAggregateOutputType | null
    _sum: LiftSumAggregateOutputType | null
    _min: LiftMinAggregateOutputType | null
    _max: LiftMaxAggregateOutputType | null
  }

  type GetLiftGroupByPayload<T extends LiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LiftGroupByOutputType[P]>
            : GetScalarType<T[P], LiftGroupByOutputType[P]>
        }
      >
    >


  export type LiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    capacity?: boolean
    status?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incidentLogs?: boolean | Lift$incidentLogsArgs<ExtArgs>
    liftChecks?: boolean | Lift$liftChecksArgs<ExtArgs>
    _count?: boolean | LiftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lift"]>

  export type LiftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    capacity?: boolean
    status?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lift"]>

  export type LiftSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    capacity?: boolean
    status?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lift"]>

  export type LiftSelectScalar = {
    id?: boolean
    name?: boolean
    capacity?: boolean
    status?: boolean
    mountainId?: boolean
  }

  export type LiftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "capacity" | "status" | "mountainId", ExtArgs["result"]["lift"]>
  export type LiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incidentLogs?: boolean | Lift$incidentLogsArgs<ExtArgs>
    liftChecks?: boolean | Lift$liftChecksArgs<ExtArgs>
    _count?: boolean | LiftCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LiftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }
  export type LiftIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }

  export type $LiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lift"
    objects: {
      mountain: Prisma.$MountainPayload<ExtArgs>
      incidentLogs: Prisma.$IncidentLogPayload<ExtArgs>[]
      liftChecks: Prisma.$LiftCheckPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      capacity: number
      status: $Enums.Status
      mountainId: string
    }, ExtArgs["result"]["lift"]>
    composites: {}
  }

  type LiftGetPayload<S extends boolean | null | undefined | LiftDefaultArgs> = $Result.GetResult<Prisma.$LiftPayload, S>

  type LiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LiftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LiftCountAggregateInputType | true
    }

  export interface LiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lift'], meta: { name: 'Lift' } }
    /**
     * Find zero or one Lift that matches the filter.
     * @param {LiftFindUniqueArgs} args - Arguments to find a Lift
     * @example
     * // Get one Lift
     * const lift = await prisma.lift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LiftFindUniqueArgs>(args: SelectSubset<T, LiftFindUniqueArgs<ExtArgs>>): Prisma__LiftClient<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lift that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LiftFindUniqueOrThrowArgs} args - Arguments to find a Lift
     * @example
     * // Get one Lift
     * const lift = await prisma.lift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LiftFindUniqueOrThrowArgs>(args: SelectSubset<T, LiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LiftClient<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftFindFirstArgs} args - Arguments to find a Lift
     * @example
     * // Get one Lift
     * const lift = await prisma.lift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LiftFindFirstArgs>(args?: SelectSubset<T, LiftFindFirstArgs<ExtArgs>>): Prisma__LiftClient<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftFindFirstOrThrowArgs} args - Arguments to find a Lift
     * @example
     * // Get one Lift
     * const lift = await prisma.lift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LiftFindFirstOrThrowArgs>(args?: SelectSubset<T, LiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__LiftClient<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lifts
     * const lifts = await prisma.lift.findMany()
     * 
     * // Get first 10 Lifts
     * const lifts = await prisma.lift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const liftWithIdOnly = await prisma.lift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LiftFindManyArgs>(args?: SelectSubset<T, LiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lift.
     * @param {LiftCreateArgs} args - Arguments to create a Lift.
     * @example
     * // Create one Lift
     * const Lift = await prisma.lift.create({
     *   data: {
     *     // ... data to create a Lift
     *   }
     * })
     * 
     */
    create<T extends LiftCreateArgs>(args: SelectSubset<T, LiftCreateArgs<ExtArgs>>): Prisma__LiftClient<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lifts.
     * @param {LiftCreateManyArgs} args - Arguments to create many Lifts.
     * @example
     * // Create many Lifts
     * const lift = await prisma.lift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LiftCreateManyArgs>(args?: SelectSubset<T, LiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lifts and returns the data saved in the database.
     * @param {LiftCreateManyAndReturnArgs} args - Arguments to create many Lifts.
     * @example
     * // Create many Lifts
     * const lift = await prisma.lift.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lifts and only return the `id`
     * const liftWithIdOnly = await prisma.lift.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LiftCreateManyAndReturnArgs>(args?: SelectSubset<T, LiftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lift.
     * @param {LiftDeleteArgs} args - Arguments to delete one Lift.
     * @example
     * // Delete one Lift
     * const Lift = await prisma.lift.delete({
     *   where: {
     *     // ... filter to delete one Lift
     *   }
     * })
     * 
     */
    delete<T extends LiftDeleteArgs>(args: SelectSubset<T, LiftDeleteArgs<ExtArgs>>): Prisma__LiftClient<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lift.
     * @param {LiftUpdateArgs} args - Arguments to update one Lift.
     * @example
     * // Update one Lift
     * const lift = await prisma.lift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LiftUpdateArgs>(args: SelectSubset<T, LiftUpdateArgs<ExtArgs>>): Prisma__LiftClient<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lifts.
     * @param {LiftDeleteManyArgs} args - Arguments to filter Lifts to delete.
     * @example
     * // Delete a few Lifts
     * const { count } = await prisma.lift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LiftDeleteManyArgs>(args?: SelectSubset<T, LiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lifts
     * const lift = await prisma.lift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LiftUpdateManyArgs>(args: SelectSubset<T, LiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lifts and returns the data updated in the database.
     * @param {LiftUpdateManyAndReturnArgs} args - Arguments to update many Lifts.
     * @example
     * // Update many Lifts
     * const lift = await prisma.lift.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lifts and only return the `id`
     * const liftWithIdOnly = await prisma.lift.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LiftUpdateManyAndReturnArgs>(args: SelectSubset<T, LiftUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lift.
     * @param {LiftUpsertArgs} args - Arguments to update or create a Lift.
     * @example
     * // Update or create a Lift
     * const lift = await prisma.lift.upsert({
     *   create: {
     *     // ... data to create a Lift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lift we want to update
     *   }
     * })
     */
    upsert<T extends LiftUpsertArgs>(args: SelectSubset<T, LiftUpsertArgs<ExtArgs>>): Prisma__LiftClient<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftCountArgs} args - Arguments to filter Lifts to count.
     * @example
     * // Count the number of Lifts
     * const count = await prisma.lift.count({
     *   where: {
     *     // ... the filter for the Lifts we want to count
     *   }
     * })
    **/
    count<T extends LiftCountArgs>(
      args?: Subset<T, LiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiftAggregateArgs>(args: Subset<T, LiftAggregateArgs>): Prisma.PrismaPromise<GetLiftAggregateType<T>>

    /**
     * Group by Lift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiftGroupByArgs['orderBy'] }
        : { orderBy?: LiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lift model
   */
  readonly fields: LiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    incidentLogs<T extends Lift$incidentLogsArgs<ExtArgs> = {}>(args?: Subset<T, Lift$incidentLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    liftChecks<T extends Lift$liftChecksArgs<ExtArgs> = {}>(args?: Subset<T, Lift$liftChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lift model
   */
  interface LiftFieldRefs {
    readonly id: FieldRef<"Lift", 'String'>
    readonly name: FieldRef<"Lift", 'String'>
    readonly capacity: FieldRef<"Lift", 'Int'>
    readonly status: FieldRef<"Lift", 'Status'>
    readonly mountainId: FieldRef<"Lift", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lift findUnique
   */
  export type LiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
    /**
     * Filter, which Lift to fetch.
     */
    where: LiftWhereUniqueInput
  }

  /**
   * Lift findUniqueOrThrow
   */
  export type LiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
    /**
     * Filter, which Lift to fetch.
     */
    where: LiftWhereUniqueInput
  }

  /**
   * Lift findFirst
   */
  export type LiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
    /**
     * Filter, which Lift to fetch.
     */
    where?: LiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lifts to fetch.
     */
    orderBy?: LiftOrderByWithRelationInput | LiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lifts.
     */
    cursor?: LiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lifts.
     */
    distinct?: LiftScalarFieldEnum | LiftScalarFieldEnum[]
  }

  /**
   * Lift findFirstOrThrow
   */
  export type LiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
    /**
     * Filter, which Lift to fetch.
     */
    where?: LiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lifts to fetch.
     */
    orderBy?: LiftOrderByWithRelationInput | LiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lifts.
     */
    cursor?: LiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lifts.
     */
    distinct?: LiftScalarFieldEnum | LiftScalarFieldEnum[]
  }

  /**
   * Lift findMany
   */
  export type LiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
    /**
     * Filter, which Lifts to fetch.
     */
    where?: LiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lifts to fetch.
     */
    orderBy?: LiftOrderByWithRelationInput | LiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lifts.
     */
    cursor?: LiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lifts.
     */
    skip?: number
    distinct?: LiftScalarFieldEnum | LiftScalarFieldEnum[]
  }

  /**
   * Lift create
   */
  export type LiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
    /**
     * The data needed to create a Lift.
     */
    data: XOR<LiftCreateInput, LiftUncheckedCreateInput>
  }

  /**
   * Lift createMany
   */
  export type LiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lifts.
     */
    data: LiftCreateManyInput | LiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lift createManyAndReturn
   */
  export type LiftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * The data used to create many Lifts.
     */
    data: LiftCreateManyInput | LiftCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lift update
   */
  export type LiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
    /**
     * The data needed to update a Lift.
     */
    data: XOR<LiftUpdateInput, LiftUncheckedUpdateInput>
    /**
     * Choose, which Lift to update.
     */
    where: LiftWhereUniqueInput
  }

  /**
   * Lift updateMany
   */
  export type LiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lifts.
     */
    data: XOR<LiftUpdateManyMutationInput, LiftUncheckedUpdateManyInput>
    /**
     * Filter which Lifts to update
     */
    where?: LiftWhereInput
    /**
     * Limit how many Lifts to update.
     */
    limit?: number
  }

  /**
   * Lift updateManyAndReturn
   */
  export type LiftUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * The data used to update Lifts.
     */
    data: XOR<LiftUpdateManyMutationInput, LiftUncheckedUpdateManyInput>
    /**
     * Filter which Lifts to update
     */
    where?: LiftWhereInput
    /**
     * Limit how many Lifts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lift upsert
   */
  export type LiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
    /**
     * The filter to search for the Lift to update in case it exists.
     */
    where: LiftWhereUniqueInput
    /**
     * In case the Lift found by the `where` argument doesn't exist, create a new Lift with this data.
     */
    create: XOR<LiftCreateInput, LiftUncheckedCreateInput>
    /**
     * In case the Lift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LiftUpdateInput, LiftUncheckedUpdateInput>
  }

  /**
   * Lift delete
   */
  export type LiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
    /**
     * Filter which Lift to delete.
     */
    where: LiftWhereUniqueInput
  }

  /**
   * Lift deleteMany
   */
  export type LiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lifts to delete
     */
    where?: LiftWhereInput
    /**
     * Limit how many Lifts to delete.
     */
    limit?: number
  }

  /**
   * Lift.incidentLogs
   */
  export type Lift$incidentLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLog
     */
    select?: IncidentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLog
     */
    omit?: IncidentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogInclude<ExtArgs> | null
    where?: IncidentLogWhereInput
    orderBy?: IncidentLogOrderByWithRelationInput | IncidentLogOrderByWithRelationInput[]
    cursor?: IncidentLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentLogScalarFieldEnum | IncidentLogScalarFieldEnum[]
  }

  /**
   * Lift.liftChecks
   */
  export type Lift$liftChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    where?: LiftCheckWhereInput
    orderBy?: LiftCheckOrderByWithRelationInput | LiftCheckOrderByWithRelationInput[]
    cursor?: LiftCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiftCheckScalarFieldEnum | LiftCheckScalarFieldEnum[]
  }

  /**
   * Lift without action
   */
  export type LiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
  }


  /**
   * Model Trail
   */

  export type AggregateTrail = {
    _count: TrailCountAggregateOutputType | null
    _avg: TrailAvgAggregateOutputType | null
    _sum: TrailSumAggregateOutputType | null
    _min: TrailMinAggregateOutputType | null
    _max: TrailMaxAggregateOutputType | null
  }

  export type TrailAvgAggregateOutputType = {
    length: number | null
  }

  export type TrailSumAggregateOutputType = {
    length: number | null
  }

  export type TrailMinAggregateOutputType = {
    id: string | null
    name: string | null
    status: $Enums.Status | null
    difficulty: $Enums.TrailDifficulty | null
    length: number | null
    condition: $Enums.TrailCondition | null
    mountainId: string | null
  }

  export type TrailMaxAggregateOutputType = {
    id: string | null
    name: string | null
    status: $Enums.Status | null
    difficulty: $Enums.TrailDifficulty | null
    length: number | null
    condition: $Enums.TrailCondition | null
    mountainId: string | null
  }

  export type TrailCountAggregateOutputType = {
    id: number
    name: number
    status: number
    difficulty: number
    length: number
    condition: number
    mountainId: number
    _all: number
  }


  export type TrailAvgAggregateInputType = {
    length?: true
  }

  export type TrailSumAggregateInputType = {
    length?: true
  }

  export type TrailMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    difficulty?: true
    length?: true
    condition?: true
    mountainId?: true
  }

  export type TrailMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    difficulty?: true
    length?: true
    condition?: true
    mountainId?: true
  }

  export type TrailCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    difficulty?: true
    length?: true
    condition?: true
    mountainId?: true
    _all?: true
  }

  export type TrailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trail to aggregate.
     */
    where?: TrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trails to fetch.
     */
    orderBy?: TrailOrderByWithRelationInput | TrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trails
    **/
    _count?: true | TrailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrailMaxAggregateInputType
  }

  export type GetTrailAggregateType<T extends TrailAggregateArgs> = {
        [P in keyof T & keyof AggregateTrail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrail[P]>
      : GetScalarType<T[P], AggregateTrail[P]>
  }




  export type TrailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrailWhereInput
    orderBy?: TrailOrderByWithAggregationInput | TrailOrderByWithAggregationInput[]
    by: TrailScalarFieldEnum[] | TrailScalarFieldEnum
    having?: TrailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrailCountAggregateInputType | true
    _avg?: TrailAvgAggregateInputType
    _sum?: TrailSumAggregateInputType
    _min?: TrailMinAggregateInputType
    _max?: TrailMaxAggregateInputType
  }

  export type TrailGroupByOutputType = {
    id: string
    name: string
    status: $Enums.Status
    difficulty: $Enums.TrailDifficulty
    length: number
    condition: $Enums.TrailCondition
    mountainId: string
    _count: TrailCountAggregateOutputType | null
    _avg: TrailAvgAggregateOutputType | null
    _sum: TrailSumAggregateOutputType | null
    _min: TrailMinAggregateOutputType | null
    _max: TrailMaxAggregateOutputType | null
  }

  type GetTrailGroupByPayload<T extends TrailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrailGroupByOutputType[P]>
            : GetScalarType<T[P], TrailGroupByOutputType[P]>
        }
      >
    >


  export type TrailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    difficulty?: boolean
    length?: boolean
    condition?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incidentLogs?: boolean | Trail$incidentLogsArgs<ExtArgs>
    trailChecks?: boolean | Trail$trailChecksArgs<ExtArgs>
    _count?: boolean | TrailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trail"]>

  export type TrailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    difficulty?: boolean
    length?: boolean
    condition?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trail"]>

  export type TrailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    difficulty?: boolean
    length?: boolean
    condition?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trail"]>

  export type TrailSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
    difficulty?: boolean
    length?: boolean
    condition?: boolean
    mountainId?: boolean
  }

  export type TrailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "status" | "difficulty" | "length" | "condition" | "mountainId", ExtArgs["result"]["trail"]>
  export type TrailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incidentLogs?: boolean | Trail$incidentLogsArgs<ExtArgs>
    trailChecks?: boolean | Trail$trailChecksArgs<ExtArgs>
    _count?: boolean | TrailCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TrailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }
  export type TrailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }

  export type $TrailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trail"
    objects: {
      mountain: Prisma.$MountainPayload<ExtArgs>
      incidentLogs: Prisma.$IncidentLogPayload<ExtArgs>[]
      trailChecks: Prisma.$TrailCheckPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      status: $Enums.Status
      difficulty: $Enums.TrailDifficulty
      length: number
      condition: $Enums.TrailCondition
      mountainId: string
    }, ExtArgs["result"]["trail"]>
    composites: {}
  }

  type TrailGetPayload<S extends boolean | null | undefined | TrailDefaultArgs> = $Result.GetResult<Prisma.$TrailPayload, S>

  type TrailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrailCountAggregateInputType | true
    }

  export interface TrailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trail'], meta: { name: 'Trail' } }
    /**
     * Find zero or one Trail that matches the filter.
     * @param {TrailFindUniqueArgs} args - Arguments to find a Trail
     * @example
     * // Get one Trail
     * const trail = await prisma.trail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrailFindUniqueArgs>(args: SelectSubset<T, TrailFindUniqueArgs<ExtArgs>>): Prisma__TrailClient<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrailFindUniqueOrThrowArgs} args - Arguments to find a Trail
     * @example
     * // Get one Trail
     * const trail = await prisma.trail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrailFindUniqueOrThrowArgs>(args: SelectSubset<T, TrailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrailClient<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailFindFirstArgs} args - Arguments to find a Trail
     * @example
     * // Get one Trail
     * const trail = await prisma.trail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrailFindFirstArgs>(args?: SelectSubset<T, TrailFindFirstArgs<ExtArgs>>): Prisma__TrailClient<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailFindFirstOrThrowArgs} args - Arguments to find a Trail
     * @example
     * // Get one Trail
     * const trail = await prisma.trail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrailFindFirstOrThrowArgs>(args?: SelectSubset<T, TrailFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrailClient<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trails
     * const trails = await prisma.trail.findMany()
     * 
     * // Get first 10 Trails
     * const trails = await prisma.trail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trailWithIdOnly = await prisma.trail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrailFindManyArgs>(args?: SelectSubset<T, TrailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trail.
     * @param {TrailCreateArgs} args - Arguments to create a Trail.
     * @example
     * // Create one Trail
     * const Trail = await prisma.trail.create({
     *   data: {
     *     // ... data to create a Trail
     *   }
     * })
     * 
     */
    create<T extends TrailCreateArgs>(args: SelectSubset<T, TrailCreateArgs<ExtArgs>>): Prisma__TrailClient<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trails.
     * @param {TrailCreateManyArgs} args - Arguments to create many Trails.
     * @example
     * // Create many Trails
     * const trail = await prisma.trail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrailCreateManyArgs>(args?: SelectSubset<T, TrailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trails and returns the data saved in the database.
     * @param {TrailCreateManyAndReturnArgs} args - Arguments to create many Trails.
     * @example
     * // Create many Trails
     * const trail = await prisma.trail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trails and only return the `id`
     * const trailWithIdOnly = await prisma.trail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrailCreateManyAndReturnArgs>(args?: SelectSubset<T, TrailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Trail.
     * @param {TrailDeleteArgs} args - Arguments to delete one Trail.
     * @example
     * // Delete one Trail
     * const Trail = await prisma.trail.delete({
     *   where: {
     *     // ... filter to delete one Trail
     *   }
     * })
     * 
     */
    delete<T extends TrailDeleteArgs>(args: SelectSubset<T, TrailDeleteArgs<ExtArgs>>): Prisma__TrailClient<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trail.
     * @param {TrailUpdateArgs} args - Arguments to update one Trail.
     * @example
     * // Update one Trail
     * const trail = await prisma.trail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrailUpdateArgs>(args: SelectSubset<T, TrailUpdateArgs<ExtArgs>>): Prisma__TrailClient<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trails.
     * @param {TrailDeleteManyArgs} args - Arguments to filter Trails to delete.
     * @example
     * // Delete a few Trails
     * const { count } = await prisma.trail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrailDeleteManyArgs>(args?: SelectSubset<T, TrailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trails
     * const trail = await prisma.trail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrailUpdateManyArgs>(args: SelectSubset<T, TrailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trails and returns the data updated in the database.
     * @param {TrailUpdateManyAndReturnArgs} args - Arguments to update many Trails.
     * @example
     * // Update many Trails
     * const trail = await prisma.trail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Trails and only return the `id`
     * const trailWithIdOnly = await prisma.trail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrailUpdateManyAndReturnArgs>(args: SelectSubset<T, TrailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Trail.
     * @param {TrailUpsertArgs} args - Arguments to update or create a Trail.
     * @example
     * // Update or create a Trail
     * const trail = await prisma.trail.upsert({
     *   create: {
     *     // ... data to create a Trail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trail we want to update
     *   }
     * })
     */
    upsert<T extends TrailUpsertArgs>(args: SelectSubset<T, TrailUpsertArgs<ExtArgs>>): Prisma__TrailClient<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailCountArgs} args - Arguments to filter Trails to count.
     * @example
     * // Count the number of Trails
     * const count = await prisma.trail.count({
     *   where: {
     *     // ... the filter for the Trails we want to count
     *   }
     * })
    **/
    count<T extends TrailCountArgs>(
      args?: Subset<T, TrailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrailAggregateArgs>(args: Subset<T, TrailAggregateArgs>): Prisma.PrismaPromise<GetTrailAggregateType<T>>

    /**
     * Group by Trail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrailGroupByArgs['orderBy'] }
        : { orderBy?: TrailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trail model
   */
  readonly fields: TrailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    incidentLogs<T extends Trail$incidentLogsArgs<ExtArgs> = {}>(args?: Subset<T, Trail$incidentLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trailChecks<T extends Trail$trailChecksArgs<ExtArgs> = {}>(args?: Subset<T, Trail$trailChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trail model
   */
  interface TrailFieldRefs {
    readonly id: FieldRef<"Trail", 'String'>
    readonly name: FieldRef<"Trail", 'String'>
    readonly status: FieldRef<"Trail", 'Status'>
    readonly difficulty: FieldRef<"Trail", 'TrailDifficulty'>
    readonly length: FieldRef<"Trail", 'Float'>
    readonly condition: FieldRef<"Trail", 'TrailCondition'>
    readonly mountainId: FieldRef<"Trail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Trail findUnique
   */
  export type TrailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
    /**
     * Filter, which Trail to fetch.
     */
    where: TrailWhereUniqueInput
  }

  /**
   * Trail findUniqueOrThrow
   */
  export type TrailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
    /**
     * Filter, which Trail to fetch.
     */
    where: TrailWhereUniqueInput
  }

  /**
   * Trail findFirst
   */
  export type TrailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
    /**
     * Filter, which Trail to fetch.
     */
    where?: TrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trails to fetch.
     */
    orderBy?: TrailOrderByWithRelationInput | TrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trails.
     */
    cursor?: TrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trails.
     */
    distinct?: TrailScalarFieldEnum | TrailScalarFieldEnum[]
  }

  /**
   * Trail findFirstOrThrow
   */
  export type TrailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
    /**
     * Filter, which Trail to fetch.
     */
    where?: TrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trails to fetch.
     */
    orderBy?: TrailOrderByWithRelationInput | TrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trails.
     */
    cursor?: TrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trails.
     */
    distinct?: TrailScalarFieldEnum | TrailScalarFieldEnum[]
  }

  /**
   * Trail findMany
   */
  export type TrailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
    /**
     * Filter, which Trails to fetch.
     */
    where?: TrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trails to fetch.
     */
    orderBy?: TrailOrderByWithRelationInput | TrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trails.
     */
    cursor?: TrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trails.
     */
    skip?: number
    distinct?: TrailScalarFieldEnum | TrailScalarFieldEnum[]
  }

  /**
   * Trail create
   */
  export type TrailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
    /**
     * The data needed to create a Trail.
     */
    data: XOR<TrailCreateInput, TrailUncheckedCreateInput>
  }

  /**
   * Trail createMany
   */
  export type TrailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trails.
     */
    data: TrailCreateManyInput | TrailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trail createManyAndReturn
   */
  export type TrailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * The data used to create many Trails.
     */
    data: TrailCreateManyInput | TrailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Trail update
   */
  export type TrailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
    /**
     * The data needed to update a Trail.
     */
    data: XOR<TrailUpdateInput, TrailUncheckedUpdateInput>
    /**
     * Choose, which Trail to update.
     */
    where: TrailWhereUniqueInput
  }

  /**
   * Trail updateMany
   */
  export type TrailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trails.
     */
    data: XOR<TrailUpdateManyMutationInput, TrailUncheckedUpdateManyInput>
    /**
     * Filter which Trails to update
     */
    where?: TrailWhereInput
    /**
     * Limit how many Trails to update.
     */
    limit?: number
  }

  /**
   * Trail updateManyAndReturn
   */
  export type TrailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * The data used to update Trails.
     */
    data: XOR<TrailUpdateManyMutationInput, TrailUncheckedUpdateManyInput>
    /**
     * Filter which Trails to update
     */
    where?: TrailWhereInput
    /**
     * Limit how many Trails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Trail upsert
   */
  export type TrailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
    /**
     * The filter to search for the Trail to update in case it exists.
     */
    where: TrailWhereUniqueInput
    /**
     * In case the Trail found by the `where` argument doesn't exist, create a new Trail with this data.
     */
    create: XOR<TrailCreateInput, TrailUncheckedCreateInput>
    /**
     * In case the Trail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrailUpdateInput, TrailUncheckedUpdateInput>
  }

  /**
   * Trail delete
   */
  export type TrailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
    /**
     * Filter which Trail to delete.
     */
    where: TrailWhereUniqueInput
  }

  /**
   * Trail deleteMany
   */
  export type TrailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trails to delete
     */
    where?: TrailWhereInput
    /**
     * Limit how many Trails to delete.
     */
    limit?: number
  }

  /**
   * Trail.incidentLogs
   */
  export type Trail$incidentLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLog
     */
    select?: IncidentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLog
     */
    omit?: IncidentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogInclude<ExtArgs> | null
    where?: IncidentLogWhereInput
    orderBy?: IncidentLogOrderByWithRelationInput | IncidentLogOrderByWithRelationInput[]
    cursor?: IncidentLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentLogScalarFieldEnum | IncidentLogScalarFieldEnum[]
  }

  /**
   * Trail.trailChecks
   */
  export type Trail$trailChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    where?: TrailCheckWhereInput
    orderBy?: TrailCheckOrderByWithRelationInput | TrailCheckOrderByWithRelationInput[]
    cursor?: TrailCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrailCheckScalarFieldEnum | TrailCheckScalarFieldEnum[]
  }

  /**
   * Trail without action
   */
  export type TrailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
  }


  /**
   * Model Lodge
   */

  export type AggregateLodge = {
    _count: LodgeCountAggregateOutputType | null
    _avg: LodgeAvgAggregateOutputType | null
    _sum: LodgeSumAggregateOutputType | null
    _min: LodgeMinAggregateOutputType | null
    _max: LodgeMaxAggregateOutputType | null
  }

  export type LodgeAvgAggregateOutputType = {
    capacity: number | null
  }

  export type LodgeSumAggregateOutputType = {
    capacity: number | null
  }

  export type LodgeMinAggregateOutputType = {
    id: string | null
    name: string | null
    capacity: number | null
    status: $Enums.Status | null
    mountainId: string | null
  }

  export type LodgeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    capacity: number | null
    status: $Enums.Status | null
    mountainId: string | null
  }

  export type LodgeCountAggregateOutputType = {
    id: number
    name: number
    capacity: number
    status: number
    mountainId: number
    _all: number
  }


  export type LodgeAvgAggregateInputType = {
    capacity?: true
  }

  export type LodgeSumAggregateInputType = {
    capacity?: true
  }

  export type LodgeMinAggregateInputType = {
    id?: true
    name?: true
    capacity?: true
    status?: true
    mountainId?: true
  }

  export type LodgeMaxAggregateInputType = {
    id?: true
    name?: true
    capacity?: true
    status?: true
    mountainId?: true
  }

  export type LodgeCountAggregateInputType = {
    id?: true
    name?: true
    capacity?: true
    status?: true
    mountainId?: true
    _all?: true
  }

  export type LodgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lodge to aggregate.
     */
    where?: LodgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lodges to fetch.
     */
    orderBy?: LodgeOrderByWithRelationInput | LodgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LodgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lodges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lodges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lodges
    **/
    _count?: true | LodgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LodgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LodgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LodgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LodgeMaxAggregateInputType
  }

  export type GetLodgeAggregateType<T extends LodgeAggregateArgs> = {
        [P in keyof T & keyof AggregateLodge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLodge[P]>
      : GetScalarType<T[P], AggregateLodge[P]>
  }




  export type LodgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LodgeWhereInput
    orderBy?: LodgeOrderByWithAggregationInput | LodgeOrderByWithAggregationInput[]
    by: LodgeScalarFieldEnum[] | LodgeScalarFieldEnum
    having?: LodgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LodgeCountAggregateInputType | true
    _avg?: LodgeAvgAggregateInputType
    _sum?: LodgeSumAggregateInputType
    _min?: LodgeMinAggregateInputType
    _max?: LodgeMaxAggregateInputType
  }

  export type LodgeGroupByOutputType = {
    id: string
    name: string
    capacity: number
    status: $Enums.Status
    mountainId: string
    _count: LodgeCountAggregateOutputType | null
    _avg: LodgeAvgAggregateOutputType | null
    _sum: LodgeSumAggregateOutputType | null
    _min: LodgeMinAggregateOutputType | null
    _max: LodgeMaxAggregateOutputType | null
  }

  type GetLodgeGroupByPayload<T extends LodgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LodgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LodgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LodgeGroupByOutputType[P]>
            : GetScalarType<T[P], LodgeGroupByOutputType[P]>
        }
      >
    >


  export type LodgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    capacity?: boolean
    status?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incidentLogs?: boolean | Lodge$incidentLogsArgs<ExtArgs>
    _count?: boolean | LodgeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lodge"]>

  export type LodgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    capacity?: boolean
    status?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lodge"]>

  export type LodgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    capacity?: boolean
    status?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lodge"]>

  export type LodgeSelectScalar = {
    id?: boolean
    name?: boolean
    capacity?: boolean
    status?: boolean
    mountainId?: boolean
  }

  export type LodgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "capacity" | "status" | "mountainId", ExtArgs["result"]["lodge"]>
  export type LodgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incidentLogs?: boolean | Lodge$incidentLogsArgs<ExtArgs>
    _count?: boolean | LodgeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LodgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }
  export type LodgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }

  export type $LodgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lodge"
    objects: {
      mountain: Prisma.$MountainPayload<ExtArgs>
      incidentLogs: Prisma.$IncidentLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      capacity: number
      status: $Enums.Status
      mountainId: string
    }, ExtArgs["result"]["lodge"]>
    composites: {}
  }

  type LodgeGetPayload<S extends boolean | null | undefined | LodgeDefaultArgs> = $Result.GetResult<Prisma.$LodgePayload, S>

  type LodgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LodgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LodgeCountAggregateInputType | true
    }

  export interface LodgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lodge'], meta: { name: 'Lodge' } }
    /**
     * Find zero or one Lodge that matches the filter.
     * @param {LodgeFindUniqueArgs} args - Arguments to find a Lodge
     * @example
     * // Get one Lodge
     * const lodge = await prisma.lodge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LodgeFindUniqueArgs>(args: SelectSubset<T, LodgeFindUniqueArgs<ExtArgs>>): Prisma__LodgeClient<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lodge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LodgeFindUniqueOrThrowArgs} args - Arguments to find a Lodge
     * @example
     * // Get one Lodge
     * const lodge = await prisma.lodge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LodgeFindUniqueOrThrowArgs>(args: SelectSubset<T, LodgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LodgeClient<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lodge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LodgeFindFirstArgs} args - Arguments to find a Lodge
     * @example
     * // Get one Lodge
     * const lodge = await prisma.lodge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LodgeFindFirstArgs>(args?: SelectSubset<T, LodgeFindFirstArgs<ExtArgs>>): Prisma__LodgeClient<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lodge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LodgeFindFirstOrThrowArgs} args - Arguments to find a Lodge
     * @example
     * // Get one Lodge
     * const lodge = await prisma.lodge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LodgeFindFirstOrThrowArgs>(args?: SelectSubset<T, LodgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LodgeClient<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lodges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LodgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lodges
     * const lodges = await prisma.lodge.findMany()
     * 
     * // Get first 10 Lodges
     * const lodges = await prisma.lodge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lodgeWithIdOnly = await prisma.lodge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LodgeFindManyArgs>(args?: SelectSubset<T, LodgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lodge.
     * @param {LodgeCreateArgs} args - Arguments to create a Lodge.
     * @example
     * // Create one Lodge
     * const Lodge = await prisma.lodge.create({
     *   data: {
     *     // ... data to create a Lodge
     *   }
     * })
     * 
     */
    create<T extends LodgeCreateArgs>(args: SelectSubset<T, LodgeCreateArgs<ExtArgs>>): Prisma__LodgeClient<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lodges.
     * @param {LodgeCreateManyArgs} args - Arguments to create many Lodges.
     * @example
     * // Create many Lodges
     * const lodge = await prisma.lodge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LodgeCreateManyArgs>(args?: SelectSubset<T, LodgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lodges and returns the data saved in the database.
     * @param {LodgeCreateManyAndReturnArgs} args - Arguments to create many Lodges.
     * @example
     * // Create many Lodges
     * const lodge = await prisma.lodge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lodges and only return the `id`
     * const lodgeWithIdOnly = await prisma.lodge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LodgeCreateManyAndReturnArgs>(args?: SelectSubset<T, LodgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lodge.
     * @param {LodgeDeleteArgs} args - Arguments to delete one Lodge.
     * @example
     * // Delete one Lodge
     * const Lodge = await prisma.lodge.delete({
     *   where: {
     *     // ... filter to delete one Lodge
     *   }
     * })
     * 
     */
    delete<T extends LodgeDeleteArgs>(args: SelectSubset<T, LodgeDeleteArgs<ExtArgs>>): Prisma__LodgeClient<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lodge.
     * @param {LodgeUpdateArgs} args - Arguments to update one Lodge.
     * @example
     * // Update one Lodge
     * const lodge = await prisma.lodge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LodgeUpdateArgs>(args: SelectSubset<T, LodgeUpdateArgs<ExtArgs>>): Prisma__LodgeClient<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lodges.
     * @param {LodgeDeleteManyArgs} args - Arguments to filter Lodges to delete.
     * @example
     * // Delete a few Lodges
     * const { count } = await prisma.lodge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LodgeDeleteManyArgs>(args?: SelectSubset<T, LodgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lodges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LodgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lodges
     * const lodge = await prisma.lodge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LodgeUpdateManyArgs>(args: SelectSubset<T, LodgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lodges and returns the data updated in the database.
     * @param {LodgeUpdateManyAndReturnArgs} args - Arguments to update many Lodges.
     * @example
     * // Update many Lodges
     * const lodge = await prisma.lodge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lodges and only return the `id`
     * const lodgeWithIdOnly = await prisma.lodge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LodgeUpdateManyAndReturnArgs>(args: SelectSubset<T, LodgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lodge.
     * @param {LodgeUpsertArgs} args - Arguments to update or create a Lodge.
     * @example
     * // Update or create a Lodge
     * const lodge = await prisma.lodge.upsert({
     *   create: {
     *     // ... data to create a Lodge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lodge we want to update
     *   }
     * })
     */
    upsert<T extends LodgeUpsertArgs>(args: SelectSubset<T, LodgeUpsertArgs<ExtArgs>>): Prisma__LodgeClient<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lodges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LodgeCountArgs} args - Arguments to filter Lodges to count.
     * @example
     * // Count the number of Lodges
     * const count = await prisma.lodge.count({
     *   where: {
     *     // ... the filter for the Lodges we want to count
     *   }
     * })
    **/
    count<T extends LodgeCountArgs>(
      args?: Subset<T, LodgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LodgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lodge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LodgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LodgeAggregateArgs>(args: Subset<T, LodgeAggregateArgs>): Prisma.PrismaPromise<GetLodgeAggregateType<T>>

    /**
     * Group by Lodge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LodgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LodgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LodgeGroupByArgs['orderBy'] }
        : { orderBy?: LodgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LodgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLodgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lodge model
   */
  readonly fields: LodgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lodge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LodgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    incidentLogs<T extends Lodge$incidentLogsArgs<ExtArgs> = {}>(args?: Subset<T, Lodge$incidentLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lodge model
   */
  interface LodgeFieldRefs {
    readonly id: FieldRef<"Lodge", 'String'>
    readonly name: FieldRef<"Lodge", 'String'>
    readonly capacity: FieldRef<"Lodge", 'Int'>
    readonly status: FieldRef<"Lodge", 'Status'>
    readonly mountainId: FieldRef<"Lodge", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lodge findUnique
   */
  export type LodgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
    /**
     * Filter, which Lodge to fetch.
     */
    where: LodgeWhereUniqueInput
  }

  /**
   * Lodge findUniqueOrThrow
   */
  export type LodgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
    /**
     * Filter, which Lodge to fetch.
     */
    where: LodgeWhereUniqueInput
  }

  /**
   * Lodge findFirst
   */
  export type LodgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
    /**
     * Filter, which Lodge to fetch.
     */
    where?: LodgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lodges to fetch.
     */
    orderBy?: LodgeOrderByWithRelationInput | LodgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lodges.
     */
    cursor?: LodgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lodges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lodges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lodges.
     */
    distinct?: LodgeScalarFieldEnum | LodgeScalarFieldEnum[]
  }

  /**
   * Lodge findFirstOrThrow
   */
  export type LodgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
    /**
     * Filter, which Lodge to fetch.
     */
    where?: LodgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lodges to fetch.
     */
    orderBy?: LodgeOrderByWithRelationInput | LodgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lodges.
     */
    cursor?: LodgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lodges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lodges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lodges.
     */
    distinct?: LodgeScalarFieldEnum | LodgeScalarFieldEnum[]
  }

  /**
   * Lodge findMany
   */
  export type LodgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
    /**
     * Filter, which Lodges to fetch.
     */
    where?: LodgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lodges to fetch.
     */
    orderBy?: LodgeOrderByWithRelationInput | LodgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lodges.
     */
    cursor?: LodgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lodges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lodges.
     */
    skip?: number
    distinct?: LodgeScalarFieldEnum | LodgeScalarFieldEnum[]
  }

  /**
   * Lodge create
   */
  export type LodgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Lodge.
     */
    data: XOR<LodgeCreateInput, LodgeUncheckedCreateInput>
  }

  /**
   * Lodge createMany
   */
  export type LodgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lodges.
     */
    data: LodgeCreateManyInput | LodgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lodge createManyAndReturn
   */
  export type LodgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * The data used to create many Lodges.
     */
    data: LodgeCreateManyInput | LodgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lodge update
   */
  export type LodgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Lodge.
     */
    data: XOR<LodgeUpdateInput, LodgeUncheckedUpdateInput>
    /**
     * Choose, which Lodge to update.
     */
    where: LodgeWhereUniqueInput
  }

  /**
   * Lodge updateMany
   */
  export type LodgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lodges.
     */
    data: XOR<LodgeUpdateManyMutationInput, LodgeUncheckedUpdateManyInput>
    /**
     * Filter which Lodges to update
     */
    where?: LodgeWhereInput
    /**
     * Limit how many Lodges to update.
     */
    limit?: number
  }

  /**
   * Lodge updateManyAndReturn
   */
  export type LodgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * The data used to update Lodges.
     */
    data: XOR<LodgeUpdateManyMutationInput, LodgeUncheckedUpdateManyInput>
    /**
     * Filter which Lodges to update
     */
    where?: LodgeWhereInput
    /**
     * Limit how many Lodges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lodge upsert
   */
  export type LodgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Lodge to update in case it exists.
     */
    where: LodgeWhereUniqueInput
    /**
     * In case the Lodge found by the `where` argument doesn't exist, create a new Lodge with this data.
     */
    create: XOR<LodgeCreateInput, LodgeUncheckedCreateInput>
    /**
     * In case the Lodge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LodgeUpdateInput, LodgeUncheckedUpdateInput>
  }

  /**
   * Lodge delete
   */
  export type LodgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
    /**
     * Filter which Lodge to delete.
     */
    where: LodgeWhereUniqueInput
  }

  /**
   * Lodge deleteMany
   */
  export type LodgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lodges to delete
     */
    where?: LodgeWhereInput
    /**
     * Limit how many Lodges to delete.
     */
    limit?: number
  }

  /**
   * Lodge.incidentLogs
   */
  export type Lodge$incidentLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLog
     */
    select?: IncidentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLog
     */
    omit?: IncidentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogInclude<ExtArgs> | null
    where?: IncidentLogWhereInput
    orderBy?: IncidentLogOrderByWithRelationInput | IncidentLogOrderByWithRelationInput[]
    cursor?: IncidentLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentLogScalarFieldEnum | IncidentLogScalarFieldEnum[]
  }

  /**
   * Lodge without action
   */
  export type LodgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
  }


  /**
   * Model Hut
   */

  export type AggregateHut = {
    _count: HutCountAggregateOutputType | null
    _min: HutMinAggregateOutputType | null
    _max: HutMaxAggregateOutputType | null
  }

  export type HutMinAggregateOutputType = {
    id: string | null
    name: string | null
    status: $Enums.Status | null
    mountainId: string | null
  }

  export type HutMaxAggregateOutputType = {
    id: string | null
    name: string | null
    status: $Enums.Status | null
    mountainId: string | null
  }

  export type HutCountAggregateOutputType = {
    id: number
    name: number
    status: number
    mountainId: number
    _all: number
  }


  export type HutMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    mountainId?: true
  }

  export type HutMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    mountainId?: true
  }

  export type HutCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    mountainId?: true
    _all?: true
  }

  export type HutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hut to aggregate.
     */
    where?: HutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Huts to fetch.
     */
    orderBy?: HutOrderByWithRelationInput | HutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Huts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Huts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Huts
    **/
    _count?: true | HutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HutMaxAggregateInputType
  }

  export type GetHutAggregateType<T extends HutAggregateArgs> = {
        [P in keyof T & keyof AggregateHut]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHut[P]>
      : GetScalarType<T[P], AggregateHut[P]>
  }




  export type HutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HutWhereInput
    orderBy?: HutOrderByWithAggregationInput | HutOrderByWithAggregationInput[]
    by: HutScalarFieldEnum[] | HutScalarFieldEnum
    having?: HutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HutCountAggregateInputType | true
    _min?: HutMinAggregateInputType
    _max?: HutMaxAggregateInputType
  }

  export type HutGroupByOutputType = {
    id: string
    name: string
    status: $Enums.Status
    mountainId: string
    _count: HutCountAggregateOutputType | null
    _min: HutMinAggregateOutputType | null
    _max: HutMaxAggregateOutputType | null
  }

  type GetHutGroupByPayload<T extends HutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HutGroupByOutputType[P]>
            : GetScalarType<T[P], HutGroupByOutputType[P]>
        }
      >
    >


  export type HutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incidentLogs?: boolean | Hut$incidentLogsArgs<ExtArgs>
    hutChecks?: boolean | Hut$hutChecksArgs<ExtArgs>
    _count?: boolean | HutCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hut"]>

  export type HutSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hut"]>

  export type HutSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hut"]>

  export type HutSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
    mountainId?: boolean
  }

  export type HutOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "status" | "mountainId", ExtArgs["result"]["hut"]>
  export type HutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incidentLogs?: boolean | Hut$incidentLogsArgs<ExtArgs>
    hutChecks?: boolean | Hut$hutChecksArgs<ExtArgs>
    _count?: boolean | HutCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HutIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }
  export type HutIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }

  export type $HutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hut"
    objects: {
      mountain: Prisma.$MountainPayload<ExtArgs>
      incidentLogs: Prisma.$IncidentLogPayload<ExtArgs>[]
      hutChecks: Prisma.$HutCheckPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      status: $Enums.Status
      mountainId: string
    }, ExtArgs["result"]["hut"]>
    composites: {}
  }

  type HutGetPayload<S extends boolean | null | undefined | HutDefaultArgs> = $Result.GetResult<Prisma.$HutPayload, S>

  type HutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HutFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HutCountAggregateInputType | true
    }

  export interface HutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hut'], meta: { name: 'Hut' } }
    /**
     * Find zero or one Hut that matches the filter.
     * @param {HutFindUniqueArgs} args - Arguments to find a Hut
     * @example
     * // Get one Hut
     * const hut = await prisma.hut.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HutFindUniqueArgs>(args: SelectSubset<T, HutFindUniqueArgs<ExtArgs>>): Prisma__HutClient<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hut that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HutFindUniqueOrThrowArgs} args - Arguments to find a Hut
     * @example
     * // Get one Hut
     * const hut = await prisma.hut.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HutFindUniqueOrThrowArgs>(args: SelectSubset<T, HutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HutClient<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hut that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutFindFirstArgs} args - Arguments to find a Hut
     * @example
     * // Get one Hut
     * const hut = await prisma.hut.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HutFindFirstArgs>(args?: SelectSubset<T, HutFindFirstArgs<ExtArgs>>): Prisma__HutClient<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hut that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutFindFirstOrThrowArgs} args - Arguments to find a Hut
     * @example
     * // Get one Hut
     * const hut = await prisma.hut.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HutFindFirstOrThrowArgs>(args?: SelectSubset<T, HutFindFirstOrThrowArgs<ExtArgs>>): Prisma__HutClient<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Huts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Huts
     * const huts = await prisma.hut.findMany()
     * 
     * // Get first 10 Huts
     * const huts = await prisma.hut.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hutWithIdOnly = await prisma.hut.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HutFindManyArgs>(args?: SelectSubset<T, HutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hut.
     * @param {HutCreateArgs} args - Arguments to create a Hut.
     * @example
     * // Create one Hut
     * const Hut = await prisma.hut.create({
     *   data: {
     *     // ... data to create a Hut
     *   }
     * })
     * 
     */
    create<T extends HutCreateArgs>(args: SelectSubset<T, HutCreateArgs<ExtArgs>>): Prisma__HutClient<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Huts.
     * @param {HutCreateManyArgs} args - Arguments to create many Huts.
     * @example
     * // Create many Huts
     * const hut = await prisma.hut.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HutCreateManyArgs>(args?: SelectSubset<T, HutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Huts and returns the data saved in the database.
     * @param {HutCreateManyAndReturnArgs} args - Arguments to create many Huts.
     * @example
     * // Create many Huts
     * const hut = await prisma.hut.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Huts and only return the `id`
     * const hutWithIdOnly = await prisma.hut.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HutCreateManyAndReturnArgs>(args?: SelectSubset<T, HutCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Hut.
     * @param {HutDeleteArgs} args - Arguments to delete one Hut.
     * @example
     * // Delete one Hut
     * const Hut = await prisma.hut.delete({
     *   where: {
     *     // ... filter to delete one Hut
     *   }
     * })
     * 
     */
    delete<T extends HutDeleteArgs>(args: SelectSubset<T, HutDeleteArgs<ExtArgs>>): Prisma__HutClient<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hut.
     * @param {HutUpdateArgs} args - Arguments to update one Hut.
     * @example
     * // Update one Hut
     * const hut = await prisma.hut.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HutUpdateArgs>(args: SelectSubset<T, HutUpdateArgs<ExtArgs>>): Prisma__HutClient<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Huts.
     * @param {HutDeleteManyArgs} args - Arguments to filter Huts to delete.
     * @example
     * // Delete a few Huts
     * const { count } = await prisma.hut.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HutDeleteManyArgs>(args?: SelectSubset<T, HutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Huts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Huts
     * const hut = await prisma.hut.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HutUpdateManyArgs>(args: SelectSubset<T, HutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Huts and returns the data updated in the database.
     * @param {HutUpdateManyAndReturnArgs} args - Arguments to update many Huts.
     * @example
     * // Update many Huts
     * const hut = await prisma.hut.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Huts and only return the `id`
     * const hutWithIdOnly = await prisma.hut.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HutUpdateManyAndReturnArgs>(args: SelectSubset<T, HutUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Hut.
     * @param {HutUpsertArgs} args - Arguments to update or create a Hut.
     * @example
     * // Update or create a Hut
     * const hut = await prisma.hut.upsert({
     *   create: {
     *     // ... data to create a Hut
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hut we want to update
     *   }
     * })
     */
    upsert<T extends HutUpsertArgs>(args: SelectSubset<T, HutUpsertArgs<ExtArgs>>): Prisma__HutClient<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Huts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutCountArgs} args - Arguments to filter Huts to count.
     * @example
     * // Count the number of Huts
     * const count = await prisma.hut.count({
     *   where: {
     *     // ... the filter for the Huts we want to count
     *   }
     * })
    **/
    count<T extends HutCountArgs>(
      args?: Subset<T, HutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HutAggregateArgs>(args: Subset<T, HutAggregateArgs>): Prisma.PrismaPromise<GetHutAggregateType<T>>

    /**
     * Group by Hut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HutGroupByArgs['orderBy'] }
        : { orderBy?: HutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hut model
   */
  readonly fields: HutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hut.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    incidentLogs<T extends Hut$incidentLogsArgs<ExtArgs> = {}>(args?: Subset<T, Hut$incidentLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hutChecks<T extends Hut$hutChecksArgs<ExtArgs> = {}>(args?: Subset<T, Hut$hutChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hut model
   */
  interface HutFieldRefs {
    readonly id: FieldRef<"Hut", 'String'>
    readonly name: FieldRef<"Hut", 'String'>
    readonly status: FieldRef<"Hut", 'Status'>
    readonly mountainId: FieldRef<"Hut", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Hut findUnique
   */
  export type HutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
    /**
     * Filter, which Hut to fetch.
     */
    where: HutWhereUniqueInput
  }

  /**
   * Hut findUniqueOrThrow
   */
  export type HutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
    /**
     * Filter, which Hut to fetch.
     */
    where: HutWhereUniqueInput
  }

  /**
   * Hut findFirst
   */
  export type HutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
    /**
     * Filter, which Hut to fetch.
     */
    where?: HutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Huts to fetch.
     */
    orderBy?: HutOrderByWithRelationInput | HutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Huts.
     */
    cursor?: HutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Huts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Huts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Huts.
     */
    distinct?: HutScalarFieldEnum | HutScalarFieldEnum[]
  }

  /**
   * Hut findFirstOrThrow
   */
  export type HutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
    /**
     * Filter, which Hut to fetch.
     */
    where?: HutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Huts to fetch.
     */
    orderBy?: HutOrderByWithRelationInput | HutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Huts.
     */
    cursor?: HutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Huts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Huts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Huts.
     */
    distinct?: HutScalarFieldEnum | HutScalarFieldEnum[]
  }

  /**
   * Hut findMany
   */
  export type HutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
    /**
     * Filter, which Huts to fetch.
     */
    where?: HutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Huts to fetch.
     */
    orderBy?: HutOrderByWithRelationInput | HutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Huts.
     */
    cursor?: HutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Huts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Huts.
     */
    skip?: number
    distinct?: HutScalarFieldEnum | HutScalarFieldEnum[]
  }

  /**
   * Hut create
   */
  export type HutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
    /**
     * The data needed to create a Hut.
     */
    data: XOR<HutCreateInput, HutUncheckedCreateInput>
  }

  /**
   * Hut createMany
   */
  export type HutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Huts.
     */
    data: HutCreateManyInput | HutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hut createManyAndReturn
   */
  export type HutCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * The data used to create many Huts.
     */
    data: HutCreateManyInput | HutCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hut update
   */
  export type HutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
    /**
     * The data needed to update a Hut.
     */
    data: XOR<HutUpdateInput, HutUncheckedUpdateInput>
    /**
     * Choose, which Hut to update.
     */
    where: HutWhereUniqueInput
  }

  /**
   * Hut updateMany
   */
  export type HutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Huts.
     */
    data: XOR<HutUpdateManyMutationInput, HutUncheckedUpdateManyInput>
    /**
     * Filter which Huts to update
     */
    where?: HutWhereInput
    /**
     * Limit how many Huts to update.
     */
    limit?: number
  }

  /**
   * Hut updateManyAndReturn
   */
  export type HutUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * The data used to update Huts.
     */
    data: XOR<HutUpdateManyMutationInput, HutUncheckedUpdateManyInput>
    /**
     * Filter which Huts to update
     */
    where?: HutWhereInput
    /**
     * Limit how many Huts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hut upsert
   */
  export type HutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
    /**
     * The filter to search for the Hut to update in case it exists.
     */
    where: HutWhereUniqueInput
    /**
     * In case the Hut found by the `where` argument doesn't exist, create a new Hut with this data.
     */
    create: XOR<HutCreateInput, HutUncheckedCreateInput>
    /**
     * In case the Hut was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HutUpdateInput, HutUncheckedUpdateInput>
  }

  /**
   * Hut delete
   */
  export type HutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
    /**
     * Filter which Hut to delete.
     */
    where: HutWhereUniqueInput
  }

  /**
   * Hut deleteMany
   */
  export type HutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Huts to delete
     */
    where?: HutWhereInput
    /**
     * Limit how many Huts to delete.
     */
    limit?: number
  }

  /**
   * Hut.incidentLogs
   */
  export type Hut$incidentLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLog
     */
    select?: IncidentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLog
     */
    omit?: IncidentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogInclude<ExtArgs> | null
    where?: IncidentLogWhereInput
    orderBy?: IncidentLogOrderByWithRelationInput | IncidentLogOrderByWithRelationInput[]
    cursor?: IncidentLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentLogScalarFieldEnum | IncidentLogScalarFieldEnum[]
  }

  /**
   * Hut.hutChecks
   */
  export type Hut$hutChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    where?: HutCheckWhereInput
    orderBy?: HutCheckOrderByWithRelationInput | HutCheckOrderByWithRelationInput[]
    cursor?: HutCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HutCheckScalarFieldEnum | HutCheckScalarFieldEnum[]
  }

  /**
   * Hut without action
   */
  export type HutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
  }


  /**
   * Model AidRoom
   */

  export type AggregateAidRoom = {
    _count: AidRoomCountAggregateOutputType | null
    _min: AidRoomMinAggregateOutputType | null
    _max: AidRoomMaxAggregateOutputType | null
  }

  export type AidRoomMinAggregateOutputType = {
    id: string | null
    name: string | null
    location: string | null
    status: $Enums.Status | null
    mountainId: string | null
  }

  export type AidRoomMaxAggregateOutputType = {
    id: string | null
    name: string | null
    location: string | null
    status: $Enums.Status | null
    mountainId: string | null
  }

  export type AidRoomCountAggregateOutputType = {
    id: number
    name: number
    location: number
    status: number
    mountainId: number
    _all: number
  }


  export type AidRoomMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    status?: true
    mountainId?: true
  }

  export type AidRoomMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    status?: true
    mountainId?: true
  }

  export type AidRoomCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    status?: true
    mountainId?: true
    _all?: true
  }

  export type AidRoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AidRoom to aggregate.
     */
    where?: AidRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AidRooms to fetch.
     */
    orderBy?: AidRoomOrderByWithRelationInput | AidRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AidRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AidRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AidRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AidRooms
    **/
    _count?: true | AidRoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AidRoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AidRoomMaxAggregateInputType
  }

  export type GetAidRoomAggregateType<T extends AidRoomAggregateArgs> = {
        [P in keyof T & keyof AggregateAidRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAidRoom[P]>
      : GetScalarType<T[P], AggregateAidRoom[P]>
  }




  export type AidRoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AidRoomWhereInput
    orderBy?: AidRoomOrderByWithAggregationInput | AidRoomOrderByWithAggregationInput[]
    by: AidRoomScalarFieldEnum[] | AidRoomScalarFieldEnum
    having?: AidRoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AidRoomCountAggregateInputType | true
    _min?: AidRoomMinAggregateInputType
    _max?: AidRoomMaxAggregateInputType
  }

  export type AidRoomGroupByOutputType = {
    id: string
    name: string
    location: string
    status: $Enums.Status
    mountainId: string
    _count: AidRoomCountAggregateOutputType | null
    _min: AidRoomMinAggregateOutputType | null
    _max: AidRoomMaxAggregateOutputType | null
  }

  type GetAidRoomGroupByPayload<T extends AidRoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AidRoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AidRoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AidRoomGroupByOutputType[P]>
            : GetScalarType<T[P], AidRoomGroupByOutputType[P]>
        }
      >
    >


  export type AidRoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    status?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incidentLogs?: boolean | AidRoom$incidentLogsArgs<ExtArgs>
    aidRoomChecks?: boolean | AidRoom$aidRoomChecksArgs<ExtArgs>
    _count?: boolean | AidRoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aidRoom"]>

  export type AidRoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    status?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aidRoom"]>

  export type AidRoomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    status?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aidRoom"]>

  export type AidRoomSelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    status?: boolean
    mountainId?: boolean
  }

  export type AidRoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "location" | "status" | "mountainId", ExtArgs["result"]["aidRoom"]>
  export type AidRoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incidentLogs?: boolean | AidRoom$incidentLogsArgs<ExtArgs>
    aidRoomChecks?: boolean | AidRoom$aidRoomChecksArgs<ExtArgs>
    _count?: boolean | AidRoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AidRoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }
  export type AidRoomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }

  export type $AidRoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AidRoom"
    objects: {
      mountain: Prisma.$MountainPayload<ExtArgs>
      incidentLogs: Prisma.$IncidentLogPayload<ExtArgs>[]
      aidRoomChecks: Prisma.$AidRoomCheckPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      location: string
      status: $Enums.Status
      mountainId: string
    }, ExtArgs["result"]["aidRoom"]>
    composites: {}
  }

  type AidRoomGetPayload<S extends boolean | null | undefined | AidRoomDefaultArgs> = $Result.GetResult<Prisma.$AidRoomPayload, S>

  type AidRoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AidRoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AidRoomCountAggregateInputType | true
    }

  export interface AidRoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AidRoom'], meta: { name: 'AidRoom' } }
    /**
     * Find zero or one AidRoom that matches the filter.
     * @param {AidRoomFindUniqueArgs} args - Arguments to find a AidRoom
     * @example
     * // Get one AidRoom
     * const aidRoom = await prisma.aidRoom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AidRoomFindUniqueArgs>(args: SelectSubset<T, AidRoomFindUniqueArgs<ExtArgs>>): Prisma__AidRoomClient<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AidRoom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AidRoomFindUniqueOrThrowArgs} args - Arguments to find a AidRoom
     * @example
     * // Get one AidRoom
     * const aidRoom = await prisma.aidRoom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AidRoomFindUniqueOrThrowArgs>(args: SelectSubset<T, AidRoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AidRoomClient<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AidRoom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomFindFirstArgs} args - Arguments to find a AidRoom
     * @example
     * // Get one AidRoom
     * const aidRoom = await prisma.aidRoom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AidRoomFindFirstArgs>(args?: SelectSubset<T, AidRoomFindFirstArgs<ExtArgs>>): Prisma__AidRoomClient<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AidRoom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomFindFirstOrThrowArgs} args - Arguments to find a AidRoom
     * @example
     * // Get one AidRoom
     * const aidRoom = await prisma.aidRoom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AidRoomFindFirstOrThrowArgs>(args?: SelectSubset<T, AidRoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__AidRoomClient<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AidRooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AidRooms
     * const aidRooms = await prisma.aidRoom.findMany()
     * 
     * // Get first 10 AidRooms
     * const aidRooms = await prisma.aidRoom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aidRoomWithIdOnly = await prisma.aidRoom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AidRoomFindManyArgs>(args?: SelectSubset<T, AidRoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AidRoom.
     * @param {AidRoomCreateArgs} args - Arguments to create a AidRoom.
     * @example
     * // Create one AidRoom
     * const AidRoom = await prisma.aidRoom.create({
     *   data: {
     *     // ... data to create a AidRoom
     *   }
     * })
     * 
     */
    create<T extends AidRoomCreateArgs>(args: SelectSubset<T, AidRoomCreateArgs<ExtArgs>>): Prisma__AidRoomClient<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AidRooms.
     * @param {AidRoomCreateManyArgs} args - Arguments to create many AidRooms.
     * @example
     * // Create many AidRooms
     * const aidRoom = await prisma.aidRoom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AidRoomCreateManyArgs>(args?: SelectSubset<T, AidRoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AidRooms and returns the data saved in the database.
     * @param {AidRoomCreateManyAndReturnArgs} args - Arguments to create many AidRooms.
     * @example
     * // Create many AidRooms
     * const aidRoom = await prisma.aidRoom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AidRooms and only return the `id`
     * const aidRoomWithIdOnly = await prisma.aidRoom.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AidRoomCreateManyAndReturnArgs>(args?: SelectSubset<T, AidRoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AidRoom.
     * @param {AidRoomDeleteArgs} args - Arguments to delete one AidRoom.
     * @example
     * // Delete one AidRoom
     * const AidRoom = await prisma.aidRoom.delete({
     *   where: {
     *     // ... filter to delete one AidRoom
     *   }
     * })
     * 
     */
    delete<T extends AidRoomDeleteArgs>(args: SelectSubset<T, AidRoomDeleteArgs<ExtArgs>>): Prisma__AidRoomClient<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AidRoom.
     * @param {AidRoomUpdateArgs} args - Arguments to update one AidRoom.
     * @example
     * // Update one AidRoom
     * const aidRoom = await prisma.aidRoom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AidRoomUpdateArgs>(args: SelectSubset<T, AidRoomUpdateArgs<ExtArgs>>): Prisma__AidRoomClient<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AidRooms.
     * @param {AidRoomDeleteManyArgs} args - Arguments to filter AidRooms to delete.
     * @example
     * // Delete a few AidRooms
     * const { count } = await prisma.aidRoom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AidRoomDeleteManyArgs>(args?: SelectSubset<T, AidRoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AidRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AidRooms
     * const aidRoom = await prisma.aidRoom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AidRoomUpdateManyArgs>(args: SelectSubset<T, AidRoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AidRooms and returns the data updated in the database.
     * @param {AidRoomUpdateManyAndReturnArgs} args - Arguments to update many AidRooms.
     * @example
     * // Update many AidRooms
     * const aidRoom = await prisma.aidRoom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AidRooms and only return the `id`
     * const aidRoomWithIdOnly = await prisma.aidRoom.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AidRoomUpdateManyAndReturnArgs>(args: SelectSubset<T, AidRoomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AidRoom.
     * @param {AidRoomUpsertArgs} args - Arguments to update or create a AidRoom.
     * @example
     * // Update or create a AidRoom
     * const aidRoom = await prisma.aidRoom.upsert({
     *   create: {
     *     // ... data to create a AidRoom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AidRoom we want to update
     *   }
     * })
     */
    upsert<T extends AidRoomUpsertArgs>(args: SelectSubset<T, AidRoomUpsertArgs<ExtArgs>>): Prisma__AidRoomClient<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AidRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomCountArgs} args - Arguments to filter AidRooms to count.
     * @example
     * // Count the number of AidRooms
     * const count = await prisma.aidRoom.count({
     *   where: {
     *     // ... the filter for the AidRooms we want to count
     *   }
     * })
    **/
    count<T extends AidRoomCountArgs>(
      args?: Subset<T, AidRoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AidRoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AidRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AidRoomAggregateArgs>(args: Subset<T, AidRoomAggregateArgs>): Prisma.PrismaPromise<GetAidRoomAggregateType<T>>

    /**
     * Group by AidRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AidRoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AidRoomGroupByArgs['orderBy'] }
        : { orderBy?: AidRoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AidRoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAidRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AidRoom model
   */
  readonly fields: AidRoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AidRoom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AidRoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    incidentLogs<T extends AidRoom$incidentLogsArgs<ExtArgs> = {}>(args?: Subset<T, AidRoom$incidentLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aidRoomChecks<T extends AidRoom$aidRoomChecksArgs<ExtArgs> = {}>(args?: Subset<T, AidRoom$aidRoomChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AidRoom model
   */
  interface AidRoomFieldRefs {
    readonly id: FieldRef<"AidRoom", 'String'>
    readonly name: FieldRef<"AidRoom", 'String'>
    readonly location: FieldRef<"AidRoom", 'String'>
    readonly status: FieldRef<"AidRoom", 'Status'>
    readonly mountainId: FieldRef<"AidRoom", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AidRoom findUnique
   */
  export type AidRoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
    /**
     * Filter, which AidRoom to fetch.
     */
    where: AidRoomWhereUniqueInput
  }

  /**
   * AidRoom findUniqueOrThrow
   */
  export type AidRoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
    /**
     * Filter, which AidRoom to fetch.
     */
    where: AidRoomWhereUniqueInput
  }

  /**
   * AidRoom findFirst
   */
  export type AidRoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
    /**
     * Filter, which AidRoom to fetch.
     */
    where?: AidRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AidRooms to fetch.
     */
    orderBy?: AidRoomOrderByWithRelationInput | AidRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AidRooms.
     */
    cursor?: AidRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AidRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AidRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AidRooms.
     */
    distinct?: AidRoomScalarFieldEnum | AidRoomScalarFieldEnum[]
  }

  /**
   * AidRoom findFirstOrThrow
   */
  export type AidRoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
    /**
     * Filter, which AidRoom to fetch.
     */
    where?: AidRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AidRooms to fetch.
     */
    orderBy?: AidRoomOrderByWithRelationInput | AidRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AidRooms.
     */
    cursor?: AidRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AidRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AidRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AidRooms.
     */
    distinct?: AidRoomScalarFieldEnum | AidRoomScalarFieldEnum[]
  }

  /**
   * AidRoom findMany
   */
  export type AidRoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
    /**
     * Filter, which AidRooms to fetch.
     */
    where?: AidRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AidRooms to fetch.
     */
    orderBy?: AidRoomOrderByWithRelationInput | AidRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AidRooms.
     */
    cursor?: AidRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AidRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AidRooms.
     */
    skip?: number
    distinct?: AidRoomScalarFieldEnum | AidRoomScalarFieldEnum[]
  }

  /**
   * AidRoom create
   */
  export type AidRoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
    /**
     * The data needed to create a AidRoom.
     */
    data: XOR<AidRoomCreateInput, AidRoomUncheckedCreateInput>
  }

  /**
   * AidRoom createMany
   */
  export type AidRoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AidRooms.
     */
    data: AidRoomCreateManyInput | AidRoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AidRoom createManyAndReturn
   */
  export type AidRoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * The data used to create many AidRooms.
     */
    data: AidRoomCreateManyInput | AidRoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AidRoom update
   */
  export type AidRoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
    /**
     * The data needed to update a AidRoom.
     */
    data: XOR<AidRoomUpdateInput, AidRoomUncheckedUpdateInput>
    /**
     * Choose, which AidRoom to update.
     */
    where: AidRoomWhereUniqueInput
  }

  /**
   * AidRoom updateMany
   */
  export type AidRoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AidRooms.
     */
    data: XOR<AidRoomUpdateManyMutationInput, AidRoomUncheckedUpdateManyInput>
    /**
     * Filter which AidRooms to update
     */
    where?: AidRoomWhereInput
    /**
     * Limit how many AidRooms to update.
     */
    limit?: number
  }

  /**
   * AidRoom updateManyAndReturn
   */
  export type AidRoomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * The data used to update AidRooms.
     */
    data: XOR<AidRoomUpdateManyMutationInput, AidRoomUncheckedUpdateManyInput>
    /**
     * Filter which AidRooms to update
     */
    where?: AidRoomWhereInput
    /**
     * Limit how many AidRooms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AidRoom upsert
   */
  export type AidRoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
    /**
     * The filter to search for the AidRoom to update in case it exists.
     */
    where: AidRoomWhereUniqueInput
    /**
     * In case the AidRoom found by the `where` argument doesn't exist, create a new AidRoom with this data.
     */
    create: XOR<AidRoomCreateInput, AidRoomUncheckedCreateInput>
    /**
     * In case the AidRoom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AidRoomUpdateInput, AidRoomUncheckedUpdateInput>
  }

  /**
   * AidRoom delete
   */
  export type AidRoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
    /**
     * Filter which AidRoom to delete.
     */
    where: AidRoomWhereUniqueInput
  }

  /**
   * AidRoom deleteMany
   */
  export type AidRoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AidRooms to delete
     */
    where?: AidRoomWhereInput
    /**
     * Limit how many AidRooms to delete.
     */
    limit?: number
  }

  /**
   * AidRoom.incidentLogs
   */
  export type AidRoom$incidentLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLog
     */
    select?: IncidentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLog
     */
    omit?: IncidentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogInclude<ExtArgs> | null
    where?: IncidentLogWhereInput
    orderBy?: IncidentLogOrderByWithRelationInput | IncidentLogOrderByWithRelationInput[]
    cursor?: IncidentLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentLogScalarFieldEnum | IncidentLogScalarFieldEnum[]
  }

  /**
   * AidRoom.aidRoomChecks
   */
  export type AidRoom$aidRoomChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    where?: AidRoomCheckWhereInput
    orderBy?: AidRoomCheckOrderByWithRelationInput | AidRoomCheckOrderByWithRelationInput[]
    cursor?: AidRoomCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AidRoomCheckScalarFieldEnum | AidRoomCheckScalarFieldEnum[]
  }

  /**
   * AidRoom without action
   */
  export type AidRoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
  }


  /**
   * Model Equipment
   */

  export type AggregateEquipment = {
    _count: EquipmentCountAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  export type EquipmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    status: $Enums.EquipmentStatus | null
    service: $Enums.EquipmentService | null
    mountainId: string | null
  }

  export type EquipmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    status: $Enums.EquipmentStatus | null
    service: $Enums.EquipmentService | null
    mountainId: string | null
  }

  export type EquipmentCountAggregateOutputType = {
    id: number
    name: number
    type: number
    status: number
    service: number
    mountainId: number
    _all: number
  }


  export type EquipmentMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    service?: true
    mountainId?: true
  }

  export type EquipmentMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    service?: true
    mountainId?: true
  }

  export type EquipmentCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    service?: true
    mountainId?: true
    _all?: true
  }

  export type EquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to aggregate.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Equipment
    **/
    _count?: true | EquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentMaxAggregateInputType
  }

  export type GetEquipmentAggregateType<T extends EquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment[P]>
      : GetScalarType<T[P], AggregateEquipment[P]>
  }




  export type EquipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithAggregationInput | EquipmentOrderByWithAggregationInput[]
    by: EquipmentScalarFieldEnum[] | EquipmentScalarFieldEnum
    having?: EquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentCountAggregateInputType | true
    _min?: EquipmentMinAggregateInputType
    _max?: EquipmentMaxAggregateInputType
  }

  export type EquipmentGroupByOutputType = {
    id: string
    name: string
    type: string
    status: $Enums.EquipmentStatus
    service: $Enums.EquipmentService
    mountainId: string
    _count: EquipmentCountAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  type GetEquipmentGroupByPayload<T extends EquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    service?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    usedInLogs?: boolean | Equipment$usedInLogsArgs<ExtArgs>
    equipmentChecks?: boolean | Equipment$equipmentChecksArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    service?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    service?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    service?: boolean
    mountainId?: boolean
  }

  export type EquipmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "status" | "service" | "mountainId", ExtArgs["result"]["equipment"]>
  export type EquipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    usedInLogs?: boolean | Equipment$usedInLogsArgs<ExtArgs>
    equipmentChecks?: boolean | Equipment$equipmentChecksArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EquipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }
  export type EquipmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }

  export type $EquipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Equipment"
    objects: {
      mountain: Prisma.$MountainPayload<ExtArgs>
      usedInLogs: Prisma.$IncidentLogEquipmentPayload<ExtArgs>[]
      equipmentChecks: Prisma.$EquipmentCheckPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      status: $Enums.EquipmentStatus
      service: $Enums.EquipmentService
      mountainId: string
    }, ExtArgs["result"]["equipment"]>
    composites: {}
  }

  type EquipmentGetPayload<S extends boolean | null | undefined | EquipmentDefaultArgs> = $Result.GetResult<Prisma.$EquipmentPayload, S>

  type EquipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipmentCountAggregateInputType | true
    }

  export interface EquipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Equipment'], meta: { name: 'Equipment' } }
    /**
     * Find zero or one Equipment that matches the filter.
     * @param {EquipmentFindUniqueArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentFindUniqueArgs>(args: SelectSubset<T, EquipmentFindUniqueArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Equipment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipmentFindUniqueOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentFindFirstArgs>(args?: SelectSubset<T, EquipmentFindFirstArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment
     * const equipment = await prisma.equipment.findMany()
     * 
     * // Get first 10 Equipment
     * const equipment = await prisma.equipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentWithIdOnly = await prisma.equipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentFindManyArgs>(args?: SelectSubset<T, EquipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Equipment.
     * @param {EquipmentCreateArgs} args - Arguments to create a Equipment.
     * @example
     * // Create one Equipment
     * const Equipment = await prisma.equipment.create({
     *   data: {
     *     // ... data to create a Equipment
     *   }
     * })
     * 
     */
    create<T extends EquipmentCreateArgs>(args: SelectSubset<T, EquipmentCreateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Equipment.
     * @param {EquipmentCreateManyArgs} args - Arguments to create many Equipment.
     * @example
     * // Create many Equipment
     * const equipment = await prisma.equipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentCreateManyArgs>(args?: SelectSubset<T, EquipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Equipment and returns the data saved in the database.
     * @param {EquipmentCreateManyAndReturnArgs} args - Arguments to create many Equipment.
     * @example
     * // Create many Equipment
     * const equipment = await prisma.equipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Equipment and only return the `id`
     * const equipmentWithIdOnly = await prisma.equipment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Equipment.
     * @param {EquipmentDeleteArgs} args - Arguments to delete one Equipment.
     * @example
     * // Delete one Equipment
     * const Equipment = await prisma.equipment.delete({
     *   where: {
     *     // ... filter to delete one Equipment
     *   }
     * })
     * 
     */
    delete<T extends EquipmentDeleteArgs>(args: SelectSubset<T, EquipmentDeleteArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Equipment.
     * @param {EquipmentUpdateArgs} args - Arguments to update one Equipment.
     * @example
     * // Update one Equipment
     * const equipment = await prisma.equipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentUpdateArgs>(args: SelectSubset<T, EquipmentUpdateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Equipment.
     * @param {EquipmentDeleteManyArgs} args - Arguments to filter Equipment to delete.
     * @example
     * // Delete a few Equipment
     * const { count } = await prisma.equipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentDeleteManyArgs>(args?: SelectSubset<T, EquipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentUpdateManyArgs>(args: SelectSubset<T, EquipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment and returns the data updated in the database.
     * @param {EquipmentUpdateManyAndReturnArgs} args - Arguments to update many Equipment.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Equipment and only return the `id`
     * const equipmentWithIdOnly = await prisma.equipment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EquipmentUpdateManyAndReturnArgs>(args: SelectSubset<T, EquipmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Equipment.
     * @param {EquipmentUpsertArgs} args - Arguments to update or create a Equipment.
     * @example
     * // Update or create a Equipment
     * const equipment = await prisma.equipment.upsert({
     *   create: {
     *     // ... data to create a Equipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentUpsertArgs>(args: SelectSubset<T, EquipmentUpsertArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCountArgs} args - Arguments to filter Equipment to count.
     * @example
     * // Count the number of Equipment
     * const count = await prisma.equipment.count({
     *   where: {
     *     // ... the filter for the Equipment we want to count
     *   }
     * })
    **/
    count<T extends EquipmentCountArgs>(
      args?: Subset<T, EquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentAggregateArgs>(args: Subset<T, EquipmentAggregateArgs>): Prisma.PrismaPromise<GetEquipmentAggregateType<T>>

    /**
     * Group by Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Equipment model
   */
  readonly fields: EquipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Equipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usedInLogs<T extends Equipment$usedInLogsArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$usedInLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentLogEquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipmentChecks<T extends Equipment$equipmentChecksArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$equipmentChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Equipment model
   */
  interface EquipmentFieldRefs {
    readonly id: FieldRef<"Equipment", 'String'>
    readonly name: FieldRef<"Equipment", 'String'>
    readonly type: FieldRef<"Equipment", 'String'>
    readonly status: FieldRef<"Equipment", 'EquipmentStatus'>
    readonly service: FieldRef<"Equipment", 'EquipmentService'>
    readonly mountainId: FieldRef<"Equipment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Equipment findUnique
   */
  export type EquipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findUniqueOrThrow
   */
  export type EquipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findFirst
   */
  export type EquipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findFirstOrThrow
   */
  export type EquipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findMany
   */
  export type EquipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment create
   */
  export type EquipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Equipment.
     */
    data: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
  }

  /**
   * Equipment createMany
   */
  export type EquipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Equipment.
     */
    data: EquipmentCreateManyInput | EquipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Equipment createManyAndReturn
   */
  export type EquipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * The data used to create many Equipment.
     */
    data: EquipmentCreateManyInput | EquipmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Equipment update
   */
  export type EquipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Equipment.
     */
    data: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
    /**
     * Choose, which Equipment to update.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment updateMany
   */
  export type EquipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to update.
     */
    limit?: number
  }

  /**
   * Equipment updateManyAndReturn
   */
  export type EquipmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Equipment upsert
   */
  export type EquipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Equipment to update in case it exists.
     */
    where: EquipmentWhereUniqueInput
    /**
     * In case the Equipment found by the `where` argument doesn't exist, create a new Equipment with this data.
     */
    create: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
    /**
     * In case the Equipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
  }

  /**
   * Equipment delete
   */
  export type EquipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter which Equipment to delete.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment deleteMany
   */
  export type EquipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to delete
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to delete.
     */
    limit?: number
  }

  /**
   * Equipment.usedInLogs
   */
  export type Equipment$usedInLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLogEquipment
     */
    select?: IncidentLogEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLogEquipment
     */
    omit?: IncidentLogEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogEquipmentInclude<ExtArgs> | null
    where?: IncidentLogEquipmentWhereInput
    orderBy?: IncidentLogEquipmentOrderByWithRelationInput | IncidentLogEquipmentOrderByWithRelationInput[]
    cursor?: IncidentLogEquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentLogEquipmentScalarFieldEnum | IncidentLogEquipmentScalarFieldEnum[]
  }

  /**
   * Equipment.equipmentChecks
   */
  export type Equipment$equipmentChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    where?: EquipmentCheckWhereInput
    orderBy?: EquipmentCheckOrderByWithRelationInput | EquipmentCheckOrderByWithRelationInput[]
    cursor?: EquipmentCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentCheckScalarFieldEnum | EquipmentCheckScalarFieldEnum[]
  }

  /**
   * Equipment without action
   */
  export type EquipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
  }


  /**
   * Model Incident
   */

  export type AggregateIncident = {
    _count: IncidentCountAggregateOutputType | null
    _min: IncidentMinAggregateOutputType | null
    _max: IncidentMaxAggregateOutputType | null
  }

  export type IncidentMinAggregateOutputType = {
    id: string | null
    description: string | null
    status: $Enums.Status | null
    mountainId: string | null
  }

  export type IncidentMaxAggregateOutputType = {
    id: string | null
    description: string | null
    status: $Enums.Status | null
    mountainId: string | null
  }

  export type IncidentCountAggregateOutputType = {
    id: number
    description: number
    status: number
    mountainId: number
    _all: number
  }


  export type IncidentMinAggregateInputType = {
    id?: true
    description?: true
    status?: true
    mountainId?: true
  }

  export type IncidentMaxAggregateInputType = {
    id?: true
    description?: true
    status?: true
    mountainId?: true
  }

  export type IncidentCountAggregateInputType = {
    id?: true
    description?: true
    status?: true
    mountainId?: true
    _all?: true
  }

  export type IncidentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incident to aggregate.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Incidents
    **/
    _count?: true | IncidentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncidentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncidentMaxAggregateInputType
  }

  export type GetIncidentAggregateType<T extends IncidentAggregateArgs> = {
        [P in keyof T & keyof AggregateIncident]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncident[P]>
      : GetScalarType<T[P], AggregateIncident[P]>
  }




  export type IncidentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithAggregationInput | IncidentOrderByWithAggregationInput[]
    by: IncidentScalarFieldEnum[] | IncidentScalarFieldEnum
    having?: IncidentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncidentCountAggregateInputType | true
    _min?: IncidentMinAggregateInputType
    _max?: IncidentMaxAggregateInputType
  }

  export type IncidentGroupByOutputType = {
    id: string
    description: string
    status: $Enums.Status
    mountainId: string
    _count: IncidentCountAggregateOutputType | null
    _min: IncidentMinAggregateOutputType | null
    _max: IncidentMaxAggregateOutputType | null
  }

  type GetIncidentGroupByPayload<T extends IncidentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncidentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncidentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncidentGroupByOutputType[P]>
            : GetScalarType<T[P], IncidentGroupByOutputType[P]>
        }
      >
    >


  export type IncidentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    status?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    logs?: boolean | Incident$logsArgs<ExtArgs>
    _count?: boolean | IncidentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incident"]>

  export type IncidentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    status?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incident"]>

  export type IncidentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    status?: boolean
    mountainId?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incident"]>

  export type IncidentSelectScalar = {
    id?: boolean
    description?: boolean
    status?: boolean
    mountainId?: boolean
  }

  export type IncidentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "status" | "mountainId", ExtArgs["result"]["incident"]>
  export type IncidentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    logs?: boolean | Incident$logsArgs<ExtArgs>
    _count?: boolean | IncidentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IncidentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }
  export type IncidentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
  }

  export type $IncidentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Incident"
    objects: {
      mountain: Prisma.$MountainPayload<ExtArgs>
      logs: Prisma.$IncidentLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      status: $Enums.Status
      mountainId: string
    }, ExtArgs["result"]["incident"]>
    composites: {}
  }

  type IncidentGetPayload<S extends boolean | null | undefined | IncidentDefaultArgs> = $Result.GetResult<Prisma.$IncidentPayload, S>

  type IncidentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IncidentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IncidentCountAggregateInputType | true
    }

  export interface IncidentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Incident'], meta: { name: 'Incident' } }
    /**
     * Find zero or one Incident that matches the filter.
     * @param {IncidentFindUniqueArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncidentFindUniqueArgs>(args: SelectSubset<T, IncidentFindUniqueArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Incident that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IncidentFindUniqueOrThrowArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncidentFindUniqueOrThrowArgs>(args: SelectSubset<T, IncidentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Incident that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindFirstArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncidentFindFirstArgs>(args?: SelectSubset<T, IncidentFindFirstArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Incident that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindFirstOrThrowArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncidentFindFirstOrThrowArgs>(args?: SelectSubset<T, IncidentFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Incidents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Incidents
     * const incidents = await prisma.incident.findMany()
     * 
     * // Get first 10 Incidents
     * const incidents = await prisma.incident.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incidentWithIdOnly = await prisma.incident.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncidentFindManyArgs>(args?: SelectSubset<T, IncidentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Incident.
     * @param {IncidentCreateArgs} args - Arguments to create a Incident.
     * @example
     * // Create one Incident
     * const Incident = await prisma.incident.create({
     *   data: {
     *     // ... data to create a Incident
     *   }
     * })
     * 
     */
    create<T extends IncidentCreateArgs>(args: SelectSubset<T, IncidentCreateArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Incidents.
     * @param {IncidentCreateManyArgs} args - Arguments to create many Incidents.
     * @example
     * // Create many Incidents
     * const incident = await prisma.incident.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncidentCreateManyArgs>(args?: SelectSubset<T, IncidentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Incidents and returns the data saved in the database.
     * @param {IncidentCreateManyAndReturnArgs} args - Arguments to create many Incidents.
     * @example
     * // Create many Incidents
     * const incident = await prisma.incident.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Incidents and only return the `id`
     * const incidentWithIdOnly = await prisma.incident.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncidentCreateManyAndReturnArgs>(args?: SelectSubset<T, IncidentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Incident.
     * @param {IncidentDeleteArgs} args - Arguments to delete one Incident.
     * @example
     * // Delete one Incident
     * const Incident = await prisma.incident.delete({
     *   where: {
     *     // ... filter to delete one Incident
     *   }
     * })
     * 
     */
    delete<T extends IncidentDeleteArgs>(args: SelectSubset<T, IncidentDeleteArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Incident.
     * @param {IncidentUpdateArgs} args - Arguments to update one Incident.
     * @example
     * // Update one Incident
     * const incident = await prisma.incident.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncidentUpdateArgs>(args: SelectSubset<T, IncidentUpdateArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Incidents.
     * @param {IncidentDeleteManyArgs} args - Arguments to filter Incidents to delete.
     * @example
     * // Delete a few Incidents
     * const { count } = await prisma.incident.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncidentDeleteManyArgs>(args?: SelectSubset<T, IncidentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Incidents
     * const incident = await prisma.incident.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncidentUpdateManyArgs>(args: SelectSubset<T, IncidentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incidents and returns the data updated in the database.
     * @param {IncidentUpdateManyAndReturnArgs} args - Arguments to update many Incidents.
     * @example
     * // Update many Incidents
     * const incident = await prisma.incident.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Incidents and only return the `id`
     * const incidentWithIdOnly = await prisma.incident.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IncidentUpdateManyAndReturnArgs>(args: SelectSubset<T, IncidentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Incident.
     * @param {IncidentUpsertArgs} args - Arguments to update or create a Incident.
     * @example
     * // Update or create a Incident
     * const incident = await prisma.incident.upsert({
     *   create: {
     *     // ... data to create a Incident
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Incident we want to update
     *   }
     * })
     */
    upsert<T extends IncidentUpsertArgs>(args: SelectSubset<T, IncidentUpsertArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Incidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentCountArgs} args - Arguments to filter Incidents to count.
     * @example
     * // Count the number of Incidents
     * const count = await prisma.incident.count({
     *   where: {
     *     // ... the filter for the Incidents we want to count
     *   }
     * })
    **/
    count<T extends IncidentCountArgs>(
      args?: Subset<T, IncidentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncidentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Incident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncidentAggregateArgs>(args: Subset<T, IncidentAggregateArgs>): Prisma.PrismaPromise<GetIncidentAggregateType<T>>

    /**
     * Group by Incident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncidentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncidentGroupByArgs['orderBy'] }
        : { orderBy?: IncidentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncidentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncidentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Incident model
   */
  readonly fields: IncidentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Incident.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncidentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    logs<T extends Incident$logsArgs<ExtArgs> = {}>(args?: Subset<T, Incident$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Incident model
   */
  interface IncidentFieldRefs {
    readonly id: FieldRef<"Incident", 'String'>
    readonly description: FieldRef<"Incident", 'String'>
    readonly status: FieldRef<"Incident", 'Status'>
    readonly mountainId: FieldRef<"Incident", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Incident findUnique
   */
  export type IncidentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident findUniqueOrThrow
   */
  export type IncidentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident findFirst
   */
  export type IncidentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidents.
     */
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident findFirstOrThrow
   */
  export type IncidentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidents.
     */
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident findMany
   */
  export type IncidentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incidents to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident create
   */
  export type IncidentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The data needed to create a Incident.
     */
    data: XOR<IncidentCreateInput, IncidentUncheckedCreateInput>
  }

  /**
   * Incident createMany
   */
  export type IncidentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Incidents.
     */
    data: IncidentCreateManyInput | IncidentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Incident createManyAndReturn
   */
  export type IncidentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * The data used to create many Incidents.
     */
    data: IncidentCreateManyInput | IncidentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Incident update
   */
  export type IncidentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The data needed to update a Incident.
     */
    data: XOR<IncidentUpdateInput, IncidentUncheckedUpdateInput>
    /**
     * Choose, which Incident to update.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident updateMany
   */
  export type IncidentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Incidents.
     */
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyInput>
    /**
     * Filter which Incidents to update
     */
    where?: IncidentWhereInput
    /**
     * Limit how many Incidents to update.
     */
    limit?: number
  }

  /**
   * Incident updateManyAndReturn
   */
  export type IncidentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * The data used to update Incidents.
     */
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyInput>
    /**
     * Filter which Incidents to update
     */
    where?: IncidentWhereInput
    /**
     * Limit how many Incidents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Incident upsert
   */
  export type IncidentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The filter to search for the Incident to update in case it exists.
     */
    where: IncidentWhereUniqueInput
    /**
     * In case the Incident found by the `where` argument doesn't exist, create a new Incident with this data.
     */
    create: XOR<IncidentCreateInput, IncidentUncheckedCreateInput>
    /**
     * In case the Incident was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncidentUpdateInput, IncidentUncheckedUpdateInput>
  }

  /**
   * Incident delete
   */
  export type IncidentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter which Incident to delete.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident deleteMany
   */
  export type IncidentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incidents to delete
     */
    where?: IncidentWhereInput
    /**
     * Limit how many Incidents to delete.
     */
    limit?: number
  }

  /**
   * Incident.logs
   */
  export type Incident$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLog
     */
    select?: IncidentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLog
     */
    omit?: IncidentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogInclude<ExtArgs> | null
    where?: IncidentLogWhereInput
    orderBy?: IncidentLogOrderByWithRelationInput | IncidentLogOrderByWithRelationInput[]
    cursor?: IncidentLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentLogScalarFieldEnum | IncidentLogScalarFieldEnum[]
  }

  /**
   * Incident without action
   */
  export type IncidentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Incident
     */
    omit?: IncidentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
  }


  /**
   * Model IncidentLog
   */

  export type AggregateIncidentLog = {
    _count: IncidentLogCountAggregateOutputType | null
    _min: IncidentLogMinAggregateOutputType | null
    _max: IncidentLogMaxAggregateOutputType | null
  }

  export type IncidentLogMinAggregateOutputType = {
    id: string | null
    incidentId: string | null
    employeeId: string | null
    mountainId: string | null
    locationType: $Enums.LocationType | null
    locationId: string | null
    locationStatus: string | null
    startTime: Date | null
    endTime: Date | null
    onSceneTime: Date | null
    stableTime: Date | null
    transportTime: Date | null
    dryRun: boolean | null
    dryRunTime: Date | null
  }

  export type IncidentLogMaxAggregateOutputType = {
    id: string | null
    incidentId: string | null
    employeeId: string | null
    mountainId: string | null
    locationType: $Enums.LocationType | null
    locationId: string | null
    locationStatus: string | null
    startTime: Date | null
    endTime: Date | null
    onSceneTime: Date | null
    stableTime: Date | null
    transportTime: Date | null
    dryRun: boolean | null
    dryRunTime: Date | null
  }

  export type IncidentLogCountAggregateOutputType = {
    id: number
    incidentId: number
    employeeId: number
    mountainId: number
    locationType: number
    locationId: number
    locationStatus: number
    startTime: number
    endTime: number
    onSceneTime: number
    stableTime: number
    transportTime: number
    dryRun: number
    dryRunTime: number
    _all: number
  }


  export type IncidentLogMinAggregateInputType = {
    id?: true
    incidentId?: true
    employeeId?: true
    mountainId?: true
    locationType?: true
    locationId?: true
    locationStatus?: true
    startTime?: true
    endTime?: true
    onSceneTime?: true
    stableTime?: true
    transportTime?: true
    dryRun?: true
    dryRunTime?: true
  }

  export type IncidentLogMaxAggregateInputType = {
    id?: true
    incidentId?: true
    employeeId?: true
    mountainId?: true
    locationType?: true
    locationId?: true
    locationStatus?: true
    startTime?: true
    endTime?: true
    onSceneTime?: true
    stableTime?: true
    transportTime?: true
    dryRun?: true
    dryRunTime?: true
  }

  export type IncidentLogCountAggregateInputType = {
    id?: true
    incidentId?: true
    employeeId?: true
    mountainId?: true
    locationType?: true
    locationId?: true
    locationStatus?: true
    startTime?: true
    endTime?: true
    onSceneTime?: true
    stableTime?: true
    transportTime?: true
    dryRun?: true
    dryRunTime?: true
    _all?: true
  }

  export type IncidentLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncidentLog to aggregate.
     */
    where?: IncidentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentLogs to fetch.
     */
    orderBy?: IncidentLogOrderByWithRelationInput | IncidentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncidentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IncidentLogs
    **/
    _count?: true | IncidentLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncidentLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncidentLogMaxAggregateInputType
  }

  export type GetIncidentLogAggregateType<T extends IncidentLogAggregateArgs> = {
        [P in keyof T & keyof AggregateIncidentLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncidentLog[P]>
      : GetScalarType<T[P], AggregateIncidentLog[P]>
  }




  export type IncidentLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentLogWhereInput
    orderBy?: IncidentLogOrderByWithAggregationInput | IncidentLogOrderByWithAggregationInput[]
    by: IncidentLogScalarFieldEnum[] | IncidentLogScalarFieldEnum
    having?: IncidentLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncidentLogCountAggregateInputType | true
    _min?: IncidentLogMinAggregateInputType
    _max?: IncidentLogMaxAggregateInputType
  }

  export type IncidentLogGroupByOutputType = {
    id: string
    incidentId: string
    employeeId: string
    mountainId: string
    locationType: $Enums.LocationType
    locationId: string
    locationStatus: string
    startTime: Date
    endTime: Date
    onSceneTime: Date | null
    stableTime: Date | null
    transportTime: Date | null
    dryRun: boolean
    dryRunTime: Date | null
    _count: IncidentLogCountAggregateOutputType | null
    _min: IncidentLogMinAggregateOutputType | null
    _max: IncidentLogMaxAggregateOutputType | null
  }

  type GetIncidentLogGroupByPayload<T extends IncidentLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncidentLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncidentLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncidentLogGroupByOutputType[P]>
            : GetScalarType<T[P], IncidentLogGroupByOutputType[P]>
        }
      >
    >


  export type IncidentLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    incidentId?: boolean
    employeeId?: boolean
    mountainId?: boolean
    locationType?: boolean
    locationId?: boolean
    locationStatus?: boolean
    startTime?: boolean
    endTime?: boolean
    onSceneTime?: boolean
    stableTime?: boolean
    transportTime?: boolean
    dryRun?: boolean
    dryRunTime?: boolean
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    equipmentUsed?: boolean | IncidentLog$equipmentUsedArgs<ExtArgs>
    lift?: boolean | IncidentLog$liftArgs<ExtArgs>
    trail?: boolean | IncidentLog$trailArgs<ExtArgs>
    lodge?: boolean | IncidentLog$lodgeArgs<ExtArgs>
    hut?: boolean | IncidentLog$hutArgs<ExtArgs>
    aidRoom?: boolean | IncidentLog$aidRoomArgs<ExtArgs>
    _count?: boolean | IncidentLogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incidentLog"]>

  export type IncidentLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    incidentId?: boolean
    employeeId?: boolean
    mountainId?: boolean
    locationType?: boolean
    locationId?: boolean
    locationStatus?: boolean
    startTime?: boolean
    endTime?: boolean
    onSceneTime?: boolean
    stableTime?: boolean
    transportTime?: boolean
    dryRun?: boolean
    dryRunTime?: boolean
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    lift?: boolean | IncidentLog$liftArgs<ExtArgs>
    trail?: boolean | IncidentLog$trailArgs<ExtArgs>
    lodge?: boolean | IncidentLog$lodgeArgs<ExtArgs>
    hut?: boolean | IncidentLog$hutArgs<ExtArgs>
    aidRoom?: boolean | IncidentLog$aidRoomArgs<ExtArgs>
  }, ExtArgs["result"]["incidentLog"]>

  export type IncidentLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    incidentId?: boolean
    employeeId?: boolean
    mountainId?: boolean
    locationType?: boolean
    locationId?: boolean
    locationStatus?: boolean
    startTime?: boolean
    endTime?: boolean
    onSceneTime?: boolean
    stableTime?: boolean
    transportTime?: boolean
    dryRun?: boolean
    dryRunTime?: boolean
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    lift?: boolean | IncidentLog$liftArgs<ExtArgs>
    trail?: boolean | IncidentLog$trailArgs<ExtArgs>
    lodge?: boolean | IncidentLog$lodgeArgs<ExtArgs>
    hut?: boolean | IncidentLog$hutArgs<ExtArgs>
    aidRoom?: boolean | IncidentLog$aidRoomArgs<ExtArgs>
  }, ExtArgs["result"]["incidentLog"]>

  export type IncidentLogSelectScalar = {
    id?: boolean
    incidentId?: boolean
    employeeId?: boolean
    mountainId?: boolean
    locationType?: boolean
    locationId?: boolean
    locationStatus?: boolean
    startTime?: boolean
    endTime?: boolean
    onSceneTime?: boolean
    stableTime?: boolean
    transportTime?: boolean
    dryRun?: boolean
    dryRunTime?: boolean
  }

  export type IncidentLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "incidentId" | "employeeId" | "mountainId" | "locationType" | "locationId" | "locationStatus" | "startTime" | "endTime" | "onSceneTime" | "stableTime" | "transportTime" | "dryRun" | "dryRunTime", ExtArgs["result"]["incidentLog"]>
  export type IncidentLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    equipmentUsed?: boolean | IncidentLog$equipmentUsedArgs<ExtArgs>
    lift?: boolean | IncidentLog$liftArgs<ExtArgs>
    trail?: boolean | IncidentLog$trailArgs<ExtArgs>
    lodge?: boolean | IncidentLog$lodgeArgs<ExtArgs>
    hut?: boolean | IncidentLog$hutArgs<ExtArgs>
    aidRoom?: boolean | IncidentLog$aidRoomArgs<ExtArgs>
    _count?: boolean | IncidentLogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IncidentLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    lift?: boolean | IncidentLog$liftArgs<ExtArgs>
    trail?: boolean | IncidentLog$trailArgs<ExtArgs>
    lodge?: boolean | IncidentLog$lodgeArgs<ExtArgs>
    hut?: boolean | IncidentLog$hutArgs<ExtArgs>
    aidRoom?: boolean | IncidentLog$aidRoomArgs<ExtArgs>
  }
  export type IncidentLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    lift?: boolean | IncidentLog$liftArgs<ExtArgs>
    trail?: boolean | IncidentLog$trailArgs<ExtArgs>
    lodge?: boolean | IncidentLog$lodgeArgs<ExtArgs>
    hut?: boolean | IncidentLog$hutArgs<ExtArgs>
    aidRoom?: boolean | IncidentLog$aidRoomArgs<ExtArgs>
  }

  export type $IncidentLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IncidentLog"
    objects: {
      incident: Prisma.$IncidentPayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs>
      mountain: Prisma.$MountainPayload<ExtArgs>
      equipmentUsed: Prisma.$IncidentLogEquipmentPayload<ExtArgs>[]
      lift: Prisma.$LiftPayload<ExtArgs> | null
      trail: Prisma.$TrailPayload<ExtArgs> | null
      lodge: Prisma.$LodgePayload<ExtArgs> | null
      hut: Prisma.$HutPayload<ExtArgs> | null
      aidRoom: Prisma.$AidRoomPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      incidentId: string
      employeeId: string
      mountainId: string
      locationType: $Enums.LocationType
      locationId: string
      locationStatus: string
      startTime: Date
      endTime: Date
      onSceneTime: Date | null
      stableTime: Date | null
      transportTime: Date | null
      dryRun: boolean
      dryRunTime: Date | null
    }, ExtArgs["result"]["incidentLog"]>
    composites: {}
  }

  type IncidentLogGetPayload<S extends boolean | null | undefined | IncidentLogDefaultArgs> = $Result.GetResult<Prisma.$IncidentLogPayload, S>

  type IncidentLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IncidentLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IncidentLogCountAggregateInputType | true
    }

  export interface IncidentLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IncidentLog'], meta: { name: 'IncidentLog' } }
    /**
     * Find zero or one IncidentLog that matches the filter.
     * @param {IncidentLogFindUniqueArgs} args - Arguments to find a IncidentLog
     * @example
     * // Get one IncidentLog
     * const incidentLog = await prisma.incidentLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncidentLogFindUniqueArgs>(args: SelectSubset<T, IncidentLogFindUniqueArgs<ExtArgs>>): Prisma__IncidentLogClient<$Result.GetResult<Prisma.$IncidentLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IncidentLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IncidentLogFindUniqueOrThrowArgs} args - Arguments to find a IncidentLog
     * @example
     * // Get one IncidentLog
     * const incidentLog = await prisma.incidentLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncidentLogFindUniqueOrThrowArgs>(args: SelectSubset<T, IncidentLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncidentLogClient<$Result.GetResult<Prisma.$IncidentLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IncidentLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentLogFindFirstArgs} args - Arguments to find a IncidentLog
     * @example
     * // Get one IncidentLog
     * const incidentLog = await prisma.incidentLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncidentLogFindFirstArgs>(args?: SelectSubset<T, IncidentLogFindFirstArgs<ExtArgs>>): Prisma__IncidentLogClient<$Result.GetResult<Prisma.$IncidentLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IncidentLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentLogFindFirstOrThrowArgs} args - Arguments to find a IncidentLog
     * @example
     * // Get one IncidentLog
     * const incidentLog = await prisma.incidentLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncidentLogFindFirstOrThrowArgs>(args?: SelectSubset<T, IncidentLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncidentLogClient<$Result.GetResult<Prisma.$IncidentLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IncidentLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IncidentLogs
     * const incidentLogs = await prisma.incidentLog.findMany()
     * 
     * // Get first 10 IncidentLogs
     * const incidentLogs = await prisma.incidentLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incidentLogWithIdOnly = await prisma.incidentLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncidentLogFindManyArgs>(args?: SelectSubset<T, IncidentLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IncidentLog.
     * @param {IncidentLogCreateArgs} args - Arguments to create a IncidentLog.
     * @example
     * // Create one IncidentLog
     * const IncidentLog = await prisma.incidentLog.create({
     *   data: {
     *     // ... data to create a IncidentLog
     *   }
     * })
     * 
     */
    create<T extends IncidentLogCreateArgs>(args: SelectSubset<T, IncidentLogCreateArgs<ExtArgs>>): Prisma__IncidentLogClient<$Result.GetResult<Prisma.$IncidentLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IncidentLogs.
     * @param {IncidentLogCreateManyArgs} args - Arguments to create many IncidentLogs.
     * @example
     * // Create many IncidentLogs
     * const incidentLog = await prisma.incidentLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncidentLogCreateManyArgs>(args?: SelectSubset<T, IncidentLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IncidentLogs and returns the data saved in the database.
     * @param {IncidentLogCreateManyAndReturnArgs} args - Arguments to create many IncidentLogs.
     * @example
     * // Create many IncidentLogs
     * const incidentLog = await prisma.incidentLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IncidentLogs and only return the `id`
     * const incidentLogWithIdOnly = await prisma.incidentLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncidentLogCreateManyAndReturnArgs>(args?: SelectSubset<T, IncidentLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IncidentLog.
     * @param {IncidentLogDeleteArgs} args - Arguments to delete one IncidentLog.
     * @example
     * // Delete one IncidentLog
     * const IncidentLog = await prisma.incidentLog.delete({
     *   where: {
     *     // ... filter to delete one IncidentLog
     *   }
     * })
     * 
     */
    delete<T extends IncidentLogDeleteArgs>(args: SelectSubset<T, IncidentLogDeleteArgs<ExtArgs>>): Prisma__IncidentLogClient<$Result.GetResult<Prisma.$IncidentLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IncidentLog.
     * @param {IncidentLogUpdateArgs} args - Arguments to update one IncidentLog.
     * @example
     * // Update one IncidentLog
     * const incidentLog = await prisma.incidentLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncidentLogUpdateArgs>(args: SelectSubset<T, IncidentLogUpdateArgs<ExtArgs>>): Prisma__IncidentLogClient<$Result.GetResult<Prisma.$IncidentLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IncidentLogs.
     * @param {IncidentLogDeleteManyArgs} args - Arguments to filter IncidentLogs to delete.
     * @example
     * // Delete a few IncidentLogs
     * const { count } = await prisma.incidentLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncidentLogDeleteManyArgs>(args?: SelectSubset<T, IncidentLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncidentLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IncidentLogs
     * const incidentLog = await prisma.incidentLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncidentLogUpdateManyArgs>(args: SelectSubset<T, IncidentLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncidentLogs and returns the data updated in the database.
     * @param {IncidentLogUpdateManyAndReturnArgs} args - Arguments to update many IncidentLogs.
     * @example
     * // Update many IncidentLogs
     * const incidentLog = await prisma.incidentLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IncidentLogs and only return the `id`
     * const incidentLogWithIdOnly = await prisma.incidentLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IncidentLogUpdateManyAndReturnArgs>(args: SelectSubset<T, IncidentLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IncidentLog.
     * @param {IncidentLogUpsertArgs} args - Arguments to update or create a IncidentLog.
     * @example
     * // Update or create a IncidentLog
     * const incidentLog = await prisma.incidentLog.upsert({
     *   create: {
     *     // ... data to create a IncidentLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IncidentLog we want to update
     *   }
     * })
     */
    upsert<T extends IncidentLogUpsertArgs>(args: SelectSubset<T, IncidentLogUpsertArgs<ExtArgs>>): Prisma__IncidentLogClient<$Result.GetResult<Prisma.$IncidentLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IncidentLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentLogCountArgs} args - Arguments to filter IncidentLogs to count.
     * @example
     * // Count the number of IncidentLogs
     * const count = await prisma.incidentLog.count({
     *   where: {
     *     // ... the filter for the IncidentLogs we want to count
     *   }
     * })
    **/
    count<T extends IncidentLogCountArgs>(
      args?: Subset<T, IncidentLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncidentLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IncidentLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncidentLogAggregateArgs>(args: Subset<T, IncidentLogAggregateArgs>): Prisma.PrismaPromise<GetIncidentLogAggregateType<T>>

    /**
     * Group by IncidentLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncidentLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncidentLogGroupByArgs['orderBy'] }
        : { orderBy?: IncidentLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncidentLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncidentLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IncidentLog model
   */
  readonly fields: IncidentLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IncidentLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncidentLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    incident<T extends IncidentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IncidentDefaultArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    equipmentUsed<T extends IncidentLog$equipmentUsedArgs<ExtArgs> = {}>(args?: Subset<T, IncidentLog$equipmentUsedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentLogEquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lift<T extends IncidentLog$liftArgs<ExtArgs> = {}>(args?: Subset<T, IncidentLog$liftArgs<ExtArgs>>): Prisma__LiftClient<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    trail<T extends IncidentLog$trailArgs<ExtArgs> = {}>(args?: Subset<T, IncidentLog$trailArgs<ExtArgs>>): Prisma__TrailClient<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lodge<T extends IncidentLog$lodgeArgs<ExtArgs> = {}>(args?: Subset<T, IncidentLog$lodgeArgs<ExtArgs>>): Prisma__LodgeClient<$Result.GetResult<Prisma.$LodgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    hut<T extends IncidentLog$hutArgs<ExtArgs> = {}>(args?: Subset<T, IncidentLog$hutArgs<ExtArgs>>): Prisma__HutClient<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    aidRoom<T extends IncidentLog$aidRoomArgs<ExtArgs> = {}>(args?: Subset<T, IncidentLog$aidRoomArgs<ExtArgs>>): Prisma__AidRoomClient<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IncidentLog model
   */
  interface IncidentLogFieldRefs {
    readonly id: FieldRef<"IncidentLog", 'String'>
    readonly incidentId: FieldRef<"IncidentLog", 'String'>
    readonly employeeId: FieldRef<"IncidentLog", 'String'>
    readonly mountainId: FieldRef<"IncidentLog", 'String'>
    readonly locationType: FieldRef<"IncidentLog", 'LocationType'>
    readonly locationId: FieldRef<"IncidentLog", 'String'>
    readonly locationStatus: FieldRef<"IncidentLog", 'String'>
    readonly startTime: FieldRef<"IncidentLog", 'DateTime'>
    readonly endTime: FieldRef<"IncidentLog", 'DateTime'>
    readonly onSceneTime: FieldRef<"IncidentLog", 'DateTime'>
    readonly stableTime: FieldRef<"IncidentLog", 'DateTime'>
    readonly transportTime: FieldRef<"IncidentLog", 'DateTime'>
    readonly dryRun: FieldRef<"IncidentLog", 'Boolean'>
    readonly dryRunTime: FieldRef<"IncidentLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IncidentLog findUnique
   */
  export type IncidentLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLog
     */
    select?: IncidentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLog
     */
    omit?: IncidentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogInclude<ExtArgs> | null
    /**
     * Filter, which IncidentLog to fetch.
     */
    where: IncidentLogWhereUniqueInput
  }

  /**
   * IncidentLog findUniqueOrThrow
   */
  export type IncidentLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLog
     */
    select?: IncidentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLog
     */
    omit?: IncidentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogInclude<ExtArgs> | null
    /**
     * Filter, which IncidentLog to fetch.
     */
    where: IncidentLogWhereUniqueInput
  }

  /**
   * IncidentLog findFirst
   */
  export type IncidentLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLog
     */
    select?: IncidentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLog
     */
    omit?: IncidentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogInclude<ExtArgs> | null
    /**
     * Filter, which IncidentLog to fetch.
     */
    where?: IncidentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentLogs to fetch.
     */
    orderBy?: IncidentLogOrderByWithRelationInput | IncidentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncidentLogs.
     */
    cursor?: IncidentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncidentLogs.
     */
    distinct?: IncidentLogScalarFieldEnum | IncidentLogScalarFieldEnum[]
  }

  /**
   * IncidentLog findFirstOrThrow
   */
  export type IncidentLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLog
     */
    select?: IncidentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLog
     */
    omit?: IncidentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogInclude<ExtArgs> | null
    /**
     * Filter, which IncidentLog to fetch.
     */
    where?: IncidentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentLogs to fetch.
     */
    orderBy?: IncidentLogOrderByWithRelationInput | IncidentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncidentLogs.
     */
    cursor?: IncidentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncidentLogs.
     */
    distinct?: IncidentLogScalarFieldEnum | IncidentLogScalarFieldEnum[]
  }

  /**
   * IncidentLog findMany
   */
  export type IncidentLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLog
     */
    select?: IncidentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLog
     */
    omit?: IncidentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogInclude<ExtArgs> | null
    /**
     * Filter, which IncidentLogs to fetch.
     */
    where?: IncidentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentLogs to fetch.
     */
    orderBy?: IncidentLogOrderByWithRelationInput | IncidentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IncidentLogs.
     */
    cursor?: IncidentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentLogs.
     */
    skip?: number
    distinct?: IncidentLogScalarFieldEnum | IncidentLogScalarFieldEnum[]
  }

  /**
   * IncidentLog create
   */
  export type IncidentLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLog
     */
    select?: IncidentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLog
     */
    omit?: IncidentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogInclude<ExtArgs> | null
    /**
     * The data needed to create a IncidentLog.
     */
    data: XOR<IncidentLogCreateInput, IncidentLogUncheckedCreateInput>
  }

  /**
   * IncidentLog createMany
   */
  export type IncidentLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IncidentLogs.
     */
    data: IncidentLogCreateManyInput | IncidentLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IncidentLog createManyAndReturn
   */
  export type IncidentLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLog
     */
    select?: IncidentLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLog
     */
    omit?: IncidentLogOmit<ExtArgs> | null
    /**
     * The data used to create many IncidentLogs.
     */
    data: IncidentLogCreateManyInput | IncidentLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IncidentLog update
   */
  export type IncidentLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLog
     */
    select?: IncidentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLog
     */
    omit?: IncidentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogInclude<ExtArgs> | null
    /**
     * The data needed to update a IncidentLog.
     */
    data: XOR<IncidentLogUpdateInput, IncidentLogUncheckedUpdateInput>
    /**
     * Choose, which IncidentLog to update.
     */
    where: IncidentLogWhereUniqueInput
  }

  /**
   * IncidentLog updateMany
   */
  export type IncidentLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IncidentLogs.
     */
    data: XOR<IncidentLogUpdateManyMutationInput, IncidentLogUncheckedUpdateManyInput>
    /**
     * Filter which IncidentLogs to update
     */
    where?: IncidentLogWhereInput
    /**
     * Limit how many IncidentLogs to update.
     */
    limit?: number
  }

  /**
   * IncidentLog updateManyAndReturn
   */
  export type IncidentLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLog
     */
    select?: IncidentLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLog
     */
    omit?: IncidentLogOmit<ExtArgs> | null
    /**
     * The data used to update IncidentLogs.
     */
    data: XOR<IncidentLogUpdateManyMutationInput, IncidentLogUncheckedUpdateManyInput>
    /**
     * Filter which IncidentLogs to update
     */
    where?: IncidentLogWhereInput
    /**
     * Limit how many IncidentLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IncidentLog upsert
   */
  export type IncidentLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLog
     */
    select?: IncidentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLog
     */
    omit?: IncidentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogInclude<ExtArgs> | null
    /**
     * The filter to search for the IncidentLog to update in case it exists.
     */
    where: IncidentLogWhereUniqueInput
    /**
     * In case the IncidentLog found by the `where` argument doesn't exist, create a new IncidentLog with this data.
     */
    create: XOR<IncidentLogCreateInput, IncidentLogUncheckedCreateInput>
    /**
     * In case the IncidentLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncidentLogUpdateInput, IncidentLogUncheckedUpdateInput>
  }

  /**
   * IncidentLog delete
   */
  export type IncidentLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLog
     */
    select?: IncidentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLog
     */
    omit?: IncidentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogInclude<ExtArgs> | null
    /**
     * Filter which IncidentLog to delete.
     */
    where: IncidentLogWhereUniqueInput
  }

  /**
   * IncidentLog deleteMany
   */
  export type IncidentLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncidentLogs to delete
     */
    where?: IncidentLogWhereInput
    /**
     * Limit how many IncidentLogs to delete.
     */
    limit?: number
  }

  /**
   * IncidentLog.equipmentUsed
   */
  export type IncidentLog$equipmentUsedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLogEquipment
     */
    select?: IncidentLogEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLogEquipment
     */
    omit?: IncidentLogEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogEquipmentInclude<ExtArgs> | null
    where?: IncidentLogEquipmentWhereInput
    orderBy?: IncidentLogEquipmentOrderByWithRelationInput | IncidentLogEquipmentOrderByWithRelationInput[]
    cursor?: IncidentLogEquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentLogEquipmentScalarFieldEnum | IncidentLogEquipmentScalarFieldEnum[]
  }

  /**
   * IncidentLog.lift
   */
  export type IncidentLog$liftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lift
     */
    select?: LiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lift
     */
    omit?: LiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftInclude<ExtArgs> | null
    where?: LiftWhereInput
  }

  /**
   * IncidentLog.trail
   */
  export type IncidentLog$trailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trail
     */
    select?: TrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trail
     */
    omit?: TrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailInclude<ExtArgs> | null
    where?: TrailWhereInput
  }

  /**
   * IncidentLog.lodge
   */
  export type IncidentLog$lodgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lodge
     */
    select?: LodgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lodge
     */
    omit?: LodgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LodgeInclude<ExtArgs> | null
    where?: LodgeWhereInput
  }

  /**
   * IncidentLog.hut
   */
  export type IncidentLog$hutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hut
     */
    select?: HutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hut
     */
    omit?: HutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutInclude<ExtArgs> | null
    where?: HutWhereInput
  }

  /**
   * IncidentLog.aidRoom
   */
  export type IncidentLog$aidRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoom
     */
    select?: AidRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoom
     */
    omit?: AidRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomInclude<ExtArgs> | null
    where?: AidRoomWhereInput
  }

  /**
   * IncidentLog without action
   */
  export type IncidentLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLog
     */
    select?: IncidentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLog
     */
    omit?: IncidentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogInclude<ExtArgs> | null
  }


  /**
   * Model IncidentLogEquipment
   */

  export type AggregateIncidentLogEquipment = {
    _count: IncidentLogEquipmentCountAggregateOutputType | null
    _min: IncidentLogEquipmentMinAggregateOutputType | null
    _max: IncidentLogEquipmentMaxAggregateOutputType | null
  }

  export type IncidentLogEquipmentMinAggregateOutputType = {
    id: string | null
    incidentLogId: string | null
    equipmentId: string | null
    mountainId: string | null
    usedAt: Date | null
    notes: string | null
  }

  export type IncidentLogEquipmentMaxAggregateOutputType = {
    id: string | null
    incidentLogId: string | null
    equipmentId: string | null
    mountainId: string | null
    usedAt: Date | null
    notes: string | null
  }

  export type IncidentLogEquipmentCountAggregateOutputType = {
    id: number
    incidentLogId: number
    equipmentId: number
    mountainId: number
    usedAt: number
    notes: number
    _all: number
  }


  export type IncidentLogEquipmentMinAggregateInputType = {
    id?: true
    incidentLogId?: true
    equipmentId?: true
    mountainId?: true
    usedAt?: true
    notes?: true
  }

  export type IncidentLogEquipmentMaxAggregateInputType = {
    id?: true
    incidentLogId?: true
    equipmentId?: true
    mountainId?: true
    usedAt?: true
    notes?: true
  }

  export type IncidentLogEquipmentCountAggregateInputType = {
    id?: true
    incidentLogId?: true
    equipmentId?: true
    mountainId?: true
    usedAt?: true
    notes?: true
    _all?: true
  }

  export type IncidentLogEquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncidentLogEquipment to aggregate.
     */
    where?: IncidentLogEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentLogEquipments to fetch.
     */
    orderBy?: IncidentLogEquipmentOrderByWithRelationInput | IncidentLogEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncidentLogEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentLogEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentLogEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IncidentLogEquipments
    **/
    _count?: true | IncidentLogEquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncidentLogEquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncidentLogEquipmentMaxAggregateInputType
  }

  export type GetIncidentLogEquipmentAggregateType<T extends IncidentLogEquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateIncidentLogEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncidentLogEquipment[P]>
      : GetScalarType<T[P], AggregateIncidentLogEquipment[P]>
  }




  export type IncidentLogEquipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentLogEquipmentWhereInput
    orderBy?: IncidentLogEquipmentOrderByWithAggregationInput | IncidentLogEquipmentOrderByWithAggregationInput[]
    by: IncidentLogEquipmentScalarFieldEnum[] | IncidentLogEquipmentScalarFieldEnum
    having?: IncidentLogEquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncidentLogEquipmentCountAggregateInputType | true
    _min?: IncidentLogEquipmentMinAggregateInputType
    _max?: IncidentLogEquipmentMaxAggregateInputType
  }

  export type IncidentLogEquipmentGroupByOutputType = {
    id: string
    incidentLogId: string
    equipmentId: string
    mountainId: string
    usedAt: Date
    notes: string | null
    _count: IncidentLogEquipmentCountAggregateOutputType | null
    _min: IncidentLogEquipmentMinAggregateOutputType | null
    _max: IncidentLogEquipmentMaxAggregateOutputType | null
  }

  type GetIncidentLogEquipmentGroupByPayload<T extends IncidentLogEquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncidentLogEquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncidentLogEquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncidentLogEquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], IncidentLogEquipmentGroupByOutputType[P]>
        }
      >
    >


  export type IncidentLogEquipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    incidentLogId?: boolean
    equipmentId?: boolean
    mountainId?: boolean
    usedAt?: boolean
    notes?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incidentLog?: boolean | IncidentLogDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incidentLogEquipment"]>

  export type IncidentLogEquipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    incidentLogId?: boolean
    equipmentId?: boolean
    mountainId?: boolean
    usedAt?: boolean
    notes?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incidentLog?: boolean | IncidentLogDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incidentLogEquipment"]>

  export type IncidentLogEquipmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    incidentLogId?: boolean
    equipmentId?: boolean
    mountainId?: boolean
    usedAt?: boolean
    notes?: boolean
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incidentLog?: boolean | IncidentLogDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incidentLogEquipment"]>

  export type IncidentLogEquipmentSelectScalar = {
    id?: boolean
    incidentLogId?: boolean
    equipmentId?: boolean
    mountainId?: boolean
    usedAt?: boolean
    notes?: boolean
  }

  export type IncidentLogEquipmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "incidentLogId" | "equipmentId" | "mountainId" | "usedAt" | "notes", ExtArgs["result"]["incidentLogEquipment"]>
  export type IncidentLogEquipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incidentLog?: boolean | IncidentLogDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }
  export type IncidentLogEquipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incidentLog?: boolean | IncidentLogDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }
  export type IncidentLogEquipmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    incidentLog?: boolean | IncidentLogDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }

  export type $IncidentLogEquipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IncidentLogEquipment"
    objects: {
      mountain: Prisma.$MountainPayload<ExtArgs>
      incidentLog: Prisma.$IncidentLogPayload<ExtArgs>
      equipment: Prisma.$EquipmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      incidentLogId: string
      equipmentId: string
      mountainId: string
      usedAt: Date
      notes: string | null
    }, ExtArgs["result"]["incidentLogEquipment"]>
    composites: {}
  }

  type IncidentLogEquipmentGetPayload<S extends boolean | null | undefined | IncidentLogEquipmentDefaultArgs> = $Result.GetResult<Prisma.$IncidentLogEquipmentPayload, S>

  type IncidentLogEquipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IncidentLogEquipmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IncidentLogEquipmentCountAggregateInputType | true
    }

  export interface IncidentLogEquipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IncidentLogEquipment'], meta: { name: 'IncidentLogEquipment' } }
    /**
     * Find zero or one IncidentLogEquipment that matches the filter.
     * @param {IncidentLogEquipmentFindUniqueArgs} args - Arguments to find a IncidentLogEquipment
     * @example
     * // Get one IncidentLogEquipment
     * const incidentLogEquipment = await prisma.incidentLogEquipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncidentLogEquipmentFindUniqueArgs>(args: SelectSubset<T, IncidentLogEquipmentFindUniqueArgs<ExtArgs>>): Prisma__IncidentLogEquipmentClient<$Result.GetResult<Prisma.$IncidentLogEquipmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IncidentLogEquipment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IncidentLogEquipmentFindUniqueOrThrowArgs} args - Arguments to find a IncidentLogEquipment
     * @example
     * // Get one IncidentLogEquipment
     * const incidentLogEquipment = await prisma.incidentLogEquipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncidentLogEquipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, IncidentLogEquipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncidentLogEquipmentClient<$Result.GetResult<Prisma.$IncidentLogEquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IncidentLogEquipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentLogEquipmentFindFirstArgs} args - Arguments to find a IncidentLogEquipment
     * @example
     * // Get one IncidentLogEquipment
     * const incidentLogEquipment = await prisma.incidentLogEquipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncidentLogEquipmentFindFirstArgs>(args?: SelectSubset<T, IncidentLogEquipmentFindFirstArgs<ExtArgs>>): Prisma__IncidentLogEquipmentClient<$Result.GetResult<Prisma.$IncidentLogEquipmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IncidentLogEquipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentLogEquipmentFindFirstOrThrowArgs} args - Arguments to find a IncidentLogEquipment
     * @example
     * // Get one IncidentLogEquipment
     * const incidentLogEquipment = await prisma.incidentLogEquipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncidentLogEquipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, IncidentLogEquipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncidentLogEquipmentClient<$Result.GetResult<Prisma.$IncidentLogEquipmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IncidentLogEquipments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentLogEquipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IncidentLogEquipments
     * const incidentLogEquipments = await prisma.incidentLogEquipment.findMany()
     * 
     * // Get first 10 IncidentLogEquipments
     * const incidentLogEquipments = await prisma.incidentLogEquipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incidentLogEquipmentWithIdOnly = await prisma.incidentLogEquipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncidentLogEquipmentFindManyArgs>(args?: SelectSubset<T, IncidentLogEquipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentLogEquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IncidentLogEquipment.
     * @param {IncidentLogEquipmentCreateArgs} args - Arguments to create a IncidentLogEquipment.
     * @example
     * // Create one IncidentLogEquipment
     * const IncidentLogEquipment = await prisma.incidentLogEquipment.create({
     *   data: {
     *     // ... data to create a IncidentLogEquipment
     *   }
     * })
     * 
     */
    create<T extends IncidentLogEquipmentCreateArgs>(args: SelectSubset<T, IncidentLogEquipmentCreateArgs<ExtArgs>>): Prisma__IncidentLogEquipmentClient<$Result.GetResult<Prisma.$IncidentLogEquipmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IncidentLogEquipments.
     * @param {IncidentLogEquipmentCreateManyArgs} args - Arguments to create many IncidentLogEquipments.
     * @example
     * // Create many IncidentLogEquipments
     * const incidentLogEquipment = await prisma.incidentLogEquipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncidentLogEquipmentCreateManyArgs>(args?: SelectSubset<T, IncidentLogEquipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IncidentLogEquipments and returns the data saved in the database.
     * @param {IncidentLogEquipmentCreateManyAndReturnArgs} args - Arguments to create many IncidentLogEquipments.
     * @example
     * // Create many IncidentLogEquipments
     * const incidentLogEquipment = await prisma.incidentLogEquipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IncidentLogEquipments and only return the `id`
     * const incidentLogEquipmentWithIdOnly = await prisma.incidentLogEquipment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncidentLogEquipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, IncidentLogEquipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentLogEquipmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IncidentLogEquipment.
     * @param {IncidentLogEquipmentDeleteArgs} args - Arguments to delete one IncidentLogEquipment.
     * @example
     * // Delete one IncidentLogEquipment
     * const IncidentLogEquipment = await prisma.incidentLogEquipment.delete({
     *   where: {
     *     // ... filter to delete one IncidentLogEquipment
     *   }
     * })
     * 
     */
    delete<T extends IncidentLogEquipmentDeleteArgs>(args: SelectSubset<T, IncidentLogEquipmentDeleteArgs<ExtArgs>>): Prisma__IncidentLogEquipmentClient<$Result.GetResult<Prisma.$IncidentLogEquipmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IncidentLogEquipment.
     * @param {IncidentLogEquipmentUpdateArgs} args - Arguments to update one IncidentLogEquipment.
     * @example
     * // Update one IncidentLogEquipment
     * const incidentLogEquipment = await prisma.incidentLogEquipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncidentLogEquipmentUpdateArgs>(args: SelectSubset<T, IncidentLogEquipmentUpdateArgs<ExtArgs>>): Prisma__IncidentLogEquipmentClient<$Result.GetResult<Prisma.$IncidentLogEquipmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IncidentLogEquipments.
     * @param {IncidentLogEquipmentDeleteManyArgs} args - Arguments to filter IncidentLogEquipments to delete.
     * @example
     * // Delete a few IncidentLogEquipments
     * const { count } = await prisma.incidentLogEquipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncidentLogEquipmentDeleteManyArgs>(args?: SelectSubset<T, IncidentLogEquipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncidentLogEquipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentLogEquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IncidentLogEquipments
     * const incidentLogEquipment = await prisma.incidentLogEquipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncidentLogEquipmentUpdateManyArgs>(args: SelectSubset<T, IncidentLogEquipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncidentLogEquipments and returns the data updated in the database.
     * @param {IncidentLogEquipmentUpdateManyAndReturnArgs} args - Arguments to update many IncidentLogEquipments.
     * @example
     * // Update many IncidentLogEquipments
     * const incidentLogEquipment = await prisma.incidentLogEquipment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IncidentLogEquipments and only return the `id`
     * const incidentLogEquipmentWithIdOnly = await prisma.incidentLogEquipment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IncidentLogEquipmentUpdateManyAndReturnArgs>(args: SelectSubset<T, IncidentLogEquipmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentLogEquipmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IncidentLogEquipment.
     * @param {IncidentLogEquipmentUpsertArgs} args - Arguments to update or create a IncidentLogEquipment.
     * @example
     * // Update or create a IncidentLogEquipment
     * const incidentLogEquipment = await prisma.incidentLogEquipment.upsert({
     *   create: {
     *     // ... data to create a IncidentLogEquipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IncidentLogEquipment we want to update
     *   }
     * })
     */
    upsert<T extends IncidentLogEquipmentUpsertArgs>(args: SelectSubset<T, IncidentLogEquipmentUpsertArgs<ExtArgs>>): Prisma__IncidentLogEquipmentClient<$Result.GetResult<Prisma.$IncidentLogEquipmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IncidentLogEquipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentLogEquipmentCountArgs} args - Arguments to filter IncidentLogEquipments to count.
     * @example
     * // Count the number of IncidentLogEquipments
     * const count = await prisma.incidentLogEquipment.count({
     *   where: {
     *     // ... the filter for the IncidentLogEquipments we want to count
     *   }
     * })
    **/
    count<T extends IncidentLogEquipmentCountArgs>(
      args?: Subset<T, IncidentLogEquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncidentLogEquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IncidentLogEquipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentLogEquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncidentLogEquipmentAggregateArgs>(args: Subset<T, IncidentLogEquipmentAggregateArgs>): Prisma.PrismaPromise<GetIncidentLogEquipmentAggregateType<T>>

    /**
     * Group by IncidentLogEquipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentLogEquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncidentLogEquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncidentLogEquipmentGroupByArgs['orderBy'] }
        : { orderBy?: IncidentLogEquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncidentLogEquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncidentLogEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IncidentLogEquipment model
   */
  readonly fields: IncidentLogEquipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IncidentLogEquipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncidentLogEquipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    incidentLog<T extends IncidentLogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IncidentLogDefaultArgs<ExtArgs>>): Prisma__IncidentLogClient<$Result.GetResult<Prisma.$IncidentLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    equipment<T extends EquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentDefaultArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IncidentLogEquipment model
   */
  interface IncidentLogEquipmentFieldRefs {
    readonly id: FieldRef<"IncidentLogEquipment", 'String'>
    readonly incidentLogId: FieldRef<"IncidentLogEquipment", 'String'>
    readonly equipmentId: FieldRef<"IncidentLogEquipment", 'String'>
    readonly mountainId: FieldRef<"IncidentLogEquipment", 'String'>
    readonly usedAt: FieldRef<"IncidentLogEquipment", 'DateTime'>
    readonly notes: FieldRef<"IncidentLogEquipment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * IncidentLogEquipment findUnique
   */
  export type IncidentLogEquipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLogEquipment
     */
    select?: IncidentLogEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLogEquipment
     */
    omit?: IncidentLogEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which IncidentLogEquipment to fetch.
     */
    where: IncidentLogEquipmentWhereUniqueInput
  }

  /**
   * IncidentLogEquipment findUniqueOrThrow
   */
  export type IncidentLogEquipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLogEquipment
     */
    select?: IncidentLogEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLogEquipment
     */
    omit?: IncidentLogEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which IncidentLogEquipment to fetch.
     */
    where: IncidentLogEquipmentWhereUniqueInput
  }

  /**
   * IncidentLogEquipment findFirst
   */
  export type IncidentLogEquipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLogEquipment
     */
    select?: IncidentLogEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLogEquipment
     */
    omit?: IncidentLogEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which IncidentLogEquipment to fetch.
     */
    where?: IncidentLogEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentLogEquipments to fetch.
     */
    orderBy?: IncidentLogEquipmentOrderByWithRelationInput | IncidentLogEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncidentLogEquipments.
     */
    cursor?: IncidentLogEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentLogEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentLogEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncidentLogEquipments.
     */
    distinct?: IncidentLogEquipmentScalarFieldEnum | IncidentLogEquipmentScalarFieldEnum[]
  }

  /**
   * IncidentLogEquipment findFirstOrThrow
   */
  export type IncidentLogEquipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLogEquipment
     */
    select?: IncidentLogEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLogEquipment
     */
    omit?: IncidentLogEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which IncidentLogEquipment to fetch.
     */
    where?: IncidentLogEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentLogEquipments to fetch.
     */
    orderBy?: IncidentLogEquipmentOrderByWithRelationInput | IncidentLogEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncidentLogEquipments.
     */
    cursor?: IncidentLogEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentLogEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentLogEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncidentLogEquipments.
     */
    distinct?: IncidentLogEquipmentScalarFieldEnum | IncidentLogEquipmentScalarFieldEnum[]
  }

  /**
   * IncidentLogEquipment findMany
   */
  export type IncidentLogEquipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLogEquipment
     */
    select?: IncidentLogEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLogEquipment
     */
    omit?: IncidentLogEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which IncidentLogEquipments to fetch.
     */
    where?: IncidentLogEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentLogEquipments to fetch.
     */
    orderBy?: IncidentLogEquipmentOrderByWithRelationInput | IncidentLogEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IncidentLogEquipments.
     */
    cursor?: IncidentLogEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentLogEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentLogEquipments.
     */
    skip?: number
    distinct?: IncidentLogEquipmentScalarFieldEnum | IncidentLogEquipmentScalarFieldEnum[]
  }

  /**
   * IncidentLogEquipment create
   */
  export type IncidentLogEquipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLogEquipment
     */
    select?: IncidentLogEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLogEquipment
     */
    omit?: IncidentLogEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogEquipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a IncidentLogEquipment.
     */
    data: XOR<IncidentLogEquipmentCreateInput, IncidentLogEquipmentUncheckedCreateInput>
  }

  /**
   * IncidentLogEquipment createMany
   */
  export type IncidentLogEquipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IncidentLogEquipments.
     */
    data: IncidentLogEquipmentCreateManyInput | IncidentLogEquipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IncidentLogEquipment createManyAndReturn
   */
  export type IncidentLogEquipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLogEquipment
     */
    select?: IncidentLogEquipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLogEquipment
     */
    omit?: IncidentLogEquipmentOmit<ExtArgs> | null
    /**
     * The data used to create many IncidentLogEquipments.
     */
    data: IncidentLogEquipmentCreateManyInput | IncidentLogEquipmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogEquipmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IncidentLogEquipment update
   */
  export type IncidentLogEquipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLogEquipment
     */
    select?: IncidentLogEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLogEquipment
     */
    omit?: IncidentLogEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogEquipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a IncidentLogEquipment.
     */
    data: XOR<IncidentLogEquipmentUpdateInput, IncidentLogEquipmentUncheckedUpdateInput>
    /**
     * Choose, which IncidentLogEquipment to update.
     */
    where: IncidentLogEquipmentWhereUniqueInput
  }

  /**
   * IncidentLogEquipment updateMany
   */
  export type IncidentLogEquipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IncidentLogEquipments.
     */
    data: XOR<IncidentLogEquipmentUpdateManyMutationInput, IncidentLogEquipmentUncheckedUpdateManyInput>
    /**
     * Filter which IncidentLogEquipments to update
     */
    where?: IncidentLogEquipmentWhereInput
    /**
     * Limit how many IncidentLogEquipments to update.
     */
    limit?: number
  }

  /**
   * IncidentLogEquipment updateManyAndReturn
   */
  export type IncidentLogEquipmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLogEquipment
     */
    select?: IncidentLogEquipmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLogEquipment
     */
    omit?: IncidentLogEquipmentOmit<ExtArgs> | null
    /**
     * The data used to update IncidentLogEquipments.
     */
    data: XOR<IncidentLogEquipmentUpdateManyMutationInput, IncidentLogEquipmentUncheckedUpdateManyInput>
    /**
     * Filter which IncidentLogEquipments to update
     */
    where?: IncidentLogEquipmentWhereInput
    /**
     * Limit how many IncidentLogEquipments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogEquipmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IncidentLogEquipment upsert
   */
  export type IncidentLogEquipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLogEquipment
     */
    select?: IncidentLogEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLogEquipment
     */
    omit?: IncidentLogEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogEquipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the IncidentLogEquipment to update in case it exists.
     */
    where: IncidentLogEquipmentWhereUniqueInput
    /**
     * In case the IncidentLogEquipment found by the `where` argument doesn't exist, create a new IncidentLogEquipment with this data.
     */
    create: XOR<IncidentLogEquipmentCreateInput, IncidentLogEquipmentUncheckedCreateInput>
    /**
     * In case the IncidentLogEquipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncidentLogEquipmentUpdateInput, IncidentLogEquipmentUncheckedUpdateInput>
  }

  /**
   * IncidentLogEquipment delete
   */
  export type IncidentLogEquipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLogEquipment
     */
    select?: IncidentLogEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLogEquipment
     */
    omit?: IncidentLogEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogEquipmentInclude<ExtArgs> | null
    /**
     * Filter which IncidentLogEquipment to delete.
     */
    where: IncidentLogEquipmentWhereUniqueInput
  }

  /**
   * IncidentLogEquipment deleteMany
   */
  export type IncidentLogEquipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncidentLogEquipments to delete
     */
    where?: IncidentLogEquipmentWhereInput
    /**
     * Limit how many IncidentLogEquipments to delete.
     */
    limit?: number
  }

  /**
   * IncidentLogEquipment without action
   */
  export type IncidentLogEquipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentLogEquipment
     */
    select?: IncidentLogEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncidentLogEquipment
     */
    omit?: IncidentLogEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentLogEquipmentInclude<ExtArgs> | null
  }


  /**
   * Model LiftCheck
   */

  export type AggregateLiftCheck = {
    _count: LiftCheckCountAggregateOutputType | null
    _min: LiftCheckMinAggregateOutputType | null
    _max: LiftCheckMaxAggregateOutputType | null
  }

  export type LiftCheckMinAggregateOutputType = {
    id: string | null
    date: Date | null
    employeeId: string | null
    mountainId: string | null
    liftId: string | null
    notes: string | null
  }

  export type LiftCheckMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    employeeId: string | null
    mountainId: string | null
    liftId: string | null
    notes: string | null
  }

  export type LiftCheckCountAggregateOutputType = {
    id: number
    date: number
    employeeId: number
    mountainId: number
    liftId: number
    notes: number
    _all: number
  }


  export type LiftCheckMinAggregateInputType = {
    id?: true
    date?: true
    employeeId?: true
    mountainId?: true
    liftId?: true
    notes?: true
  }

  export type LiftCheckMaxAggregateInputType = {
    id?: true
    date?: true
    employeeId?: true
    mountainId?: true
    liftId?: true
    notes?: true
  }

  export type LiftCheckCountAggregateInputType = {
    id?: true
    date?: true
    employeeId?: true
    mountainId?: true
    liftId?: true
    notes?: true
    _all?: true
  }

  export type LiftCheckAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiftCheck to aggregate.
     */
    where?: LiftCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiftChecks to fetch.
     */
    orderBy?: LiftCheckOrderByWithRelationInput | LiftCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LiftCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiftChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiftChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LiftChecks
    **/
    _count?: true | LiftCheckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiftCheckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiftCheckMaxAggregateInputType
  }

  export type GetLiftCheckAggregateType<T extends LiftCheckAggregateArgs> = {
        [P in keyof T & keyof AggregateLiftCheck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiftCheck[P]>
      : GetScalarType<T[P], AggregateLiftCheck[P]>
  }




  export type LiftCheckGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiftCheckWhereInput
    orderBy?: LiftCheckOrderByWithAggregationInput | LiftCheckOrderByWithAggregationInput[]
    by: LiftCheckScalarFieldEnum[] | LiftCheckScalarFieldEnum
    having?: LiftCheckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiftCheckCountAggregateInputType | true
    _min?: LiftCheckMinAggregateInputType
    _max?: LiftCheckMaxAggregateInputType
  }

  export type LiftCheckGroupByOutputType = {
    id: string
    date: Date
    employeeId: string
    mountainId: string
    liftId: string
    notes: string | null
    _count: LiftCheckCountAggregateOutputType | null
    _min: LiftCheckMinAggregateOutputType | null
    _max: LiftCheckMaxAggregateOutputType | null
  }

  type GetLiftCheckGroupByPayload<T extends LiftCheckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LiftCheckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LiftCheckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LiftCheckGroupByOutputType[P]>
            : GetScalarType<T[P], LiftCheckGroupByOutputType[P]>
        }
      >
    >


  export type LiftCheckSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    employeeId?: boolean
    mountainId?: boolean
    liftId?: boolean
    notes?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    lift?: boolean | LiftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liftCheck"]>

  export type LiftCheckSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    employeeId?: boolean
    mountainId?: boolean
    liftId?: boolean
    notes?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    lift?: boolean | LiftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liftCheck"]>

  export type LiftCheckSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    employeeId?: boolean
    mountainId?: boolean
    liftId?: boolean
    notes?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    lift?: boolean | LiftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liftCheck"]>

  export type LiftCheckSelectScalar = {
    id?: boolean
    date?: boolean
    employeeId?: boolean
    mountainId?: boolean
    liftId?: boolean
    notes?: boolean
  }

  export type LiftCheckOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "employeeId" | "mountainId" | "liftId" | "notes", ExtArgs["result"]["liftCheck"]>
  export type LiftCheckInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    lift?: boolean | LiftDefaultArgs<ExtArgs>
  }
  export type LiftCheckIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    lift?: boolean | LiftDefaultArgs<ExtArgs>
  }
  export type LiftCheckIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    lift?: boolean | LiftDefaultArgs<ExtArgs>
  }

  export type $LiftCheckPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LiftCheck"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      mountain: Prisma.$MountainPayload<ExtArgs>
      lift: Prisma.$LiftPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      employeeId: string
      mountainId: string
      liftId: string
      notes: string | null
    }, ExtArgs["result"]["liftCheck"]>
    composites: {}
  }

  type LiftCheckGetPayload<S extends boolean | null | undefined | LiftCheckDefaultArgs> = $Result.GetResult<Prisma.$LiftCheckPayload, S>

  type LiftCheckCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LiftCheckFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LiftCheckCountAggregateInputType | true
    }

  export interface LiftCheckDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LiftCheck'], meta: { name: 'LiftCheck' } }
    /**
     * Find zero or one LiftCheck that matches the filter.
     * @param {LiftCheckFindUniqueArgs} args - Arguments to find a LiftCheck
     * @example
     * // Get one LiftCheck
     * const liftCheck = await prisma.liftCheck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LiftCheckFindUniqueArgs>(args: SelectSubset<T, LiftCheckFindUniqueArgs<ExtArgs>>): Prisma__LiftCheckClient<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LiftCheck that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LiftCheckFindUniqueOrThrowArgs} args - Arguments to find a LiftCheck
     * @example
     * // Get one LiftCheck
     * const liftCheck = await prisma.liftCheck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LiftCheckFindUniqueOrThrowArgs>(args: SelectSubset<T, LiftCheckFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LiftCheckClient<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LiftCheck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftCheckFindFirstArgs} args - Arguments to find a LiftCheck
     * @example
     * // Get one LiftCheck
     * const liftCheck = await prisma.liftCheck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LiftCheckFindFirstArgs>(args?: SelectSubset<T, LiftCheckFindFirstArgs<ExtArgs>>): Prisma__LiftCheckClient<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LiftCheck that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftCheckFindFirstOrThrowArgs} args - Arguments to find a LiftCheck
     * @example
     * // Get one LiftCheck
     * const liftCheck = await prisma.liftCheck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LiftCheckFindFirstOrThrowArgs>(args?: SelectSubset<T, LiftCheckFindFirstOrThrowArgs<ExtArgs>>): Prisma__LiftCheckClient<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LiftChecks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftCheckFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LiftChecks
     * const liftChecks = await prisma.liftCheck.findMany()
     * 
     * // Get first 10 LiftChecks
     * const liftChecks = await prisma.liftCheck.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const liftCheckWithIdOnly = await prisma.liftCheck.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LiftCheckFindManyArgs>(args?: SelectSubset<T, LiftCheckFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LiftCheck.
     * @param {LiftCheckCreateArgs} args - Arguments to create a LiftCheck.
     * @example
     * // Create one LiftCheck
     * const LiftCheck = await prisma.liftCheck.create({
     *   data: {
     *     // ... data to create a LiftCheck
     *   }
     * })
     * 
     */
    create<T extends LiftCheckCreateArgs>(args: SelectSubset<T, LiftCheckCreateArgs<ExtArgs>>): Prisma__LiftCheckClient<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LiftChecks.
     * @param {LiftCheckCreateManyArgs} args - Arguments to create many LiftChecks.
     * @example
     * // Create many LiftChecks
     * const liftCheck = await prisma.liftCheck.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LiftCheckCreateManyArgs>(args?: SelectSubset<T, LiftCheckCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LiftChecks and returns the data saved in the database.
     * @param {LiftCheckCreateManyAndReturnArgs} args - Arguments to create many LiftChecks.
     * @example
     * // Create many LiftChecks
     * const liftCheck = await prisma.liftCheck.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LiftChecks and only return the `id`
     * const liftCheckWithIdOnly = await prisma.liftCheck.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LiftCheckCreateManyAndReturnArgs>(args?: SelectSubset<T, LiftCheckCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LiftCheck.
     * @param {LiftCheckDeleteArgs} args - Arguments to delete one LiftCheck.
     * @example
     * // Delete one LiftCheck
     * const LiftCheck = await prisma.liftCheck.delete({
     *   where: {
     *     // ... filter to delete one LiftCheck
     *   }
     * })
     * 
     */
    delete<T extends LiftCheckDeleteArgs>(args: SelectSubset<T, LiftCheckDeleteArgs<ExtArgs>>): Prisma__LiftCheckClient<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LiftCheck.
     * @param {LiftCheckUpdateArgs} args - Arguments to update one LiftCheck.
     * @example
     * // Update one LiftCheck
     * const liftCheck = await prisma.liftCheck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LiftCheckUpdateArgs>(args: SelectSubset<T, LiftCheckUpdateArgs<ExtArgs>>): Prisma__LiftCheckClient<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LiftChecks.
     * @param {LiftCheckDeleteManyArgs} args - Arguments to filter LiftChecks to delete.
     * @example
     * // Delete a few LiftChecks
     * const { count } = await prisma.liftCheck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LiftCheckDeleteManyArgs>(args?: SelectSubset<T, LiftCheckDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiftChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftCheckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LiftChecks
     * const liftCheck = await prisma.liftCheck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LiftCheckUpdateManyArgs>(args: SelectSubset<T, LiftCheckUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiftChecks and returns the data updated in the database.
     * @param {LiftCheckUpdateManyAndReturnArgs} args - Arguments to update many LiftChecks.
     * @example
     * // Update many LiftChecks
     * const liftCheck = await prisma.liftCheck.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LiftChecks and only return the `id`
     * const liftCheckWithIdOnly = await prisma.liftCheck.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LiftCheckUpdateManyAndReturnArgs>(args: SelectSubset<T, LiftCheckUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LiftCheck.
     * @param {LiftCheckUpsertArgs} args - Arguments to update or create a LiftCheck.
     * @example
     * // Update or create a LiftCheck
     * const liftCheck = await prisma.liftCheck.upsert({
     *   create: {
     *     // ... data to create a LiftCheck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LiftCheck we want to update
     *   }
     * })
     */
    upsert<T extends LiftCheckUpsertArgs>(args: SelectSubset<T, LiftCheckUpsertArgs<ExtArgs>>): Prisma__LiftCheckClient<$Result.GetResult<Prisma.$LiftCheckPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LiftChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftCheckCountArgs} args - Arguments to filter LiftChecks to count.
     * @example
     * // Count the number of LiftChecks
     * const count = await prisma.liftCheck.count({
     *   where: {
     *     // ... the filter for the LiftChecks we want to count
     *   }
     * })
    **/
    count<T extends LiftCheckCountArgs>(
      args?: Subset<T, LiftCheckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiftCheckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LiftCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftCheckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiftCheckAggregateArgs>(args: Subset<T, LiftCheckAggregateArgs>): Prisma.PrismaPromise<GetLiftCheckAggregateType<T>>

    /**
     * Group by LiftCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiftCheckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiftCheckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiftCheckGroupByArgs['orderBy'] }
        : { orderBy?: LiftCheckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiftCheckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiftCheckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LiftCheck model
   */
  readonly fields: LiftCheckFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LiftCheck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LiftCheckClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lift<T extends LiftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LiftDefaultArgs<ExtArgs>>): Prisma__LiftClient<$Result.GetResult<Prisma.$LiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LiftCheck model
   */
  interface LiftCheckFieldRefs {
    readonly id: FieldRef<"LiftCheck", 'String'>
    readonly date: FieldRef<"LiftCheck", 'DateTime'>
    readonly employeeId: FieldRef<"LiftCheck", 'String'>
    readonly mountainId: FieldRef<"LiftCheck", 'String'>
    readonly liftId: FieldRef<"LiftCheck", 'String'>
    readonly notes: FieldRef<"LiftCheck", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LiftCheck findUnique
   */
  export type LiftCheckFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    /**
     * Filter, which LiftCheck to fetch.
     */
    where: LiftCheckWhereUniqueInput
  }

  /**
   * LiftCheck findUniqueOrThrow
   */
  export type LiftCheckFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    /**
     * Filter, which LiftCheck to fetch.
     */
    where: LiftCheckWhereUniqueInput
  }

  /**
   * LiftCheck findFirst
   */
  export type LiftCheckFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    /**
     * Filter, which LiftCheck to fetch.
     */
    where?: LiftCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiftChecks to fetch.
     */
    orderBy?: LiftCheckOrderByWithRelationInput | LiftCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiftChecks.
     */
    cursor?: LiftCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiftChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiftChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiftChecks.
     */
    distinct?: LiftCheckScalarFieldEnum | LiftCheckScalarFieldEnum[]
  }

  /**
   * LiftCheck findFirstOrThrow
   */
  export type LiftCheckFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    /**
     * Filter, which LiftCheck to fetch.
     */
    where?: LiftCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiftChecks to fetch.
     */
    orderBy?: LiftCheckOrderByWithRelationInput | LiftCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiftChecks.
     */
    cursor?: LiftCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiftChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiftChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiftChecks.
     */
    distinct?: LiftCheckScalarFieldEnum | LiftCheckScalarFieldEnum[]
  }

  /**
   * LiftCheck findMany
   */
  export type LiftCheckFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    /**
     * Filter, which LiftChecks to fetch.
     */
    where?: LiftCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiftChecks to fetch.
     */
    orderBy?: LiftCheckOrderByWithRelationInput | LiftCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LiftChecks.
     */
    cursor?: LiftCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiftChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiftChecks.
     */
    skip?: number
    distinct?: LiftCheckScalarFieldEnum | LiftCheckScalarFieldEnum[]
  }

  /**
   * LiftCheck create
   */
  export type LiftCheckCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    /**
     * The data needed to create a LiftCheck.
     */
    data: XOR<LiftCheckCreateInput, LiftCheckUncheckedCreateInput>
  }

  /**
   * LiftCheck createMany
   */
  export type LiftCheckCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LiftChecks.
     */
    data: LiftCheckCreateManyInput | LiftCheckCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LiftCheck createManyAndReturn
   */
  export type LiftCheckCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * The data used to create many LiftChecks.
     */
    data: LiftCheckCreateManyInput | LiftCheckCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiftCheck update
   */
  export type LiftCheckUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    /**
     * The data needed to update a LiftCheck.
     */
    data: XOR<LiftCheckUpdateInput, LiftCheckUncheckedUpdateInput>
    /**
     * Choose, which LiftCheck to update.
     */
    where: LiftCheckWhereUniqueInput
  }

  /**
   * LiftCheck updateMany
   */
  export type LiftCheckUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LiftChecks.
     */
    data: XOR<LiftCheckUpdateManyMutationInput, LiftCheckUncheckedUpdateManyInput>
    /**
     * Filter which LiftChecks to update
     */
    where?: LiftCheckWhereInput
    /**
     * Limit how many LiftChecks to update.
     */
    limit?: number
  }

  /**
   * LiftCheck updateManyAndReturn
   */
  export type LiftCheckUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * The data used to update LiftChecks.
     */
    data: XOR<LiftCheckUpdateManyMutationInput, LiftCheckUncheckedUpdateManyInput>
    /**
     * Filter which LiftChecks to update
     */
    where?: LiftCheckWhereInput
    /**
     * Limit how many LiftChecks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiftCheck upsert
   */
  export type LiftCheckUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    /**
     * The filter to search for the LiftCheck to update in case it exists.
     */
    where: LiftCheckWhereUniqueInput
    /**
     * In case the LiftCheck found by the `where` argument doesn't exist, create a new LiftCheck with this data.
     */
    create: XOR<LiftCheckCreateInput, LiftCheckUncheckedCreateInput>
    /**
     * In case the LiftCheck was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LiftCheckUpdateInput, LiftCheckUncheckedUpdateInput>
  }

  /**
   * LiftCheck delete
   */
  export type LiftCheckDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
    /**
     * Filter which LiftCheck to delete.
     */
    where: LiftCheckWhereUniqueInput
  }

  /**
   * LiftCheck deleteMany
   */
  export type LiftCheckDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiftChecks to delete
     */
    where?: LiftCheckWhereInput
    /**
     * Limit how many LiftChecks to delete.
     */
    limit?: number
  }

  /**
   * LiftCheck without action
   */
  export type LiftCheckDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiftCheck
     */
    select?: LiftCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiftCheck
     */
    omit?: LiftCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiftCheckInclude<ExtArgs> | null
  }


  /**
   * Model TrailCheck
   */

  export type AggregateTrailCheck = {
    _count: TrailCheckCountAggregateOutputType | null
    _min: TrailCheckMinAggregateOutputType | null
    _max: TrailCheckMaxAggregateOutputType | null
  }

  export type TrailCheckMinAggregateOutputType = {
    id: string | null
    date: Date | null
    employeeId: string | null
    mountainId: string | null
    trailId: string | null
    notes: string | null
  }

  export type TrailCheckMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    employeeId: string | null
    mountainId: string | null
    trailId: string | null
    notes: string | null
  }

  export type TrailCheckCountAggregateOutputType = {
    id: number
    date: number
    employeeId: number
    mountainId: number
    trailId: number
    notes: number
    _all: number
  }


  export type TrailCheckMinAggregateInputType = {
    id?: true
    date?: true
    employeeId?: true
    mountainId?: true
    trailId?: true
    notes?: true
  }

  export type TrailCheckMaxAggregateInputType = {
    id?: true
    date?: true
    employeeId?: true
    mountainId?: true
    trailId?: true
    notes?: true
  }

  export type TrailCheckCountAggregateInputType = {
    id?: true
    date?: true
    employeeId?: true
    mountainId?: true
    trailId?: true
    notes?: true
    _all?: true
  }

  export type TrailCheckAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrailCheck to aggregate.
     */
    where?: TrailCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrailChecks to fetch.
     */
    orderBy?: TrailCheckOrderByWithRelationInput | TrailCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrailCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrailChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrailChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrailChecks
    **/
    _count?: true | TrailCheckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrailCheckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrailCheckMaxAggregateInputType
  }

  export type GetTrailCheckAggregateType<T extends TrailCheckAggregateArgs> = {
        [P in keyof T & keyof AggregateTrailCheck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrailCheck[P]>
      : GetScalarType<T[P], AggregateTrailCheck[P]>
  }




  export type TrailCheckGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrailCheckWhereInput
    orderBy?: TrailCheckOrderByWithAggregationInput | TrailCheckOrderByWithAggregationInput[]
    by: TrailCheckScalarFieldEnum[] | TrailCheckScalarFieldEnum
    having?: TrailCheckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrailCheckCountAggregateInputType | true
    _min?: TrailCheckMinAggregateInputType
    _max?: TrailCheckMaxAggregateInputType
  }

  export type TrailCheckGroupByOutputType = {
    id: string
    date: Date
    employeeId: string
    mountainId: string
    trailId: string
    notes: string | null
    _count: TrailCheckCountAggregateOutputType | null
    _min: TrailCheckMinAggregateOutputType | null
    _max: TrailCheckMaxAggregateOutputType | null
  }

  type GetTrailCheckGroupByPayload<T extends TrailCheckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrailCheckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrailCheckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrailCheckGroupByOutputType[P]>
            : GetScalarType<T[P], TrailCheckGroupByOutputType[P]>
        }
      >
    >


  export type TrailCheckSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    employeeId?: boolean
    mountainId?: boolean
    trailId?: boolean
    notes?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    trail?: boolean | TrailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trailCheck"]>

  export type TrailCheckSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    employeeId?: boolean
    mountainId?: boolean
    trailId?: boolean
    notes?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    trail?: boolean | TrailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trailCheck"]>

  export type TrailCheckSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    employeeId?: boolean
    mountainId?: boolean
    trailId?: boolean
    notes?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    trail?: boolean | TrailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trailCheck"]>

  export type TrailCheckSelectScalar = {
    id?: boolean
    date?: boolean
    employeeId?: boolean
    mountainId?: boolean
    trailId?: boolean
    notes?: boolean
  }

  export type TrailCheckOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "employeeId" | "mountainId" | "trailId" | "notes", ExtArgs["result"]["trailCheck"]>
  export type TrailCheckInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    trail?: boolean | TrailDefaultArgs<ExtArgs>
  }
  export type TrailCheckIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    trail?: boolean | TrailDefaultArgs<ExtArgs>
  }
  export type TrailCheckIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    trail?: boolean | TrailDefaultArgs<ExtArgs>
  }

  export type $TrailCheckPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrailCheck"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      mountain: Prisma.$MountainPayload<ExtArgs>
      trail: Prisma.$TrailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      employeeId: string
      mountainId: string
      trailId: string
      notes: string | null
    }, ExtArgs["result"]["trailCheck"]>
    composites: {}
  }

  type TrailCheckGetPayload<S extends boolean | null | undefined | TrailCheckDefaultArgs> = $Result.GetResult<Prisma.$TrailCheckPayload, S>

  type TrailCheckCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrailCheckFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrailCheckCountAggregateInputType | true
    }

  export interface TrailCheckDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrailCheck'], meta: { name: 'TrailCheck' } }
    /**
     * Find zero or one TrailCheck that matches the filter.
     * @param {TrailCheckFindUniqueArgs} args - Arguments to find a TrailCheck
     * @example
     * // Get one TrailCheck
     * const trailCheck = await prisma.trailCheck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrailCheckFindUniqueArgs>(args: SelectSubset<T, TrailCheckFindUniqueArgs<ExtArgs>>): Prisma__TrailCheckClient<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrailCheck that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrailCheckFindUniqueOrThrowArgs} args - Arguments to find a TrailCheck
     * @example
     * // Get one TrailCheck
     * const trailCheck = await prisma.trailCheck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrailCheckFindUniqueOrThrowArgs>(args: SelectSubset<T, TrailCheckFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrailCheckClient<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrailCheck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailCheckFindFirstArgs} args - Arguments to find a TrailCheck
     * @example
     * // Get one TrailCheck
     * const trailCheck = await prisma.trailCheck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrailCheckFindFirstArgs>(args?: SelectSubset<T, TrailCheckFindFirstArgs<ExtArgs>>): Prisma__TrailCheckClient<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrailCheck that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailCheckFindFirstOrThrowArgs} args - Arguments to find a TrailCheck
     * @example
     * // Get one TrailCheck
     * const trailCheck = await prisma.trailCheck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrailCheckFindFirstOrThrowArgs>(args?: SelectSubset<T, TrailCheckFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrailCheckClient<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrailChecks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailCheckFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrailChecks
     * const trailChecks = await prisma.trailCheck.findMany()
     * 
     * // Get first 10 TrailChecks
     * const trailChecks = await prisma.trailCheck.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trailCheckWithIdOnly = await prisma.trailCheck.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrailCheckFindManyArgs>(args?: SelectSubset<T, TrailCheckFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrailCheck.
     * @param {TrailCheckCreateArgs} args - Arguments to create a TrailCheck.
     * @example
     * // Create one TrailCheck
     * const TrailCheck = await prisma.trailCheck.create({
     *   data: {
     *     // ... data to create a TrailCheck
     *   }
     * })
     * 
     */
    create<T extends TrailCheckCreateArgs>(args: SelectSubset<T, TrailCheckCreateArgs<ExtArgs>>): Prisma__TrailCheckClient<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrailChecks.
     * @param {TrailCheckCreateManyArgs} args - Arguments to create many TrailChecks.
     * @example
     * // Create many TrailChecks
     * const trailCheck = await prisma.trailCheck.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrailCheckCreateManyArgs>(args?: SelectSubset<T, TrailCheckCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrailChecks and returns the data saved in the database.
     * @param {TrailCheckCreateManyAndReturnArgs} args - Arguments to create many TrailChecks.
     * @example
     * // Create many TrailChecks
     * const trailCheck = await prisma.trailCheck.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrailChecks and only return the `id`
     * const trailCheckWithIdOnly = await prisma.trailCheck.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrailCheckCreateManyAndReturnArgs>(args?: SelectSubset<T, TrailCheckCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrailCheck.
     * @param {TrailCheckDeleteArgs} args - Arguments to delete one TrailCheck.
     * @example
     * // Delete one TrailCheck
     * const TrailCheck = await prisma.trailCheck.delete({
     *   where: {
     *     // ... filter to delete one TrailCheck
     *   }
     * })
     * 
     */
    delete<T extends TrailCheckDeleteArgs>(args: SelectSubset<T, TrailCheckDeleteArgs<ExtArgs>>): Prisma__TrailCheckClient<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrailCheck.
     * @param {TrailCheckUpdateArgs} args - Arguments to update one TrailCheck.
     * @example
     * // Update one TrailCheck
     * const trailCheck = await prisma.trailCheck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrailCheckUpdateArgs>(args: SelectSubset<T, TrailCheckUpdateArgs<ExtArgs>>): Prisma__TrailCheckClient<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrailChecks.
     * @param {TrailCheckDeleteManyArgs} args - Arguments to filter TrailChecks to delete.
     * @example
     * // Delete a few TrailChecks
     * const { count } = await prisma.trailCheck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrailCheckDeleteManyArgs>(args?: SelectSubset<T, TrailCheckDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrailChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailCheckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrailChecks
     * const trailCheck = await prisma.trailCheck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrailCheckUpdateManyArgs>(args: SelectSubset<T, TrailCheckUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrailChecks and returns the data updated in the database.
     * @param {TrailCheckUpdateManyAndReturnArgs} args - Arguments to update many TrailChecks.
     * @example
     * // Update many TrailChecks
     * const trailCheck = await prisma.trailCheck.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrailChecks and only return the `id`
     * const trailCheckWithIdOnly = await prisma.trailCheck.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrailCheckUpdateManyAndReturnArgs>(args: SelectSubset<T, TrailCheckUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrailCheck.
     * @param {TrailCheckUpsertArgs} args - Arguments to update or create a TrailCheck.
     * @example
     * // Update or create a TrailCheck
     * const trailCheck = await prisma.trailCheck.upsert({
     *   create: {
     *     // ... data to create a TrailCheck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrailCheck we want to update
     *   }
     * })
     */
    upsert<T extends TrailCheckUpsertArgs>(args: SelectSubset<T, TrailCheckUpsertArgs<ExtArgs>>): Prisma__TrailCheckClient<$Result.GetResult<Prisma.$TrailCheckPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrailChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailCheckCountArgs} args - Arguments to filter TrailChecks to count.
     * @example
     * // Count the number of TrailChecks
     * const count = await prisma.trailCheck.count({
     *   where: {
     *     // ... the filter for the TrailChecks we want to count
     *   }
     * })
    **/
    count<T extends TrailCheckCountArgs>(
      args?: Subset<T, TrailCheckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrailCheckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrailCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailCheckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrailCheckAggregateArgs>(args: Subset<T, TrailCheckAggregateArgs>): Prisma.PrismaPromise<GetTrailCheckAggregateType<T>>

    /**
     * Group by TrailCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrailCheckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrailCheckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrailCheckGroupByArgs['orderBy'] }
        : { orderBy?: TrailCheckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrailCheckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrailCheckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrailCheck model
   */
  readonly fields: TrailCheckFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrailCheck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrailCheckClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    trail<T extends TrailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrailDefaultArgs<ExtArgs>>): Prisma__TrailClient<$Result.GetResult<Prisma.$TrailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrailCheck model
   */
  interface TrailCheckFieldRefs {
    readonly id: FieldRef<"TrailCheck", 'String'>
    readonly date: FieldRef<"TrailCheck", 'DateTime'>
    readonly employeeId: FieldRef<"TrailCheck", 'String'>
    readonly mountainId: FieldRef<"TrailCheck", 'String'>
    readonly trailId: FieldRef<"TrailCheck", 'String'>
    readonly notes: FieldRef<"TrailCheck", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TrailCheck findUnique
   */
  export type TrailCheckFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    /**
     * Filter, which TrailCheck to fetch.
     */
    where: TrailCheckWhereUniqueInput
  }

  /**
   * TrailCheck findUniqueOrThrow
   */
  export type TrailCheckFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    /**
     * Filter, which TrailCheck to fetch.
     */
    where: TrailCheckWhereUniqueInput
  }

  /**
   * TrailCheck findFirst
   */
  export type TrailCheckFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    /**
     * Filter, which TrailCheck to fetch.
     */
    where?: TrailCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrailChecks to fetch.
     */
    orderBy?: TrailCheckOrderByWithRelationInput | TrailCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrailChecks.
     */
    cursor?: TrailCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrailChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrailChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrailChecks.
     */
    distinct?: TrailCheckScalarFieldEnum | TrailCheckScalarFieldEnum[]
  }

  /**
   * TrailCheck findFirstOrThrow
   */
  export type TrailCheckFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    /**
     * Filter, which TrailCheck to fetch.
     */
    where?: TrailCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrailChecks to fetch.
     */
    orderBy?: TrailCheckOrderByWithRelationInput | TrailCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrailChecks.
     */
    cursor?: TrailCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrailChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrailChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrailChecks.
     */
    distinct?: TrailCheckScalarFieldEnum | TrailCheckScalarFieldEnum[]
  }

  /**
   * TrailCheck findMany
   */
  export type TrailCheckFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    /**
     * Filter, which TrailChecks to fetch.
     */
    where?: TrailCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrailChecks to fetch.
     */
    orderBy?: TrailCheckOrderByWithRelationInput | TrailCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrailChecks.
     */
    cursor?: TrailCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrailChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrailChecks.
     */
    skip?: number
    distinct?: TrailCheckScalarFieldEnum | TrailCheckScalarFieldEnum[]
  }

  /**
   * TrailCheck create
   */
  export type TrailCheckCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    /**
     * The data needed to create a TrailCheck.
     */
    data: XOR<TrailCheckCreateInput, TrailCheckUncheckedCreateInput>
  }

  /**
   * TrailCheck createMany
   */
  export type TrailCheckCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrailChecks.
     */
    data: TrailCheckCreateManyInput | TrailCheckCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrailCheck createManyAndReturn
   */
  export type TrailCheckCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * The data used to create many TrailChecks.
     */
    data: TrailCheckCreateManyInput | TrailCheckCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrailCheck update
   */
  export type TrailCheckUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    /**
     * The data needed to update a TrailCheck.
     */
    data: XOR<TrailCheckUpdateInput, TrailCheckUncheckedUpdateInput>
    /**
     * Choose, which TrailCheck to update.
     */
    where: TrailCheckWhereUniqueInput
  }

  /**
   * TrailCheck updateMany
   */
  export type TrailCheckUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrailChecks.
     */
    data: XOR<TrailCheckUpdateManyMutationInput, TrailCheckUncheckedUpdateManyInput>
    /**
     * Filter which TrailChecks to update
     */
    where?: TrailCheckWhereInput
    /**
     * Limit how many TrailChecks to update.
     */
    limit?: number
  }

  /**
   * TrailCheck updateManyAndReturn
   */
  export type TrailCheckUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * The data used to update TrailChecks.
     */
    data: XOR<TrailCheckUpdateManyMutationInput, TrailCheckUncheckedUpdateManyInput>
    /**
     * Filter which TrailChecks to update
     */
    where?: TrailCheckWhereInput
    /**
     * Limit how many TrailChecks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrailCheck upsert
   */
  export type TrailCheckUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    /**
     * The filter to search for the TrailCheck to update in case it exists.
     */
    where: TrailCheckWhereUniqueInput
    /**
     * In case the TrailCheck found by the `where` argument doesn't exist, create a new TrailCheck with this data.
     */
    create: XOR<TrailCheckCreateInput, TrailCheckUncheckedCreateInput>
    /**
     * In case the TrailCheck was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrailCheckUpdateInput, TrailCheckUncheckedUpdateInput>
  }

  /**
   * TrailCheck delete
   */
  export type TrailCheckDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
    /**
     * Filter which TrailCheck to delete.
     */
    where: TrailCheckWhereUniqueInput
  }

  /**
   * TrailCheck deleteMany
   */
  export type TrailCheckDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrailChecks to delete
     */
    where?: TrailCheckWhereInput
    /**
     * Limit how many TrailChecks to delete.
     */
    limit?: number
  }

  /**
   * TrailCheck without action
   */
  export type TrailCheckDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrailCheck
     */
    select?: TrailCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrailCheck
     */
    omit?: TrailCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrailCheckInclude<ExtArgs> | null
  }


  /**
   * Model HutCheck
   */

  export type AggregateHutCheck = {
    _count: HutCheckCountAggregateOutputType | null
    _min: HutCheckMinAggregateOutputType | null
    _max: HutCheckMaxAggregateOutputType | null
  }

  export type HutCheckMinAggregateOutputType = {
    id: string | null
    date: Date | null
    employeeId: string | null
    mountainId: string | null
    hutId: string | null
    notes: string | null
  }

  export type HutCheckMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    employeeId: string | null
    mountainId: string | null
    hutId: string | null
    notes: string | null
  }

  export type HutCheckCountAggregateOutputType = {
    id: number
    date: number
    employeeId: number
    mountainId: number
    hutId: number
    notes: number
    _all: number
  }


  export type HutCheckMinAggregateInputType = {
    id?: true
    date?: true
    employeeId?: true
    mountainId?: true
    hutId?: true
    notes?: true
  }

  export type HutCheckMaxAggregateInputType = {
    id?: true
    date?: true
    employeeId?: true
    mountainId?: true
    hutId?: true
    notes?: true
  }

  export type HutCheckCountAggregateInputType = {
    id?: true
    date?: true
    employeeId?: true
    mountainId?: true
    hutId?: true
    notes?: true
    _all?: true
  }

  export type HutCheckAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HutCheck to aggregate.
     */
    where?: HutCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HutChecks to fetch.
     */
    orderBy?: HutCheckOrderByWithRelationInput | HutCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HutCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HutChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HutChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HutChecks
    **/
    _count?: true | HutCheckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HutCheckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HutCheckMaxAggregateInputType
  }

  export type GetHutCheckAggregateType<T extends HutCheckAggregateArgs> = {
        [P in keyof T & keyof AggregateHutCheck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHutCheck[P]>
      : GetScalarType<T[P], AggregateHutCheck[P]>
  }




  export type HutCheckGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HutCheckWhereInput
    orderBy?: HutCheckOrderByWithAggregationInput | HutCheckOrderByWithAggregationInput[]
    by: HutCheckScalarFieldEnum[] | HutCheckScalarFieldEnum
    having?: HutCheckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HutCheckCountAggregateInputType | true
    _min?: HutCheckMinAggregateInputType
    _max?: HutCheckMaxAggregateInputType
  }

  export type HutCheckGroupByOutputType = {
    id: string
    date: Date
    employeeId: string
    mountainId: string
    hutId: string
    notes: string | null
    _count: HutCheckCountAggregateOutputType | null
    _min: HutCheckMinAggregateOutputType | null
    _max: HutCheckMaxAggregateOutputType | null
  }

  type GetHutCheckGroupByPayload<T extends HutCheckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HutCheckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HutCheckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HutCheckGroupByOutputType[P]>
            : GetScalarType<T[P], HutCheckGroupByOutputType[P]>
        }
      >
    >


  export type HutCheckSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    employeeId?: boolean
    mountainId?: boolean
    hutId?: boolean
    notes?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    hut?: boolean | HutDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hutCheck"]>

  export type HutCheckSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    employeeId?: boolean
    mountainId?: boolean
    hutId?: boolean
    notes?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    hut?: boolean | HutDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hutCheck"]>

  export type HutCheckSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    employeeId?: boolean
    mountainId?: boolean
    hutId?: boolean
    notes?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    hut?: boolean | HutDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hutCheck"]>

  export type HutCheckSelectScalar = {
    id?: boolean
    date?: boolean
    employeeId?: boolean
    mountainId?: boolean
    hutId?: boolean
    notes?: boolean
  }

  export type HutCheckOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "employeeId" | "mountainId" | "hutId" | "notes", ExtArgs["result"]["hutCheck"]>
  export type HutCheckInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    hut?: boolean | HutDefaultArgs<ExtArgs>
  }
  export type HutCheckIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    hut?: boolean | HutDefaultArgs<ExtArgs>
  }
  export type HutCheckIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    hut?: boolean | HutDefaultArgs<ExtArgs>
  }

  export type $HutCheckPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HutCheck"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      mountain: Prisma.$MountainPayload<ExtArgs>
      hut: Prisma.$HutPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      employeeId: string
      mountainId: string
      hutId: string
      notes: string | null
    }, ExtArgs["result"]["hutCheck"]>
    composites: {}
  }

  type HutCheckGetPayload<S extends boolean | null | undefined | HutCheckDefaultArgs> = $Result.GetResult<Prisma.$HutCheckPayload, S>

  type HutCheckCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HutCheckFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HutCheckCountAggregateInputType | true
    }

  export interface HutCheckDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HutCheck'], meta: { name: 'HutCheck' } }
    /**
     * Find zero or one HutCheck that matches the filter.
     * @param {HutCheckFindUniqueArgs} args - Arguments to find a HutCheck
     * @example
     * // Get one HutCheck
     * const hutCheck = await prisma.hutCheck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HutCheckFindUniqueArgs>(args: SelectSubset<T, HutCheckFindUniqueArgs<ExtArgs>>): Prisma__HutCheckClient<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HutCheck that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HutCheckFindUniqueOrThrowArgs} args - Arguments to find a HutCheck
     * @example
     * // Get one HutCheck
     * const hutCheck = await prisma.hutCheck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HutCheckFindUniqueOrThrowArgs>(args: SelectSubset<T, HutCheckFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HutCheckClient<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HutCheck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutCheckFindFirstArgs} args - Arguments to find a HutCheck
     * @example
     * // Get one HutCheck
     * const hutCheck = await prisma.hutCheck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HutCheckFindFirstArgs>(args?: SelectSubset<T, HutCheckFindFirstArgs<ExtArgs>>): Prisma__HutCheckClient<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HutCheck that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutCheckFindFirstOrThrowArgs} args - Arguments to find a HutCheck
     * @example
     * // Get one HutCheck
     * const hutCheck = await prisma.hutCheck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HutCheckFindFirstOrThrowArgs>(args?: SelectSubset<T, HutCheckFindFirstOrThrowArgs<ExtArgs>>): Prisma__HutCheckClient<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HutChecks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutCheckFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HutChecks
     * const hutChecks = await prisma.hutCheck.findMany()
     * 
     * // Get first 10 HutChecks
     * const hutChecks = await prisma.hutCheck.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hutCheckWithIdOnly = await prisma.hutCheck.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HutCheckFindManyArgs>(args?: SelectSubset<T, HutCheckFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HutCheck.
     * @param {HutCheckCreateArgs} args - Arguments to create a HutCheck.
     * @example
     * // Create one HutCheck
     * const HutCheck = await prisma.hutCheck.create({
     *   data: {
     *     // ... data to create a HutCheck
     *   }
     * })
     * 
     */
    create<T extends HutCheckCreateArgs>(args: SelectSubset<T, HutCheckCreateArgs<ExtArgs>>): Prisma__HutCheckClient<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HutChecks.
     * @param {HutCheckCreateManyArgs} args - Arguments to create many HutChecks.
     * @example
     * // Create many HutChecks
     * const hutCheck = await prisma.hutCheck.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HutCheckCreateManyArgs>(args?: SelectSubset<T, HutCheckCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HutChecks and returns the data saved in the database.
     * @param {HutCheckCreateManyAndReturnArgs} args - Arguments to create many HutChecks.
     * @example
     * // Create many HutChecks
     * const hutCheck = await prisma.hutCheck.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HutChecks and only return the `id`
     * const hutCheckWithIdOnly = await prisma.hutCheck.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HutCheckCreateManyAndReturnArgs>(args?: SelectSubset<T, HutCheckCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HutCheck.
     * @param {HutCheckDeleteArgs} args - Arguments to delete one HutCheck.
     * @example
     * // Delete one HutCheck
     * const HutCheck = await prisma.hutCheck.delete({
     *   where: {
     *     // ... filter to delete one HutCheck
     *   }
     * })
     * 
     */
    delete<T extends HutCheckDeleteArgs>(args: SelectSubset<T, HutCheckDeleteArgs<ExtArgs>>): Prisma__HutCheckClient<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HutCheck.
     * @param {HutCheckUpdateArgs} args - Arguments to update one HutCheck.
     * @example
     * // Update one HutCheck
     * const hutCheck = await prisma.hutCheck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HutCheckUpdateArgs>(args: SelectSubset<T, HutCheckUpdateArgs<ExtArgs>>): Prisma__HutCheckClient<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HutChecks.
     * @param {HutCheckDeleteManyArgs} args - Arguments to filter HutChecks to delete.
     * @example
     * // Delete a few HutChecks
     * const { count } = await prisma.hutCheck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HutCheckDeleteManyArgs>(args?: SelectSubset<T, HutCheckDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HutChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutCheckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HutChecks
     * const hutCheck = await prisma.hutCheck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HutCheckUpdateManyArgs>(args: SelectSubset<T, HutCheckUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HutChecks and returns the data updated in the database.
     * @param {HutCheckUpdateManyAndReturnArgs} args - Arguments to update many HutChecks.
     * @example
     * // Update many HutChecks
     * const hutCheck = await prisma.hutCheck.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HutChecks and only return the `id`
     * const hutCheckWithIdOnly = await prisma.hutCheck.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HutCheckUpdateManyAndReturnArgs>(args: SelectSubset<T, HutCheckUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HutCheck.
     * @param {HutCheckUpsertArgs} args - Arguments to update or create a HutCheck.
     * @example
     * // Update or create a HutCheck
     * const hutCheck = await prisma.hutCheck.upsert({
     *   create: {
     *     // ... data to create a HutCheck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HutCheck we want to update
     *   }
     * })
     */
    upsert<T extends HutCheckUpsertArgs>(args: SelectSubset<T, HutCheckUpsertArgs<ExtArgs>>): Prisma__HutCheckClient<$Result.GetResult<Prisma.$HutCheckPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HutChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutCheckCountArgs} args - Arguments to filter HutChecks to count.
     * @example
     * // Count the number of HutChecks
     * const count = await prisma.hutCheck.count({
     *   where: {
     *     // ... the filter for the HutChecks we want to count
     *   }
     * })
    **/
    count<T extends HutCheckCountArgs>(
      args?: Subset<T, HutCheckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HutCheckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HutCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutCheckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HutCheckAggregateArgs>(args: Subset<T, HutCheckAggregateArgs>): Prisma.PrismaPromise<GetHutCheckAggregateType<T>>

    /**
     * Group by HutCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HutCheckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HutCheckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HutCheckGroupByArgs['orderBy'] }
        : { orderBy?: HutCheckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HutCheckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHutCheckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HutCheck model
   */
  readonly fields: HutCheckFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HutCheck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HutCheckClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    hut<T extends HutDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HutDefaultArgs<ExtArgs>>): Prisma__HutClient<$Result.GetResult<Prisma.$HutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HutCheck model
   */
  interface HutCheckFieldRefs {
    readonly id: FieldRef<"HutCheck", 'String'>
    readonly date: FieldRef<"HutCheck", 'DateTime'>
    readonly employeeId: FieldRef<"HutCheck", 'String'>
    readonly mountainId: FieldRef<"HutCheck", 'String'>
    readonly hutId: FieldRef<"HutCheck", 'String'>
    readonly notes: FieldRef<"HutCheck", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HutCheck findUnique
   */
  export type HutCheckFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    /**
     * Filter, which HutCheck to fetch.
     */
    where: HutCheckWhereUniqueInput
  }

  /**
   * HutCheck findUniqueOrThrow
   */
  export type HutCheckFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    /**
     * Filter, which HutCheck to fetch.
     */
    where: HutCheckWhereUniqueInput
  }

  /**
   * HutCheck findFirst
   */
  export type HutCheckFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    /**
     * Filter, which HutCheck to fetch.
     */
    where?: HutCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HutChecks to fetch.
     */
    orderBy?: HutCheckOrderByWithRelationInput | HutCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HutChecks.
     */
    cursor?: HutCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HutChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HutChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HutChecks.
     */
    distinct?: HutCheckScalarFieldEnum | HutCheckScalarFieldEnum[]
  }

  /**
   * HutCheck findFirstOrThrow
   */
  export type HutCheckFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    /**
     * Filter, which HutCheck to fetch.
     */
    where?: HutCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HutChecks to fetch.
     */
    orderBy?: HutCheckOrderByWithRelationInput | HutCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HutChecks.
     */
    cursor?: HutCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HutChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HutChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HutChecks.
     */
    distinct?: HutCheckScalarFieldEnum | HutCheckScalarFieldEnum[]
  }

  /**
   * HutCheck findMany
   */
  export type HutCheckFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    /**
     * Filter, which HutChecks to fetch.
     */
    where?: HutCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HutChecks to fetch.
     */
    orderBy?: HutCheckOrderByWithRelationInput | HutCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HutChecks.
     */
    cursor?: HutCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HutChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HutChecks.
     */
    skip?: number
    distinct?: HutCheckScalarFieldEnum | HutCheckScalarFieldEnum[]
  }

  /**
   * HutCheck create
   */
  export type HutCheckCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    /**
     * The data needed to create a HutCheck.
     */
    data: XOR<HutCheckCreateInput, HutCheckUncheckedCreateInput>
  }

  /**
   * HutCheck createMany
   */
  export type HutCheckCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HutChecks.
     */
    data: HutCheckCreateManyInput | HutCheckCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HutCheck createManyAndReturn
   */
  export type HutCheckCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * The data used to create many HutChecks.
     */
    data: HutCheckCreateManyInput | HutCheckCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HutCheck update
   */
  export type HutCheckUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    /**
     * The data needed to update a HutCheck.
     */
    data: XOR<HutCheckUpdateInput, HutCheckUncheckedUpdateInput>
    /**
     * Choose, which HutCheck to update.
     */
    where: HutCheckWhereUniqueInput
  }

  /**
   * HutCheck updateMany
   */
  export type HutCheckUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HutChecks.
     */
    data: XOR<HutCheckUpdateManyMutationInput, HutCheckUncheckedUpdateManyInput>
    /**
     * Filter which HutChecks to update
     */
    where?: HutCheckWhereInput
    /**
     * Limit how many HutChecks to update.
     */
    limit?: number
  }

  /**
   * HutCheck updateManyAndReturn
   */
  export type HutCheckUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * The data used to update HutChecks.
     */
    data: XOR<HutCheckUpdateManyMutationInput, HutCheckUncheckedUpdateManyInput>
    /**
     * Filter which HutChecks to update
     */
    where?: HutCheckWhereInput
    /**
     * Limit how many HutChecks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HutCheck upsert
   */
  export type HutCheckUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    /**
     * The filter to search for the HutCheck to update in case it exists.
     */
    where: HutCheckWhereUniqueInput
    /**
     * In case the HutCheck found by the `where` argument doesn't exist, create a new HutCheck with this data.
     */
    create: XOR<HutCheckCreateInput, HutCheckUncheckedCreateInput>
    /**
     * In case the HutCheck was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HutCheckUpdateInput, HutCheckUncheckedUpdateInput>
  }

  /**
   * HutCheck delete
   */
  export type HutCheckDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
    /**
     * Filter which HutCheck to delete.
     */
    where: HutCheckWhereUniqueInput
  }

  /**
   * HutCheck deleteMany
   */
  export type HutCheckDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HutChecks to delete
     */
    where?: HutCheckWhereInput
    /**
     * Limit how many HutChecks to delete.
     */
    limit?: number
  }

  /**
   * HutCheck without action
   */
  export type HutCheckDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HutCheck
     */
    select?: HutCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HutCheck
     */
    omit?: HutCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HutCheckInclude<ExtArgs> | null
  }


  /**
   * Model AidRoomCheck
   */

  export type AggregateAidRoomCheck = {
    _count: AidRoomCheckCountAggregateOutputType | null
    _min: AidRoomCheckMinAggregateOutputType | null
    _max: AidRoomCheckMaxAggregateOutputType | null
  }

  export type AidRoomCheckMinAggregateOutputType = {
    id: string | null
    date: Date | null
    employeeId: string | null
    mountainId: string | null
    aidRoomId: string | null
    notes: string | null
  }

  export type AidRoomCheckMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    employeeId: string | null
    mountainId: string | null
    aidRoomId: string | null
    notes: string | null
  }

  export type AidRoomCheckCountAggregateOutputType = {
    id: number
    date: number
    employeeId: number
    mountainId: number
    aidRoomId: number
    notes: number
    _all: number
  }


  export type AidRoomCheckMinAggregateInputType = {
    id?: true
    date?: true
    employeeId?: true
    mountainId?: true
    aidRoomId?: true
    notes?: true
  }

  export type AidRoomCheckMaxAggregateInputType = {
    id?: true
    date?: true
    employeeId?: true
    mountainId?: true
    aidRoomId?: true
    notes?: true
  }

  export type AidRoomCheckCountAggregateInputType = {
    id?: true
    date?: true
    employeeId?: true
    mountainId?: true
    aidRoomId?: true
    notes?: true
    _all?: true
  }

  export type AidRoomCheckAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AidRoomCheck to aggregate.
     */
    where?: AidRoomCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AidRoomChecks to fetch.
     */
    orderBy?: AidRoomCheckOrderByWithRelationInput | AidRoomCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AidRoomCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AidRoomChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AidRoomChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AidRoomChecks
    **/
    _count?: true | AidRoomCheckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AidRoomCheckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AidRoomCheckMaxAggregateInputType
  }

  export type GetAidRoomCheckAggregateType<T extends AidRoomCheckAggregateArgs> = {
        [P in keyof T & keyof AggregateAidRoomCheck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAidRoomCheck[P]>
      : GetScalarType<T[P], AggregateAidRoomCheck[P]>
  }




  export type AidRoomCheckGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AidRoomCheckWhereInput
    orderBy?: AidRoomCheckOrderByWithAggregationInput | AidRoomCheckOrderByWithAggregationInput[]
    by: AidRoomCheckScalarFieldEnum[] | AidRoomCheckScalarFieldEnum
    having?: AidRoomCheckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AidRoomCheckCountAggregateInputType | true
    _min?: AidRoomCheckMinAggregateInputType
    _max?: AidRoomCheckMaxAggregateInputType
  }

  export type AidRoomCheckGroupByOutputType = {
    id: string
    date: Date
    employeeId: string
    mountainId: string
    aidRoomId: string
    notes: string | null
    _count: AidRoomCheckCountAggregateOutputType | null
    _min: AidRoomCheckMinAggregateOutputType | null
    _max: AidRoomCheckMaxAggregateOutputType | null
  }

  type GetAidRoomCheckGroupByPayload<T extends AidRoomCheckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AidRoomCheckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AidRoomCheckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AidRoomCheckGroupByOutputType[P]>
            : GetScalarType<T[P], AidRoomCheckGroupByOutputType[P]>
        }
      >
    >


  export type AidRoomCheckSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    employeeId?: boolean
    mountainId?: boolean
    aidRoomId?: boolean
    notes?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    aidRoom?: boolean | AidRoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aidRoomCheck"]>

  export type AidRoomCheckSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    employeeId?: boolean
    mountainId?: boolean
    aidRoomId?: boolean
    notes?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    aidRoom?: boolean | AidRoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aidRoomCheck"]>

  export type AidRoomCheckSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    employeeId?: boolean
    mountainId?: boolean
    aidRoomId?: boolean
    notes?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    aidRoom?: boolean | AidRoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aidRoomCheck"]>

  export type AidRoomCheckSelectScalar = {
    id?: boolean
    date?: boolean
    employeeId?: boolean
    mountainId?: boolean
    aidRoomId?: boolean
    notes?: boolean
  }

  export type AidRoomCheckOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "employeeId" | "mountainId" | "aidRoomId" | "notes", ExtArgs["result"]["aidRoomCheck"]>
  export type AidRoomCheckInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    aidRoom?: boolean | AidRoomDefaultArgs<ExtArgs>
  }
  export type AidRoomCheckIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    aidRoom?: boolean | AidRoomDefaultArgs<ExtArgs>
  }
  export type AidRoomCheckIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    aidRoom?: boolean | AidRoomDefaultArgs<ExtArgs>
  }

  export type $AidRoomCheckPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AidRoomCheck"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      mountain: Prisma.$MountainPayload<ExtArgs>
      aidRoom: Prisma.$AidRoomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      employeeId: string
      mountainId: string
      aidRoomId: string
      notes: string | null
    }, ExtArgs["result"]["aidRoomCheck"]>
    composites: {}
  }

  type AidRoomCheckGetPayload<S extends boolean | null | undefined | AidRoomCheckDefaultArgs> = $Result.GetResult<Prisma.$AidRoomCheckPayload, S>

  type AidRoomCheckCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AidRoomCheckFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AidRoomCheckCountAggregateInputType | true
    }

  export interface AidRoomCheckDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AidRoomCheck'], meta: { name: 'AidRoomCheck' } }
    /**
     * Find zero or one AidRoomCheck that matches the filter.
     * @param {AidRoomCheckFindUniqueArgs} args - Arguments to find a AidRoomCheck
     * @example
     * // Get one AidRoomCheck
     * const aidRoomCheck = await prisma.aidRoomCheck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AidRoomCheckFindUniqueArgs>(args: SelectSubset<T, AidRoomCheckFindUniqueArgs<ExtArgs>>): Prisma__AidRoomCheckClient<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AidRoomCheck that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AidRoomCheckFindUniqueOrThrowArgs} args - Arguments to find a AidRoomCheck
     * @example
     * // Get one AidRoomCheck
     * const aidRoomCheck = await prisma.aidRoomCheck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AidRoomCheckFindUniqueOrThrowArgs>(args: SelectSubset<T, AidRoomCheckFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AidRoomCheckClient<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AidRoomCheck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomCheckFindFirstArgs} args - Arguments to find a AidRoomCheck
     * @example
     * // Get one AidRoomCheck
     * const aidRoomCheck = await prisma.aidRoomCheck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AidRoomCheckFindFirstArgs>(args?: SelectSubset<T, AidRoomCheckFindFirstArgs<ExtArgs>>): Prisma__AidRoomCheckClient<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AidRoomCheck that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomCheckFindFirstOrThrowArgs} args - Arguments to find a AidRoomCheck
     * @example
     * // Get one AidRoomCheck
     * const aidRoomCheck = await prisma.aidRoomCheck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AidRoomCheckFindFirstOrThrowArgs>(args?: SelectSubset<T, AidRoomCheckFindFirstOrThrowArgs<ExtArgs>>): Prisma__AidRoomCheckClient<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AidRoomChecks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomCheckFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AidRoomChecks
     * const aidRoomChecks = await prisma.aidRoomCheck.findMany()
     * 
     * // Get first 10 AidRoomChecks
     * const aidRoomChecks = await prisma.aidRoomCheck.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aidRoomCheckWithIdOnly = await prisma.aidRoomCheck.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AidRoomCheckFindManyArgs>(args?: SelectSubset<T, AidRoomCheckFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AidRoomCheck.
     * @param {AidRoomCheckCreateArgs} args - Arguments to create a AidRoomCheck.
     * @example
     * // Create one AidRoomCheck
     * const AidRoomCheck = await prisma.aidRoomCheck.create({
     *   data: {
     *     // ... data to create a AidRoomCheck
     *   }
     * })
     * 
     */
    create<T extends AidRoomCheckCreateArgs>(args: SelectSubset<T, AidRoomCheckCreateArgs<ExtArgs>>): Prisma__AidRoomCheckClient<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AidRoomChecks.
     * @param {AidRoomCheckCreateManyArgs} args - Arguments to create many AidRoomChecks.
     * @example
     * // Create many AidRoomChecks
     * const aidRoomCheck = await prisma.aidRoomCheck.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AidRoomCheckCreateManyArgs>(args?: SelectSubset<T, AidRoomCheckCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AidRoomChecks and returns the data saved in the database.
     * @param {AidRoomCheckCreateManyAndReturnArgs} args - Arguments to create many AidRoomChecks.
     * @example
     * // Create many AidRoomChecks
     * const aidRoomCheck = await prisma.aidRoomCheck.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AidRoomChecks and only return the `id`
     * const aidRoomCheckWithIdOnly = await prisma.aidRoomCheck.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AidRoomCheckCreateManyAndReturnArgs>(args?: SelectSubset<T, AidRoomCheckCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AidRoomCheck.
     * @param {AidRoomCheckDeleteArgs} args - Arguments to delete one AidRoomCheck.
     * @example
     * // Delete one AidRoomCheck
     * const AidRoomCheck = await prisma.aidRoomCheck.delete({
     *   where: {
     *     // ... filter to delete one AidRoomCheck
     *   }
     * })
     * 
     */
    delete<T extends AidRoomCheckDeleteArgs>(args: SelectSubset<T, AidRoomCheckDeleteArgs<ExtArgs>>): Prisma__AidRoomCheckClient<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AidRoomCheck.
     * @param {AidRoomCheckUpdateArgs} args - Arguments to update one AidRoomCheck.
     * @example
     * // Update one AidRoomCheck
     * const aidRoomCheck = await prisma.aidRoomCheck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AidRoomCheckUpdateArgs>(args: SelectSubset<T, AidRoomCheckUpdateArgs<ExtArgs>>): Prisma__AidRoomCheckClient<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AidRoomChecks.
     * @param {AidRoomCheckDeleteManyArgs} args - Arguments to filter AidRoomChecks to delete.
     * @example
     * // Delete a few AidRoomChecks
     * const { count } = await prisma.aidRoomCheck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AidRoomCheckDeleteManyArgs>(args?: SelectSubset<T, AidRoomCheckDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AidRoomChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomCheckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AidRoomChecks
     * const aidRoomCheck = await prisma.aidRoomCheck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AidRoomCheckUpdateManyArgs>(args: SelectSubset<T, AidRoomCheckUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AidRoomChecks and returns the data updated in the database.
     * @param {AidRoomCheckUpdateManyAndReturnArgs} args - Arguments to update many AidRoomChecks.
     * @example
     * // Update many AidRoomChecks
     * const aidRoomCheck = await prisma.aidRoomCheck.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AidRoomChecks and only return the `id`
     * const aidRoomCheckWithIdOnly = await prisma.aidRoomCheck.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AidRoomCheckUpdateManyAndReturnArgs>(args: SelectSubset<T, AidRoomCheckUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AidRoomCheck.
     * @param {AidRoomCheckUpsertArgs} args - Arguments to update or create a AidRoomCheck.
     * @example
     * // Update or create a AidRoomCheck
     * const aidRoomCheck = await prisma.aidRoomCheck.upsert({
     *   create: {
     *     // ... data to create a AidRoomCheck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AidRoomCheck we want to update
     *   }
     * })
     */
    upsert<T extends AidRoomCheckUpsertArgs>(args: SelectSubset<T, AidRoomCheckUpsertArgs<ExtArgs>>): Prisma__AidRoomCheckClient<$Result.GetResult<Prisma.$AidRoomCheckPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AidRoomChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomCheckCountArgs} args - Arguments to filter AidRoomChecks to count.
     * @example
     * // Count the number of AidRoomChecks
     * const count = await prisma.aidRoomCheck.count({
     *   where: {
     *     // ... the filter for the AidRoomChecks we want to count
     *   }
     * })
    **/
    count<T extends AidRoomCheckCountArgs>(
      args?: Subset<T, AidRoomCheckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AidRoomCheckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AidRoomCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomCheckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AidRoomCheckAggregateArgs>(args: Subset<T, AidRoomCheckAggregateArgs>): Prisma.PrismaPromise<GetAidRoomCheckAggregateType<T>>

    /**
     * Group by AidRoomCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AidRoomCheckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AidRoomCheckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AidRoomCheckGroupByArgs['orderBy'] }
        : { orderBy?: AidRoomCheckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AidRoomCheckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAidRoomCheckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AidRoomCheck model
   */
  readonly fields: AidRoomCheckFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AidRoomCheck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AidRoomCheckClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    aidRoom<T extends AidRoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AidRoomDefaultArgs<ExtArgs>>): Prisma__AidRoomClient<$Result.GetResult<Prisma.$AidRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AidRoomCheck model
   */
  interface AidRoomCheckFieldRefs {
    readonly id: FieldRef<"AidRoomCheck", 'String'>
    readonly date: FieldRef<"AidRoomCheck", 'DateTime'>
    readonly employeeId: FieldRef<"AidRoomCheck", 'String'>
    readonly mountainId: FieldRef<"AidRoomCheck", 'String'>
    readonly aidRoomId: FieldRef<"AidRoomCheck", 'String'>
    readonly notes: FieldRef<"AidRoomCheck", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AidRoomCheck findUnique
   */
  export type AidRoomCheckFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    /**
     * Filter, which AidRoomCheck to fetch.
     */
    where: AidRoomCheckWhereUniqueInput
  }

  /**
   * AidRoomCheck findUniqueOrThrow
   */
  export type AidRoomCheckFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    /**
     * Filter, which AidRoomCheck to fetch.
     */
    where: AidRoomCheckWhereUniqueInput
  }

  /**
   * AidRoomCheck findFirst
   */
  export type AidRoomCheckFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    /**
     * Filter, which AidRoomCheck to fetch.
     */
    where?: AidRoomCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AidRoomChecks to fetch.
     */
    orderBy?: AidRoomCheckOrderByWithRelationInput | AidRoomCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AidRoomChecks.
     */
    cursor?: AidRoomCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AidRoomChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AidRoomChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AidRoomChecks.
     */
    distinct?: AidRoomCheckScalarFieldEnum | AidRoomCheckScalarFieldEnum[]
  }

  /**
   * AidRoomCheck findFirstOrThrow
   */
  export type AidRoomCheckFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    /**
     * Filter, which AidRoomCheck to fetch.
     */
    where?: AidRoomCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AidRoomChecks to fetch.
     */
    orderBy?: AidRoomCheckOrderByWithRelationInput | AidRoomCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AidRoomChecks.
     */
    cursor?: AidRoomCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AidRoomChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AidRoomChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AidRoomChecks.
     */
    distinct?: AidRoomCheckScalarFieldEnum | AidRoomCheckScalarFieldEnum[]
  }

  /**
   * AidRoomCheck findMany
   */
  export type AidRoomCheckFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    /**
     * Filter, which AidRoomChecks to fetch.
     */
    where?: AidRoomCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AidRoomChecks to fetch.
     */
    orderBy?: AidRoomCheckOrderByWithRelationInput | AidRoomCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AidRoomChecks.
     */
    cursor?: AidRoomCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AidRoomChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AidRoomChecks.
     */
    skip?: number
    distinct?: AidRoomCheckScalarFieldEnum | AidRoomCheckScalarFieldEnum[]
  }

  /**
   * AidRoomCheck create
   */
  export type AidRoomCheckCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    /**
     * The data needed to create a AidRoomCheck.
     */
    data: XOR<AidRoomCheckCreateInput, AidRoomCheckUncheckedCreateInput>
  }

  /**
   * AidRoomCheck createMany
   */
  export type AidRoomCheckCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AidRoomChecks.
     */
    data: AidRoomCheckCreateManyInput | AidRoomCheckCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AidRoomCheck createManyAndReturn
   */
  export type AidRoomCheckCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * The data used to create many AidRoomChecks.
     */
    data: AidRoomCheckCreateManyInput | AidRoomCheckCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AidRoomCheck update
   */
  export type AidRoomCheckUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    /**
     * The data needed to update a AidRoomCheck.
     */
    data: XOR<AidRoomCheckUpdateInput, AidRoomCheckUncheckedUpdateInput>
    /**
     * Choose, which AidRoomCheck to update.
     */
    where: AidRoomCheckWhereUniqueInput
  }

  /**
   * AidRoomCheck updateMany
   */
  export type AidRoomCheckUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AidRoomChecks.
     */
    data: XOR<AidRoomCheckUpdateManyMutationInput, AidRoomCheckUncheckedUpdateManyInput>
    /**
     * Filter which AidRoomChecks to update
     */
    where?: AidRoomCheckWhereInput
    /**
     * Limit how many AidRoomChecks to update.
     */
    limit?: number
  }

  /**
   * AidRoomCheck updateManyAndReturn
   */
  export type AidRoomCheckUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * The data used to update AidRoomChecks.
     */
    data: XOR<AidRoomCheckUpdateManyMutationInput, AidRoomCheckUncheckedUpdateManyInput>
    /**
     * Filter which AidRoomChecks to update
     */
    where?: AidRoomCheckWhereInput
    /**
     * Limit how many AidRoomChecks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AidRoomCheck upsert
   */
  export type AidRoomCheckUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    /**
     * The filter to search for the AidRoomCheck to update in case it exists.
     */
    where: AidRoomCheckWhereUniqueInput
    /**
     * In case the AidRoomCheck found by the `where` argument doesn't exist, create a new AidRoomCheck with this data.
     */
    create: XOR<AidRoomCheckCreateInput, AidRoomCheckUncheckedCreateInput>
    /**
     * In case the AidRoomCheck was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AidRoomCheckUpdateInput, AidRoomCheckUncheckedUpdateInput>
  }

  /**
   * AidRoomCheck delete
   */
  export type AidRoomCheckDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
    /**
     * Filter which AidRoomCheck to delete.
     */
    where: AidRoomCheckWhereUniqueInput
  }

  /**
   * AidRoomCheck deleteMany
   */
  export type AidRoomCheckDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AidRoomChecks to delete
     */
    where?: AidRoomCheckWhereInput
    /**
     * Limit how many AidRoomChecks to delete.
     */
    limit?: number
  }

  /**
   * AidRoomCheck without action
   */
  export type AidRoomCheckDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AidRoomCheck
     */
    select?: AidRoomCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AidRoomCheck
     */
    omit?: AidRoomCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AidRoomCheckInclude<ExtArgs> | null
  }


  /**
   * Model EquipmentCheck
   */

  export type AggregateEquipmentCheck = {
    _count: EquipmentCheckCountAggregateOutputType | null
    _min: EquipmentCheckMinAggregateOutputType | null
    _max: EquipmentCheckMaxAggregateOutputType | null
  }

  export type EquipmentCheckMinAggregateOutputType = {
    id: string | null
    date: Date | null
    employeeId: string | null
    mountainId: string | null
    equipmentId: string | null
    notes: string | null
  }

  export type EquipmentCheckMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    employeeId: string | null
    mountainId: string | null
    equipmentId: string | null
    notes: string | null
  }

  export type EquipmentCheckCountAggregateOutputType = {
    id: number
    date: number
    employeeId: number
    mountainId: number
    equipmentId: number
    notes: number
    _all: number
  }


  export type EquipmentCheckMinAggregateInputType = {
    id?: true
    date?: true
    employeeId?: true
    mountainId?: true
    equipmentId?: true
    notes?: true
  }

  export type EquipmentCheckMaxAggregateInputType = {
    id?: true
    date?: true
    employeeId?: true
    mountainId?: true
    equipmentId?: true
    notes?: true
  }

  export type EquipmentCheckCountAggregateInputType = {
    id?: true
    date?: true
    employeeId?: true
    mountainId?: true
    equipmentId?: true
    notes?: true
    _all?: true
  }

  export type EquipmentCheckAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentCheck to aggregate.
     */
    where?: EquipmentCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentChecks to fetch.
     */
    orderBy?: EquipmentCheckOrderByWithRelationInput | EquipmentCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EquipmentChecks
    **/
    _count?: true | EquipmentCheckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentCheckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentCheckMaxAggregateInputType
  }

  export type GetEquipmentCheckAggregateType<T extends EquipmentCheckAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipmentCheck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipmentCheck[P]>
      : GetScalarType<T[P], AggregateEquipmentCheck[P]>
  }




  export type EquipmentCheckGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentCheckWhereInput
    orderBy?: EquipmentCheckOrderByWithAggregationInput | EquipmentCheckOrderByWithAggregationInput[]
    by: EquipmentCheckScalarFieldEnum[] | EquipmentCheckScalarFieldEnum
    having?: EquipmentCheckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentCheckCountAggregateInputType | true
    _min?: EquipmentCheckMinAggregateInputType
    _max?: EquipmentCheckMaxAggregateInputType
  }

  export type EquipmentCheckGroupByOutputType = {
    id: string
    date: Date
    employeeId: string
    mountainId: string
    equipmentId: string
    notes: string | null
    _count: EquipmentCheckCountAggregateOutputType | null
    _min: EquipmentCheckMinAggregateOutputType | null
    _max: EquipmentCheckMaxAggregateOutputType | null
  }

  type GetEquipmentCheckGroupByPayload<T extends EquipmentCheckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentCheckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentCheckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentCheckGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentCheckGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentCheckSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    employeeId?: boolean
    mountainId?: boolean
    equipmentId?: boolean
    notes?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentCheck"]>

  export type EquipmentCheckSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    employeeId?: boolean
    mountainId?: boolean
    equipmentId?: boolean
    notes?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentCheck"]>

  export type EquipmentCheckSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    employeeId?: boolean
    mountainId?: boolean
    equipmentId?: boolean
    notes?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentCheck"]>

  export type EquipmentCheckSelectScalar = {
    id?: boolean
    date?: boolean
    employeeId?: boolean
    mountainId?: boolean
    equipmentId?: boolean
    notes?: boolean
  }

  export type EquipmentCheckOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "employeeId" | "mountainId" | "equipmentId" | "notes", ExtArgs["result"]["equipmentCheck"]>
  export type EquipmentCheckInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }
  export type EquipmentCheckIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }
  export type EquipmentCheckIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    mountain?: boolean | MountainDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }

  export type $EquipmentCheckPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EquipmentCheck"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      mountain: Prisma.$MountainPayload<ExtArgs>
      equipment: Prisma.$EquipmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      employeeId: string
      mountainId: string
      equipmentId: string
      notes: string | null
    }, ExtArgs["result"]["equipmentCheck"]>
    composites: {}
  }

  type EquipmentCheckGetPayload<S extends boolean | null | undefined | EquipmentCheckDefaultArgs> = $Result.GetResult<Prisma.$EquipmentCheckPayload, S>

  type EquipmentCheckCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipmentCheckFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipmentCheckCountAggregateInputType | true
    }

  export interface EquipmentCheckDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EquipmentCheck'], meta: { name: 'EquipmentCheck' } }
    /**
     * Find zero or one EquipmentCheck that matches the filter.
     * @param {EquipmentCheckFindUniqueArgs} args - Arguments to find a EquipmentCheck
     * @example
     * // Get one EquipmentCheck
     * const equipmentCheck = await prisma.equipmentCheck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentCheckFindUniqueArgs>(args: SelectSubset<T, EquipmentCheckFindUniqueArgs<ExtArgs>>): Prisma__EquipmentCheckClient<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EquipmentCheck that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipmentCheckFindUniqueOrThrowArgs} args - Arguments to find a EquipmentCheck
     * @example
     * // Get one EquipmentCheck
     * const equipmentCheck = await prisma.equipmentCheck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentCheckFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentCheckFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentCheckClient<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipmentCheck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCheckFindFirstArgs} args - Arguments to find a EquipmentCheck
     * @example
     * // Get one EquipmentCheck
     * const equipmentCheck = await prisma.equipmentCheck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentCheckFindFirstArgs>(args?: SelectSubset<T, EquipmentCheckFindFirstArgs<ExtArgs>>): Prisma__EquipmentCheckClient<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipmentCheck that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCheckFindFirstOrThrowArgs} args - Arguments to find a EquipmentCheck
     * @example
     * // Get one EquipmentCheck
     * const equipmentCheck = await prisma.equipmentCheck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentCheckFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentCheckFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentCheckClient<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EquipmentChecks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCheckFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipmentChecks
     * const equipmentChecks = await prisma.equipmentCheck.findMany()
     * 
     * // Get first 10 EquipmentChecks
     * const equipmentChecks = await prisma.equipmentCheck.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentCheckWithIdOnly = await prisma.equipmentCheck.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentCheckFindManyArgs>(args?: SelectSubset<T, EquipmentCheckFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EquipmentCheck.
     * @param {EquipmentCheckCreateArgs} args - Arguments to create a EquipmentCheck.
     * @example
     * // Create one EquipmentCheck
     * const EquipmentCheck = await prisma.equipmentCheck.create({
     *   data: {
     *     // ... data to create a EquipmentCheck
     *   }
     * })
     * 
     */
    create<T extends EquipmentCheckCreateArgs>(args: SelectSubset<T, EquipmentCheckCreateArgs<ExtArgs>>): Prisma__EquipmentCheckClient<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EquipmentChecks.
     * @param {EquipmentCheckCreateManyArgs} args - Arguments to create many EquipmentChecks.
     * @example
     * // Create many EquipmentChecks
     * const equipmentCheck = await prisma.equipmentCheck.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentCheckCreateManyArgs>(args?: SelectSubset<T, EquipmentCheckCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EquipmentChecks and returns the data saved in the database.
     * @param {EquipmentCheckCreateManyAndReturnArgs} args - Arguments to create many EquipmentChecks.
     * @example
     * // Create many EquipmentChecks
     * const equipmentCheck = await prisma.equipmentCheck.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EquipmentChecks and only return the `id`
     * const equipmentCheckWithIdOnly = await prisma.equipmentCheck.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipmentCheckCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipmentCheckCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EquipmentCheck.
     * @param {EquipmentCheckDeleteArgs} args - Arguments to delete one EquipmentCheck.
     * @example
     * // Delete one EquipmentCheck
     * const EquipmentCheck = await prisma.equipmentCheck.delete({
     *   where: {
     *     // ... filter to delete one EquipmentCheck
     *   }
     * })
     * 
     */
    delete<T extends EquipmentCheckDeleteArgs>(args: SelectSubset<T, EquipmentCheckDeleteArgs<ExtArgs>>): Prisma__EquipmentCheckClient<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EquipmentCheck.
     * @param {EquipmentCheckUpdateArgs} args - Arguments to update one EquipmentCheck.
     * @example
     * // Update one EquipmentCheck
     * const equipmentCheck = await prisma.equipmentCheck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentCheckUpdateArgs>(args: SelectSubset<T, EquipmentCheckUpdateArgs<ExtArgs>>): Prisma__EquipmentCheckClient<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EquipmentChecks.
     * @param {EquipmentCheckDeleteManyArgs} args - Arguments to filter EquipmentChecks to delete.
     * @example
     * // Delete a few EquipmentChecks
     * const { count } = await prisma.equipmentCheck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentCheckDeleteManyArgs>(args?: SelectSubset<T, EquipmentCheckDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCheckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipmentChecks
     * const equipmentCheck = await prisma.equipmentCheck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentCheckUpdateManyArgs>(args: SelectSubset<T, EquipmentCheckUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentChecks and returns the data updated in the database.
     * @param {EquipmentCheckUpdateManyAndReturnArgs} args - Arguments to update many EquipmentChecks.
     * @example
     * // Update many EquipmentChecks
     * const equipmentCheck = await prisma.equipmentCheck.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EquipmentChecks and only return the `id`
     * const equipmentCheckWithIdOnly = await prisma.equipmentCheck.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EquipmentCheckUpdateManyAndReturnArgs>(args: SelectSubset<T, EquipmentCheckUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EquipmentCheck.
     * @param {EquipmentCheckUpsertArgs} args - Arguments to update or create a EquipmentCheck.
     * @example
     * // Update or create a EquipmentCheck
     * const equipmentCheck = await prisma.equipmentCheck.upsert({
     *   create: {
     *     // ... data to create a EquipmentCheck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipmentCheck we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentCheckUpsertArgs>(args: SelectSubset<T, EquipmentCheckUpsertArgs<ExtArgs>>): Prisma__EquipmentCheckClient<$Result.GetResult<Prisma.$EquipmentCheckPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EquipmentChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCheckCountArgs} args - Arguments to filter EquipmentChecks to count.
     * @example
     * // Count the number of EquipmentChecks
     * const count = await prisma.equipmentCheck.count({
     *   where: {
     *     // ... the filter for the EquipmentChecks we want to count
     *   }
     * })
    **/
    count<T extends EquipmentCheckCountArgs>(
      args?: Subset<T, EquipmentCheckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentCheckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipmentCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCheckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentCheckAggregateArgs>(args: Subset<T, EquipmentCheckAggregateArgs>): Prisma.PrismaPromise<GetEquipmentCheckAggregateType<T>>

    /**
     * Group by EquipmentCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCheckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentCheckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentCheckGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentCheckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentCheckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentCheckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EquipmentCheck model
   */
  readonly fields: EquipmentCheckFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EquipmentCheck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentCheckClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mountain<T extends MountainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MountainDefaultArgs<ExtArgs>>): Prisma__MountainClient<$Result.GetResult<Prisma.$MountainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    equipment<T extends EquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentDefaultArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EquipmentCheck model
   */
  interface EquipmentCheckFieldRefs {
    readonly id: FieldRef<"EquipmentCheck", 'String'>
    readonly date: FieldRef<"EquipmentCheck", 'DateTime'>
    readonly employeeId: FieldRef<"EquipmentCheck", 'String'>
    readonly mountainId: FieldRef<"EquipmentCheck", 'String'>
    readonly equipmentId: FieldRef<"EquipmentCheck", 'String'>
    readonly notes: FieldRef<"EquipmentCheck", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EquipmentCheck findUnique
   */
  export type EquipmentCheckFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentCheck to fetch.
     */
    where: EquipmentCheckWhereUniqueInput
  }

  /**
   * EquipmentCheck findUniqueOrThrow
   */
  export type EquipmentCheckFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentCheck to fetch.
     */
    where: EquipmentCheckWhereUniqueInput
  }

  /**
   * EquipmentCheck findFirst
   */
  export type EquipmentCheckFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentCheck to fetch.
     */
    where?: EquipmentCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentChecks to fetch.
     */
    orderBy?: EquipmentCheckOrderByWithRelationInput | EquipmentCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentChecks.
     */
    cursor?: EquipmentCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentChecks.
     */
    distinct?: EquipmentCheckScalarFieldEnum | EquipmentCheckScalarFieldEnum[]
  }

  /**
   * EquipmentCheck findFirstOrThrow
   */
  export type EquipmentCheckFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentCheck to fetch.
     */
    where?: EquipmentCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentChecks to fetch.
     */
    orderBy?: EquipmentCheckOrderByWithRelationInput | EquipmentCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentChecks.
     */
    cursor?: EquipmentCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentChecks.
     */
    distinct?: EquipmentCheckScalarFieldEnum | EquipmentCheckScalarFieldEnum[]
  }

  /**
   * EquipmentCheck findMany
   */
  export type EquipmentCheckFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentChecks to fetch.
     */
    where?: EquipmentCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentChecks to fetch.
     */
    orderBy?: EquipmentCheckOrderByWithRelationInput | EquipmentCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EquipmentChecks.
     */
    cursor?: EquipmentCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentChecks.
     */
    skip?: number
    distinct?: EquipmentCheckScalarFieldEnum | EquipmentCheckScalarFieldEnum[]
  }

  /**
   * EquipmentCheck create
   */
  export type EquipmentCheckCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    /**
     * The data needed to create a EquipmentCheck.
     */
    data: XOR<EquipmentCheckCreateInput, EquipmentCheckUncheckedCreateInput>
  }

  /**
   * EquipmentCheck createMany
   */
  export type EquipmentCheckCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EquipmentChecks.
     */
    data: EquipmentCheckCreateManyInput | EquipmentCheckCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EquipmentCheck createManyAndReturn
   */
  export type EquipmentCheckCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * The data used to create many EquipmentChecks.
     */
    data: EquipmentCheckCreateManyInput | EquipmentCheckCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EquipmentCheck update
   */
  export type EquipmentCheckUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    /**
     * The data needed to update a EquipmentCheck.
     */
    data: XOR<EquipmentCheckUpdateInput, EquipmentCheckUncheckedUpdateInput>
    /**
     * Choose, which EquipmentCheck to update.
     */
    where: EquipmentCheckWhereUniqueInput
  }

  /**
   * EquipmentCheck updateMany
   */
  export type EquipmentCheckUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EquipmentChecks.
     */
    data: XOR<EquipmentCheckUpdateManyMutationInput, EquipmentCheckUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentChecks to update
     */
    where?: EquipmentCheckWhereInput
    /**
     * Limit how many EquipmentChecks to update.
     */
    limit?: number
  }

  /**
   * EquipmentCheck updateManyAndReturn
   */
  export type EquipmentCheckUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * The data used to update EquipmentChecks.
     */
    data: XOR<EquipmentCheckUpdateManyMutationInput, EquipmentCheckUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentChecks to update
     */
    where?: EquipmentCheckWhereInput
    /**
     * Limit how many EquipmentChecks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EquipmentCheck upsert
   */
  export type EquipmentCheckUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    /**
     * The filter to search for the EquipmentCheck to update in case it exists.
     */
    where: EquipmentCheckWhereUniqueInput
    /**
     * In case the EquipmentCheck found by the `where` argument doesn't exist, create a new EquipmentCheck with this data.
     */
    create: XOR<EquipmentCheckCreateInput, EquipmentCheckUncheckedCreateInput>
    /**
     * In case the EquipmentCheck was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentCheckUpdateInput, EquipmentCheckUncheckedUpdateInput>
  }

  /**
   * EquipmentCheck delete
   */
  export type EquipmentCheckDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
    /**
     * Filter which EquipmentCheck to delete.
     */
    where: EquipmentCheckWhereUniqueInput
  }

  /**
   * EquipmentCheck deleteMany
   */
  export type EquipmentCheckDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentChecks to delete
     */
    where?: EquipmentCheckWhereInput
    /**
     * Limit how many EquipmentChecks to delete.
     */
    limit?: number
  }

  /**
   * EquipmentCheck without action
   */
  export type EquipmentCheckDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCheck
     */
    select?: EquipmentCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCheck
     */
    omit?: EquipmentCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCheckInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const MountainScalarFieldEnum: {
    id: 'id',
    name: 'name',
    latitude: 'latitude',
    longitude: 'longitude',
    height: 'height',
    hours: 'hours',
    phoneNumber: 'phoneNumber',
    address: 'address',
    city: 'city',
    state: 'state',
    zipcode: 'zipcode',
    openingDate: 'openingDate',
    closingDate: 'closingDate'
  };

  export type MountainScalarFieldEnum = (typeof MountainScalarFieldEnum)[keyof typeof MountainScalarFieldEnum]


  export const WeatherScalarFieldEnum: {
    id: 'id',
    mountainId: 'mountainId',
    date: 'date',
    temperature: 'temperature',
    windSpeed: 'windSpeed',
    windDirection: 'windDirection',
    visibility: 'visibility',
    conditions: 'conditions',
    snowfall24h: 'snowfall24h',
    snowfall7d: 'snowfall7d',
    updatedAt: 'updatedAt'
  };

  export type WeatherScalarFieldEnum = (typeof WeatherScalarFieldEnum)[keyof typeof WeatherScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    role: 'role',
    department: 'department',
    mountainId: 'mountainId'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const DispatcherAssignmentScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    assignedAt: 'assignedAt',
    mountainId: 'mountainId'
  };

  export type DispatcherAssignmentScalarFieldEnum = (typeof DispatcherAssignmentScalarFieldEnum)[keyof typeof DispatcherAssignmentScalarFieldEnum]


  export const LiftScalarFieldEnum: {
    id: 'id',
    name: 'name',
    capacity: 'capacity',
    status: 'status',
    mountainId: 'mountainId'
  };

  export type LiftScalarFieldEnum = (typeof LiftScalarFieldEnum)[keyof typeof LiftScalarFieldEnum]


  export const TrailScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    difficulty: 'difficulty',
    length: 'length',
    condition: 'condition',
    mountainId: 'mountainId'
  };

  export type TrailScalarFieldEnum = (typeof TrailScalarFieldEnum)[keyof typeof TrailScalarFieldEnum]


  export const LodgeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    capacity: 'capacity',
    status: 'status',
    mountainId: 'mountainId'
  };

  export type LodgeScalarFieldEnum = (typeof LodgeScalarFieldEnum)[keyof typeof LodgeScalarFieldEnum]


  export const HutScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    mountainId: 'mountainId'
  };

  export type HutScalarFieldEnum = (typeof HutScalarFieldEnum)[keyof typeof HutScalarFieldEnum]


  export const AidRoomScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    status: 'status',
    mountainId: 'mountainId'
  };

  export type AidRoomScalarFieldEnum = (typeof AidRoomScalarFieldEnum)[keyof typeof AidRoomScalarFieldEnum]


  export const EquipmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    status: 'status',
    service: 'service',
    mountainId: 'mountainId'
  };

  export type EquipmentScalarFieldEnum = (typeof EquipmentScalarFieldEnum)[keyof typeof EquipmentScalarFieldEnum]


  export const IncidentScalarFieldEnum: {
    id: 'id',
    description: 'description',
    status: 'status',
    mountainId: 'mountainId'
  };

  export type IncidentScalarFieldEnum = (typeof IncidentScalarFieldEnum)[keyof typeof IncidentScalarFieldEnum]


  export const IncidentLogScalarFieldEnum: {
    id: 'id',
    incidentId: 'incidentId',
    employeeId: 'employeeId',
    mountainId: 'mountainId',
    locationType: 'locationType',
    locationId: 'locationId',
    locationStatus: 'locationStatus',
    startTime: 'startTime',
    endTime: 'endTime',
    onSceneTime: 'onSceneTime',
    stableTime: 'stableTime',
    transportTime: 'transportTime',
    dryRun: 'dryRun',
    dryRunTime: 'dryRunTime'
  };

  export type IncidentLogScalarFieldEnum = (typeof IncidentLogScalarFieldEnum)[keyof typeof IncidentLogScalarFieldEnum]


  export const IncidentLogEquipmentScalarFieldEnum: {
    id: 'id',
    incidentLogId: 'incidentLogId',
    equipmentId: 'equipmentId',
    mountainId: 'mountainId',
    usedAt: 'usedAt',
    notes: 'notes'
  };

  export type IncidentLogEquipmentScalarFieldEnum = (typeof IncidentLogEquipmentScalarFieldEnum)[keyof typeof IncidentLogEquipmentScalarFieldEnum]


  export const LiftCheckScalarFieldEnum: {
    id: 'id',
    date: 'date',
    employeeId: 'employeeId',
    mountainId: 'mountainId',
    liftId: 'liftId',
    notes: 'notes'
  };

  export type LiftCheckScalarFieldEnum = (typeof LiftCheckScalarFieldEnum)[keyof typeof LiftCheckScalarFieldEnum]


  export const TrailCheckScalarFieldEnum: {
    id: 'id',
    date: 'date',
    employeeId: 'employeeId',
    mountainId: 'mountainId',
    trailId: 'trailId',
    notes: 'notes'
  };

  export type TrailCheckScalarFieldEnum = (typeof TrailCheckScalarFieldEnum)[keyof typeof TrailCheckScalarFieldEnum]


  export const HutCheckScalarFieldEnum: {
    id: 'id',
    date: 'date',
    employeeId: 'employeeId',
    mountainId: 'mountainId',
    hutId: 'hutId',
    notes: 'notes'
  };

  export type HutCheckScalarFieldEnum = (typeof HutCheckScalarFieldEnum)[keyof typeof HutCheckScalarFieldEnum]


  export const AidRoomCheckScalarFieldEnum: {
    id: 'id',
    date: 'date',
    employeeId: 'employeeId',
    mountainId: 'mountainId',
    aidRoomId: 'aidRoomId',
    notes: 'notes'
  };

  export type AidRoomCheckScalarFieldEnum = (typeof AidRoomCheckScalarFieldEnum)[keyof typeof AidRoomCheckScalarFieldEnum]


  export const EquipmentCheckScalarFieldEnum: {
    id: 'id',
    date: 'date',
    employeeId: 'employeeId',
    mountainId: 'mountainId',
    equipmentId: 'equipmentId',
    notes: 'notes'
  };

  export type EquipmentCheckScalarFieldEnum = (typeof EquipmentCheckScalarFieldEnum)[keyof typeof EquipmentCheckScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Department'
   */
  export type EnumDepartmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Department'>
    


  /**
   * Reference to a field of type 'Department[]'
   */
  export type ListEnumDepartmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Department[]'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'TrailDifficulty'
   */
  export type EnumTrailDifficultyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrailDifficulty'>
    


  /**
   * Reference to a field of type 'TrailDifficulty[]'
   */
  export type ListEnumTrailDifficultyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrailDifficulty[]'>
    


  /**
   * Reference to a field of type 'TrailCondition'
   */
  export type EnumTrailConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrailCondition'>
    


  /**
   * Reference to a field of type 'TrailCondition[]'
   */
  export type ListEnumTrailConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrailCondition[]'>
    


  /**
   * Reference to a field of type 'EquipmentStatus'
   */
  export type EnumEquipmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentStatus'>
    


  /**
   * Reference to a field of type 'EquipmentStatus[]'
   */
  export type ListEnumEquipmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentStatus[]'>
    


  /**
   * Reference to a field of type 'EquipmentService'
   */
  export type EnumEquipmentServiceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentService'>
    


  /**
   * Reference to a field of type 'EquipmentService[]'
   */
  export type ListEnumEquipmentServiceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentService[]'>
    


  /**
   * Reference to a field of type 'LocationType'
   */
  export type EnumLocationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LocationType'>
    


  /**
   * Reference to a field of type 'LocationType[]'
   */
  export type ListEnumLocationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LocationType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type MountainWhereInput = {
    AND?: MountainWhereInput | MountainWhereInput[]
    OR?: MountainWhereInput[]
    NOT?: MountainWhereInput | MountainWhereInput[]
    id?: StringFilter<"Mountain"> | string
    name?: StringFilter<"Mountain"> | string
    latitude?: FloatFilter<"Mountain"> | number
    longitude?: FloatFilter<"Mountain"> | number
    height?: IntFilter<"Mountain"> | number
    hours?: StringFilter<"Mountain"> | string
    phoneNumber?: StringFilter<"Mountain"> | string
    address?: StringFilter<"Mountain"> | string
    city?: StringFilter<"Mountain"> | string
    state?: StringFilter<"Mountain"> | string
    zipcode?: StringFilter<"Mountain"> | string
    openingDate?: DateTimeNullableFilter<"Mountain"> | Date | string | null
    closingDate?: DateTimeNullableFilter<"Mountain"> | Date | string | null
    lifts?: LiftListRelationFilter
    liftChecks?: LiftCheckListRelationFilter
    trails?: TrailListRelationFilter
    trailChecks?: TrailCheckListRelationFilter
    employees?: EmployeeListRelationFilter
    lodges?: LodgeListRelationFilter
    huts?: HutListRelationFilter
    hutChecks?: HutCheckListRelationFilter
    aidRooms?: AidRoomListRelationFilter
    aidRoomChecks?: AidRoomCheckListRelationFilter
    equipment?: EquipmentListRelationFilter
    equipmentChecks?: EquipmentCheckListRelationFilter
    incidents?: IncidentListRelationFilter
    incidentLogs?: IncidentLogListRelationFilter
    dispatcherAssignments?: DispatcherAssignmentListRelationFilter
    incidentLogEquipment?: IncidentLogEquipmentListRelationFilter
    weather?: WeatherListRelationFilter
  }

  export type MountainOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    height?: SortOrder
    hours?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    openingDate?: SortOrderInput | SortOrder
    closingDate?: SortOrderInput | SortOrder
    lifts?: LiftOrderByRelationAggregateInput
    liftChecks?: LiftCheckOrderByRelationAggregateInput
    trails?: TrailOrderByRelationAggregateInput
    trailChecks?: TrailCheckOrderByRelationAggregateInput
    employees?: EmployeeOrderByRelationAggregateInput
    lodges?: LodgeOrderByRelationAggregateInput
    huts?: HutOrderByRelationAggregateInput
    hutChecks?: HutCheckOrderByRelationAggregateInput
    aidRooms?: AidRoomOrderByRelationAggregateInput
    aidRoomChecks?: AidRoomCheckOrderByRelationAggregateInput
    equipment?: EquipmentOrderByRelationAggregateInput
    equipmentChecks?: EquipmentCheckOrderByRelationAggregateInput
    incidents?: IncidentOrderByRelationAggregateInput
    incidentLogs?: IncidentLogOrderByRelationAggregateInput
    dispatcherAssignments?: DispatcherAssignmentOrderByRelationAggregateInput
    incidentLogEquipment?: IncidentLogEquipmentOrderByRelationAggregateInput
    weather?: WeatherOrderByRelationAggregateInput
  }

  export type MountainWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: MountainWhereInput | MountainWhereInput[]
    OR?: MountainWhereInput[]
    NOT?: MountainWhereInput | MountainWhereInput[]
    latitude?: FloatFilter<"Mountain"> | number
    longitude?: FloatFilter<"Mountain"> | number
    height?: IntFilter<"Mountain"> | number
    hours?: StringFilter<"Mountain"> | string
    phoneNumber?: StringFilter<"Mountain"> | string
    address?: StringFilter<"Mountain"> | string
    city?: StringFilter<"Mountain"> | string
    state?: StringFilter<"Mountain"> | string
    zipcode?: StringFilter<"Mountain"> | string
    openingDate?: DateTimeNullableFilter<"Mountain"> | Date | string | null
    closingDate?: DateTimeNullableFilter<"Mountain"> | Date | string | null
    lifts?: LiftListRelationFilter
    liftChecks?: LiftCheckListRelationFilter
    trails?: TrailListRelationFilter
    trailChecks?: TrailCheckListRelationFilter
    employees?: EmployeeListRelationFilter
    lodges?: LodgeListRelationFilter
    huts?: HutListRelationFilter
    hutChecks?: HutCheckListRelationFilter
    aidRooms?: AidRoomListRelationFilter
    aidRoomChecks?: AidRoomCheckListRelationFilter
    equipment?: EquipmentListRelationFilter
    equipmentChecks?: EquipmentCheckListRelationFilter
    incidents?: IncidentListRelationFilter
    incidentLogs?: IncidentLogListRelationFilter
    dispatcherAssignments?: DispatcherAssignmentListRelationFilter
    incidentLogEquipment?: IncidentLogEquipmentListRelationFilter
    weather?: WeatherListRelationFilter
  }, "id" | "name">

  export type MountainOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    height?: SortOrder
    hours?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    openingDate?: SortOrderInput | SortOrder
    closingDate?: SortOrderInput | SortOrder
    _count?: MountainCountOrderByAggregateInput
    _avg?: MountainAvgOrderByAggregateInput
    _max?: MountainMaxOrderByAggregateInput
    _min?: MountainMinOrderByAggregateInput
    _sum?: MountainSumOrderByAggregateInput
  }

  export type MountainScalarWhereWithAggregatesInput = {
    AND?: MountainScalarWhereWithAggregatesInput | MountainScalarWhereWithAggregatesInput[]
    OR?: MountainScalarWhereWithAggregatesInput[]
    NOT?: MountainScalarWhereWithAggregatesInput | MountainScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Mountain"> | string
    name?: StringWithAggregatesFilter<"Mountain"> | string
    latitude?: FloatWithAggregatesFilter<"Mountain"> | number
    longitude?: FloatWithAggregatesFilter<"Mountain"> | number
    height?: IntWithAggregatesFilter<"Mountain"> | number
    hours?: StringWithAggregatesFilter<"Mountain"> | string
    phoneNumber?: StringWithAggregatesFilter<"Mountain"> | string
    address?: StringWithAggregatesFilter<"Mountain"> | string
    city?: StringWithAggregatesFilter<"Mountain"> | string
    state?: StringWithAggregatesFilter<"Mountain"> | string
    zipcode?: StringWithAggregatesFilter<"Mountain"> | string
    openingDate?: DateTimeNullableWithAggregatesFilter<"Mountain"> | Date | string | null
    closingDate?: DateTimeNullableWithAggregatesFilter<"Mountain"> | Date | string | null
  }

  export type WeatherWhereInput = {
    AND?: WeatherWhereInput | WeatherWhereInput[]
    OR?: WeatherWhereInput[]
    NOT?: WeatherWhereInput | WeatherWhereInput[]
    id?: StringFilter<"Weather"> | string
    mountainId?: StringFilter<"Weather"> | string
    date?: DateTimeFilter<"Weather"> | Date | string
    temperature?: FloatFilter<"Weather"> | number
    windSpeed?: FloatFilter<"Weather"> | number
    windDirection?: StringNullableFilter<"Weather"> | string | null
    visibility?: FloatNullableFilter<"Weather"> | number | null
    conditions?: StringFilter<"Weather"> | string
    snowfall24h?: FloatNullableFilter<"Weather"> | number | null
    snowfall7d?: FloatNullableFilter<"Weather"> | number | null
    updatedAt?: DateTimeFilter<"Weather"> | Date | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
  }

  export type WeatherOrderByWithRelationInput = {
    id?: SortOrder
    mountainId?: SortOrder
    date?: SortOrder
    temperature?: SortOrder
    windSpeed?: SortOrder
    windDirection?: SortOrderInput | SortOrder
    visibility?: SortOrderInput | SortOrder
    conditions?: SortOrder
    snowfall24h?: SortOrderInput | SortOrder
    snowfall7d?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    mountain?: MountainOrderByWithRelationInput
  }

  export type WeatherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WeatherWhereInput | WeatherWhereInput[]
    OR?: WeatherWhereInput[]
    NOT?: WeatherWhereInput | WeatherWhereInput[]
    mountainId?: StringFilter<"Weather"> | string
    date?: DateTimeFilter<"Weather"> | Date | string
    temperature?: FloatFilter<"Weather"> | number
    windSpeed?: FloatFilter<"Weather"> | number
    windDirection?: StringNullableFilter<"Weather"> | string | null
    visibility?: FloatNullableFilter<"Weather"> | number | null
    conditions?: StringFilter<"Weather"> | string
    snowfall24h?: FloatNullableFilter<"Weather"> | number | null
    snowfall7d?: FloatNullableFilter<"Weather"> | number | null
    updatedAt?: DateTimeFilter<"Weather"> | Date | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
  }, "id">

  export type WeatherOrderByWithAggregationInput = {
    id?: SortOrder
    mountainId?: SortOrder
    date?: SortOrder
    temperature?: SortOrder
    windSpeed?: SortOrder
    windDirection?: SortOrderInput | SortOrder
    visibility?: SortOrderInput | SortOrder
    conditions?: SortOrder
    snowfall24h?: SortOrderInput | SortOrder
    snowfall7d?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: WeatherCountOrderByAggregateInput
    _avg?: WeatherAvgOrderByAggregateInput
    _max?: WeatherMaxOrderByAggregateInput
    _min?: WeatherMinOrderByAggregateInput
    _sum?: WeatherSumOrderByAggregateInput
  }

  export type WeatherScalarWhereWithAggregatesInput = {
    AND?: WeatherScalarWhereWithAggregatesInput | WeatherScalarWhereWithAggregatesInput[]
    OR?: WeatherScalarWhereWithAggregatesInput[]
    NOT?: WeatherScalarWhereWithAggregatesInput | WeatherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Weather"> | string
    mountainId?: StringWithAggregatesFilter<"Weather"> | string
    date?: DateTimeWithAggregatesFilter<"Weather"> | Date | string
    temperature?: FloatWithAggregatesFilter<"Weather"> | number
    windSpeed?: FloatWithAggregatesFilter<"Weather"> | number
    windDirection?: StringNullableWithAggregatesFilter<"Weather"> | string | null
    visibility?: FloatNullableWithAggregatesFilter<"Weather"> | number | null
    conditions?: StringWithAggregatesFilter<"Weather"> | string
    snowfall24h?: FloatNullableWithAggregatesFilter<"Weather"> | number | null
    snowfall7d?: FloatNullableWithAggregatesFilter<"Weather"> | number | null
    updatedAt?: DateTimeWithAggregatesFilter<"Weather"> | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: StringFilter<"Employee"> | string
    name?: StringFilter<"Employee"> | string
    role?: StringFilter<"Employee"> | string
    department?: EnumDepartmentFilter<"Employee"> | $Enums.Department
    mountainId?: StringFilter<"Employee"> | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    dispatcherAssignments?: DispatcherAssignmentListRelationFilter
    logs?: IncidentLogListRelationFilter
    liftChecks?: LiftCheckListRelationFilter
    trailChecks?: TrailCheckListRelationFilter
    hutChecks?: HutCheckListRelationFilter
    aidRoomChecks?: AidRoomCheckListRelationFilter
    equipmentChecks?: EquipmentCheckListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrder
    mountainId?: SortOrder
    mountain?: MountainOrderByWithRelationInput
    dispatcherAssignments?: DispatcherAssignmentOrderByRelationAggregateInput
    logs?: IncidentLogOrderByRelationAggregateInput
    liftChecks?: LiftCheckOrderByRelationAggregateInput
    trailChecks?: TrailCheckOrderByRelationAggregateInput
    hutChecks?: HutCheckOrderByRelationAggregateInput
    aidRoomChecks?: AidRoomCheckOrderByRelationAggregateInput
    equipmentChecks?: EquipmentCheckOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    name?: StringFilter<"Employee"> | string
    role?: StringFilter<"Employee"> | string
    department?: EnumDepartmentFilter<"Employee"> | $Enums.Department
    mountainId?: StringFilter<"Employee"> | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    dispatcherAssignments?: DispatcherAssignmentListRelationFilter
    logs?: IncidentLogListRelationFilter
    liftChecks?: LiftCheckListRelationFilter
    trailChecks?: TrailCheckListRelationFilter
    hutChecks?: HutCheckListRelationFilter
    aidRoomChecks?: AidRoomCheckListRelationFilter
    equipmentChecks?: EquipmentCheckListRelationFilter
  }, "id">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrder
    mountainId?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Employee"> | string
    name?: StringWithAggregatesFilter<"Employee"> | string
    role?: StringWithAggregatesFilter<"Employee"> | string
    department?: EnumDepartmentWithAggregatesFilter<"Employee"> | $Enums.Department
    mountainId?: StringWithAggregatesFilter<"Employee"> | string
  }

  export type DispatcherAssignmentWhereInput = {
    AND?: DispatcherAssignmentWhereInput | DispatcherAssignmentWhereInput[]
    OR?: DispatcherAssignmentWhereInput[]
    NOT?: DispatcherAssignmentWhereInput | DispatcherAssignmentWhereInput[]
    id?: StringFilter<"DispatcherAssignment"> | string
    employeeId?: StringFilter<"DispatcherAssignment"> | string
    assignedAt?: DateTimeFilter<"DispatcherAssignment"> | Date | string
    mountainId?: StringFilter<"DispatcherAssignment"> | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
  }

  export type DispatcherAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    assignedAt?: SortOrder
    mountainId?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    mountain?: MountainOrderByWithRelationInput
  }

  export type DispatcherAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DispatcherAssignmentWhereInput | DispatcherAssignmentWhereInput[]
    OR?: DispatcherAssignmentWhereInput[]
    NOT?: DispatcherAssignmentWhereInput | DispatcherAssignmentWhereInput[]
    employeeId?: StringFilter<"DispatcherAssignment"> | string
    assignedAt?: DateTimeFilter<"DispatcherAssignment"> | Date | string
    mountainId?: StringFilter<"DispatcherAssignment"> | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
  }, "id">

  export type DispatcherAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    assignedAt?: SortOrder
    mountainId?: SortOrder
    _count?: DispatcherAssignmentCountOrderByAggregateInput
    _max?: DispatcherAssignmentMaxOrderByAggregateInput
    _min?: DispatcherAssignmentMinOrderByAggregateInput
  }

  export type DispatcherAssignmentScalarWhereWithAggregatesInput = {
    AND?: DispatcherAssignmentScalarWhereWithAggregatesInput | DispatcherAssignmentScalarWhereWithAggregatesInput[]
    OR?: DispatcherAssignmentScalarWhereWithAggregatesInput[]
    NOT?: DispatcherAssignmentScalarWhereWithAggregatesInput | DispatcherAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DispatcherAssignment"> | string
    employeeId?: StringWithAggregatesFilter<"DispatcherAssignment"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"DispatcherAssignment"> | Date | string
    mountainId?: StringWithAggregatesFilter<"DispatcherAssignment"> | string
  }

  export type LiftWhereInput = {
    AND?: LiftWhereInput | LiftWhereInput[]
    OR?: LiftWhereInput[]
    NOT?: LiftWhereInput | LiftWhereInput[]
    id?: StringFilter<"Lift"> | string
    name?: StringFilter<"Lift"> | string
    capacity?: IntFilter<"Lift"> | number
    status?: EnumStatusFilter<"Lift"> | $Enums.Status
    mountainId?: StringFilter<"Lift"> | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    incidentLogs?: IncidentLogListRelationFilter
    liftChecks?: LiftCheckListRelationFilter
  }

  export type LiftOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
    mountain?: MountainOrderByWithRelationInput
    incidentLogs?: IncidentLogOrderByRelationAggregateInput
    liftChecks?: LiftCheckOrderByRelationAggregateInput
  }

  export type LiftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LiftWhereInput | LiftWhereInput[]
    OR?: LiftWhereInput[]
    NOT?: LiftWhereInput | LiftWhereInput[]
    name?: StringFilter<"Lift"> | string
    capacity?: IntFilter<"Lift"> | number
    status?: EnumStatusFilter<"Lift"> | $Enums.Status
    mountainId?: StringFilter<"Lift"> | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    incidentLogs?: IncidentLogListRelationFilter
    liftChecks?: LiftCheckListRelationFilter
  }, "id">

  export type LiftOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
    _count?: LiftCountOrderByAggregateInput
    _avg?: LiftAvgOrderByAggregateInput
    _max?: LiftMaxOrderByAggregateInput
    _min?: LiftMinOrderByAggregateInput
    _sum?: LiftSumOrderByAggregateInput
  }

  export type LiftScalarWhereWithAggregatesInput = {
    AND?: LiftScalarWhereWithAggregatesInput | LiftScalarWhereWithAggregatesInput[]
    OR?: LiftScalarWhereWithAggregatesInput[]
    NOT?: LiftScalarWhereWithAggregatesInput | LiftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lift"> | string
    name?: StringWithAggregatesFilter<"Lift"> | string
    capacity?: IntWithAggregatesFilter<"Lift"> | number
    status?: EnumStatusWithAggregatesFilter<"Lift"> | $Enums.Status
    mountainId?: StringWithAggregatesFilter<"Lift"> | string
  }

  export type TrailWhereInput = {
    AND?: TrailWhereInput | TrailWhereInput[]
    OR?: TrailWhereInput[]
    NOT?: TrailWhereInput | TrailWhereInput[]
    id?: StringFilter<"Trail"> | string
    name?: StringFilter<"Trail"> | string
    status?: EnumStatusFilter<"Trail"> | $Enums.Status
    difficulty?: EnumTrailDifficultyFilter<"Trail"> | $Enums.TrailDifficulty
    length?: FloatFilter<"Trail"> | number
    condition?: EnumTrailConditionFilter<"Trail"> | $Enums.TrailCondition
    mountainId?: StringFilter<"Trail"> | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    incidentLogs?: IncidentLogListRelationFilter
    trailChecks?: TrailCheckListRelationFilter
  }

  export type TrailOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    difficulty?: SortOrder
    length?: SortOrder
    condition?: SortOrder
    mountainId?: SortOrder
    mountain?: MountainOrderByWithRelationInput
    incidentLogs?: IncidentLogOrderByRelationAggregateInput
    trailChecks?: TrailCheckOrderByRelationAggregateInput
  }

  export type TrailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrailWhereInput | TrailWhereInput[]
    OR?: TrailWhereInput[]
    NOT?: TrailWhereInput | TrailWhereInput[]
    name?: StringFilter<"Trail"> | string
    status?: EnumStatusFilter<"Trail"> | $Enums.Status
    difficulty?: EnumTrailDifficultyFilter<"Trail"> | $Enums.TrailDifficulty
    length?: FloatFilter<"Trail"> | number
    condition?: EnumTrailConditionFilter<"Trail"> | $Enums.TrailCondition
    mountainId?: StringFilter<"Trail"> | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    incidentLogs?: IncidentLogListRelationFilter
    trailChecks?: TrailCheckListRelationFilter
  }, "id">

  export type TrailOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    difficulty?: SortOrder
    length?: SortOrder
    condition?: SortOrder
    mountainId?: SortOrder
    _count?: TrailCountOrderByAggregateInput
    _avg?: TrailAvgOrderByAggregateInput
    _max?: TrailMaxOrderByAggregateInput
    _min?: TrailMinOrderByAggregateInput
    _sum?: TrailSumOrderByAggregateInput
  }

  export type TrailScalarWhereWithAggregatesInput = {
    AND?: TrailScalarWhereWithAggregatesInput | TrailScalarWhereWithAggregatesInput[]
    OR?: TrailScalarWhereWithAggregatesInput[]
    NOT?: TrailScalarWhereWithAggregatesInput | TrailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Trail"> | string
    name?: StringWithAggregatesFilter<"Trail"> | string
    status?: EnumStatusWithAggregatesFilter<"Trail"> | $Enums.Status
    difficulty?: EnumTrailDifficultyWithAggregatesFilter<"Trail"> | $Enums.TrailDifficulty
    length?: FloatWithAggregatesFilter<"Trail"> | number
    condition?: EnumTrailConditionWithAggregatesFilter<"Trail"> | $Enums.TrailCondition
    mountainId?: StringWithAggregatesFilter<"Trail"> | string
  }

  export type LodgeWhereInput = {
    AND?: LodgeWhereInput | LodgeWhereInput[]
    OR?: LodgeWhereInput[]
    NOT?: LodgeWhereInput | LodgeWhereInput[]
    id?: StringFilter<"Lodge"> | string
    name?: StringFilter<"Lodge"> | string
    capacity?: IntFilter<"Lodge"> | number
    status?: EnumStatusFilter<"Lodge"> | $Enums.Status
    mountainId?: StringFilter<"Lodge"> | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    incidentLogs?: IncidentLogListRelationFilter
  }

  export type LodgeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
    mountain?: MountainOrderByWithRelationInput
    incidentLogs?: IncidentLogOrderByRelationAggregateInput
  }

  export type LodgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LodgeWhereInput | LodgeWhereInput[]
    OR?: LodgeWhereInput[]
    NOT?: LodgeWhereInput | LodgeWhereInput[]
    name?: StringFilter<"Lodge"> | string
    capacity?: IntFilter<"Lodge"> | number
    status?: EnumStatusFilter<"Lodge"> | $Enums.Status
    mountainId?: StringFilter<"Lodge"> | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    incidentLogs?: IncidentLogListRelationFilter
  }, "id">

  export type LodgeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
    _count?: LodgeCountOrderByAggregateInput
    _avg?: LodgeAvgOrderByAggregateInput
    _max?: LodgeMaxOrderByAggregateInput
    _min?: LodgeMinOrderByAggregateInput
    _sum?: LodgeSumOrderByAggregateInput
  }

  export type LodgeScalarWhereWithAggregatesInput = {
    AND?: LodgeScalarWhereWithAggregatesInput | LodgeScalarWhereWithAggregatesInput[]
    OR?: LodgeScalarWhereWithAggregatesInput[]
    NOT?: LodgeScalarWhereWithAggregatesInput | LodgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lodge"> | string
    name?: StringWithAggregatesFilter<"Lodge"> | string
    capacity?: IntWithAggregatesFilter<"Lodge"> | number
    status?: EnumStatusWithAggregatesFilter<"Lodge"> | $Enums.Status
    mountainId?: StringWithAggregatesFilter<"Lodge"> | string
  }

  export type HutWhereInput = {
    AND?: HutWhereInput | HutWhereInput[]
    OR?: HutWhereInput[]
    NOT?: HutWhereInput | HutWhereInput[]
    id?: StringFilter<"Hut"> | string
    name?: StringFilter<"Hut"> | string
    status?: EnumStatusFilter<"Hut"> | $Enums.Status
    mountainId?: StringFilter<"Hut"> | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    incidentLogs?: IncidentLogListRelationFilter
    hutChecks?: HutCheckListRelationFilter
  }

  export type HutOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
    mountain?: MountainOrderByWithRelationInput
    incidentLogs?: IncidentLogOrderByRelationAggregateInput
    hutChecks?: HutCheckOrderByRelationAggregateInput
  }

  export type HutWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HutWhereInput | HutWhereInput[]
    OR?: HutWhereInput[]
    NOT?: HutWhereInput | HutWhereInput[]
    name?: StringFilter<"Hut"> | string
    status?: EnumStatusFilter<"Hut"> | $Enums.Status
    mountainId?: StringFilter<"Hut"> | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    incidentLogs?: IncidentLogListRelationFilter
    hutChecks?: HutCheckListRelationFilter
  }, "id">

  export type HutOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
    _count?: HutCountOrderByAggregateInput
    _max?: HutMaxOrderByAggregateInput
    _min?: HutMinOrderByAggregateInput
  }

  export type HutScalarWhereWithAggregatesInput = {
    AND?: HutScalarWhereWithAggregatesInput | HutScalarWhereWithAggregatesInput[]
    OR?: HutScalarWhereWithAggregatesInput[]
    NOT?: HutScalarWhereWithAggregatesInput | HutScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Hut"> | string
    name?: StringWithAggregatesFilter<"Hut"> | string
    status?: EnumStatusWithAggregatesFilter<"Hut"> | $Enums.Status
    mountainId?: StringWithAggregatesFilter<"Hut"> | string
  }

  export type AidRoomWhereInput = {
    AND?: AidRoomWhereInput | AidRoomWhereInput[]
    OR?: AidRoomWhereInput[]
    NOT?: AidRoomWhereInput | AidRoomWhereInput[]
    id?: StringFilter<"AidRoom"> | string
    name?: StringFilter<"AidRoom"> | string
    location?: StringFilter<"AidRoom"> | string
    status?: EnumStatusFilter<"AidRoom"> | $Enums.Status
    mountainId?: StringFilter<"AidRoom"> | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    incidentLogs?: IncidentLogListRelationFilter
    aidRoomChecks?: AidRoomCheckListRelationFilter
  }

  export type AidRoomOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
    mountain?: MountainOrderByWithRelationInput
    incidentLogs?: IncidentLogOrderByRelationAggregateInput
    aidRoomChecks?: AidRoomCheckOrderByRelationAggregateInput
  }

  export type AidRoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AidRoomWhereInput | AidRoomWhereInput[]
    OR?: AidRoomWhereInput[]
    NOT?: AidRoomWhereInput | AidRoomWhereInput[]
    name?: StringFilter<"AidRoom"> | string
    location?: StringFilter<"AidRoom"> | string
    status?: EnumStatusFilter<"AidRoom"> | $Enums.Status
    mountainId?: StringFilter<"AidRoom"> | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    incidentLogs?: IncidentLogListRelationFilter
    aidRoomChecks?: AidRoomCheckListRelationFilter
  }, "id">

  export type AidRoomOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
    _count?: AidRoomCountOrderByAggregateInput
    _max?: AidRoomMaxOrderByAggregateInput
    _min?: AidRoomMinOrderByAggregateInput
  }

  export type AidRoomScalarWhereWithAggregatesInput = {
    AND?: AidRoomScalarWhereWithAggregatesInput | AidRoomScalarWhereWithAggregatesInput[]
    OR?: AidRoomScalarWhereWithAggregatesInput[]
    NOT?: AidRoomScalarWhereWithAggregatesInput | AidRoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AidRoom"> | string
    name?: StringWithAggregatesFilter<"AidRoom"> | string
    location?: StringWithAggregatesFilter<"AidRoom"> | string
    status?: EnumStatusWithAggregatesFilter<"AidRoom"> | $Enums.Status
    mountainId?: StringWithAggregatesFilter<"AidRoom"> | string
  }

  export type EquipmentWhereInput = {
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    id?: StringFilter<"Equipment"> | string
    name?: StringFilter<"Equipment"> | string
    type?: StringFilter<"Equipment"> | string
    status?: EnumEquipmentStatusFilter<"Equipment"> | $Enums.EquipmentStatus
    service?: EnumEquipmentServiceFilter<"Equipment"> | $Enums.EquipmentService
    mountainId?: StringFilter<"Equipment"> | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    usedInLogs?: IncidentLogEquipmentListRelationFilter
    equipmentChecks?: EquipmentCheckListRelationFilter
  }

  export type EquipmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    service?: SortOrder
    mountainId?: SortOrder
    mountain?: MountainOrderByWithRelationInput
    usedInLogs?: IncidentLogEquipmentOrderByRelationAggregateInput
    equipmentChecks?: EquipmentCheckOrderByRelationAggregateInput
  }

  export type EquipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    name?: StringFilter<"Equipment"> | string
    type?: StringFilter<"Equipment"> | string
    status?: EnumEquipmentStatusFilter<"Equipment"> | $Enums.EquipmentStatus
    service?: EnumEquipmentServiceFilter<"Equipment"> | $Enums.EquipmentService
    mountainId?: StringFilter<"Equipment"> | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    usedInLogs?: IncidentLogEquipmentListRelationFilter
    equipmentChecks?: EquipmentCheckListRelationFilter
  }, "id">

  export type EquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    service?: SortOrder
    mountainId?: SortOrder
    _count?: EquipmentCountOrderByAggregateInput
    _max?: EquipmentMaxOrderByAggregateInput
    _min?: EquipmentMinOrderByAggregateInput
  }

  export type EquipmentScalarWhereWithAggregatesInput = {
    AND?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    OR?: EquipmentScalarWhereWithAggregatesInput[]
    NOT?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Equipment"> | string
    name?: StringWithAggregatesFilter<"Equipment"> | string
    type?: StringWithAggregatesFilter<"Equipment"> | string
    status?: EnumEquipmentStatusWithAggregatesFilter<"Equipment"> | $Enums.EquipmentStatus
    service?: EnumEquipmentServiceWithAggregatesFilter<"Equipment"> | $Enums.EquipmentService
    mountainId?: StringWithAggregatesFilter<"Equipment"> | string
  }

  export type IncidentWhereInput = {
    AND?: IncidentWhereInput | IncidentWhereInput[]
    OR?: IncidentWhereInput[]
    NOT?: IncidentWhereInput | IncidentWhereInput[]
    id?: StringFilter<"Incident"> | string
    description?: StringFilter<"Incident"> | string
    status?: EnumStatusFilter<"Incident"> | $Enums.Status
    mountainId?: StringFilter<"Incident"> | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    logs?: IncidentLogListRelationFilter
  }

  export type IncidentOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
    mountain?: MountainOrderByWithRelationInput
    logs?: IncidentLogOrderByRelationAggregateInput
  }

  export type IncidentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncidentWhereInput | IncidentWhereInput[]
    OR?: IncidentWhereInput[]
    NOT?: IncidentWhereInput | IncidentWhereInput[]
    description?: StringFilter<"Incident"> | string
    status?: EnumStatusFilter<"Incident"> | $Enums.Status
    mountainId?: StringFilter<"Incident"> | string
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    logs?: IncidentLogListRelationFilter
  }, "id">

  export type IncidentOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
    _count?: IncidentCountOrderByAggregateInput
    _max?: IncidentMaxOrderByAggregateInput
    _min?: IncidentMinOrderByAggregateInput
  }

  export type IncidentScalarWhereWithAggregatesInput = {
    AND?: IncidentScalarWhereWithAggregatesInput | IncidentScalarWhereWithAggregatesInput[]
    OR?: IncidentScalarWhereWithAggregatesInput[]
    NOT?: IncidentScalarWhereWithAggregatesInput | IncidentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Incident"> | string
    description?: StringWithAggregatesFilter<"Incident"> | string
    status?: EnumStatusWithAggregatesFilter<"Incident"> | $Enums.Status
    mountainId?: StringWithAggregatesFilter<"Incident"> | string
  }

  export type IncidentLogWhereInput = {
    AND?: IncidentLogWhereInput | IncidentLogWhereInput[]
    OR?: IncidentLogWhereInput[]
    NOT?: IncidentLogWhereInput | IncidentLogWhereInput[]
    id?: StringFilter<"IncidentLog"> | string
    incidentId?: StringFilter<"IncidentLog"> | string
    employeeId?: StringFilter<"IncidentLog"> | string
    mountainId?: StringFilter<"IncidentLog"> | string
    locationType?: EnumLocationTypeFilter<"IncidentLog"> | $Enums.LocationType
    locationId?: StringFilter<"IncidentLog"> | string
    locationStatus?: StringFilter<"IncidentLog"> | string
    startTime?: DateTimeFilter<"IncidentLog"> | Date | string
    endTime?: DateTimeFilter<"IncidentLog"> | Date | string
    onSceneTime?: DateTimeNullableFilter<"IncidentLog"> | Date | string | null
    stableTime?: DateTimeNullableFilter<"IncidentLog"> | Date | string | null
    transportTime?: DateTimeNullableFilter<"IncidentLog"> | Date | string | null
    dryRun?: BoolFilter<"IncidentLog"> | boolean
    dryRunTime?: DateTimeNullableFilter<"IncidentLog"> | Date | string | null
    incident?: XOR<IncidentScalarRelationFilter, IncidentWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    equipmentUsed?: IncidentLogEquipmentListRelationFilter
    lift?: XOR<LiftNullableScalarRelationFilter, LiftWhereInput> | null
    trail?: XOR<TrailNullableScalarRelationFilter, TrailWhereInput> | null
    lodge?: XOR<LodgeNullableScalarRelationFilter, LodgeWhereInput> | null
    hut?: XOR<HutNullableScalarRelationFilter, HutWhereInput> | null
    aidRoom?: XOR<AidRoomNullableScalarRelationFilter, AidRoomWhereInput> | null
  }

  export type IncidentLogOrderByWithRelationInput = {
    id?: SortOrder
    incidentId?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    locationType?: SortOrder
    locationId?: SortOrder
    locationStatus?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    onSceneTime?: SortOrderInput | SortOrder
    stableTime?: SortOrderInput | SortOrder
    transportTime?: SortOrderInput | SortOrder
    dryRun?: SortOrder
    dryRunTime?: SortOrderInput | SortOrder
    incident?: IncidentOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
    mountain?: MountainOrderByWithRelationInput
    equipmentUsed?: IncidentLogEquipmentOrderByRelationAggregateInput
    lift?: LiftOrderByWithRelationInput
    trail?: TrailOrderByWithRelationInput
    lodge?: LodgeOrderByWithRelationInput
    hut?: HutOrderByWithRelationInput
    aidRoom?: AidRoomOrderByWithRelationInput
  }

  export type IncidentLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncidentLogWhereInput | IncidentLogWhereInput[]
    OR?: IncidentLogWhereInput[]
    NOT?: IncidentLogWhereInput | IncidentLogWhereInput[]
    incidentId?: StringFilter<"IncidentLog"> | string
    employeeId?: StringFilter<"IncidentLog"> | string
    mountainId?: StringFilter<"IncidentLog"> | string
    locationType?: EnumLocationTypeFilter<"IncidentLog"> | $Enums.LocationType
    locationId?: StringFilter<"IncidentLog"> | string
    locationStatus?: StringFilter<"IncidentLog"> | string
    startTime?: DateTimeFilter<"IncidentLog"> | Date | string
    endTime?: DateTimeFilter<"IncidentLog"> | Date | string
    onSceneTime?: DateTimeNullableFilter<"IncidentLog"> | Date | string | null
    stableTime?: DateTimeNullableFilter<"IncidentLog"> | Date | string | null
    transportTime?: DateTimeNullableFilter<"IncidentLog"> | Date | string | null
    dryRun?: BoolFilter<"IncidentLog"> | boolean
    dryRunTime?: DateTimeNullableFilter<"IncidentLog"> | Date | string | null
    incident?: XOR<IncidentScalarRelationFilter, IncidentWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    equipmentUsed?: IncidentLogEquipmentListRelationFilter
    lift?: XOR<LiftNullableScalarRelationFilter, LiftWhereInput> | null
    trail?: XOR<TrailNullableScalarRelationFilter, TrailWhereInput> | null
    lodge?: XOR<LodgeNullableScalarRelationFilter, LodgeWhereInput> | null
    hut?: XOR<HutNullableScalarRelationFilter, HutWhereInput> | null
    aidRoom?: XOR<AidRoomNullableScalarRelationFilter, AidRoomWhereInput> | null
  }, "id">

  export type IncidentLogOrderByWithAggregationInput = {
    id?: SortOrder
    incidentId?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    locationType?: SortOrder
    locationId?: SortOrder
    locationStatus?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    onSceneTime?: SortOrderInput | SortOrder
    stableTime?: SortOrderInput | SortOrder
    transportTime?: SortOrderInput | SortOrder
    dryRun?: SortOrder
    dryRunTime?: SortOrderInput | SortOrder
    _count?: IncidentLogCountOrderByAggregateInput
    _max?: IncidentLogMaxOrderByAggregateInput
    _min?: IncidentLogMinOrderByAggregateInput
  }

  export type IncidentLogScalarWhereWithAggregatesInput = {
    AND?: IncidentLogScalarWhereWithAggregatesInput | IncidentLogScalarWhereWithAggregatesInput[]
    OR?: IncidentLogScalarWhereWithAggregatesInput[]
    NOT?: IncidentLogScalarWhereWithAggregatesInput | IncidentLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IncidentLog"> | string
    incidentId?: StringWithAggregatesFilter<"IncidentLog"> | string
    employeeId?: StringWithAggregatesFilter<"IncidentLog"> | string
    mountainId?: StringWithAggregatesFilter<"IncidentLog"> | string
    locationType?: EnumLocationTypeWithAggregatesFilter<"IncidentLog"> | $Enums.LocationType
    locationId?: StringWithAggregatesFilter<"IncidentLog"> | string
    locationStatus?: StringWithAggregatesFilter<"IncidentLog"> | string
    startTime?: DateTimeWithAggregatesFilter<"IncidentLog"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"IncidentLog"> | Date | string
    onSceneTime?: DateTimeNullableWithAggregatesFilter<"IncidentLog"> | Date | string | null
    stableTime?: DateTimeNullableWithAggregatesFilter<"IncidentLog"> | Date | string | null
    transportTime?: DateTimeNullableWithAggregatesFilter<"IncidentLog"> | Date | string | null
    dryRun?: BoolWithAggregatesFilter<"IncidentLog"> | boolean
    dryRunTime?: DateTimeNullableWithAggregatesFilter<"IncidentLog"> | Date | string | null
  }

  export type IncidentLogEquipmentWhereInput = {
    AND?: IncidentLogEquipmentWhereInput | IncidentLogEquipmentWhereInput[]
    OR?: IncidentLogEquipmentWhereInput[]
    NOT?: IncidentLogEquipmentWhereInput | IncidentLogEquipmentWhereInput[]
    id?: StringFilter<"IncidentLogEquipment"> | string
    incidentLogId?: StringFilter<"IncidentLogEquipment"> | string
    equipmentId?: StringFilter<"IncidentLogEquipment"> | string
    mountainId?: StringFilter<"IncidentLogEquipment"> | string
    usedAt?: DateTimeFilter<"IncidentLogEquipment"> | Date | string
    notes?: StringNullableFilter<"IncidentLogEquipment"> | string | null
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    incidentLog?: XOR<IncidentLogScalarRelationFilter, IncidentLogWhereInput>
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
  }

  export type IncidentLogEquipmentOrderByWithRelationInput = {
    id?: SortOrder
    incidentLogId?: SortOrder
    equipmentId?: SortOrder
    mountainId?: SortOrder
    usedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    mountain?: MountainOrderByWithRelationInput
    incidentLog?: IncidentLogOrderByWithRelationInput
    equipment?: EquipmentOrderByWithRelationInput
  }

  export type IncidentLogEquipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncidentLogEquipmentWhereInput | IncidentLogEquipmentWhereInput[]
    OR?: IncidentLogEquipmentWhereInput[]
    NOT?: IncidentLogEquipmentWhereInput | IncidentLogEquipmentWhereInput[]
    incidentLogId?: StringFilter<"IncidentLogEquipment"> | string
    equipmentId?: StringFilter<"IncidentLogEquipment"> | string
    mountainId?: StringFilter<"IncidentLogEquipment"> | string
    usedAt?: DateTimeFilter<"IncidentLogEquipment"> | Date | string
    notes?: StringNullableFilter<"IncidentLogEquipment"> | string | null
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    incidentLog?: XOR<IncidentLogScalarRelationFilter, IncidentLogWhereInput>
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
  }, "id">

  export type IncidentLogEquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    incidentLogId?: SortOrder
    equipmentId?: SortOrder
    mountainId?: SortOrder
    usedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: IncidentLogEquipmentCountOrderByAggregateInput
    _max?: IncidentLogEquipmentMaxOrderByAggregateInput
    _min?: IncidentLogEquipmentMinOrderByAggregateInput
  }

  export type IncidentLogEquipmentScalarWhereWithAggregatesInput = {
    AND?: IncidentLogEquipmentScalarWhereWithAggregatesInput | IncidentLogEquipmentScalarWhereWithAggregatesInput[]
    OR?: IncidentLogEquipmentScalarWhereWithAggregatesInput[]
    NOT?: IncidentLogEquipmentScalarWhereWithAggregatesInput | IncidentLogEquipmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IncidentLogEquipment"> | string
    incidentLogId?: StringWithAggregatesFilter<"IncidentLogEquipment"> | string
    equipmentId?: StringWithAggregatesFilter<"IncidentLogEquipment"> | string
    mountainId?: StringWithAggregatesFilter<"IncidentLogEquipment"> | string
    usedAt?: DateTimeWithAggregatesFilter<"IncidentLogEquipment"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"IncidentLogEquipment"> | string | null
  }

  export type LiftCheckWhereInput = {
    AND?: LiftCheckWhereInput | LiftCheckWhereInput[]
    OR?: LiftCheckWhereInput[]
    NOT?: LiftCheckWhereInput | LiftCheckWhereInput[]
    id?: StringFilter<"LiftCheck"> | string
    date?: DateTimeFilter<"LiftCheck"> | Date | string
    employeeId?: StringFilter<"LiftCheck"> | string
    mountainId?: StringFilter<"LiftCheck"> | string
    liftId?: StringFilter<"LiftCheck"> | string
    notes?: StringNullableFilter<"LiftCheck"> | string | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    lift?: XOR<LiftScalarRelationFilter, LiftWhereInput>
  }

  export type LiftCheckOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    liftId?: SortOrder
    notes?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
    mountain?: MountainOrderByWithRelationInput
    lift?: LiftOrderByWithRelationInput
  }

  export type LiftCheckWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LiftCheckWhereInput | LiftCheckWhereInput[]
    OR?: LiftCheckWhereInput[]
    NOT?: LiftCheckWhereInput | LiftCheckWhereInput[]
    date?: DateTimeFilter<"LiftCheck"> | Date | string
    employeeId?: StringFilter<"LiftCheck"> | string
    mountainId?: StringFilter<"LiftCheck"> | string
    liftId?: StringFilter<"LiftCheck"> | string
    notes?: StringNullableFilter<"LiftCheck"> | string | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    lift?: XOR<LiftScalarRelationFilter, LiftWhereInput>
  }, "id">

  export type LiftCheckOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    liftId?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: LiftCheckCountOrderByAggregateInput
    _max?: LiftCheckMaxOrderByAggregateInput
    _min?: LiftCheckMinOrderByAggregateInput
  }

  export type LiftCheckScalarWhereWithAggregatesInput = {
    AND?: LiftCheckScalarWhereWithAggregatesInput | LiftCheckScalarWhereWithAggregatesInput[]
    OR?: LiftCheckScalarWhereWithAggregatesInput[]
    NOT?: LiftCheckScalarWhereWithAggregatesInput | LiftCheckScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LiftCheck"> | string
    date?: DateTimeWithAggregatesFilter<"LiftCheck"> | Date | string
    employeeId?: StringWithAggregatesFilter<"LiftCheck"> | string
    mountainId?: StringWithAggregatesFilter<"LiftCheck"> | string
    liftId?: StringWithAggregatesFilter<"LiftCheck"> | string
    notes?: StringNullableWithAggregatesFilter<"LiftCheck"> | string | null
  }

  export type TrailCheckWhereInput = {
    AND?: TrailCheckWhereInput | TrailCheckWhereInput[]
    OR?: TrailCheckWhereInput[]
    NOT?: TrailCheckWhereInput | TrailCheckWhereInput[]
    id?: StringFilter<"TrailCheck"> | string
    date?: DateTimeFilter<"TrailCheck"> | Date | string
    employeeId?: StringFilter<"TrailCheck"> | string
    mountainId?: StringFilter<"TrailCheck"> | string
    trailId?: StringFilter<"TrailCheck"> | string
    notes?: StringNullableFilter<"TrailCheck"> | string | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    trail?: XOR<TrailScalarRelationFilter, TrailWhereInput>
  }

  export type TrailCheckOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    trailId?: SortOrder
    notes?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
    mountain?: MountainOrderByWithRelationInput
    trail?: TrailOrderByWithRelationInput
  }

  export type TrailCheckWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrailCheckWhereInput | TrailCheckWhereInput[]
    OR?: TrailCheckWhereInput[]
    NOT?: TrailCheckWhereInput | TrailCheckWhereInput[]
    date?: DateTimeFilter<"TrailCheck"> | Date | string
    employeeId?: StringFilter<"TrailCheck"> | string
    mountainId?: StringFilter<"TrailCheck"> | string
    trailId?: StringFilter<"TrailCheck"> | string
    notes?: StringNullableFilter<"TrailCheck"> | string | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    trail?: XOR<TrailScalarRelationFilter, TrailWhereInput>
  }, "id">

  export type TrailCheckOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    trailId?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: TrailCheckCountOrderByAggregateInput
    _max?: TrailCheckMaxOrderByAggregateInput
    _min?: TrailCheckMinOrderByAggregateInput
  }

  export type TrailCheckScalarWhereWithAggregatesInput = {
    AND?: TrailCheckScalarWhereWithAggregatesInput | TrailCheckScalarWhereWithAggregatesInput[]
    OR?: TrailCheckScalarWhereWithAggregatesInput[]
    NOT?: TrailCheckScalarWhereWithAggregatesInput | TrailCheckScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrailCheck"> | string
    date?: DateTimeWithAggregatesFilter<"TrailCheck"> | Date | string
    employeeId?: StringWithAggregatesFilter<"TrailCheck"> | string
    mountainId?: StringWithAggregatesFilter<"TrailCheck"> | string
    trailId?: StringWithAggregatesFilter<"TrailCheck"> | string
    notes?: StringNullableWithAggregatesFilter<"TrailCheck"> | string | null
  }

  export type HutCheckWhereInput = {
    AND?: HutCheckWhereInput | HutCheckWhereInput[]
    OR?: HutCheckWhereInput[]
    NOT?: HutCheckWhereInput | HutCheckWhereInput[]
    id?: StringFilter<"HutCheck"> | string
    date?: DateTimeFilter<"HutCheck"> | Date | string
    employeeId?: StringFilter<"HutCheck"> | string
    mountainId?: StringFilter<"HutCheck"> | string
    hutId?: StringFilter<"HutCheck"> | string
    notes?: StringNullableFilter<"HutCheck"> | string | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    hut?: XOR<HutScalarRelationFilter, HutWhereInput>
  }

  export type HutCheckOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    hutId?: SortOrder
    notes?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
    mountain?: MountainOrderByWithRelationInput
    hut?: HutOrderByWithRelationInput
  }

  export type HutCheckWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HutCheckWhereInput | HutCheckWhereInput[]
    OR?: HutCheckWhereInput[]
    NOT?: HutCheckWhereInput | HutCheckWhereInput[]
    date?: DateTimeFilter<"HutCheck"> | Date | string
    employeeId?: StringFilter<"HutCheck"> | string
    mountainId?: StringFilter<"HutCheck"> | string
    hutId?: StringFilter<"HutCheck"> | string
    notes?: StringNullableFilter<"HutCheck"> | string | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    hut?: XOR<HutScalarRelationFilter, HutWhereInput>
  }, "id">

  export type HutCheckOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    hutId?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: HutCheckCountOrderByAggregateInput
    _max?: HutCheckMaxOrderByAggregateInput
    _min?: HutCheckMinOrderByAggregateInput
  }

  export type HutCheckScalarWhereWithAggregatesInput = {
    AND?: HutCheckScalarWhereWithAggregatesInput | HutCheckScalarWhereWithAggregatesInput[]
    OR?: HutCheckScalarWhereWithAggregatesInput[]
    NOT?: HutCheckScalarWhereWithAggregatesInput | HutCheckScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HutCheck"> | string
    date?: DateTimeWithAggregatesFilter<"HutCheck"> | Date | string
    employeeId?: StringWithAggregatesFilter<"HutCheck"> | string
    mountainId?: StringWithAggregatesFilter<"HutCheck"> | string
    hutId?: StringWithAggregatesFilter<"HutCheck"> | string
    notes?: StringNullableWithAggregatesFilter<"HutCheck"> | string | null
  }

  export type AidRoomCheckWhereInput = {
    AND?: AidRoomCheckWhereInput | AidRoomCheckWhereInput[]
    OR?: AidRoomCheckWhereInput[]
    NOT?: AidRoomCheckWhereInput | AidRoomCheckWhereInput[]
    id?: StringFilter<"AidRoomCheck"> | string
    date?: DateTimeFilter<"AidRoomCheck"> | Date | string
    employeeId?: StringFilter<"AidRoomCheck"> | string
    mountainId?: StringFilter<"AidRoomCheck"> | string
    aidRoomId?: StringFilter<"AidRoomCheck"> | string
    notes?: StringNullableFilter<"AidRoomCheck"> | string | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    aidRoom?: XOR<AidRoomScalarRelationFilter, AidRoomWhereInput>
  }

  export type AidRoomCheckOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    aidRoomId?: SortOrder
    notes?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
    mountain?: MountainOrderByWithRelationInput
    aidRoom?: AidRoomOrderByWithRelationInput
  }

  export type AidRoomCheckWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AidRoomCheckWhereInput | AidRoomCheckWhereInput[]
    OR?: AidRoomCheckWhereInput[]
    NOT?: AidRoomCheckWhereInput | AidRoomCheckWhereInput[]
    date?: DateTimeFilter<"AidRoomCheck"> | Date | string
    employeeId?: StringFilter<"AidRoomCheck"> | string
    mountainId?: StringFilter<"AidRoomCheck"> | string
    aidRoomId?: StringFilter<"AidRoomCheck"> | string
    notes?: StringNullableFilter<"AidRoomCheck"> | string | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    aidRoom?: XOR<AidRoomScalarRelationFilter, AidRoomWhereInput>
  }, "id">

  export type AidRoomCheckOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    aidRoomId?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: AidRoomCheckCountOrderByAggregateInput
    _max?: AidRoomCheckMaxOrderByAggregateInput
    _min?: AidRoomCheckMinOrderByAggregateInput
  }

  export type AidRoomCheckScalarWhereWithAggregatesInput = {
    AND?: AidRoomCheckScalarWhereWithAggregatesInput | AidRoomCheckScalarWhereWithAggregatesInput[]
    OR?: AidRoomCheckScalarWhereWithAggregatesInput[]
    NOT?: AidRoomCheckScalarWhereWithAggregatesInput | AidRoomCheckScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AidRoomCheck"> | string
    date?: DateTimeWithAggregatesFilter<"AidRoomCheck"> | Date | string
    employeeId?: StringWithAggregatesFilter<"AidRoomCheck"> | string
    mountainId?: StringWithAggregatesFilter<"AidRoomCheck"> | string
    aidRoomId?: StringWithAggregatesFilter<"AidRoomCheck"> | string
    notes?: StringNullableWithAggregatesFilter<"AidRoomCheck"> | string | null
  }

  export type EquipmentCheckWhereInput = {
    AND?: EquipmentCheckWhereInput | EquipmentCheckWhereInput[]
    OR?: EquipmentCheckWhereInput[]
    NOT?: EquipmentCheckWhereInput | EquipmentCheckWhereInput[]
    id?: StringFilter<"EquipmentCheck"> | string
    date?: DateTimeFilter<"EquipmentCheck"> | Date | string
    employeeId?: StringFilter<"EquipmentCheck"> | string
    mountainId?: StringFilter<"EquipmentCheck"> | string
    equipmentId?: StringFilter<"EquipmentCheck"> | string
    notes?: StringNullableFilter<"EquipmentCheck"> | string | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
  }

  export type EquipmentCheckOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    equipmentId?: SortOrder
    notes?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
    mountain?: MountainOrderByWithRelationInput
    equipment?: EquipmentOrderByWithRelationInput
  }

  export type EquipmentCheckWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EquipmentCheckWhereInput | EquipmentCheckWhereInput[]
    OR?: EquipmentCheckWhereInput[]
    NOT?: EquipmentCheckWhereInput | EquipmentCheckWhereInput[]
    date?: DateTimeFilter<"EquipmentCheck"> | Date | string
    employeeId?: StringFilter<"EquipmentCheck"> | string
    mountainId?: StringFilter<"EquipmentCheck"> | string
    equipmentId?: StringFilter<"EquipmentCheck"> | string
    notes?: StringNullableFilter<"EquipmentCheck"> | string | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    mountain?: XOR<MountainScalarRelationFilter, MountainWhereInput>
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
  }, "id">

  export type EquipmentCheckOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    equipmentId?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: EquipmentCheckCountOrderByAggregateInput
    _max?: EquipmentCheckMaxOrderByAggregateInput
    _min?: EquipmentCheckMinOrderByAggregateInput
  }

  export type EquipmentCheckScalarWhereWithAggregatesInput = {
    AND?: EquipmentCheckScalarWhereWithAggregatesInput | EquipmentCheckScalarWhereWithAggregatesInput[]
    OR?: EquipmentCheckScalarWhereWithAggregatesInput[]
    NOT?: EquipmentCheckScalarWhereWithAggregatesInput | EquipmentCheckScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EquipmentCheck"> | string
    date?: DateTimeWithAggregatesFilter<"EquipmentCheck"> | Date | string
    employeeId?: StringWithAggregatesFilter<"EquipmentCheck"> | string
    mountainId?: StringWithAggregatesFilter<"EquipmentCheck"> | string
    equipmentId?: StringWithAggregatesFilter<"EquipmentCheck"> | string
    notes?: StringNullableWithAggregatesFilter<"EquipmentCheck"> | string | null
  }

  export type MountainCreateInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    employees?: EmployeeCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentCreateNestedManyWithoutMountainInput
    weather?: WeatherCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutMountainInput
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUpdateManyWithoutMountainNestedInput
    weather?: WeatherUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedUpdateManyWithoutMountainNestedInput
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type MountainCreateManyInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
  }

  export type MountainUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MountainUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WeatherCreateInput = {
    id?: string
    date?: Date | string
    temperature: number
    windSpeed: number
    windDirection?: string | null
    visibility?: number | null
    conditions: string
    snowfall24h?: number | null
    snowfall7d?: number | null
    updatedAt?: Date | string
    mountain: MountainCreateNestedOneWithoutWeatherInput
  }

  export type WeatherUncheckedCreateInput = {
    id?: string
    mountainId: string
    date?: Date | string
    temperature: number
    windSpeed: number
    windDirection?: string | null
    visibility?: number | null
    conditions: string
    snowfall24h?: number | null
    snowfall7d?: number | null
    updatedAt?: Date | string
  }

  export type WeatherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    windSpeed?: FloatFieldUpdateOperationsInput | number
    windDirection?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: NullableFloatFieldUpdateOperationsInput | number | null
    conditions?: StringFieldUpdateOperationsInput | string
    snowfall24h?: NullableFloatFieldUpdateOperationsInput | number | null
    snowfall7d?: NullableFloatFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountain?: MountainUpdateOneRequiredWithoutWeatherNestedInput
  }

  export type WeatherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    windSpeed?: FloatFieldUpdateOperationsInput | number
    windDirection?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: NullableFloatFieldUpdateOperationsInput | number | null
    conditions?: StringFieldUpdateOperationsInput | string
    snowfall24h?: NullableFloatFieldUpdateOperationsInput | number | null
    snowfall7d?: NullableFloatFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherCreateManyInput = {
    id?: string
    mountainId: string
    date?: Date | string
    temperature: number
    windSpeed: number
    windDirection?: string | null
    visibility?: number | null
    conditions: string
    snowfall24h?: number | null
    snowfall7d?: number | null
    updatedAt?: Date | string
  }

  export type WeatherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    windSpeed?: FloatFieldUpdateOperationsInput | number
    windDirection?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: NullableFloatFieldUpdateOperationsInput | number | null
    conditions?: StringFieldUpdateOperationsInput | string
    snowfall24h?: NullableFloatFieldUpdateOperationsInput | number | null
    snowfall7d?: NullableFloatFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    windSpeed?: FloatFieldUpdateOperationsInput | number
    windDirection?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: NullableFloatFieldUpdateOperationsInput | number | null
    conditions?: StringFieldUpdateOperationsInput | string
    snowfall24h?: NullableFloatFieldUpdateOperationsInput | number | null
    snowfall7d?: NullableFloatFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    id?: string
    name: string
    role: string
    department: $Enums.Department
    mountain: MountainCreateNestedOneWithoutEmployeesInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutEmployeeInput
    logs?: IncidentLogCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckCreateNestedManyWithoutEmployeeInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    name: string
    role: string
    department: $Enums.Department
    mountainId: string
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    logs?: IncidentLogUncheckedCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutEmployeeInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: EnumDepartmentFieldUpdateOperationsInput | $Enums.Department
    mountain?: MountainUpdateOneRequiredWithoutEmployeesNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutEmployeeNestedInput
    logs?: IncidentLogUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUpdateManyWithoutEmployeeNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: EnumDepartmentFieldUpdateOperationsInput | $Enums.Department
    mountainId?: StringFieldUpdateOperationsInput | string
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    logs?: IncidentLogUncheckedUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    name: string
    role: string
    department: $Enums.Department
    mountainId: string
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: EnumDepartmentFieldUpdateOperationsInput | $Enums.Department
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: EnumDepartmentFieldUpdateOperationsInput | $Enums.Department
    mountainId?: StringFieldUpdateOperationsInput | string
  }

  export type DispatcherAssignmentCreateInput = {
    id?: string
    assignedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutDispatcherAssignmentsInput
    mountain: MountainCreateNestedOneWithoutDispatcherAssignmentsInput
  }

  export type DispatcherAssignmentUncheckedCreateInput = {
    id?: string
    employeeId: string
    assignedAt?: Date | string
    mountainId: string
  }

  export type DispatcherAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutDispatcherAssignmentsNestedInput
    mountain?: MountainUpdateOneRequiredWithoutDispatcherAssignmentsNestedInput
  }

  export type DispatcherAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
  }

  export type DispatcherAssignmentCreateManyInput = {
    id?: string
    employeeId: string
    assignedAt?: Date | string
    mountainId: string
  }

  export type DispatcherAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatcherAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
  }

  export type LiftCreateInput = {
    id?: string
    name: string
    capacity: number
    status?: $Enums.Status
    mountain: MountainCreateNestedOneWithoutLiftsInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutLiftInput
    liftChecks?: LiftCheckCreateNestedManyWithoutLiftInput
  }

  export type LiftUncheckedCreateInput = {
    id?: string
    name: string
    capacity: number
    status?: $Enums.Status
    mountainId: string
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutLiftInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutLiftInput
  }

  export type LiftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountain?: MountainUpdateOneRequiredWithoutLiftsNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutLiftNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutLiftNestedInput
  }

  export type LiftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountainId?: StringFieldUpdateOperationsInput | string
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutLiftNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutLiftNestedInput
  }

  export type LiftCreateManyInput = {
    id?: string
    name: string
    capacity: number
    status?: $Enums.Status
    mountainId: string
  }

  export type LiftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
  }

  export type LiftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountainId?: StringFieldUpdateOperationsInput | string
  }

  export type TrailCreateInput = {
    id?: string
    name: string
    status?: $Enums.Status
    difficulty: $Enums.TrailDifficulty
    length: number
    condition?: $Enums.TrailCondition
    mountain: MountainCreateNestedOneWithoutTrailsInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutTrailInput
    trailChecks?: TrailCheckCreateNestedManyWithoutTrailInput
  }

  export type TrailUncheckedCreateInput = {
    id?: string
    name: string
    status?: $Enums.Status
    difficulty: $Enums.TrailDifficulty
    length: number
    condition?: $Enums.TrailCondition
    mountainId: string
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutTrailInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutTrailInput
  }

  export type TrailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    difficulty?: EnumTrailDifficultyFieldUpdateOperationsInput | $Enums.TrailDifficulty
    length?: FloatFieldUpdateOperationsInput | number
    condition?: EnumTrailConditionFieldUpdateOperationsInput | $Enums.TrailCondition
    mountain?: MountainUpdateOneRequiredWithoutTrailsNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutTrailNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutTrailNestedInput
  }

  export type TrailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    difficulty?: EnumTrailDifficultyFieldUpdateOperationsInput | $Enums.TrailDifficulty
    length?: FloatFieldUpdateOperationsInput | number
    condition?: EnumTrailConditionFieldUpdateOperationsInput | $Enums.TrailCondition
    mountainId?: StringFieldUpdateOperationsInput | string
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutTrailNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutTrailNestedInput
  }

  export type TrailCreateManyInput = {
    id?: string
    name: string
    status?: $Enums.Status
    difficulty: $Enums.TrailDifficulty
    length: number
    condition?: $Enums.TrailCondition
    mountainId: string
  }

  export type TrailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    difficulty?: EnumTrailDifficultyFieldUpdateOperationsInput | $Enums.TrailDifficulty
    length?: FloatFieldUpdateOperationsInput | number
    condition?: EnumTrailConditionFieldUpdateOperationsInput | $Enums.TrailCondition
  }

  export type TrailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    difficulty?: EnumTrailDifficultyFieldUpdateOperationsInput | $Enums.TrailDifficulty
    length?: FloatFieldUpdateOperationsInput | number
    condition?: EnumTrailConditionFieldUpdateOperationsInput | $Enums.TrailCondition
    mountainId?: StringFieldUpdateOperationsInput | string
  }

  export type LodgeCreateInput = {
    id?: string
    name: string
    capacity: number
    status?: $Enums.Status
    mountain: MountainCreateNestedOneWithoutLodgesInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutLodgeInput
  }

  export type LodgeUncheckedCreateInput = {
    id?: string
    name: string
    capacity: number
    status?: $Enums.Status
    mountainId: string
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutLodgeInput
  }

  export type LodgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountain?: MountainUpdateOneRequiredWithoutLodgesNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutLodgeNestedInput
  }

  export type LodgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountainId?: StringFieldUpdateOperationsInput | string
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutLodgeNestedInput
  }

  export type LodgeCreateManyInput = {
    id?: string
    name: string
    capacity: number
    status?: $Enums.Status
    mountainId: string
  }

  export type LodgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
  }

  export type LodgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountainId?: StringFieldUpdateOperationsInput | string
  }

  export type HutCreateInput = {
    id?: string
    name: string
    status?: $Enums.Status
    mountain: MountainCreateNestedOneWithoutHutsInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutHutInput
    hutChecks?: HutCheckCreateNestedManyWithoutHutInput
  }

  export type HutUncheckedCreateInput = {
    id?: string
    name: string
    status?: $Enums.Status
    mountainId: string
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutHutInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutHutInput
  }

  export type HutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountain?: MountainUpdateOneRequiredWithoutHutsNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutHutNestedInput
    hutChecks?: HutCheckUpdateManyWithoutHutNestedInput
  }

  export type HutUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountainId?: StringFieldUpdateOperationsInput | string
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutHutNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutHutNestedInput
  }

  export type HutCreateManyInput = {
    id?: string
    name: string
    status?: $Enums.Status
    mountainId: string
  }

  export type HutUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
  }

  export type HutUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountainId?: StringFieldUpdateOperationsInput | string
  }

  export type AidRoomCreateInput = {
    id?: string
    name: string
    location: string
    status?: $Enums.Status
    mountain: MountainCreateNestedOneWithoutAidRoomsInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutAidRoomInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutAidRoomInput
  }

  export type AidRoomUncheckedCreateInput = {
    id?: string
    name: string
    location: string
    status?: $Enums.Status
    mountainId: string
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutAidRoomInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutAidRoomInput
  }

  export type AidRoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountain?: MountainUpdateOneRequiredWithoutAidRoomsNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutAidRoomNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutAidRoomNestedInput
  }

  export type AidRoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountainId?: StringFieldUpdateOperationsInput | string
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutAidRoomNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutAidRoomNestedInput
  }

  export type AidRoomCreateManyInput = {
    id?: string
    name: string
    location: string
    status?: $Enums.Status
    mountainId: string
  }

  export type AidRoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
  }

  export type AidRoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountainId?: StringFieldUpdateOperationsInput | string
  }

  export type EquipmentCreateInput = {
    id?: string
    name: string
    type: string
    status: $Enums.EquipmentStatus
    service: $Enums.EquipmentService
    mountain: MountainCreateNestedOneWithoutEquipmentInput
    usedInLogs?: IncidentLogEquipmentCreateNestedManyWithoutEquipmentInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    status: $Enums.EquipmentStatus
    service: $Enums.EquipmentService
    mountainId: string
    usedInLogs?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutEquipmentInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    service?: EnumEquipmentServiceFieldUpdateOperationsInput | $Enums.EquipmentService
    mountain?: MountainUpdateOneRequiredWithoutEquipmentNestedInput
    usedInLogs?: IncidentLogEquipmentUpdateManyWithoutEquipmentNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    service?: EnumEquipmentServiceFieldUpdateOperationsInput | $Enums.EquipmentService
    mountainId?: StringFieldUpdateOperationsInput | string
    usedInLogs?: IncidentLogEquipmentUncheckedUpdateManyWithoutEquipmentNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentCreateManyInput = {
    id?: string
    name: string
    type: string
    status: $Enums.EquipmentStatus
    service: $Enums.EquipmentService
    mountainId: string
  }

  export type EquipmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    service?: EnumEquipmentServiceFieldUpdateOperationsInput | $Enums.EquipmentService
  }

  export type EquipmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    service?: EnumEquipmentServiceFieldUpdateOperationsInput | $Enums.EquipmentService
    mountainId?: StringFieldUpdateOperationsInput | string
  }

  export type IncidentCreateInput = {
    id?: string
    description: string
    status?: $Enums.Status
    mountain: MountainCreateNestedOneWithoutIncidentsInput
    logs?: IncidentLogCreateNestedManyWithoutIncidentInput
  }

  export type IncidentUncheckedCreateInput = {
    id?: string
    description: string
    status?: $Enums.Status
    mountainId: string
    logs?: IncidentLogUncheckedCreateNestedManyWithoutIncidentInput
  }

  export type IncidentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountain?: MountainUpdateOneRequiredWithoutIncidentsNestedInput
    logs?: IncidentLogUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountainId?: StringFieldUpdateOperationsInput | string
    logs?: IncidentLogUncheckedUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentCreateManyInput = {
    id?: string
    description: string
    status?: $Enums.Status
    mountainId: string
  }

  export type IncidentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
  }

  export type IncidentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountainId?: StringFieldUpdateOperationsInput | string
  }

  export type IncidentLogCreateInput = {
    id?: string
    locationType: $Enums.LocationType
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
    incident: IncidentCreateNestedOneWithoutLogsInput
    employee: EmployeeCreateNestedOneWithoutLogsInput
    mountain: MountainCreateNestedOneWithoutIncidentLogsInput
    equipmentUsed?: IncidentLogEquipmentCreateNestedManyWithoutIncidentLogInput
    lift?: LiftCreateNestedOneWithoutIncidentLogsInput
    trail?: TrailCreateNestedOneWithoutIncidentLogsInput
    lodge?: LodgeCreateNestedOneWithoutIncidentLogsInput
    hut?: HutCreateNestedOneWithoutIncidentLogsInput
    aidRoom?: AidRoomCreateNestedOneWithoutIncidentLogsInput
  }

  export type IncidentLogUncheckedCreateInput = {
    id?: string
    incidentId: string
    employeeId: string
    mountainId: string
    locationType: $Enums.LocationType
    locationId: string
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
    equipmentUsed?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutIncidentLogInput
  }

  export type IncidentLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incident?: IncidentUpdateOneRequiredWithoutLogsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutLogsNestedInput
    mountain?: MountainUpdateOneRequiredWithoutIncidentLogsNestedInput
    equipmentUsed?: IncidentLogEquipmentUpdateManyWithoutIncidentLogNestedInput
    lift?: LiftUpdateOneWithoutIncidentLogsNestedInput
    trail?: TrailUpdateOneWithoutIncidentLogsNestedInput
    lodge?: LodgeUpdateOneWithoutIncidentLogsNestedInput
    hut?: HutUpdateOneWithoutIncidentLogsNestedInput
    aidRoom?: AidRoomUpdateOneWithoutIncidentLogsNestedInput
  }

  export type IncidentLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationId?: StringFieldUpdateOperationsInput | string
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipmentUsed?: IncidentLogEquipmentUncheckedUpdateManyWithoutIncidentLogNestedInput
  }

  export type IncidentLogCreateManyInput = {
    id?: string
    incidentId: string
    employeeId: string
    mountainId: string
    locationType: $Enums.LocationType
    locationId: string
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
  }

  export type IncidentLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IncidentLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationId?: StringFieldUpdateOperationsInput | string
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IncidentLogEquipmentCreateInput = {
    id?: string
    usedAt?: Date | string
    notes?: string | null
    mountain: MountainCreateNestedOneWithoutIncidentLogEquipmentInput
    incidentLog: IncidentLogCreateNestedOneWithoutEquipmentUsedInput
    equipment: EquipmentCreateNestedOneWithoutUsedInLogsInput
  }

  export type IncidentLogEquipmentUncheckedCreateInput = {
    id?: string
    incidentLogId: string
    equipmentId: string
    mountainId: string
    usedAt?: Date | string
    notes?: string | null
  }

  export type IncidentLogEquipmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mountain?: MountainUpdateOneRequiredWithoutIncidentLogEquipmentNestedInput
    incidentLog?: IncidentLogUpdateOneRequiredWithoutEquipmentUsedNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutUsedInLogsNestedInput
  }

  export type IncidentLogEquipmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentLogId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IncidentLogEquipmentCreateManyInput = {
    id?: string
    incidentLogId: string
    equipmentId: string
    mountainId: string
    usedAt?: Date | string
    notes?: string | null
  }

  export type IncidentLogEquipmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IncidentLogEquipmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentLogId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LiftCheckCreateInput = {
    id?: string
    date?: Date | string
    notes?: string | null
    employee: EmployeeCreateNestedOneWithoutLiftChecksInput
    mountain: MountainCreateNestedOneWithoutLiftChecksInput
    lift: LiftCreateNestedOneWithoutLiftChecksInput
  }

  export type LiftCheckUncheckedCreateInput = {
    id?: string
    date?: Date | string
    employeeId: string
    mountainId: string
    liftId: string
    notes?: string | null
  }

  export type LiftCheckUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutLiftChecksNestedInput
    mountain?: MountainUpdateOneRequiredWithoutLiftChecksNestedInput
    lift?: LiftUpdateOneRequiredWithoutLiftChecksNestedInput
  }

  export type LiftCheckUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    liftId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LiftCheckCreateManyInput = {
    id?: string
    date?: Date | string
    employeeId: string
    mountainId: string
    liftId: string
    notes?: string | null
  }

  export type LiftCheckUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LiftCheckUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    liftId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrailCheckCreateInput = {
    id?: string
    date?: Date | string
    notes?: string | null
    employee: EmployeeCreateNestedOneWithoutTrailChecksInput
    mountain: MountainCreateNestedOneWithoutTrailChecksInput
    trail: TrailCreateNestedOneWithoutTrailChecksInput
  }

  export type TrailCheckUncheckedCreateInput = {
    id?: string
    date?: Date | string
    employeeId: string
    mountainId: string
    trailId: string
    notes?: string | null
  }

  export type TrailCheckUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutTrailChecksNestedInput
    mountain?: MountainUpdateOneRequiredWithoutTrailChecksNestedInput
    trail?: TrailUpdateOneRequiredWithoutTrailChecksNestedInput
  }

  export type TrailCheckUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    trailId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrailCheckCreateManyInput = {
    id?: string
    date?: Date | string
    employeeId: string
    mountainId: string
    trailId: string
    notes?: string | null
  }

  export type TrailCheckUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrailCheckUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    trailId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HutCheckCreateInput = {
    id?: string
    date?: Date | string
    notes?: string | null
    employee: EmployeeCreateNestedOneWithoutHutChecksInput
    mountain: MountainCreateNestedOneWithoutHutChecksInput
    hut: HutCreateNestedOneWithoutHutChecksInput
  }

  export type HutCheckUncheckedCreateInput = {
    id?: string
    date?: Date | string
    employeeId: string
    mountainId: string
    hutId: string
    notes?: string | null
  }

  export type HutCheckUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutHutChecksNestedInput
    mountain?: MountainUpdateOneRequiredWithoutHutChecksNestedInput
    hut?: HutUpdateOneRequiredWithoutHutChecksNestedInput
  }

  export type HutCheckUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    hutId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HutCheckCreateManyInput = {
    id?: string
    date?: Date | string
    employeeId: string
    mountainId: string
    hutId: string
    notes?: string | null
  }

  export type HutCheckUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HutCheckUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    hutId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AidRoomCheckCreateInput = {
    id?: string
    date?: Date | string
    notes?: string | null
    employee: EmployeeCreateNestedOneWithoutAidRoomChecksInput
    mountain: MountainCreateNestedOneWithoutAidRoomChecksInput
    aidRoom: AidRoomCreateNestedOneWithoutAidRoomChecksInput
  }

  export type AidRoomCheckUncheckedCreateInput = {
    id?: string
    date?: Date | string
    employeeId: string
    mountainId: string
    aidRoomId: string
    notes?: string | null
  }

  export type AidRoomCheckUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutAidRoomChecksNestedInput
    mountain?: MountainUpdateOneRequiredWithoutAidRoomChecksNestedInput
    aidRoom?: AidRoomUpdateOneRequiredWithoutAidRoomChecksNestedInput
  }

  export type AidRoomCheckUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    aidRoomId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AidRoomCheckCreateManyInput = {
    id?: string
    date?: Date | string
    employeeId: string
    mountainId: string
    aidRoomId: string
    notes?: string | null
  }

  export type AidRoomCheckUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AidRoomCheckUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    aidRoomId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipmentCheckCreateInput = {
    id?: string
    date?: Date | string
    notes?: string | null
    employee: EmployeeCreateNestedOneWithoutEquipmentChecksInput
    mountain: MountainCreateNestedOneWithoutEquipmentChecksInput
    equipment: EquipmentCreateNestedOneWithoutEquipmentChecksInput
  }

  export type EquipmentCheckUncheckedCreateInput = {
    id?: string
    date?: Date | string
    employeeId: string
    mountainId: string
    equipmentId: string
    notes?: string | null
  }

  export type EquipmentCheckUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutEquipmentChecksNestedInput
    mountain?: MountainUpdateOneRequiredWithoutEquipmentChecksNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutEquipmentChecksNestedInput
  }

  export type EquipmentCheckUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipmentCheckCreateManyInput = {
    id?: string
    date?: Date | string
    employeeId: string
    mountainId: string
    equipmentId: string
    notes?: string | null
  }

  export type EquipmentCheckUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipmentCheckUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type LiftListRelationFilter = {
    every?: LiftWhereInput
    some?: LiftWhereInput
    none?: LiftWhereInput
  }

  export type LiftCheckListRelationFilter = {
    every?: LiftCheckWhereInput
    some?: LiftCheckWhereInput
    none?: LiftCheckWhereInput
  }

  export type TrailListRelationFilter = {
    every?: TrailWhereInput
    some?: TrailWhereInput
    none?: TrailWhereInput
  }

  export type TrailCheckListRelationFilter = {
    every?: TrailCheckWhereInput
    some?: TrailCheckWhereInput
    none?: TrailCheckWhereInput
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type LodgeListRelationFilter = {
    every?: LodgeWhereInput
    some?: LodgeWhereInput
    none?: LodgeWhereInput
  }

  export type HutListRelationFilter = {
    every?: HutWhereInput
    some?: HutWhereInput
    none?: HutWhereInput
  }

  export type HutCheckListRelationFilter = {
    every?: HutCheckWhereInput
    some?: HutCheckWhereInput
    none?: HutCheckWhereInput
  }

  export type AidRoomListRelationFilter = {
    every?: AidRoomWhereInput
    some?: AidRoomWhereInput
    none?: AidRoomWhereInput
  }

  export type AidRoomCheckListRelationFilter = {
    every?: AidRoomCheckWhereInput
    some?: AidRoomCheckWhereInput
    none?: AidRoomCheckWhereInput
  }

  export type EquipmentListRelationFilter = {
    every?: EquipmentWhereInput
    some?: EquipmentWhereInput
    none?: EquipmentWhereInput
  }

  export type EquipmentCheckListRelationFilter = {
    every?: EquipmentCheckWhereInput
    some?: EquipmentCheckWhereInput
    none?: EquipmentCheckWhereInput
  }

  export type IncidentListRelationFilter = {
    every?: IncidentWhereInput
    some?: IncidentWhereInput
    none?: IncidentWhereInput
  }

  export type IncidentLogListRelationFilter = {
    every?: IncidentLogWhereInput
    some?: IncidentLogWhereInput
    none?: IncidentLogWhereInput
  }

  export type DispatcherAssignmentListRelationFilter = {
    every?: DispatcherAssignmentWhereInput
    some?: DispatcherAssignmentWhereInput
    none?: DispatcherAssignmentWhereInput
  }

  export type IncidentLogEquipmentListRelationFilter = {
    every?: IncidentLogEquipmentWhereInput
    some?: IncidentLogEquipmentWhereInput
    none?: IncidentLogEquipmentWhereInput
  }

  export type WeatherListRelationFilter = {
    every?: WeatherWhereInput
    some?: WeatherWhereInput
    none?: WeatherWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type LiftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LiftCheckOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrailCheckOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LodgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HutCheckOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AidRoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AidRoomCheckOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentCheckOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncidentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncidentLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DispatcherAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncidentLogEquipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeatherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MountainCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    height?: SortOrder
    hours?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    openingDate?: SortOrder
    closingDate?: SortOrder
  }

  export type MountainAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    height?: SortOrder
  }

  export type MountainMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    height?: SortOrder
    hours?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    openingDate?: SortOrder
    closingDate?: SortOrder
  }

  export type MountainMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    height?: SortOrder
    hours?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    openingDate?: SortOrder
    closingDate?: SortOrder
  }

  export type MountainSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    height?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type MountainScalarRelationFilter = {
    is?: MountainWhereInput
    isNot?: MountainWhereInput
  }

  export type WeatherCountOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    date?: SortOrder
    temperature?: SortOrder
    windSpeed?: SortOrder
    windDirection?: SortOrder
    visibility?: SortOrder
    conditions?: SortOrder
    snowfall24h?: SortOrder
    snowfall7d?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeatherAvgOrderByAggregateInput = {
    temperature?: SortOrder
    windSpeed?: SortOrder
    visibility?: SortOrder
    snowfall24h?: SortOrder
    snowfall7d?: SortOrder
  }

  export type WeatherMaxOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    date?: SortOrder
    temperature?: SortOrder
    windSpeed?: SortOrder
    windDirection?: SortOrder
    visibility?: SortOrder
    conditions?: SortOrder
    snowfall24h?: SortOrder
    snowfall7d?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeatherMinOrderByAggregateInput = {
    id?: SortOrder
    mountainId?: SortOrder
    date?: SortOrder
    temperature?: SortOrder
    windSpeed?: SortOrder
    windDirection?: SortOrder
    visibility?: SortOrder
    conditions?: SortOrder
    snowfall24h?: SortOrder
    snowfall7d?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeatherSumOrderByAggregateInput = {
    temperature?: SortOrder
    windSpeed?: SortOrder
    visibility?: SortOrder
    snowfall24h?: SortOrder
    snowfall7d?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumDepartmentFilter<$PrismaModel = never> = {
    equals?: $Enums.Department | EnumDepartmentFieldRefInput<$PrismaModel>
    in?: $Enums.Department[] | ListEnumDepartmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.Department[] | ListEnumDepartmentFieldRefInput<$PrismaModel>
    not?: NestedEnumDepartmentFilter<$PrismaModel> | $Enums.Department
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrder
    mountainId?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrder
    mountainId?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrder
    mountainId?: SortOrder
  }

  export type EnumDepartmentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Department | EnumDepartmentFieldRefInput<$PrismaModel>
    in?: $Enums.Department[] | ListEnumDepartmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.Department[] | ListEnumDepartmentFieldRefInput<$PrismaModel>
    not?: NestedEnumDepartmentWithAggregatesFilter<$PrismaModel> | $Enums.Department
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDepartmentFilter<$PrismaModel>
    _max?: NestedEnumDepartmentFilter<$PrismaModel>
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type DispatcherAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    assignedAt?: SortOrder
    mountainId?: SortOrder
  }

  export type DispatcherAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    assignedAt?: SortOrder
    mountainId?: SortOrder
  }

  export type DispatcherAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    assignedAt?: SortOrder
    mountainId?: SortOrder
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type LiftCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
  }

  export type LiftAvgOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type LiftMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
  }

  export type LiftMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
  }

  export type LiftSumOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type EnumTrailDifficultyFilter<$PrismaModel = never> = {
    equals?: $Enums.TrailDifficulty | EnumTrailDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.TrailDifficulty[] | ListEnumTrailDifficultyFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrailDifficulty[] | ListEnumTrailDifficultyFieldRefInput<$PrismaModel>
    not?: NestedEnumTrailDifficultyFilter<$PrismaModel> | $Enums.TrailDifficulty
  }

  export type EnumTrailConditionFilter<$PrismaModel = never> = {
    equals?: $Enums.TrailCondition | EnumTrailConditionFieldRefInput<$PrismaModel>
    in?: $Enums.TrailCondition[] | ListEnumTrailConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrailCondition[] | ListEnumTrailConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumTrailConditionFilter<$PrismaModel> | $Enums.TrailCondition
  }

  export type TrailCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    difficulty?: SortOrder
    length?: SortOrder
    condition?: SortOrder
    mountainId?: SortOrder
  }

  export type TrailAvgOrderByAggregateInput = {
    length?: SortOrder
  }

  export type TrailMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    difficulty?: SortOrder
    length?: SortOrder
    condition?: SortOrder
    mountainId?: SortOrder
  }

  export type TrailMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    difficulty?: SortOrder
    length?: SortOrder
    condition?: SortOrder
    mountainId?: SortOrder
  }

  export type TrailSumOrderByAggregateInput = {
    length?: SortOrder
  }

  export type EnumTrailDifficultyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrailDifficulty | EnumTrailDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.TrailDifficulty[] | ListEnumTrailDifficultyFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrailDifficulty[] | ListEnumTrailDifficultyFieldRefInput<$PrismaModel>
    not?: NestedEnumTrailDifficultyWithAggregatesFilter<$PrismaModel> | $Enums.TrailDifficulty
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrailDifficultyFilter<$PrismaModel>
    _max?: NestedEnumTrailDifficultyFilter<$PrismaModel>
  }

  export type EnumTrailConditionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrailCondition | EnumTrailConditionFieldRefInput<$PrismaModel>
    in?: $Enums.TrailCondition[] | ListEnumTrailConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrailCondition[] | ListEnumTrailConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumTrailConditionWithAggregatesFilter<$PrismaModel> | $Enums.TrailCondition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrailConditionFilter<$PrismaModel>
    _max?: NestedEnumTrailConditionFilter<$PrismaModel>
  }

  export type LodgeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
  }

  export type LodgeAvgOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type LodgeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
  }

  export type LodgeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
  }

  export type LodgeSumOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type HutCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
  }

  export type HutMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
  }

  export type HutMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
  }

  export type AidRoomCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
  }

  export type AidRoomMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
  }

  export type AidRoomMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
  }

  export type EnumEquipmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusFilter<$PrismaModel> | $Enums.EquipmentStatus
  }

  export type EnumEquipmentServiceFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentService | EnumEquipmentServiceFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentService[] | ListEnumEquipmentServiceFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentService[] | ListEnumEquipmentServiceFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentServiceFilter<$PrismaModel> | $Enums.EquipmentService
  }

  export type EquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    service?: SortOrder
    mountainId?: SortOrder
  }

  export type EquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    service?: SortOrder
    mountainId?: SortOrder
  }

  export type EquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    service?: SortOrder
    mountainId?: SortOrder
  }

  export type EnumEquipmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentStatusFilter<$PrismaModel>
    _max?: NestedEnumEquipmentStatusFilter<$PrismaModel>
  }

  export type EnumEquipmentServiceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentService | EnumEquipmentServiceFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentService[] | ListEnumEquipmentServiceFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentService[] | ListEnumEquipmentServiceFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentServiceWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentService
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentServiceFilter<$PrismaModel>
    _max?: NestedEnumEquipmentServiceFilter<$PrismaModel>
  }

  export type IncidentCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
  }

  export type IncidentMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
  }

  export type IncidentMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    mountainId?: SortOrder
  }

  export type EnumLocationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLocationTypeFilter<$PrismaModel> | $Enums.LocationType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IncidentScalarRelationFilter = {
    is?: IncidentWhereInput
    isNot?: IncidentWhereInput
  }

  export type LiftNullableScalarRelationFilter = {
    is?: LiftWhereInput | null
    isNot?: LiftWhereInput | null
  }

  export type TrailNullableScalarRelationFilter = {
    is?: TrailWhereInput | null
    isNot?: TrailWhereInput | null
  }

  export type LodgeNullableScalarRelationFilter = {
    is?: LodgeWhereInput | null
    isNot?: LodgeWhereInput | null
  }

  export type HutNullableScalarRelationFilter = {
    is?: HutWhereInput | null
    isNot?: HutWhereInput | null
  }

  export type AidRoomNullableScalarRelationFilter = {
    is?: AidRoomWhereInput | null
    isNot?: AidRoomWhereInput | null
  }

  export type IncidentLogCountOrderByAggregateInput = {
    id?: SortOrder
    incidentId?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    locationType?: SortOrder
    locationId?: SortOrder
    locationStatus?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    onSceneTime?: SortOrder
    stableTime?: SortOrder
    transportTime?: SortOrder
    dryRun?: SortOrder
    dryRunTime?: SortOrder
  }

  export type IncidentLogMaxOrderByAggregateInput = {
    id?: SortOrder
    incidentId?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    locationType?: SortOrder
    locationId?: SortOrder
    locationStatus?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    onSceneTime?: SortOrder
    stableTime?: SortOrder
    transportTime?: SortOrder
    dryRun?: SortOrder
    dryRunTime?: SortOrder
  }

  export type IncidentLogMinOrderByAggregateInput = {
    id?: SortOrder
    incidentId?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    locationType?: SortOrder
    locationId?: SortOrder
    locationStatus?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    onSceneTime?: SortOrder
    stableTime?: SortOrder
    transportTime?: SortOrder
    dryRun?: SortOrder
    dryRunTime?: SortOrder
  }

  export type EnumLocationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLocationTypeWithAggregatesFilter<$PrismaModel> | $Enums.LocationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLocationTypeFilter<$PrismaModel>
    _max?: NestedEnumLocationTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IncidentLogScalarRelationFilter = {
    is?: IncidentLogWhereInput
    isNot?: IncidentLogWhereInput
  }

  export type EquipmentScalarRelationFilter = {
    is?: EquipmentWhereInput
    isNot?: EquipmentWhereInput
  }

  export type IncidentLogEquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    incidentLogId?: SortOrder
    equipmentId?: SortOrder
    mountainId?: SortOrder
    usedAt?: SortOrder
    notes?: SortOrder
  }

  export type IncidentLogEquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    incidentLogId?: SortOrder
    equipmentId?: SortOrder
    mountainId?: SortOrder
    usedAt?: SortOrder
    notes?: SortOrder
  }

  export type IncidentLogEquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    incidentLogId?: SortOrder
    equipmentId?: SortOrder
    mountainId?: SortOrder
    usedAt?: SortOrder
    notes?: SortOrder
  }

  export type LiftScalarRelationFilter = {
    is?: LiftWhereInput
    isNot?: LiftWhereInput
  }

  export type LiftCheckCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    liftId?: SortOrder
    notes?: SortOrder
  }

  export type LiftCheckMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    liftId?: SortOrder
    notes?: SortOrder
  }

  export type LiftCheckMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    liftId?: SortOrder
    notes?: SortOrder
  }

  export type TrailScalarRelationFilter = {
    is?: TrailWhereInput
    isNot?: TrailWhereInput
  }

  export type TrailCheckCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    trailId?: SortOrder
    notes?: SortOrder
  }

  export type TrailCheckMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    trailId?: SortOrder
    notes?: SortOrder
  }

  export type TrailCheckMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    trailId?: SortOrder
    notes?: SortOrder
  }

  export type HutScalarRelationFilter = {
    is?: HutWhereInput
    isNot?: HutWhereInput
  }

  export type HutCheckCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    hutId?: SortOrder
    notes?: SortOrder
  }

  export type HutCheckMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    hutId?: SortOrder
    notes?: SortOrder
  }

  export type HutCheckMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    hutId?: SortOrder
    notes?: SortOrder
  }

  export type AidRoomScalarRelationFilter = {
    is?: AidRoomWhereInput
    isNot?: AidRoomWhereInput
  }

  export type AidRoomCheckCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    aidRoomId?: SortOrder
    notes?: SortOrder
  }

  export type AidRoomCheckMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    aidRoomId?: SortOrder
    notes?: SortOrder
  }

  export type AidRoomCheckMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    aidRoomId?: SortOrder
    notes?: SortOrder
  }

  export type EquipmentCheckCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    equipmentId?: SortOrder
    notes?: SortOrder
  }

  export type EquipmentCheckMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    equipmentId?: SortOrder
    notes?: SortOrder
  }

  export type EquipmentCheckMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    mountainId?: SortOrder
    equipmentId?: SortOrder
    notes?: SortOrder
  }

  export type LiftCreateNestedManyWithoutMountainInput = {
    create?: XOR<LiftCreateWithoutMountainInput, LiftUncheckedCreateWithoutMountainInput> | LiftCreateWithoutMountainInput[] | LiftUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LiftCreateOrConnectWithoutMountainInput | LiftCreateOrConnectWithoutMountainInput[]
    createMany?: LiftCreateManyMountainInputEnvelope
    connect?: LiftWhereUniqueInput | LiftWhereUniqueInput[]
  }

  export type LiftCheckCreateNestedManyWithoutMountainInput = {
    create?: XOR<LiftCheckCreateWithoutMountainInput, LiftCheckUncheckedCreateWithoutMountainInput> | LiftCheckCreateWithoutMountainInput[] | LiftCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutMountainInput | LiftCheckCreateOrConnectWithoutMountainInput[]
    createMany?: LiftCheckCreateManyMountainInputEnvelope
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
  }

  export type TrailCreateNestedManyWithoutMountainInput = {
    create?: XOR<TrailCreateWithoutMountainInput, TrailUncheckedCreateWithoutMountainInput> | TrailCreateWithoutMountainInput[] | TrailUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: TrailCreateOrConnectWithoutMountainInput | TrailCreateOrConnectWithoutMountainInput[]
    createMany?: TrailCreateManyMountainInputEnvelope
    connect?: TrailWhereUniqueInput | TrailWhereUniqueInput[]
  }

  export type TrailCheckCreateNestedManyWithoutMountainInput = {
    create?: XOR<TrailCheckCreateWithoutMountainInput, TrailCheckUncheckedCreateWithoutMountainInput> | TrailCheckCreateWithoutMountainInput[] | TrailCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutMountainInput | TrailCheckCreateOrConnectWithoutMountainInput[]
    createMany?: TrailCheckCreateManyMountainInputEnvelope
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutMountainInput = {
    create?: XOR<EmployeeCreateWithoutMountainInput, EmployeeUncheckedCreateWithoutMountainInput> | EmployeeCreateWithoutMountainInput[] | EmployeeUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutMountainInput | EmployeeCreateOrConnectWithoutMountainInput[]
    createMany?: EmployeeCreateManyMountainInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type LodgeCreateNestedManyWithoutMountainInput = {
    create?: XOR<LodgeCreateWithoutMountainInput, LodgeUncheckedCreateWithoutMountainInput> | LodgeCreateWithoutMountainInput[] | LodgeUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LodgeCreateOrConnectWithoutMountainInput | LodgeCreateOrConnectWithoutMountainInput[]
    createMany?: LodgeCreateManyMountainInputEnvelope
    connect?: LodgeWhereUniqueInput | LodgeWhereUniqueInput[]
  }

  export type HutCreateNestedManyWithoutMountainInput = {
    create?: XOR<HutCreateWithoutMountainInput, HutUncheckedCreateWithoutMountainInput> | HutCreateWithoutMountainInput[] | HutUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: HutCreateOrConnectWithoutMountainInput | HutCreateOrConnectWithoutMountainInput[]
    createMany?: HutCreateManyMountainInputEnvelope
    connect?: HutWhereUniqueInput | HutWhereUniqueInput[]
  }

  export type HutCheckCreateNestedManyWithoutMountainInput = {
    create?: XOR<HutCheckCreateWithoutMountainInput, HutCheckUncheckedCreateWithoutMountainInput> | HutCheckCreateWithoutMountainInput[] | HutCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutMountainInput | HutCheckCreateOrConnectWithoutMountainInput[]
    createMany?: HutCheckCreateManyMountainInputEnvelope
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
  }

  export type AidRoomCreateNestedManyWithoutMountainInput = {
    create?: XOR<AidRoomCreateWithoutMountainInput, AidRoomUncheckedCreateWithoutMountainInput> | AidRoomCreateWithoutMountainInput[] | AidRoomUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: AidRoomCreateOrConnectWithoutMountainInput | AidRoomCreateOrConnectWithoutMountainInput[]
    createMany?: AidRoomCreateManyMountainInputEnvelope
    connect?: AidRoomWhereUniqueInput | AidRoomWhereUniqueInput[]
  }

  export type AidRoomCheckCreateNestedManyWithoutMountainInput = {
    create?: XOR<AidRoomCheckCreateWithoutMountainInput, AidRoomCheckUncheckedCreateWithoutMountainInput> | AidRoomCheckCreateWithoutMountainInput[] | AidRoomCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutMountainInput | AidRoomCheckCreateOrConnectWithoutMountainInput[]
    createMany?: AidRoomCheckCreateManyMountainInputEnvelope
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
  }

  export type EquipmentCreateNestedManyWithoutMountainInput = {
    create?: XOR<EquipmentCreateWithoutMountainInput, EquipmentUncheckedCreateWithoutMountainInput> | EquipmentCreateWithoutMountainInput[] | EquipmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutMountainInput | EquipmentCreateOrConnectWithoutMountainInput[]
    createMany?: EquipmentCreateManyMountainInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type EquipmentCheckCreateNestedManyWithoutMountainInput = {
    create?: XOR<EquipmentCheckCreateWithoutMountainInput, EquipmentCheckUncheckedCreateWithoutMountainInput> | EquipmentCheckCreateWithoutMountainInput[] | EquipmentCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutMountainInput | EquipmentCheckCreateOrConnectWithoutMountainInput[]
    createMany?: EquipmentCheckCreateManyMountainInputEnvelope
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
  }

  export type IncidentCreateNestedManyWithoutMountainInput = {
    create?: XOR<IncidentCreateWithoutMountainInput, IncidentUncheckedCreateWithoutMountainInput> | IncidentCreateWithoutMountainInput[] | IncidentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutMountainInput | IncidentCreateOrConnectWithoutMountainInput[]
    createMany?: IncidentCreateManyMountainInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type IncidentLogCreateNestedManyWithoutMountainInput = {
    create?: XOR<IncidentLogCreateWithoutMountainInput, IncidentLogUncheckedCreateWithoutMountainInput> | IncidentLogCreateWithoutMountainInput[] | IncidentLogUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutMountainInput | IncidentLogCreateOrConnectWithoutMountainInput[]
    createMany?: IncidentLogCreateManyMountainInputEnvelope
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
  }

  export type DispatcherAssignmentCreateNestedManyWithoutMountainInput = {
    create?: XOR<DispatcherAssignmentCreateWithoutMountainInput, DispatcherAssignmentUncheckedCreateWithoutMountainInput> | DispatcherAssignmentCreateWithoutMountainInput[] | DispatcherAssignmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: DispatcherAssignmentCreateOrConnectWithoutMountainInput | DispatcherAssignmentCreateOrConnectWithoutMountainInput[]
    createMany?: DispatcherAssignmentCreateManyMountainInputEnvelope
    connect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
  }

  export type IncidentLogEquipmentCreateNestedManyWithoutMountainInput = {
    create?: XOR<IncidentLogEquipmentCreateWithoutMountainInput, IncidentLogEquipmentUncheckedCreateWithoutMountainInput> | IncidentLogEquipmentCreateWithoutMountainInput[] | IncidentLogEquipmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: IncidentLogEquipmentCreateOrConnectWithoutMountainInput | IncidentLogEquipmentCreateOrConnectWithoutMountainInput[]
    createMany?: IncidentLogEquipmentCreateManyMountainInputEnvelope
    connect?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
  }

  export type WeatherCreateNestedManyWithoutMountainInput = {
    create?: XOR<WeatherCreateWithoutMountainInput, WeatherUncheckedCreateWithoutMountainInput> | WeatherCreateWithoutMountainInput[] | WeatherUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: WeatherCreateOrConnectWithoutMountainInput | WeatherCreateOrConnectWithoutMountainInput[]
    createMany?: WeatherCreateManyMountainInputEnvelope
    connect?: WeatherWhereUniqueInput | WeatherWhereUniqueInput[]
  }

  export type LiftUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<LiftCreateWithoutMountainInput, LiftUncheckedCreateWithoutMountainInput> | LiftCreateWithoutMountainInput[] | LiftUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LiftCreateOrConnectWithoutMountainInput | LiftCreateOrConnectWithoutMountainInput[]
    createMany?: LiftCreateManyMountainInputEnvelope
    connect?: LiftWhereUniqueInput | LiftWhereUniqueInput[]
  }

  export type LiftCheckUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<LiftCheckCreateWithoutMountainInput, LiftCheckUncheckedCreateWithoutMountainInput> | LiftCheckCreateWithoutMountainInput[] | LiftCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutMountainInput | LiftCheckCreateOrConnectWithoutMountainInput[]
    createMany?: LiftCheckCreateManyMountainInputEnvelope
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
  }

  export type TrailUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<TrailCreateWithoutMountainInput, TrailUncheckedCreateWithoutMountainInput> | TrailCreateWithoutMountainInput[] | TrailUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: TrailCreateOrConnectWithoutMountainInput | TrailCreateOrConnectWithoutMountainInput[]
    createMany?: TrailCreateManyMountainInputEnvelope
    connect?: TrailWhereUniqueInput | TrailWhereUniqueInput[]
  }

  export type TrailCheckUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<TrailCheckCreateWithoutMountainInput, TrailCheckUncheckedCreateWithoutMountainInput> | TrailCheckCreateWithoutMountainInput[] | TrailCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutMountainInput | TrailCheckCreateOrConnectWithoutMountainInput[]
    createMany?: TrailCheckCreateManyMountainInputEnvelope
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<EmployeeCreateWithoutMountainInput, EmployeeUncheckedCreateWithoutMountainInput> | EmployeeCreateWithoutMountainInput[] | EmployeeUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutMountainInput | EmployeeCreateOrConnectWithoutMountainInput[]
    createMany?: EmployeeCreateManyMountainInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type LodgeUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<LodgeCreateWithoutMountainInput, LodgeUncheckedCreateWithoutMountainInput> | LodgeCreateWithoutMountainInput[] | LodgeUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LodgeCreateOrConnectWithoutMountainInput | LodgeCreateOrConnectWithoutMountainInput[]
    createMany?: LodgeCreateManyMountainInputEnvelope
    connect?: LodgeWhereUniqueInput | LodgeWhereUniqueInput[]
  }

  export type HutUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<HutCreateWithoutMountainInput, HutUncheckedCreateWithoutMountainInput> | HutCreateWithoutMountainInput[] | HutUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: HutCreateOrConnectWithoutMountainInput | HutCreateOrConnectWithoutMountainInput[]
    createMany?: HutCreateManyMountainInputEnvelope
    connect?: HutWhereUniqueInput | HutWhereUniqueInput[]
  }

  export type HutCheckUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<HutCheckCreateWithoutMountainInput, HutCheckUncheckedCreateWithoutMountainInput> | HutCheckCreateWithoutMountainInput[] | HutCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutMountainInput | HutCheckCreateOrConnectWithoutMountainInput[]
    createMany?: HutCheckCreateManyMountainInputEnvelope
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
  }

  export type AidRoomUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<AidRoomCreateWithoutMountainInput, AidRoomUncheckedCreateWithoutMountainInput> | AidRoomCreateWithoutMountainInput[] | AidRoomUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: AidRoomCreateOrConnectWithoutMountainInput | AidRoomCreateOrConnectWithoutMountainInput[]
    createMany?: AidRoomCreateManyMountainInputEnvelope
    connect?: AidRoomWhereUniqueInput | AidRoomWhereUniqueInput[]
  }

  export type AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<AidRoomCheckCreateWithoutMountainInput, AidRoomCheckUncheckedCreateWithoutMountainInput> | AidRoomCheckCreateWithoutMountainInput[] | AidRoomCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutMountainInput | AidRoomCheckCreateOrConnectWithoutMountainInput[]
    createMany?: AidRoomCheckCreateManyMountainInputEnvelope
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
  }

  export type EquipmentUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<EquipmentCreateWithoutMountainInput, EquipmentUncheckedCreateWithoutMountainInput> | EquipmentCreateWithoutMountainInput[] | EquipmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutMountainInput | EquipmentCreateOrConnectWithoutMountainInput[]
    createMany?: EquipmentCreateManyMountainInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<EquipmentCheckCreateWithoutMountainInput, EquipmentCheckUncheckedCreateWithoutMountainInput> | EquipmentCheckCreateWithoutMountainInput[] | EquipmentCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutMountainInput | EquipmentCheckCreateOrConnectWithoutMountainInput[]
    createMany?: EquipmentCheckCreateManyMountainInputEnvelope
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
  }

  export type IncidentUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<IncidentCreateWithoutMountainInput, IncidentUncheckedCreateWithoutMountainInput> | IncidentCreateWithoutMountainInput[] | IncidentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutMountainInput | IncidentCreateOrConnectWithoutMountainInput[]
    createMany?: IncidentCreateManyMountainInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type IncidentLogUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<IncidentLogCreateWithoutMountainInput, IncidentLogUncheckedCreateWithoutMountainInput> | IncidentLogCreateWithoutMountainInput[] | IncidentLogUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutMountainInput | IncidentLogCreateOrConnectWithoutMountainInput[]
    createMany?: IncidentLogCreateManyMountainInputEnvelope
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
  }

  export type DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<DispatcherAssignmentCreateWithoutMountainInput, DispatcherAssignmentUncheckedCreateWithoutMountainInput> | DispatcherAssignmentCreateWithoutMountainInput[] | DispatcherAssignmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: DispatcherAssignmentCreateOrConnectWithoutMountainInput | DispatcherAssignmentCreateOrConnectWithoutMountainInput[]
    createMany?: DispatcherAssignmentCreateManyMountainInputEnvelope
    connect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
  }

  export type IncidentLogEquipmentUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<IncidentLogEquipmentCreateWithoutMountainInput, IncidentLogEquipmentUncheckedCreateWithoutMountainInput> | IncidentLogEquipmentCreateWithoutMountainInput[] | IncidentLogEquipmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: IncidentLogEquipmentCreateOrConnectWithoutMountainInput | IncidentLogEquipmentCreateOrConnectWithoutMountainInput[]
    createMany?: IncidentLogEquipmentCreateManyMountainInputEnvelope
    connect?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
  }

  export type WeatherUncheckedCreateNestedManyWithoutMountainInput = {
    create?: XOR<WeatherCreateWithoutMountainInput, WeatherUncheckedCreateWithoutMountainInput> | WeatherCreateWithoutMountainInput[] | WeatherUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: WeatherCreateOrConnectWithoutMountainInput | WeatherCreateOrConnectWithoutMountainInput[]
    createMany?: WeatherCreateManyMountainInputEnvelope
    connect?: WeatherWhereUniqueInput | WeatherWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type LiftUpdateManyWithoutMountainNestedInput = {
    create?: XOR<LiftCreateWithoutMountainInput, LiftUncheckedCreateWithoutMountainInput> | LiftCreateWithoutMountainInput[] | LiftUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LiftCreateOrConnectWithoutMountainInput | LiftCreateOrConnectWithoutMountainInput[]
    upsert?: LiftUpsertWithWhereUniqueWithoutMountainInput | LiftUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: LiftCreateManyMountainInputEnvelope
    set?: LiftWhereUniqueInput | LiftWhereUniqueInput[]
    disconnect?: LiftWhereUniqueInput | LiftWhereUniqueInput[]
    delete?: LiftWhereUniqueInput | LiftWhereUniqueInput[]
    connect?: LiftWhereUniqueInput | LiftWhereUniqueInput[]
    update?: LiftUpdateWithWhereUniqueWithoutMountainInput | LiftUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: LiftUpdateManyWithWhereWithoutMountainInput | LiftUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: LiftScalarWhereInput | LiftScalarWhereInput[]
  }

  export type LiftCheckUpdateManyWithoutMountainNestedInput = {
    create?: XOR<LiftCheckCreateWithoutMountainInput, LiftCheckUncheckedCreateWithoutMountainInput> | LiftCheckCreateWithoutMountainInput[] | LiftCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutMountainInput | LiftCheckCreateOrConnectWithoutMountainInput[]
    upsert?: LiftCheckUpsertWithWhereUniqueWithoutMountainInput | LiftCheckUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: LiftCheckCreateManyMountainInputEnvelope
    set?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    disconnect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    delete?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    update?: LiftCheckUpdateWithWhereUniqueWithoutMountainInput | LiftCheckUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: LiftCheckUpdateManyWithWhereWithoutMountainInput | LiftCheckUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: LiftCheckScalarWhereInput | LiftCheckScalarWhereInput[]
  }

  export type TrailUpdateManyWithoutMountainNestedInput = {
    create?: XOR<TrailCreateWithoutMountainInput, TrailUncheckedCreateWithoutMountainInput> | TrailCreateWithoutMountainInput[] | TrailUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: TrailCreateOrConnectWithoutMountainInput | TrailCreateOrConnectWithoutMountainInput[]
    upsert?: TrailUpsertWithWhereUniqueWithoutMountainInput | TrailUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: TrailCreateManyMountainInputEnvelope
    set?: TrailWhereUniqueInput | TrailWhereUniqueInput[]
    disconnect?: TrailWhereUniqueInput | TrailWhereUniqueInput[]
    delete?: TrailWhereUniqueInput | TrailWhereUniqueInput[]
    connect?: TrailWhereUniqueInput | TrailWhereUniqueInput[]
    update?: TrailUpdateWithWhereUniqueWithoutMountainInput | TrailUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: TrailUpdateManyWithWhereWithoutMountainInput | TrailUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: TrailScalarWhereInput | TrailScalarWhereInput[]
  }

  export type TrailCheckUpdateManyWithoutMountainNestedInput = {
    create?: XOR<TrailCheckCreateWithoutMountainInput, TrailCheckUncheckedCreateWithoutMountainInput> | TrailCheckCreateWithoutMountainInput[] | TrailCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutMountainInput | TrailCheckCreateOrConnectWithoutMountainInput[]
    upsert?: TrailCheckUpsertWithWhereUniqueWithoutMountainInput | TrailCheckUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: TrailCheckCreateManyMountainInputEnvelope
    set?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    disconnect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    delete?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    update?: TrailCheckUpdateWithWhereUniqueWithoutMountainInput | TrailCheckUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: TrailCheckUpdateManyWithWhereWithoutMountainInput | TrailCheckUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: TrailCheckScalarWhereInput | TrailCheckScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutMountainNestedInput = {
    create?: XOR<EmployeeCreateWithoutMountainInput, EmployeeUncheckedCreateWithoutMountainInput> | EmployeeCreateWithoutMountainInput[] | EmployeeUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutMountainInput | EmployeeCreateOrConnectWithoutMountainInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutMountainInput | EmployeeUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: EmployeeCreateManyMountainInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutMountainInput | EmployeeUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutMountainInput | EmployeeUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type LodgeUpdateManyWithoutMountainNestedInput = {
    create?: XOR<LodgeCreateWithoutMountainInput, LodgeUncheckedCreateWithoutMountainInput> | LodgeCreateWithoutMountainInput[] | LodgeUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LodgeCreateOrConnectWithoutMountainInput | LodgeCreateOrConnectWithoutMountainInput[]
    upsert?: LodgeUpsertWithWhereUniqueWithoutMountainInput | LodgeUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: LodgeCreateManyMountainInputEnvelope
    set?: LodgeWhereUniqueInput | LodgeWhereUniqueInput[]
    disconnect?: LodgeWhereUniqueInput | LodgeWhereUniqueInput[]
    delete?: LodgeWhereUniqueInput | LodgeWhereUniqueInput[]
    connect?: LodgeWhereUniqueInput | LodgeWhereUniqueInput[]
    update?: LodgeUpdateWithWhereUniqueWithoutMountainInput | LodgeUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: LodgeUpdateManyWithWhereWithoutMountainInput | LodgeUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: LodgeScalarWhereInput | LodgeScalarWhereInput[]
  }

  export type HutUpdateManyWithoutMountainNestedInput = {
    create?: XOR<HutCreateWithoutMountainInput, HutUncheckedCreateWithoutMountainInput> | HutCreateWithoutMountainInput[] | HutUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: HutCreateOrConnectWithoutMountainInput | HutCreateOrConnectWithoutMountainInput[]
    upsert?: HutUpsertWithWhereUniqueWithoutMountainInput | HutUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: HutCreateManyMountainInputEnvelope
    set?: HutWhereUniqueInput | HutWhereUniqueInput[]
    disconnect?: HutWhereUniqueInput | HutWhereUniqueInput[]
    delete?: HutWhereUniqueInput | HutWhereUniqueInput[]
    connect?: HutWhereUniqueInput | HutWhereUniqueInput[]
    update?: HutUpdateWithWhereUniqueWithoutMountainInput | HutUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: HutUpdateManyWithWhereWithoutMountainInput | HutUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: HutScalarWhereInput | HutScalarWhereInput[]
  }

  export type HutCheckUpdateManyWithoutMountainNestedInput = {
    create?: XOR<HutCheckCreateWithoutMountainInput, HutCheckUncheckedCreateWithoutMountainInput> | HutCheckCreateWithoutMountainInput[] | HutCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutMountainInput | HutCheckCreateOrConnectWithoutMountainInput[]
    upsert?: HutCheckUpsertWithWhereUniqueWithoutMountainInput | HutCheckUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: HutCheckCreateManyMountainInputEnvelope
    set?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    disconnect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    delete?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    update?: HutCheckUpdateWithWhereUniqueWithoutMountainInput | HutCheckUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: HutCheckUpdateManyWithWhereWithoutMountainInput | HutCheckUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: HutCheckScalarWhereInput | HutCheckScalarWhereInput[]
  }

  export type AidRoomUpdateManyWithoutMountainNestedInput = {
    create?: XOR<AidRoomCreateWithoutMountainInput, AidRoomUncheckedCreateWithoutMountainInput> | AidRoomCreateWithoutMountainInput[] | AidRoomUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: AidRoomCreateOrConnectWithoutMountainInput | AidRoomCreateOrConnectWithoutMountainInput[]
    upsert?: AidRoomUpsertWithWhereUniqueWithoutMountainInput | AidRoomUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: AidRoomCreateManyMountainInputEnvelope
    set?: AidRoomWhereUniqueInput | AidRoomWhereUniqueInput[]
    disconnect?: AidRoomWhereUniqueInput | AidRoomWhereUniqueInput[]
    delete?: AidRoomWhereUniqueInput | AidRoomWhereUniqueInput[]
    connect?: AidRoomWhereUniqueInput | AidRoomWhereUniqueInput[]
    update?: AidRoomUpdateWithWhereUniqueWithoutMountainInput | AidRoomUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: AidRoomUpdateManyWithWhereWithoutMountainInput | AidRoomUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: AidRoomScalarWhereInput | AidRoomScalarWhereInput[]
  }

  export type AidRoomCheckUpdateManyWithoutMountainNestedInput = {
    create?: XOR<AidRoomCheckCreateWithoutMountainInput, AidRoomCheckUncheckedCreateWithoutMountainInput> | AidRoomCheckCreateWithoutMountainInput[] | AidRoomCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutMountainInput | AidRoomCheckCreateOrConnectWithoutMountainInput[]
    upsert?: AidRoomCheckUpsertWithWhereUniqueWithoutMountainInput | AidRoomCheckUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: AidRoomCheckCreateManyMountainInputEnvelope
    set?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    disconnect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    delete?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    update?: AidRoomCheckUpdateWithWhereUniqueWithoutMountainInput | AidRoomCheckUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: AidRoomCheckUpdateManyWithWhereWithoutMountainInput | AidRoomCheckUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: AidRoomCheckScalarWhereInput | AidRoomCheckScalarWhereInput[]
  }

  export type EquipmentUpdateManyWithoutMountainNestedInput = {
    create?: XOR<EquipmentCreateWithoutMountainInput, EquipmentUncheckedCreateWithoutMountainInput> | EquipmentCreateWithoutMountainInput[] | EquipmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutMountainInput | EquipmentCreateOrConnectWithoutMountainInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutMountainInput | EquipmentUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: EquipmentCreateManyMountainInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutMountainInput | EquipmentUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutMountainInput | EquipmentUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type EquipmentCheckUpdateManyWithoutMountainNestedInput = {
    create?: XOR<EquipmentCheckCreateWithoutMountainInput, EquipmentCheckUncheckedCreateWithoutMountainInput> | EquipmentCheckCreateWithoutMountainInput[] | EquipmentCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutMountainInput | EquipmentCheckCreateOrConnectWithoutMountainInput[]
    upsert?: EquipmentCheckUpsertWithWhereUniqueWithoutMountainInput | EquipmentCheckUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: EquipmentCheckCreateManyMountainInputEnvelope
    set?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    disconnect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    delete?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    update?: EquipmentCheckUpdateWithWhereUniqueWithoutMountainInput | EquipmentCheckUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: EquipmentCheckUpdateManyWithWhereWithoutMountainInput | EquipmentCheckUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: EquipmentCheckScalarWhereInput | EquipmentCheckScalarWhereInput[]
  }

  export type IncidentUpdateManyWithoutMountainNestedInput = {
    create?: XOR<IncidentCreateWithoutMountainInput, IncidentUncheckedCreateWithoutMountainInput> | IncidentCreateWithoutMountainInput[] | IncidentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutMountainInput | IncidentCreateOrConnectWithoutMountainInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutMountainInput | IncidentUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: IncidentCreateManyMountainInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutMountainInput | IncidentUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutMountainInput | IncidentUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type IncidentLogUpdateManyWithoutMountainNestedInput = {
    create?: XOR<IncidentLogCreateWithoutMountainInput, IncidentLogUncheckedCreateWithoutMountainInput> | IncidentLogCreateWithoutMountainInput[] | IncidentLogUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutMountainInput | IncidentLogCreateOrConnectWithoutMountainInput[]
    upsert?: IncidentLogUpsertWithWhereUniqueWithoutMountainInput | IncidentLogUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: IncidentLogCreateManyMountainInputEnvelope
    set?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    disconnect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    delete?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    update?: IncidentLogUpdateWithWhereUniqueWithoutMountainInput | IncidentLogUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: IncidentLogUpdateManyWithWhereWithoutMountainInput | IncidentLogUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: IncidentLogScalarWhereInput | IncidentLogScalarWhereInput[]
  }

  export type DispatcherAssignmentUpdateManyWithoutMountainNestedInput = {
    create?: XOR<DispatcherAssignmentCreateWithoutMountainInput, DispatcherAssignmentUncheckedCreateWithoutMountainInput> | DispatcherAssignmentCreateWithoutMountainInput[] | DispatcherAssignmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: DispatcherAssignmentCreateOrConnectWithoutMountainInput | DispatcherAssignmentCreateOrConnectWithoutMountainInput[]
    upsert?: DispatcherAssignmentUpsertWithWhereUniqueWithoutMountainInput | DispatcherAssignmentUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: DispatcherAssignmentCreateManyMountainInputEnvelope
    set?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    disconnect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    delete?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    connect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    update?: DispatcherAssignmentUpdateWithWhereUniqueWithoutMountainInput | DispatcherAssignmentUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: DispatcherAssignmentUpdateManyWithWhereWithoutMountainInput | DispatcherAssignmentUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: DispatcherAssignmentScalarWhereInput | DispatcherAssignmentScalarWhereInput[]
  }

  export type IncidentLogEquipmentUpdateManyWithoutMountainNestedInput = {
    create?: XOR<IncidentLogEquipmentCreateWithoutMountainInput, IncidentLogEquipmentUncheckedCreateWithoutMountainInput> | IncidentLogEquipmentCreateWithoutMountainInput[] | IncidentLogEquipmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: IncidentLogEquipmentCreateOrConnectWithoutMountainInput | IncidentLogEquipmentCreateOrConnectWithoutMountainInput[]
    upsert?: IncidentLogEquipmentUpsertWithWhereUniqueWithoutMountainInput | IncidentLogEquipmentUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: IncidentLogEquipmentCreateManyMountainInputEnvelope
    set?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    disconnect?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    delete?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    connect?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    update?: IncidentLogEquipmentUpdateWithWhereUniqueWithoutMountainInput | IncidentLogEquipmentUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: IncidentLogEquipmentUpdateManyWithWhereWithoutMountainInput | IncidentLogEquipmentUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: IncidentLogEquipmentScalarWhereInput | IncidentLogEquipmentScalarWhereInput[]
  }

  export type WeatherUpdateManyWithoutMountainNestedInput = {
    create?: XOR<WeatherCreateWithoutMountainInput, WeatherUncheckedCreateWithoutMountainInput> | WeatherCreateWithoutMountainInput[] | WeatherUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: WeatherCreateOrConnectWithoutMountainInput | WeatherCreateOrConnectWithoutMountainInput[]
    upsert?: WeatherUpsertWithWhereUniqueWithoutMountainInput | WeatherUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: WeatherCreateManyMountainInputEnvelope
    set?: WeatherWhereUniqueInput | WeatherWhereUniqueInput[]
    disconnect?: WeatherWhereUniqueInput | WeatherWhereUniqueInput[]
    delete?: WeatherWhereUniqueInput | WeatherWhereUniqueInput[]
    connect?: WeatherWhereUniqueInput | WeatherWhereUniqueInput[]
    update?: WeatherUpdateWithWhereUniqueWithoutMountainInput | WeatherUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: WeatherUpdateManyWithWhereWithoutMountainInput | WeatherUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: WeatherScalarWhereInput | WeatherScalarWhereInput[]
  }

  export type LiftUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<LiftCreateWithoutMountainInput, LiftUncheckedCreateWithoutMountainInput> | LiftCreateWithoutMountainInput[] | LiftUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LiftCreateOrConnectWithoutMountainInput | LiftCreateOrConnectWithoutMountainInput[]
    upsert?: LiftUpsertWithWhereUniqueWithoutMountainInput | LiftUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: LiftCreateManyMountainInputEnvelope
    set?: LiftWhereUniqueInput | LiftWhereUniqueInput[]
    disconnect?: LiftWhereUniqueInput | LiftWhereUniqueInput[]
    delete?: LiftWhereUniqueInput | LiftWhereUniqueInput[]
    connect?: LiftWhereUniqueInput | LiftWhereUniqueInput[]
    update?: LiftUpdateWithWhereUniqueWithoutMountainInput | LiftUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: LiftUpdateManyWithWhereWithoutMountainInput | LiftUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: LiftScalarWhereInput | LiftScalarWhereInput[]
  }

  export type LiftCheckUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<LiftCheckCreateWithoutMountainInput, LiftCheckUncheckedCreateWithoutMountainInput> | LiftCheckCreateWithoutMountainInput[] | LiftCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutMountainInput | LiftCheckCreateOrConnectWithoutMountainInput[]
    upsert?: LiftCheckUpsertWithWhereUniqueWithoutMountainInput | LiftCheckUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: LiftCheckCreateManyMountainInputEnvelope
    set?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    disconnect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    delete?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    update?: LiftCheckUpdateWithWhereUniqueWithoutMountainInput | LiftCheckUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: LiftCheckUpdateManyWithWhereWithoutMountainInput | LiftCheckUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: LiftCheckScalarWhereInput | LiftCheckScalarWhereInput[]
  }

  export type TrailUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<TrailCreateWithoutMountainInput, TrailUncheckedCreateWithoutMountainInput> | TrailCreateWithoutMountainInput[] | TrailUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: TrailCreateOrConnectWithoutMountainInput | TrailCreateOrConnectWithoutMountainInput[]
    upsert?: TrailUpsertWithWhereUniqueWithoutMountainInput | TrailUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: TrailCreateManyMountainInputEnvelope
    set?: TrailWhereUniqueInput | TrailWhereUniqueInput[]
    disconnect?: TrailWhereUniqueInput | TrailWhereUniqueInput[]
    delete?: TrailWhereUniqueInput | TrailWhereUniqueInput[]
    connect?: TrailWhereUniqueInput | TrailWhereUniqueInput[]
    update?: TrailUpdateWithWhereUniqueWithoutMountainInput | TrailUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: TrailUpdateManyWithWhereWithoutMountainInput | TrailUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: TrailScalarWhereInput | TrailScalarWhereInput[]
  }

  export type TrailCheckUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<TrailCheckCreateWithoutMountainInput, TrailCheckUncheckedCreateWithoutMountainInput> | TrailCheckCreateWithoutMountainInput[] | TrailCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutMountainInput | TrailCheckCreateOrConnectWithoutMountainInput[]
    upsert?: TrailCheckUpsertWithWhereUniqueWithoutMountainInput | TrailCheckUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: TrailCheckCreateManyMountainInputEnvelope
    set?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    disconnect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    delete?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    update?: TrailCheckUpdateWithWhereUniqueWithoutMountainInput | TrailCheckUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: TrailCheckUpdateManyWithWhereWithoutMountainInput | TrailCheckUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: TrailCheckScalarWhereInput | TrailCheckScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<EmployeeCreateWithoutMountainInput, EmployeeUncheckedCreateWithoutMountainInput> | EmployeeCreateWithoutMountainInput[] | EmployeeUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutMountainInput | EmployeeCreateOrConnectWithoutMountainInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutMountainInput | EmployeeUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: EmployeeCreateManyMountainInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutMountainInput | EmployeeUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutMountainInput | EmployeeUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type LodgeUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<LodgeCreateWithoutMountainInput, LodgeUncheckedCreateWithoutMountainInput> | LodgeCreateWithoutMountainInput[] | LodgeUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: LodgeCreateOrConnectWithoutMountainInput | LodgeCreateOrConnectWithoutMountainInput[]
    upsert?: LodgeUpsertWithWhereUniqueWithoutMountainInput | LodgeUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: LodgeCreateManyMountainInputEnvelope
    set?: LodgeWhereUniqueInput | LodgeWhereUniqueInput[]
    disconnect?: LodgeWhereUniqueInput | LodgeWhereUniqueInput[]
    delete?: LodgeWhereUniqueInput | LodgeWhereUniqueInput[]
    connect?: LodgeWhereUniqueInput | LodgeWhereUniqueInput[]
    update?: LodgeUpdateWithWhereUniqueWithoutMountainInput | LodgeUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: LodgeUpdateManyWithWhereWithoutMountainInput | LodgeUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: LodgeScalarWhereInput | LodgeScalarWhereInput[]
  }

  export type HutUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<HutCreateWithoutMountainInput, HutUncheckedCreateWithoutMountainInput> | HutCreateWithoutMountainInput[] | HutUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: HutCreateOrConnectWithoutMountainInput | HutCreateOrConnectWithoutMountainInput[]
    upsert?: HutUpsertWithWhereUniqueWithoutMountainInput | HutUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: HutCreateManyMountainInputEnvelope
    set?: HutWhereUniqueInput | HutWhereUniqueInput[]
    disconnect?: HutWhereUniqueInput | HutWhereUniqueInput[]
    delete?: HutWhereUniqueInput | HutWhereUniqueInput[]
    connect?: HutWhereUniqueInput | HutWhereUniqueInput[]
    update?: HutUpdateWithWhereUniqueWithoutMountainInput | HutUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: HutUpdateManyWithWhereWithoutMountainInput | HutUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: HutScalarWhereInput | HutScalarWhereInput[]
  }

  export type HutCheckUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<HutCheckCreateWithoutMountainInput, HutCheckUncheckedCreateWithoutMountainInput> | HutCheckCreateWithoutMountainInput[] | HutCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutMountainInput | HutCheckCreateOrConnectWithoutMountainInput[]
    upsert?: HutCheckUpsertWithWhereUniqueWithoutMountainInput | HutCheckUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: HutCheckCreateManyMountainInputEnvelope
    set?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    disconnect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    delete?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    update?: HutCheckUpdateWithWhereUniqueWithoutMountainInput | HutCheckUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: HutCheckUpdateManyWithWhereWithoutMountainInput | HutCheckUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: HutCheckScalarWhereInput | HutCheckScalarWhereInput[]
  }

  export type AidRoomUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<AidRoomCreateWithoutMountainInput, AidRoomUncheckedCreateWithoutMountainInput> | AidRoomCreateWithoutMountainInput[] | AidRoomUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: AidRoomCreateOrConnectWithoutMountainInput | AidRoomCreateOrConnectWithoutMountainInput[]
    upsert?: AidRoomUpsertWithWhereUniqueWithoutMountainInput | AidRoomUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: AidRoomCreateManyMountainInputEnvelope
    set?: AidRoomWhereUniqueInput | AidRoomWhereUniqueInput[]
    disconnect?: AidRoomWhereUniqueInput | AidRoomWhereUniqueInput[]
    delete?: AidRoomWhereUniqueInput | AidRoomWhereUniqueInput[]
    connect?: AidRoomWhereUniqueInput | AidRoomWhereUniqueInput[]
    update?: AidRoomUpdateWithWhereUniqueWithoutMountainInput | AidRoomUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: AidRoomUpdateManyWithWhereWithoutMountainInput | AidRoomUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: AidRoomScalarWhereInput | AidRoomScalarWhereInput[]
  }

  export type AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<AidRoomCheckCreateWithoutMountainInput, AidRoomCheckUncheckedCreateWithoutMountainInput> | AidRoomCheckCreateWithoutMountainInput[] | AidRoomCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutMountainInput | AidRoomCheckCreateOrConnectWithoutMountainInput[]
    upsert?: AidRoomCheckUpsertWithWhereUniqueWithoutMountainInput | AidRoomCheckUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: AidRoomCheckCreateManyMountainInputEnvelope
    set?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    disconnect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    delete?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    update?: AidRoomCheckUpdateWithWhereUniqueWithoutMountainInput | AidRoomCheckUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: AidRoomCheckUpdateManyWithWhereWithoutMountainInput | AidRoomCheckUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: AidRoomCheckScalarWhereInput | AidRoomCheckScalarWhereInput[]
  }

  export type EquipmentUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<EquipmentCreateWithoutMountainInput, EquipmentUncheckedCreateWithoutMountainInput> | EquipmentCreateWithoutMountainInput[] | EquipmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutMountainInput | EquipmentCreateOrConnectWithoutMountainInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutMountainInput | EquipmentUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: EquipmentCreateManyMountainInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutMountainInput | EquipmentUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutMountainInput | EquipmentUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<EquipmentCheckCreateWithoutMountainInput, EquipmentCheckUncheckedCreateWithoutMountainInput> | EquipmentCheckCreateWithoutMountainInput[] | EquipmentCheckUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutMountainInput | EquipmentCheckCreateOrConnectWithoutMountainInput[]
    upsert?: EquipmentCheckUpsertWithWhereUniqueWithoutMountainInput | EquipmentCheckUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: EquipmentCheckCreateManyMountainInputEnvelope
    set?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    disconnect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    delete?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    update?: EquipmentCheckUpdateWithWhereUniqueWithoutMountainInput | EquipmentCheckUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: EquipmentCheckUpdateManyWithWhereWithoutMountainInput | EquipmentCheckUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: EquipmentCheckScalarWhereInput | EquipmentCheckScalarWhereInput[]
  }

  export type IncidentUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<IncidentCreateWithoutMountainInput, IncidentUncheckedCreateWithoutMountainInput> | IncidentCreateWithoutMountainInput[] | IncidentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutMountainInput | IncidentCreateOrConnectWithoutMountainInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutMountainInput | IncidentUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: IncidentCreateManyMountainInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutMountainInput | IncidentUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutMountainInput | IncidentUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type IncidentLogUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<IncidentLogCreateWithoutMountainInput, IncidentLogUncheckedCreateWithoutMountainInput> | IncidentLogCreateWithoutMountainInput[] | IncidentLogUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutMountainInput | IncidentLogCreateOrConnectWithoutMountainInput[]
    upsert?: IncidentLogUpsertWithWhereUniqueWithoutMountainInput | IncidentLogUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: IncidentLogCreateManyMountainInputEnvelope
    set?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    disconnect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    delete?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    update?: IncidentLogUpdateWithWhereUniqueWithoutMountainInput | IncidentLogUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: IncidentLogUpdateManyWithWhereWithoutMountainInput | IncidentLogUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: IncidentLogScalarWhereInput | IncidentLogScalarWhereInput[]
  }

  export type DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<DispatcherAssignmentCreateWithoutMountainInput, DispatcherAssignmentUncheckedCreateWithoutMountainInput> | DispatcherAssignmentCreateWithoutMountainInput[] | DispatcherAssignmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: DispatcherAssignmentCreateOrConnectWithoutMountainInput | DispatcherAssignmentCreateOrConnectWithoutMountainInput[]
    upsert?: DispatcherAssignmentUpsertWithWhereUniqueWithoutMountainInput | DispatcherAssignmentUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: DispatcherAssignmentCreateManyMountainInputEnvelope
    set?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    disconnect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    delete?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    connect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    update?: DispatcherAssignmentUpdateWithWhereUniqueWithoutMountainInput | DispatcherAssignmentUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: DispatcherAssignmentUpdateManyWithWhereWithoutMountainInput | DispatcherAssignmentUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: DispatcherAssignmentScalarWhereInput | DispatcherAssignmentScalarWhereInput[]
  }

  export type IncidentLogEquipmentUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<IncidentLogEquipmentCreateWithoutMountainInput, IncidentLogEquipmentUncheckedCreateWithoutMountainInput> | IncidentLogEquipmentCreateWithoutMountainInput[] | IncidentLogEquipmentUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: IncidentLogEquipmentCreateOrConnectWithoutMountainInput | IncidentLogEquipmentCreateOrConnectWithoutMountainInput[]
    upsert?: IncidentLogEquipmentUpsertWithWhereUniqueWithoutMountainInput | IncidentLogEquipmentUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: IncidentLogEquipmentCreateManyMountainInputEnvelope
    set?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    disconnect?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    delete?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    connect?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    update?: IncidentLogEquipmentUpdateWithWhereUniqueWithoutMountainInput | IncidentLogEquipmentUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: IncidentLogEquipmentUpdateManyWithWhereWithoutMountainInput | IncidentLogEquipmentUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: IncidentLogEquipmentScalarWhereInput | IncidentLogEquipmentScalarWhereInput[]
  }

  export type WeatherUncheckedUpdateManyWithoutMountainNestedInput = {
    create?: XOR<WeatherCreateWithoutMountainInput, WeatherUncheckedCreateWithoutMountainInput> | WeatherCreateWithoutMountainInput[] | WeatherUncheckedCreateWithoutMountainInput[]
    connectOrCreate?: WeatherCreateOrConnectWithoutMountainInput | WeatherCreateOrConnectWithoutMountainInput[]
    upsert?: WeatherUpsertWithWhereUniqueWithoutMountainInput | WeatherUpsertWithWhereUniqueWithoutMountainInput[]
    createMany?: WeatherCreateManyMountainInputEnvelope
    set?: WeatherWhereUniqueInput | WeatherWhereUniqueInput[]
    disconnect?: WeatherWhereUniqueInput | WeatherWhereUniqueInput[]
    delete?: WeatherWhereUniqueInput | WeatherWhereUniqueInput[]
    connect?: WeatherWhereUniqueInput | WeatherWhereUniqueInput[]
    update?: WeatherUpdateWithWhereUniqueWithoutMountainInput | WeatherUpdateWithWhereUniqueWithoutMountainInput[]
    updateMany?: WeatherUpdateManyWithWhereWithoutMountainInput | WeatherUpdateManyWithWhereWithoutMountainInput[]
    deleteMany?: WeatherScalarWhereInput | WeatherScalarWhereInput[]
  }

  export type MountainCreateNestedOneWithoutWeatherInput = {
    create?: XOR<MountainCreateWithoutWeatherInput, MountainUncheckedCreateWithoutWeatherInput>
    connectOrCreate?: MountainCreateOrConnectWithoutWeatherInput
    connect?: MountainWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MountainUpdateOneRequiredWithoutWeatherNestedInput = {
    create?: XOR<MountainCreateWithoutWeatherInput, MountainUncheckedCreateWithoutWeatherInput>
    connectOrCreate?: MountainCreateOrConnectWithoutWeatherInput
    upsert?: MountainUpsertWithoutWeatherInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutWeatherInput, MountainUpdateWithoutWeatherInput>, MountainUncheckedUpdateWithoutWeatherInput>
  }

  export type MountainCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<MountainCreateWithoutEmployeesInput, MountainUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: MountainCreateOrConnectWithoutEmployeesInput
    connect?: MountainWhereUniqueInput
  }

  export type DispatcherAssignmentCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<DispatcherAssignmentCreateWithoutEmployeeInput, DispatcherAssignmentUncheckedCreateWithoutEmployeeInput> | DispatcherAssignmentCreateWithoutEmployeeInput[] | DispatcherAssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DispatcherAssignmentCreateOrConnectWithoutEmployeeInput | DispatcherAssignmentCreateOrConnectWithoutEmployeeInput[]
    createMany?: DispatcherAssignmentCreateManyEmployeeInputEnvelope
    connect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
  }

  export type IncidentLogCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<IncidentLogCreateWithoutEmployeeInput, IncidentLogUncheckedCreateWithoutEmployeeInput> | IncidentLogCreateWithoutEmployeeInput[] | IncidentLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutEmployeeInput | IncidentLogCreateOrConnectWithoutEmployeeInput[]
    createMany?: IncidentLogCreateManyEmployeeInputEnvelope
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
  }

  export type LiftCheckCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LiftCheckCreateWithoutEmployeeInput, LiftCheckUncheckedCreateWithoutEmployeeInput> | LiftCheckCreateWithoutEmployeeInput[] | LiftCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutEmployeeInput | LiftCheckCreateOrConnectWithoutEmployeeInput[]
    createMany?: LiftCheckCreateManyEmployeeInputEnvelope
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
  }

  export type TrailCheckCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<TrailCheckCreateWithoutEmployeeInput, TrailCheckUncheckedCreateWithoutEmployeeInput> | TrailCheckCreateWithoutEmployeeInput[] | TrailCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutEmployeeInput | TrailCheckCreateOrConnectWithoutEmployeeInput[]
    createMany?: TrailCheckCreateManyEmployeeInputEnvelope
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
  }

  export type HutCheckCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<HutCheckCreateWithoutEmployeeInput, HutCheckUncheckedCreateWithoutEmployeeInput> | HutCheckCreateWithoutEmployeeInput[] | HutCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutEmployeeInput | HutCheckCreateOrConnectWithoutEmployeeInput[]
    createMany?: HutCheckCreateManyEmployeeInputEnvelope
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
  }

  export type AidRoomCheckCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AidRoomCheckCreateWithoutEmployeeInput, AidRoomCheckUncheckedCreateWithoutEmployeeInput> | AidRoomCheckCreateWithoutEmployeeInput[] | AidRoomCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutEmployeeInput | AidRoomCheckCreateOrConnectWithoutEmployeeInput[]
    createMany?: AidRoomCheckCreateManyEmployeeInputEnvelope
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
  }

  export type EquipmentCheckCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EquipmentCheckCreateWithoutEmployeeInput, EquipmentCheckUncheckedCreateWithoutEmployeeInput> | EquipmentCheckCreateWithoutEmployeeInput[] | EquipmentCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutEmployeeInput | EquipmentCheckCreateOrConnectWithoutEmployeeInput[]
    createMany?: EquipmentCheckCreateManyEmployeeInputEnvelope
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
  }

  export type DispatcherAssignmentUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<DispatcherAssignmentCreateWithoutEmployeeInput, DispatcherAssignmentUncheckedCreateWithoutEmployeeInput> | DispatcherAssignmentCreateWithoutEmployeeInput[] | DispatcherAssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DispatcherAssignmentCreateOrConnectWithoutEmployeeInput | DispatcherAssignmentCreateOrConnectWithoutEmployeeInput[]
    createMany?: DispatcherAssignmentCreateManyEmployeeInputEnvelope
    connect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
  }

  export type IncidentLogUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<IncidentLogCreateWithoutEmployeeInput, IncidentLogUncheckedCreateWithoutEmployeeInput> | IncidentLogCreateWithoutEmployeeInput[] | IncidentLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutEmployeeInput | IncidentLogCreateOrConnectWithoutEmployeeInput[]
    createMany?: IncidentLogCreateManyEmployeeInputEnvelope
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
  }

  export type LiftCheckUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LiftCheckCreateWithoutEmployeeInput, LiftCheckUncheckedCreateWithoutEmployeeInput> | LiftCheckCreateWithoutEmployeeInput[] | LiftCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutEmployeeInput | LiftCheckCreateOrConnectWithoutEmployeeInput[]
    createMany?: LiftCheckCreateManyEmployeeInputEnvelope
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
  }

  export type TrailCheckUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<TrailCheckCreateWithoutEmployeeInput, TrailCheckUncheckedCreateWithoutEmployeeInput> | TrailCheckCreateWithoutEmployeeInput[] | TrailCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutEmployeeInput | TrailCheckCreateOrConnectWithoutEmployeeInput[]
    createMany?: TrailCheckCreateManyEmployeeInputEnvelope
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
  }

  export type HutCheckUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<HutCheckCreateWithoutEmployeeInput, HutCheckUncheckedCreateWithoutEmployeeInput> | HutCheckCreateWithoutEmployeeInput[] | HutCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutEmployeeInput | HutCheckCreateOrConnectWithoutEmployeeInput[]
    createMany?: HutCheckCreateManyEmployeeInputEnvelope
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
  }

  export type AidRoomCheckUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AidRoomCheckCreateWithoutEmployeeInput, AidRoomCheckUncheckedCreateWithoutEmployeeInput> | AidRoomCheckCreateWithoutEmployeeInput[] | AidRoomCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutEmployeeInput | AidRoomCheckCreateOrConnectWithoutEmployeeInput[]
    createMany?: AidRoomCheckCreateManyEmployeeInputEnvelope
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
  }

  export type EquipmentCheckUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EquipmentCheckCreateWithoutEmployeeInput, EquipmentCheckUncheckedCreateWithoutEmployeeInput> | EquipmentCheckCreateWithoutEmployeeInput[] | EquipmentCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutEmployeeInput | EquipmentCheckCreateOrConnectWithoutEmployeeInput[]
    createMany?: EquipmentCheckCreateManyEmployeeInputEnvelope
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
  }

  export type EnumDepartmentFieldUpdateOperationsInput = {
    set?: $Enums.Department
  }

  export type MountainUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<MountainCreateWithoutEmployeesInput, MountainUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: MountainCreateOrConnectWithoutEmployeesInput
    upsert?: MountainUpsertWithoutEmployeesInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutEmployeesInput, MountainUpdateWithoutEmployeesInput>, MountainUncheckedUpdateWithoutEmployeesInput>
  }

  export type DispatcherAssignmentUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<DispatcherAssignmentCreateWithoutEmployeeInput, DispatcherAssignmentUncheckedCreateWithoutEmployeeInput> | DispatcherAssignmentCreateWithoutEmployeeInput[] | DispatcherAssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DispatcherAssignmentCreateOrConnectWithoutEmployeeInput | DispatcherAssignmentCreateOrConnectWithoutEmployeeInput[]
    upsert?: DispatcherAssignmentUpsertWithWhereUniqueWithoutEmployeeInput | DispatcherAssignmentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: DispatcherAssignmentCreateManyEmployeeInputEnvelope
    set?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    disconnect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    delete?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    connect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    update?: DispatcherAssignmentUpdateWithWhereUniqueWithoutEmployeeInput | DispatcherAssignmentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: DispatcherAssignmentUpdateManyWithWhereWithoutEmployeeInput | DispatcherAssignmentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: DispatcherAssignmentScalarWhereInput | DispatcherAssignmentScalarWhereInput[]
  }

  export type IncidentLogUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<IncidentLogCreateWithoutEmployeeInput, IncidentLogUncheckedCreateWithoutEmployeeInput> | IncidentLogCreateWithoutEmployeeInput[] | IncidentLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutEmployeeInput | IncidentLogCreateOrConnectWithoutEmployeeInput[]
    upsert?: IncidentLogUpsertWithWhereUniqueWithoutEmployeeInput | IncidentLogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: IncidentLogCreateManyEmployeeInputEnvelope
    set?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    disconnect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    delete?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    update?: IncidentLogUpdateWithWhereUniqueWithoutEmployeeInput | IncidentLogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: IncidentLogUpdateManyWithWhereWithoutEmployeeInput | IncidentLogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: IncidentLogScalarWhereInput | IncidentLogScalarWhereInput[]
  }

  export type LiftCheckUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LiftCheckCreateWithoutEmployeeInput, LiftCheckUncheckedCreateWithoutEmployeeInput> | LiftCheckCreateWithoutEmployeeInput[] | LiftCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutEmployeeInput | LiftCheckCreateOrConnectWithoutEmployeeInput[]
    upsert?: LiftCheckUpsertWithWhereUniqueWithoutEmployeeInput | LiftCheckUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LiftCheckCreateManyEmployeeInputEnvelope
    set?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    disconnect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    delete?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    update?: LiftCheckUpdateWithWhereUniqueWithoutEmployeeInput | LiftCheckUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LiftCheckUpdateManyWithWhereWithoutEmployeeInput | LiftCheckUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LiftCheckScalarWhereInput | LiftCheckScalarWhereInput[]
  }

  export type TrailCheckUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<TrailCheckCreateWithoutEmployeeInput, TrailCheckUncheckedCreateWithoutEmployeeInput> | TrailCheckCreateWithoutEmployeeInput[] | TrailCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutEmployeeInput | TrailCheckCreateOrConnectWithoutEmployeeInput[]
    upsert?: TrailCheckUpsertWithWhereUniqueWithoutEmployeeInput | TrailCheckUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: TrailCheckCreateManyEmployeeInputEnvelope
    set?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    disconnect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    delete?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    update?: TrailCheckUpdateWithWhereUniqueWithoutEmployeeInput | TrailCheckUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: TrailCheckUpdateManyWithWhereWithoutEmployeeInput | TrailCheckUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: TrailCheckScalarWhereInput | TrailCheckScalarWhereInput[]
  }

  export type HutCheckUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<HutCheckCreateWithoutEmployeeInput, HutCheckUncheckedCreateWithoutEmployeeInput> | HutCheckCreateWithoutEmployeeInput[] | HutCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutEmployeeInput | HutCheckCreateOrConnectWithoutEmployeeInput[]
    upsert?: HutCheckUpsertWithWhereUniqueWithoutEmployeeInput | HutCheckUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: HutCheckCreateManyEmployeeInputEnvelope
    set?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    disconnect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    delete?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    update?: HutCheckUpdateWithWhereUniqueWithoutEmployeeInput | HutCheckUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: HutCheckUpdateManyWithWhereWithoutEmployeeInput | HutCheckUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: HutCheckScalarWhereInput | HutCheckScalarWhereInput[]
  }

  export type AidRoomCheckUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AidRoomCheckCreateWithoutEmployeeInput, AidRoomCheckUncheckedCreateWithoutEmployeeInput> | AidRoomCheckCreateWithoutEmployeeInput[] | AidRoomCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutEmployeeInput | AidRoomCheckCreateOrConnectWithoutEmployeeInput[]
    upsert?: AidRoomCheckUpsertWithWhereUniqueWithoutEmployeeInput | AidRoomCheckUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AidRoomCheckCreateManyEmployeeInputEnvelope
    set?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    disconnect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    delete?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    update?: AidRoomCheckUpdateWithWhereUniqueWithoutEmployeeInput | AidRoomCheckUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AidRoomCheckUpdateManyWithWhereWithoutEmployeeInput | AidRoomCheckUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AidRoomCheckScalarWhereInput | AidRoomCheckScalarWhereInput[]
  }

  export type EquipmentCheckUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EquipmentCheckCreateWithoutEmployeeInput, EquipmentCheckUncheckedCreateWithoutEmployeeInput> | EquipmentCheckCreateWithoutEmployeeInput[] | EquipmentCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutEmployeeInput | EquipmentCheckCreateOrConnectWithoutEmployeeInput[]
    upsert?: EquipmentCheckUpsertWithWhereUniqueWithoutEmployeeInput | EquipmentCheckUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EquipmentCheckCreateManyEmployeeInputEnvelope
    set?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    disconnect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    delete?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    update?: EquipmentCheckUpdateWithWhereUniqueWithoutEmployeeInput | EquipmentCheckUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EquipmentCheckUpdateManyWithWhereWithoutEmployeeInput | EquipmentCheckUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EquipmentCheckScalarWhereInput | EquipmentCheckScalarWhereInput[]
  }

  export type DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<DispatcherAssignmentCreateWithoutEmployeeInput, DispatcherAssignmentUncheckedCreateWithoutEmployeeInput> | DispatcherAssignmentCreateWithoutEmployeeInput[] | DispatcherAssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DispatcherAssignmentCreateOrConnectWithoutEmployeeInput | DispatcherAssignmentCreateOrConnectWithoutEmployeeInput[]
    upsert?: DispatcherAssignmentUpsertWithWhereUniqueWithoutEmployeeInput | DispatcherAssignmentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: DispatcherAssignmentCreateManyEmployeeInputEnvelope
    set?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    disconnect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    delete?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    connect?: DispatcherAssignmentWhereUniqueInput | DispatcherAssignmentWhereUniqueInput[]
    update?: DispatcherAssignmentUpdateWithWhereUniqueWithoutEmployeeInput | DispatcherAssignmentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: DispatcherAssignmentUpdateManyWithWhereWithoutEmployeeInput | DispatcherAssignmentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: DispatcherAssignmentScalarWhereInput | DispatcherAssignmentScalarWhereInput[]
  }

  export type IncidentLogUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<IncidentLogCreateWithoutEmployeeInput, IncidentLogUncheckedCreateWithoutEmployeeInput> | IncidentLogCreateWithoutEmployeeInput[] | IncidentLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutEmployeeInput | IncidentLogCreateOrConnectWithoutEmployeeInput[]
    upsert?: IncidentLogUpsertWithWhereUniqueWithoutEmployeeInput | IncidentLogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: IncidentLogCreateManyEmployeeInputEnvelope
    set?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    disconnect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    delete?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    update?: IncidentLogUpdateWithWhereUniqueWithoutEmployeeInput | IncidentLogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: IncidentLogUpdateManyWithWhereWithoutEmployeeInput | IncidentLogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: IncidentLogScalarWhereInput | IncidentLogScalarWhereInput[]
  }

  export type LiftCheckUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LiftCheckCreateWithoutEmployeeInput, LiftCheckUncheckedCreateWithoutEmployeeInput> | LiftCheckCreateWithoutEmployeeInput[] | LiftCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutEmployeeInput | LiftCheckCreateOrConnectWithoutEmployeeInput[]
    upsert?: LiftCheckUpsertWithWhereUniqueWithoutEmployeeInput | LiftCheckUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LiftCheckCreateManyEmployeeInputEnvelope
    set?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    disconnect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    delete?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    update?: LiftCheckUpdateWithWhereUniqueWithoutEmployeeInput | LiftCheckUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LiftCheckUpdateManyWithWhereWithoutEmployeeInput | LiftCheckUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LiftCheckScalarWhereInput | LiftCheckScalarWhereInput[]
  }

  export type TrailCheckUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<TrailCheckCreateWithoutEmployeeInput, TrailCheckUncheckedCreateWithoutEmployeeInput> | TrailCheckCreateWithoutEmployeeInput[] | TrailCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutEmployeeInput | TrailCheckCreateOrConnectWithoutEmployeeInput[]
    upsert?: TrailCheckUpsertWithWhereUniqueWithoutEmployeeInput | TrailCheckUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: TrailCheckCreateManyEmployeeInputEnvelope
    set?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    disconnect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    delete?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    update?: TrailCheckUpdateWithWhereUniqueWithoutEmployeeInput | TrailCheckUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: TrailCheckUpdateManyWithWhereWithoutEmployeeInput | TrailCheckUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: TrailCheckScalarWhereInput | TrailCheckScalarWhereInput[]
  }

  export type HutCheckUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<HutCheckCreateWithoutEmployeeInput, HutCheckUncheckedCreateWithoutEmployeeInput> | HutCheckCreateWithoutEmployeeInput[] | HutCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutEmployeeInput | HutCheckCreateOrConnectWithoutEmployeeInput[]
    upsert?: HutCheckUpsertWithWhereUniqueWithoutEmployeeInput | HutCheckUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: HutCheckCreateManyEmployeeInputEnvelope
    set?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    disconnect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    delete?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    update?: HutCheckUpdateWithWhereUniqueWithoutEmployeeInput | HutCheckUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: HutCheckUpdateManyWithWhereWithoutEmployeeInput | HutCheckUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: HutCheckScalarWhereInput | HutCheckScalarWhereInput[]
  }

  export type AidRoomCheckUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AidRoomCheckCreateWithoutEmployeeInput, AidRoomCheckUncheckedCreateWithoutEmployeeInput> | AidRoomCheckCreateWithoutEmployeeInput[] | AidRoomCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutEmployeeInput | AidRoomCheckCreateOrConnectWithoutEmployeeInput[]
    upsert?: AidRoomCheckUpsertWithWhereUniqueWithoutEmployeeInput | AidRoomCheckUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AidRoomCheckCreateManyEmployeeInputEnvelope
    set?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    disconnect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    delete?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    update?: AidRoomCheckUpdateWithWhereUniqueWithoutEmployeeInput | AidRoomCheckUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AidRoomCheckUpdateManyWithWhereWithoutEmployeeInput | AidRoomCheckUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AidRoomCheckScalarWhereInput | AidRoomCheckScalarWhereInput[]
  }

  export type EquipmentCheckUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EquipmentCheckCreateWithoutEmployeeInput, EquipmentCheckUncheckedCreateWithoutEmployeeInput> | EquipmentCheckCreateWithoutEmployeeInput[] | EquipmentCheckUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutEmployeeInput | EquipmentCheckCreateOrConnectWithoutEmployeeInput[]
    upsert?: EquipmentCheckUpsertWithWhereUniqueWithoutEmployeeInput | EquipmentCheckUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EquipmentCheckCreateManyEmployeeInputEnvelope
    set?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    disconnect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    delete?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    update?: EquipmentCheckUpdateWithWhereUniqueWithoutEmployeeInput | EquipmentCheckUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EquipmentCheckUpdateManyWithWhereWithoutEmployeeInput | EquipmentCheckUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EquipmentCheckScalarWhereInput | EquipmentCheckScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutDispatcherAssignmentsInput = {
    create?: XOR<EmployeeCreateWithoutDispatcherAssignmentsInput, EmployeeUncheckedCreateWithoutDispatcherAssignmentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDispatcherAssignmentsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type MountainCreateNestedOneWithoutDispatcherAssignmentsInput = {
    create?: XOR<MountainCreateWithoutDispatcherAssignmentsInput, MountainUncheckedCreateWithoutDispatcherAssignmentsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutDispatcherAssignmentsInput
    connect?: MountainWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutDispatcherAssignmentsNestedInput = {
    create?: XOR<EmployeeCreateWithoutDispatcherAssignmentsInput, EmployeeUncheckedCreateWithoutDispatcherAssignmentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDispatcherAssignmentsInput
    upsert?: EmployeeUpsertWithoutDispatcherAssignmentsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutDispatcherAssignmentsInput, EmployeeUpdateWithoutDispatcherAssignmentsInput>, EmployeeUncheckedUpdateWithoutDispatcherAssignmentsInput>
  }

  export type MountainUpdateOneRequiredWithoutDispatcherAssignmentsNestedInput = {
    create?: XOR<MountainCreateWithoutDispatcherAssignmentsInput, MountainUncheckedCreateWithoutDispatcherAssignmentsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutDispatcherAssignmentsInput
    upsert?: MountainUpsertWithoutDispatcherAssignmentsInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutDispatcherAssignmentsInput, MountainUpdateWithoutDispatcherAssignmentsInput>, MountainUncheckedUpdateWithoutDispatcherAssignmentsInput>
  }

  export type MountainCreateNestedOneWithoutLiftsInput = {
    create?: XOR<MountainCreateWithoutLiftsInput, MountainUncheckedCreateWithoutLiftsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutLiftsInput
    connect?: MountainWhereUniqueInput
  }

  export type IncidentLogCreateNestedManyWithoutLiftInput = {
    create?: XOR<IncidentLogCreateWithoutLiftInput, IncidentLogUncheckedCreateWithoutLiftInput> | IncidentLogCreateWithoutLiftInput[] | IncidentLogUncheckedCreateWithoutLiftInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutLiftInput | IncidentLogCreateOrConnectWithoutLiftInput[]
    createMany?: IncidentLogCreateManyLiftInputEnvelope
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
  }

  export type LiftCheckCreateNestedManyWithoutLiftInput = {
    create?: XOR<LiftCheckCreateWithoutLiftInput, LiftCheckUncheckedCreateWithoutLiftInput> | LiftCheckCreateWithoutLiftInput[] | LiftCheckUncheckedCreateWithoutLiftInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutLiftInput | LiftCheckCreateOrConnectWithoutLiftInput[]
    createMany?: LiftCheckCreateManyLiftInputEnvelope
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
  }

  export type IncidentLogUncheckedCreateNestedManyWithoutLiftInput = {
    create?: XOR<IncidentLogCreateWithoutLiftInput, IncidentLogUncheckedCreateWithoutLiftInput> | IncidentLogCreateWithoutLiftInput[] | IncidentLogUncheckedCreateWithoutLiftInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutLiftInput | IncidentLogCreateOrConnectWithoutLiftInput[]
    createMany?: IncidentLogCreateManyLiftInputEnvelope
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
  }

  export type LiftCheckUncheckedCreateNestedManyWithoutLiftInput = {
    create?: XOR<LiftCheckCreateWithoutLiftInput, LiftCheckUncheckedCreateWithoutLiftInput> | LiftCheckCreateWithoutLiftInput[] | LiftCheckUncheckedCreateWithoutLiftInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutLiftInput | LiftCheckCreateOrConnectWithoutLiftInput[]
    createMany?: LiftCheckCreateManyLiftInputEnvelope
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type MountainUpdateOneRequiredWithoutLiftsNestedInput = {
    create?: XOR<MountainCreateWithoutLiftsInput, MountainUncheckedCreateWithoutLiftsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutLiftsInput
    upsert?: MountainUpsertWithoutLiftsInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutLiftsInput, MountainUpdateWithoutLiftsInput>, MountainUncheckedUpdateWithoutLiftsInput>
  }

  export type IncidentLogUpdateManyWithoutLiftNestedInput = {
    create?: XOR<IncidentLogCreateWithoutLiftInput, IncidentLogUncheckedCreateWithoutLiftInput> | IncidentLogCreateWithoutLiftInput[] | IncidentLogUncheckedCreateWithoutLiftInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutLiftInput | IncidentLogCreateOrConnectWithoutLiftInput[]
    upsert?: IncidentLogUpsertWithWhereUniqueWithoutLiftInput | IncidentLogUpsertWithWhereUniqueWithoutLiftInput[]
    createMany?: IncidentLogCreateManyLiftInputEnvelope
    set?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    disconnect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    delete?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    update?: IncidentLogUpdateWithWhereUniqueWithoutLiftInput | IncidentLogUpdateWithWhereUniqueWithoutLiftInput[]
    updateMany?: IncidentLogUpdateManyWithWhereWithoutLiftInput | IncidentLogUpdateManyWithWhereWithoutLiftInput[]
    deleteMany?: IncidentLogScalarWhereInput | IncidentLogScalarWhereInput[]
  }

  export type LiftCheckUpdateManyWithoutLiftNestedInput = {
    create?: XOR<LiftCheckCreateWithoutLiftInput, LiftCheckUncheckedCreateWithoutLiftInput> | LiftCheckCreateWithoutLiftInput[] | LiftCheckUncheckedCreateWithoutLiftInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutLiftInput | LiftCheckCreateOrConnectWithoutLiftInput[]
    upsert?: LiftCheckUpsertWithWhereUniqueWithoutLiftInput | LiftCheckUpsertWithWhereUniqueWithoutLiftInput[]
    createMany?: LiftCheckCreateManyLiftInputEnvelope
    set?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    disconnect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    delete?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    update?: LiftCheckUpdateWithWhereUniqueWithoutLiftInput | LiftCheckUpdateWithWhereUniqueWithoutLiftInput[]
    updateMany?: LiftCheckUpdateManyWithWhereWithoutLiftInput | LiftCheckUpdateManyWithWhereWithoutLiftInput[]
    deleteMany?: LiftCheckScalarWhereInput | LiftCheckScalarWhereInput[]
  }

  export type IncidentLogUncheckedUpdateManyWithoutLiftNestedInput = {
    create?: XOR<IncidentLogCreateWithoutLiftInput, IncidentLogUncheckedCreateWithoutLiftInput> | IncidentLogCreateWithoutLiftInput[] | IncidentLogUncheckedCreateWithoutLiftInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutLiftInput | IncidentLogCreateOrConnectWithoutLiftInput[]
    upsert?: IncidentLogUpsertWithWhereUniqueWithoutLiftInput | IncidentLogUpsertWithWhereUniqueWithoutLiftInput[]
    createMany?: IncidentLogCreateManyLiftInputEnvelope
    set?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    disconnect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    delete?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    update?: IncidentLogUpdateWithWhereUniqueWithoutLiftInput | IncidentLogUpdateWithWhereUniqueWithoutLiftInput[]
    updateMany?: IncidentLogUpdateManyWithWhereWithoutLiftInput | IncidentLogUpdateManyWithWhereWithoutLiftInput[]
    deleteMany?: IncidentLogScalarWhereInput | IncidentLogScalarWhereInput[]
  }

  export type LiftCheckUncheckedUpdateManyWithoutLiftNestedInput = {
    create?: XOR<LiftCheckCreateWithoutLiftInput, LiftCheckUncheckedCreateWithoutLiftInput> | LiftCheckCreateWithoutLiftInput[] | LiftCheckUncheckedCreateWithoutLiftInput[]
    connectOrCreate?: LiftCheckCreateOrConnectWithoutLiftInput | LiftCheckCreateOrConnectWithoutLiftInput[]
    upsert?: LiftCheckUpsertWithWhereUniqueWithoutLiftInput | LiftCheckUpsertWithWhereUniqueWithoutLiftInput[]
    createMany?: LiftCheckCreateManyLiftInputEnvelope
    set?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    disconnect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    delete?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    connect?: LiftCheckWhereUniqueInput | LiftCheckWhereUniqueInput[]
    update?: LiftCheckUpdateWithWhereUniqueWithoutLiftInput | LiftCheckUpdateWithWhereUniqueWithoutLiftInput[]
    updateMany?: LiftCheckUpdateManyWithWhereWithoutLiftInput | LiftCheckUpdateManyWithWhereWithoutLiftInput[]
    deleteMany?: LiftCheckScalarWhereInput | LiftCheckScalarWhereInput[]
  }

  export type MountainCreateNestedOneWithoutTrailsInput = {
    create?: XOR<MountainCreateWithoutTrailsInput, MountainUncheckedCreateWithoutTrailsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutTrailsInput
    connect?: MountainWhereUniqueInput
  }

  export type IncidentLogCreateNestedManyWithoutTrailInput = {
    create?: XOR<IncidentLogCreateWithoutTrailInput, IncidentLogUncheckedCreateWithoutTrailInput> | IncidentLogCreateWithoutTrailInput[] | IncidentLogUncheckedCreateWithoutTrailInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutTrailInput | IncidentLogCreateOrConnectWithoutTrailInput[]
    createMany?: IncidentLogCreateManyTrailInputEnvelope
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
  }

  export type TrailCheckCreateNestedManyWithoutTrailInput = {
    create?: XOR<TrailCheckCreateWithoutTrailInput, TrailCheckUncheckedCreateWithoutTrailInput> | TrailCheckCreateWithoutTrailInput[] | TrailCheckUncheckedCreateWithoutTrailInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutTrailInput | TrailCheckCreateOrConnectWithoutTrailInput[]
    createMany?: TrailCheckCreateManyTrailInputEnvelope
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
  }

  export type IncidentLogUncheckedCreateNestedManyWithoutTrailInput = {
    create?: XOR<IncidentLogCreateWithoutTrailInput, IncidentLogUncheckedCreateWithoutTrailInput> | IncidentLogCreateWithoutTrailInput[] | IncidentLogUncheckedCreateWithoutTrailInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutTrailInput | IncidentLogCreateOrConnectWithoutTrailInput[]
    createMany?: IncidentLogCreateManyTrailInputEnvelope
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
  }

  export type TrailCheckUncheckedCreateNestedManyWithoutTrailInput = {
    create?: XOR<TrailCheckCreateWithoutTrailInput, TrailCheckUncheckedCreateWithoutTrailInput> | TrailCheckCreateWithoutTrailInput[] | TrailCheckUncheckedCreateWithoutTrailInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutTrailInput | TrailCheckCreateOrConnectWithoutTrailInput[]
    createMany?: TrailCheckCreateManyTrailInputEnvelope
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
  }

  export type EnumTrailDifficultyFieldUpdateOperationsInput = {
    set?: $Enums.TrailDifficulty
  }

  export type EnumTrailConditionFieldUpdateOperationsInput = {
    set?: $Enums.TrailCondition
  }

  export type MountainUpdateOneRequiredWithoutTrailsNestedInput = {
    create?: XOR<MountainCreateWithoutTrailsInput, MountainUncheckedCreateWithoutTrailsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutTrailsInput
    upsert?: MountainUpsertWithoutTrailsInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutTrailsInput, MountainUpdateWithoutTrailsInput>, MountainUncheckedUpdateWithoutTrailsInput>
  }

  export type IncidentLogUpdateManyWithoutTrailNestedInput = {
    create?: XOR<IncidentLogCreateWithoutTrailInput, IncidentLogUncheckedCreateWithoutTrailInput> | IncidentLogCreateWithoutTrailInput[] | IncidentLogUncheckedCreateWithoutTrailInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutTrailInput | IncidentLogCreateOrConnectWithoutTrailInput[]
    upsert?: IncidentLogUpsertWithWhereUniqueWithoutTrailInput | IncidentLogUpsertWithWhereUniqueWithoutTrailInput[]
    createMany?: IncidentLogCreateManyTrailInputEnvelope
    set?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    disconnect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    delete?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    update?: IncidentLogUpdateWithWhereUniqueWithoutTrailInput | IncidentLogUpdateWithWhereUniqueWithoutTrailInput[]
    updateMany?: IncidentLogUpdateManyWithWhereWithoutTrailInput | IncidentLogUpdateManyWithWhereWithoutTrailInput[]
    deleteMany?: IncidentLogScalarWhereInput | IncidentLogScalarWhereInput[]
  }

  export type TrailCheckUpdateManyWithoutTrailNestedInput = {
    create?: XOR<TrailCheckCreateWithoutTrailInput, TrailCheckUncheckedCreateWithoutTrailInput> | TrailCheckCreateWithoutTrailInput[] | TrailCheckUncheckedCreateWithoutTrailInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutTrailInput | TrailCheckCreateOrConnectWithoutTrailInput[]
    upsert?: TrailCheckUpsertWithWhereUniqueWithoutTrailInput | TrailCheckUpsertWithWhereUniqueWithoutTrailInput[]
    createMany?: TrailCheckCreateManyTrailInputEnvelope
    set?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    disconnect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    delete?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    update?: TrailCheckUpdateWithWhereUniqueWithoutTrailInput | TrailCheckUpdateWithWhereUniqueWithoutTrailInput[]
    updateMany?: TrailCheckUpdateManyWithWhereWithoutTrailInput | TrailCheckUpdateManyWithWhereWithoutTrailInput[]
    deleteMany?: TrailCheckScalarWhereInput | TrailCheckScalarWhereInput[]
  }

  export type IncidentLogUncheckedUpdateManyWithoutTrailNestedInput = {
    create?: XOR<IncidentLogCreateWithoutTrailInput, IncidentLogUncheckedCreateWithoutTrailInput> | IncidentLogCreateWithoutTrailInput[] | IncidentLogUncheckedCreateWithoutTrailInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutTrailInput | IncidentLogCreateOrConnectWithoutTrailInput[]
    upsert?: IncidentLogUpsertWithWhereUniqueWithoutTrailInput | IncidentLogUpsertWithWhereUniqueWithoutTrailInput[]
    createMany?: IncidentLogCreateManyTrailInputEnvelope
    set?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    disconnect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    delete?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    update?: IncidentLogUpdateWithWhereUniqueWithoutTrailInput | IncidentLogUpdateWithWhereUniqueWithoutTrailInput[]
    updateMany?: IncidentLogUpdateManyWithWhereWithoutTrailInput | IncidentLogUpdateManyWithWhereWithoutTrailInput[]
    deleteMany?: IncidentLogScalarWhereInput | IncidentLogScalarWhereInput[]
  }

  export type TrailCheckUncheckedUpdateManyWithoutTrailNestedInput = {
    create?: XOR<TrailCheckCreateWithoutTrailInput, TrailCheckUncheckedCreateWithoutTrailInput> | TrailCheckCreateWithoutTrailInput[] | TrailCheckUncheckedCreateWithoutTrailInput[]
    connectOrCreate?: TrailCheckCreateOrConnectWithoutTrailInput | TrailCheckCreateOrConnectWithoutTrailInput[]
    upsert?: TrailCheckUpsertWithWhereUniqueWithoutTrailInput | TrailCheckUpsertWithWhereUniqueWithoutTrailInput[]
    createMany?: TrailCheckCreateManyTrailInputEnvelope
    set?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    disconnect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    delete?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    connect?: TrailCheckWhereUniqueInput | TrailCheckWhereUniqueInput[]
    update?: TrailCheckUpdateWithWhereUniqueWithoutTrailInput | TrailCheckUpdateWithWhereUniqueWithoutTrailInput[]
    updateMany?: TrailCheckUpdateManyWithWhereWithoutTrailInput | TrailCheckUpdateManyWithWhereWithoutTrailInput[]
    deleteMany?: TrailCheckScalarWhereInput | TrailCheckScalarWhereInput[]
  }

  export type MountainCreateNestedOneWithoutLodgesInput = {
    create?: XOR<MountainCreateWithoutLodgesInput, MountainUncheckedCreateWithoutLodgesInput>
    connectOrCreate?: MountainCreateOrConnectWithoutLodgesInput
    connect?: MountainWhereUniqueInput
  }

  export type IncidentLogCreateNestedManyWithoutLodgeInput = {
    create?: XOR<IncidentLogCreateWithoutLodgeInput, IncidentLogUncheckedCreateWithoutLodgeInput> | IncidentLogCreateWithoutLodgeInput[] | IncidentLogUncheckedCreateWithoutLodgeInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutLodgeInput | IncidentLogCreateOrConnectWithoutLodgeInput[]
    createMany?: IncidentLogCreateManyLodgeInputEnvelope
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
  }

  export type IncidentLogUncheckedCreateNestedManyWithoutLodgeInput = {
    create?: XOR<IncidentLogCreateWithoutLodgeInput, IncidentLogUncheckedCreateWithoutLodgeInput> | IncidentLogCreateWithoutLodgeInput[] | IncidentLogUncheckedCreateWithoutLodgeInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutLodgeInput | IncidentLogCreateOrConnectWithoutLodgeInput[]
    createMany?: IncidentLogCreateManyLodgeInputEnvelope
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
  }

  export type MountainUpdateOneRequiredWithoutLodgesNestedInput = {
    create?: XOR<MountainCreateWithoutLodgesInput, MountainUncheckedCreateWithoutLodgesInput>
    connectOrCreate?: MountainCreateOrConnectWithoutLodgesInput
    upsert?: MountainUpsertWithoutLodgesInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutLodgesInput, MountainUpdateWithoutLodgesInput>, MountainUncheckedUpdateWithoutLodgesInput>
  }

  export type IncidentLogUpdateManyWithoutLodgeNestedInput = {
    create?: XOR<IncidentLogCreateWithoutLodgeInput, IncidentLogUncheckedCreateWithoutLodgeInput> | IncidentLogCreateWithoutLodgeInput[] | IncidentLogUncheckedCreateWithoutLodgeInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutLodgeInput | IncidentLogCreateOrConnectWithoutLodgeInput[]
    upsert?: IncidentLogUpsertWithWhereUniqueWithoutLodgeInput | IncidentLogUpsertWithWhereUniqueWithoutLodgeInput[]
    createMany?: IncidentLogCreateManyLodgeInputEnvelope
    set?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    disconnect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    delete?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    update?: IncidentLogUpdateWithWhereUniqueWithoutLodgeInput | IncidentLogUpdateWithWhereUniqueWithoutLodgeInput[]
    updateMany?: IncidentLogUpdateManyWithWhereWithoutLodgeInput | IncidentLogUpdateManyWithWhereWithoutLodgeInput[]
    deleteMany?: IncidentLogScalarWhereInput | IncidentLogScalarWhereInput[]
  }

  export type IncidentLogUncheckedUpdateManyWithoutLodgeNestedInput = {
    create?: XOR<IncidentLogCreateWithoutLodgeInput, IncidentLogUncheckedCreateWithoutLodgeInput> | IncidentLogCreateWithoutLodgeInput[] | IncidentLogUncheckedCreateWithoutLodgeInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutLodgeInput | IncidentLogCreateOrConnectWithoutLodgeInput[]
    upsert?: IncidentLogUpsertWithWhereUniqueWithoutLodgeInput | IncidentLogUpsertWithWhereUniqueWithoutLodgeInput[]
    createMany?: IncidentLogCreateManyLodgeInputEnvelope
    set?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    disconnect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    delete?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    update?: IncidentLogUpdateWithWhereUniqueWithoutLodgeInput | IncidentLogUpdateWithWhereUniqueWithoutLodgeInput[]
    updateMany?: IncidentLogUpdateManyWithWhereWithoutLodgeInput | IncidentLogUpdateManyWithWhereWithoutLodgeInput[]
    deleteMany?: IncidentLogScalarWhereInput | IncidentLogScalarWhereInput[]
  }

  export type MountainCreateNestedOneWithoutHutsInput = {
    create?: XOR<MountainCreateWithoutHutsInput, MountainUncheckedCreateWithoutHutsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutHutsInput
    connect?: MountainWhereUniqueInput
  }

  export type IncidentLogCreateNestedManyWithoutHutInput = {
    create?: XOR<IncidentLogCreateWithoutHutInput, IncidentLogUncheckedCreateWithoutHutInput> | IncidentLogCreateWithoutHutInput[] | IncidentLogUncheckedCreateWithoutHutInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutHutInput | IncidentLogCreateOrConnectWithoutHutInput[]
    createMany?: IncidentLogCreateManyHutInputEnvelope
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
  }

  export type HutCheckCreateNestedManyWithoutHutInput = {
    create?: XOR<HutCheckCreateWithoutHutInput, HutCheckUncheckedCreateWithoutHutInput> | HutCheckCreateWithoutHutInput[] | HutCheckUncheckedCreateWithoutHutInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutHutInput | HutCheckCreateOrConnectWithoutHutInput[]
    createMany?: HutCheckCreateManyHutInputEnvelope
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
  }

  export type IncidentLogUncheckedCreateNestedManyWithoutHutInput = {
    create?: XOR<IncidentLogCreateWithoutHutInput, IncidentLogUncheckedCreateWithoutHutInput> | IncidentLogCreateWithoutHutInput[] | IncidentLogUncheckedCreateWithoutHutInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutHutInput | IncidentLogCreateOrConnectWithoutHutInput[]
    createMany?: IncidentLogCreateManyHutInputEnvelope
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
  }

  export type HutCheckUncheckedCreateNestedManyWithoutHutInput = {
    create?: XOR<HutCheckCreateWithoutHutInput, HutCheckUncheckedCreateWithoutHutInput> | HutCheckCreateWithoutHutInput[] | HutCheckUncheckedCreateWithoutHutInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutHutInput | HutCheckCreateOrConnectWithoutHutInput[]
    createMany?: HutCheckCreateManyHutInputEnvelope
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
  }

  export type MountainUpdateOneRequiredWithoutHutsNestedInput = {
    create?: XOR<MountainCreateWithoutHutsInput, MountainUncheckedCreateWithoutHutsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutHutsInput
    upsert?: MountainUpsertWithoutHutsInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutHutsInput, MountainUpdateWithoutHutsInput>, MountainUncheckedUpdateWithoutHutsInput>
  }

  export type IncidentLogUpdateManyWithoutHutNestedInput = {
    create?: XOR<IncidentLogCreateWithoutHutInput, IncidentLogUncheckedCreateWithoutHutInput> | IncidentLogCreateWithoutHutInput[] | IncidentLogUncheckedCreateWithoutHutInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutHutInput | IncidentLogCreateOrConnectWithoutHutInput[]
    upsert?: IncidentLogUpsertWithWhereUniqueWithoutHutInput | IncidentLogUpsertWithWhereUniqueWithoutHutInput[]
    createMany?: IncidentLogCreateManyHutInputEnvelope
    set?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    disconnect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    delete?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    update?: IncidentLogUpdateWithWhereUniqueWithoutHutInput | IncidentLogUpdateWithWhereUniqueWithoutHutInput[]
    updateMany?: IncidentLogUpdateManyWithWhereWithoutHutInput | IncidentLogUpdateManyWithWhereWithoutHutInput[]
    deleteMany?: IncidentLogScalarWhereInput | IncidentLogScalarWhereInput[]
  }

  export type HutCheckUpdateManyWithoutHutNestedInput = {
    create?: XOR<HutCheckCreateWithoutHutInput, HutCheckUncheckedCreateWithoutHutInput> | HutCheckCreateWithoutHutInput[] | HutCheckUncheckedCreateWithoutHutInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutHutInput | HutCheckCreateOrConnectWithoutHutInput[]
    upsert?: HutCheckUpsertWithWhereUniqueWithoutHutInput | HutCheckUpsertWithWhereUniqueWithoutHutInput[]
    createMany?: HutCheckCreateManyHutInputEnvelope
    set?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    disconnect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    delete?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    update?: HutCheckUpdateWithWhereUniqueWithoutHutInput | HutCheckUpdateWithWhereUniqueWithoutHutInput[]
    updateMany?: HutCheckUpdateManyWithWhereWithoutHutInput | HutCheckUpdateManyWithWhereWithoutHutInput[]
    deleteMany?: HutCheckScalarWhereInput | HutCheckScalarWhereInput[]
  }

  export type IncidentLogUncheckedUpdateManyWithoutHutNestedInput = {
    create?: XOR<IncidentLogCreateWithoutHutInput, IncidentLogUncheckedCreateWithoutHutInput> | IncidentLogCreateWithoutHutInput[] | IncidentLogUncheckedCreateWithoutHutInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutHutInput | IncidentLogCreateOrConnectWithoutHutInput[]
    upsert?: IncidentLogUpsertWithWhereUniqueWithoutHutInput | IncidentLogUpsertWithWhereUniqueWithoutHutInput[]
    createMany?: IncidentLogCreateManyHutInputEnvelope
    set?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    disconnect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    delete?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    update?: IncidentLogUpdateWithWhereUniqueWithoutHutInput | IncidentLogUpdateWithWhereUniqueWithoutHutInput[]
    updateMany?: IncidentLogUpdateManyWithWhereWithoutHutInput | IncidentLogUpdateManyWithWhereWithoutHutInput[]
    deleteMany?: IncidentLogScalarWhereInput | IncidentLogScalarWhereInput[]
  }

  export type HutCheckUncheckedUpdateManyWithoutHutNestedInput = {
    create?: XOR<HutCheckCreateWithoutHutInput, HutCheckUncheckedCreateWithoutHutInput> | HutCheckCreateWithoutHutInput[] | HutCheckUncheckedCreateWithoutHutInput[]
    connectOrCreate?: HutCheckCreateOrConnectWithoutHutInput | HutCheckCreateOrConnectWithoutHutInput[]
    upsert?: HutCheckUpsertWithWhereUniqueWithoutHutInput | HutCheckUpsertWithWhereUniqueWithoutHutInput[]
    createMany?: HutCheckCreateManyHutInputEnvelope
    set?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    disconnect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    delete?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    connect?: HutCheckWhereUniqueInput | HutCheckWhereUniqueInput[]
    update?: HutCheckUpdateWithWhereUniqueWithoutHutInput | HutCheckUpdateWithWhereUniqueWithoutHutInput[]
    updateMany?: HutCheckUpdateManyWithWhereWithoutHutInput | HutCheckUpdateManyWithWhereWithoutHutInput[]
    deleteMany?: HutCheckScalarWhereInput | HutCheckScalarWhereInput[]
  }

  export type MountainCreateNestedOneWithoutAidRoomsInput = {
    create?: XOR<MountainCreateWithoutAidRoomsInput, MountainUncheckedCreateWithoutAidRoomsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutAidRoomsInput
    connect?: MountainWhereUniqueInput
  }

  export type IncidentLogCreateNestedManyWithoutAidRoomInput = {
    create?: XOR<IncidentLogCreateWithoutAidRoomInput, IncidentLogUncheckedCreateWithoutAidRoomInput> | IncidentLogCreateWithoutAidRoomInput[] | IncidentLogUncheckedCreateWithoutAidRoomInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutAidRoomInput | IncidentLogCreateOrConnectWithoutAidRoomInput[]
    createMany?: IncidentLogCreateManyAidRoomInputEnvelope
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
  }

  export type AidRoomCheckCreateNestedManyWithoutAidRoomInput = {
    create?: XOR<AidRoomCheckCreateWithoutAidRoomInput, AidRoomCheckUncheckedCreateWithoutAidRoomInput> | AidRoomCheckCreateWithoutAidRoomInput[] | AidRoomCheckUncheckedCreateWithoutAidRoomInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutAidRoomInput | AidRoomCheckCreateOrConnectWithoutAidRoomInput[]
    createMany?: AidRoomCheckCreateManyAidRoomInputEnvelope
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
  }

  export type IncidentLogUncheckedCreateNestedManyWithoutAidRoomInput = {
    create?: XOR<IncidentLogCreateWithoutAidRoomInput, IncidentLogUncheckedCreateWithoutAidRoomInput> | IncidentLogCreateWithoutAidRoomInput[] | IncidentLogUncheckedCreateWithoutAidRoomInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutAidRoomInput | IncidentLogCreateOrConnectWithoutAidRoomInput[]
    createMany?: IncidentLogCreateManyAidRoomInputEnvelope
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
  }

  export type AidRoomCheckUncheckedCreateNestedManyWithoutAidRoomInput = {
    create?: XOR<AidRoomCheckCreateWithoutAidRoomInput, AidRoomCheckUncheckedCreateWithoutAidRoomInput> | AidRoomCheckCreateWithoutAidRoomInput[] | AidRoomCheckUncheckedCreateWithoutAidRoomInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutAidRoomInput | AidRoomCheckCreateOrConnectWithoutAidRoomInput[]
    createMany?: AidRoomCheckCreateManyAidRoomInputEnvelope
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
  }

  export type MountainUpdateOneRequiredWithoutAidRoomsNestedInput = {
    create?: XOR<MountainCreateWithoutAidRoomsInput, MountainUncheckedCreateWithoutAidRoomsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutAidRoomsInput
    upsert?: MountainUpsertWithoutAidRoomsInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutAidRoomsInput, MountainUpdateWithoutAidRoomsInput>, MountainUncheckedUpdateWithoutAidRoomsInput>
  }

  export type IncidentLogUpdateManyWithoutAidRoomNestedInput = {
    create?: XOR<IncidentLogCreateWithoutAidRoomInput, IncidentLogUncheckedCreateWithoutAidRoomInput> | IncidentLogCreateWithoutAidRoomInput[] | IncidentLogUncheckedCreateWithoutAidRoomInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutAidRoomInput | IncidentLogCreateOrConnectWithoutAidRoomInput[]
    upsert?: IncidentLogUpsertWithWhereUniqueWithoutAidRoomInput | IncidentLogUpsertWithWhereUniqueWithoutAidRoomInput[]
    createMany?: IncidentLogCreateManyAidRoomInputEnvelope
    set?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    disconnect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    delete?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    update?: IncidentLogUpdateWithWhereUniqueWithoutAidRoomInput | IncidentLogUpdateWithWhereUniqueWithoutAidRoomInput[]
    updateMany?: IncidentLogUpdateManyWithWhereWithoutAidRoomInput | IncidentLogUpdateManyWithWhereWithoutAidRoomInput[]
    deleteMany?: IncidentLogScalarWhereInput | IncidentLogScalarWhereInput[]
  }

  export type AidRoomCheckUpdateManyWithoutAidRoomNestedInput = {
    create?: XOR<AidRoomCheckCreateWithoutAidRoomInput, AidRoomCheckUncheckedCreateWithoutAidRoomInput> | AidRoomCheckCreateWithoutAidRoomInput[] | AidRoomCheckUncheckedCreateWithoutAidRoomInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutAidRoomInput | AidRoomCheckCreateOrConnectWithoutAidRoomInput[]
    upsert?: AidRoomCheckUpsertWithWhereUniqueWithoutAidRoomInput | AidRoomCheckUpsertWithWhereUniqueWithoutAidRoomInput[]
    createMany?: AidRoomCheckCreateManyAidRoomInputEnvelope
    set?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    disconnect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    delete?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    update?: AidRoomCheckUpdateWithWhereUniqueWithoutAidRoomInput | AidRoomCheckUpdateWithWhereUniqueWithoutAidRoomInput[]
    updateMany?: AidRoomCheckUpdateManyWithWhereWithoutAidRoomInput | AidRoomCheckUpdateManyWithWhereWithoutAidRoomInput[]
    deleteMany?: AidRoomCheckScalarWhereInput | AidRoomCheckScalarWhereInput[]
  }

  export type IncidentLogUncheckedUpdateManyWithoutAidRoomNestedInput = {
    create?: XOR<IncidentLogCreateWithoutAidRoomInput, IncidentLogUncheckedCreateWithoutAidRoomInput> | IncidentLogCreateWithoutAidRoomInput[] | IncidentLogUncheckedCreateWithoutAidRoomInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutAidRoomInput | IncidentLogCreateOrConnectWithoutAidRoomInput[]
    upsert?: IncidentLogUpsertWithWhereUniqueWithoutAidRoomInput | IncidentLogUpsertWithWhereUniqueWithoutAidRoomInput[]
    createMany?: IncidentLogCreateManyAidRoomInputEnvelope
    set?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    disconnect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    delete?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    update?: IncidentLogUpdateWithWhereUniqueWithoutAidRoomInput | IncidentLogUpdateWithWhereUniqueWithoutAidRoomInput[]
    updateMany?: IncidentLogUpdateManyWithWhereWithoutAidRoomInput | IncidentLogUpdateManyWithWhereWithoutAidRoomInput[]
    deleteMany?: IncidentLogScalarWhereInput | IncidentLogScalarWhereInput[]
  }

  export type AidRoomCheckUncheckedUpdateManyWithoutAidRoomNestedInput = {
    create?: XOR<AidRoomCheckCreateWithoutAidRoomInput, AidRoomCheckUncheckedCreateWithoutAidRoomInput> | AidRoomCheckCreateWithoutAidRoomInput[] | AidRoomCheckUncheckedCreateWithoutAidRoomInput[]
    connectOrCreate?: AidRoomCheckCreateOrConnectWithoutAidRoomInput | AidRoomCheckCreateOrConnectWithoutAidRoomInput[]
    upsert?: AidRoomCheckUpsertWithWhereUniqueWithoutAidRoomInput | AidRoomCheckUpsertWithWhereUniqueWithoutAidRoomInput[]
    createMany?: AidRoomCheckCreateManyAidRoomInputEnvelope
    set?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    disconnect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    delete?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    connect?: AidRoomCheckWhereUniqueInput | AidRoomCheckWhereUniqueInput[]
    update?: AidRoomCheckUpdateWithWhereUniqueWithoutAidRoomInput | AidRoomCheckUpdateWithWhereUniqueWithoutAidRoomInput[]
    updateMany?: AidRoomCheckUpdateManyWithWhereWithoutAidRoomInput | AidRoomCheckUpdateManyWithWhereWithoutAidRoomInput[]
    deleteMany?: AidRoomCheckScalarWhereInput | AidRoomCheckScalarWhereInput[]
  }

  export type MountainCreateNestedOneWithoutEquipmentInput = {
    create?: XOR<MountainCreateWithoutEquipmentInput, MountainUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: MountainCreateOrConnectWithoutEquipmentInput
    connect?: MountainWhereUniqueInput
  }

  export type IncidentLogEquipmentCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<IncidentLogEquipmentCreateWithoutEquipmentInput, IncidentLogEquipmentUncheckedCreateWithoutEquipmentInput> | IncidentLogEquipmentCreateWithoutEquipmentInput[] | IncidentLogEquipmentUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: IncidentLogEquipmentCreateOrConnectWithoutEquipmentInput | IncidentLogEquipmentCreateOrConnectWithoutEquipmentInput[]
    createMany?: IncidentLogEquipmentCreateManyEquipmentInputEnvelope
    connect?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
  }

  export type EquipmentCheckCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<EquipmentCheckCreateWithoutEquipmentInput, EquipmentCheckUncheckedCreateWithoutEquipmentInput> | EquipmentCheckCreateWithoutEquipmentInput[] | EquipmentCheckUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutEquipmentInput | EquipmentCheckCreateOrConnectWithoutEquipmentInput[]
    createMany?: EquipmentCheckCreateManyEquipmentInputEnvelope
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
  }

  export type IncidentLogEquipmentUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<IncidentLogEquipmentCreateWithoutEquipmentInput, IncidentLogEquipmentUncheckedCreateWithoutEquipmentInput> | IncidentLogEquipmentCreateWithoutEquipmentInput[] | IncidentLogEquipmentUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: IncidentLogEquipmentCreateOrConnectWithoutEquipmentInput | IncidentLogEquipmentCreateOrConnectWithoutEquipmentInput[]
    createMany?: IncidentLogEquipmentCreateManyEquipmentInputEnvelope
    connect?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
  }

  export type EquipmentCheckUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<EquipmentCheckCreateWithoutEquipmentInput, EquipmentCheckUncheckedCreateWithoutEquipmentInput> | EquipmentCheckCreateWithoutEquipmentInput[] | EquipmentCheckUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutEquipmentInput | EquipmentCheckCreateOrConnectWithoutEquipmentInput[]
    createMany?: EquipmentCheckCreateManyEquipmentInputEnvelope
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
  }

  export type EnumEquipmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.EquipmentStatus
  }

  export type EnumEquipmentServiceFieldUpdateOperationsInput = {
    set?: $Enums.EquipmentService
  }

  export type MountainUpdateOneRequiredWithoutEquipmentNestedInput = {
    create?: XOR<MountainCreateWithoutEquipmentInput, MountainUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: MountainCreateOrConnectWithoutEquipmentInput
    upsert?: MountainUpsertWithoutEquipmentInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutEquipmentInput, MountainUpdateWithoutEquipmentInput>, MountainUncheckedUpdateWithoutEquipmentInput>
  }

  export type IncidentLogEquipmentUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<IncidentLogEquipmentCreateWithoutEquipmentInput, IncidentLogEquipmentUncheckedCreateWithoutEquipmentInput> | IncidentLogEquipmentCreateWithoutEquipmentInput[] | IncidentLogEquipmentUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: IncidentLogEquipmentCreateOrConnectWithoutEquipmentInput | IncidentLogEquipmentCreateOrConnectWithoutEquipmentInput[]
    upsert?: IncidentLogEquipmentUpsertWithWhereUniqueWithoutEquipmentInput | IncidentLogEquipmentUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: IncidentLogEquipmentCreateManyEquipmentInputEnvelope
    set?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    disconnect?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    delete?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    connect?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    update?: IncidentLogEquipmentUpdateWithWhereUniqueWithoutEquipmentInput | IncidentLogEquipmentUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: IncidentLogEquipmentUpdateManyWithWhereWithoutEquipmentInput | IncidentLogEquipmentUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: IncidentLogEquipmentScalarWhereInput | IncidentLogEquipmentScalarWhereInput[]
  }

  export type EquipmentCheckUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<EquipmentCheckCreateWithoutEquipmentInput, EquipmentCheckUncheckedCreateWithoutEquipmentInput> | EquipmentCheckCreateWithoutEquipmentInput[] | EquipmentCheckUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutEquipmentInput | EquipmentCheckCreateOrConnectWithoutEquipmentInput[]
    upsert?: EquipmentCheckUpsertWithWhereUniqueWithoutEquipmentInput | EquipmentCheckUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: EquipmentCheckCreateManyEquipmentInputEnvelope
    set?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    disconnect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    delete?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    update?: EquipmentCheckUpdateWithWhereUniqueWithoutEquipmentInput | EquipmentCheckUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: EquipmentCheckUpdateManyWithWhereWithoutEquipmentInput | EquipmentCheckUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: EquipmentCheckScalarWhereInput | EquipmentCheckScalarWhereInput[]
  }

  export type IncidentLogEquipmentUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<IncidentLogEquipmentCreateWithoutEquipmentInput, IncidentLogEquipmentUncheckedCreateWithoutEquipmentInput> | IncidentLogEquipmentCreateWithoutEquipmentInput[] | IncidentLogEquipmentUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: IncidentLogEquipmentCreateOrConnectWithoutEquipmentInput | IncidentLogEquipmentCreateOrConnectWithoutEquipmentInput[]
    upsert?: IncidentLogEquipmentUpsertWithWhereUniqueWithoutEquipmentInput | IncidentLogEquipmentUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: IncidentLogEquipmentCreateManyEquipmentInputEnvelope
    set?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    disconnect?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    delete?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    connect?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    update?: IncidentLogEquipmentUpdateWithWhereUniqueWithoutEquipmentInput | IncidentLogEquipmentUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: IncidentLogEquipmentUpdateManyWithWhereWithoutEquipmentInput | IncidentLogEquipmentUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: IncidentLogEquipmentScalarWhereInput | IncidentLogEquipmentScalarWhereInput[]
  }

  export type EquipmentCheckUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<EquipmentCheckCreateWithoutEquipmentInput, EquipmentCheckUncheckedCreateWithoutEquipmentInput> | EquipmentCheckCreateWithoutEquipmentInput[] | EquipmentCheckUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentCheckCreateOrConnectWithoutEquipmentInput | EquipmentCheckCreateOrConnectWithoutEquipmentInput[]
    upsert?: EquipmentCheckUpsertWithWhereUniqueWithoutEquipmentInput | EquipmentCheckUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: EquipmentCheckCreateManyEquipmentInputEnvelope
    set?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    disconnect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    delete?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    connect?: EquipmentCheckWhereUniqueInput | EquipmentCheckWhereUniqueInput[]
    update?: EquipmentCheckUpdateWithWhereUniqueWithoutEquipmentInput | EquipmentCheckUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: EquipmentCheckUpdateManyWithWhereWithoutEquipmentInput | EquipmentCheckUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: EquipmentCheckScalarWhereInput | EquipmentCheckScalarWhereInput[]
  }

  export type MountainCreateNestedOneWithoutIncidentsInput = {
    create?: XOR<MountainCreateWithoutIncidentsInput, MountainUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutIncidentsInput
    connect?: MountainWhereUniqueInput
  }

  export type IncidentLogCreateNestedManyWithoutIncidentInput = {
    create?: XOR<IncidentLogCreateWithoutIncidentInput, IncidentLogUncheckedCreateWithoutIncidentInput> | IncidentLogCreateWithoutIncidentInput[] | IncidentLogUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutIncidentInput | IncidentLogCreateOrConnectWithoutIncidentInput[]
    createMany?: IncidentLogCreateManyIncidentInputEnvelope
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
  }

  export type IncidentLogUncheckedCreateNestedManyWithoutIncidentInput = {
    create?: XOR<IncidentLogCreateWithoutIncidentInput, IncidentLogUncheckedCreateWithoutIncidentInput> | IncidentLogCreateWithoutIncidentInput[] | IncidentLogUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutIncidentInput | IncidentLogCreateOrConnectWithoutIncidentInput[]
    createMany?: IncidentLogCreateManyIncidentInputEnvelope
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
  }

  export type MountainUpdateOneRequiredWithoutIncidentsNestedInput = {
    create?: XOR<MountainCreateWithoutIncidentsInput, MountainUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutIncidentsInput
    upsert?: MountainUpsertWithoutIncidentsInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutIncidentsInput, MountainUpdateWithoutIncidentsInput>, MountainUncheckedUpdateWithoutIncidentsInput>
  }

  export type IncidentLogUpdateManyWithoutIncidentNestedInput = {
    create?: XOR<IncidentLogCreateWithoutIncidentInput, IncidentLogUncheckedCreateWithoutIncidentInput> | IncidentLogCreateWithoutIncidentInput[] | IncidentLogUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutIncidentInput | IncidentLogCreateOrConnectWithoutIncidentInput[]
    upsert?: IncidentLogUpsertWithWhereUniqueWithoutIncidentInput | IncidentLogUpsertWithWhereUniqueWithoutIncidentInput[]
    createMany?: IncidentLogCreateManyIncidentInputEnvelope
    set?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    disconnect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    delete?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    update?: IncidentLogUpdateWithWhereUniqueWithoutIncidentInput | IncidentLogUpdateWithWhereUniqueWithoutIncidentInput[]
    updateMany?: IncidentLogUpdateManyWithWhereWithoutIncidentInput | IncidentLogUpdateManyWithWhereWithoutIncidentInput[]
    deleteMany?: IncidentLogScalarWhereInput | IncidentLogScalarWhereInput[]
  }

  export type IncidentLogUncheckedUpdateManyWithoutIncidentNestedInput = {
    create?: XOR<IncidentLogCreateWithoutIncidentInput, IncidentLogUncheckedCreateWithoutIncidentInput> | IncidentLogCreateWithoutIncidentInput[] | IncidentLogUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentLogCreateOrConnectWithoutIncidentInput | IncidentLogCreateOrConnectWithoutIncidentInput[]
    upsert?: IncidentLogUpsertWithWhereUniqueWithoutIncidentInput | IncidentLogUpsertWithWhereUniqueWithoutIncidentInput[]
    createMany?: IncidentLogCreateManyIncidentInputEnvelope
    set?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    disconnect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    delete?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    connect?: IncidentLogWhereUniqueInput | IncidentLogWhereUniqueInput[]
    update?: IncidentLogUpdateWithWhereUniqueWithoutIncidentInput | IncidentLogUpdateWithWhereUniqueWithoutIncidentInput[]
    updateMany?: IncidentLogUpdateManyWithWhereWithoutIncidentInput | IncidentLogUpdateManyWithWhereWithoutIncidentInput[]
    deleteMany?: IncidentLogScalarWhereInput | IncidentLogScalarWhereInput[]
  }

  export type IncidentCreateNestedOneWithoutLogsInput = {
    create?: XOR<IncidentCreateWithoutLogsInput, IncidentUncheckedCreateWithoutLogsInput>
    connectOrCreate?: IncidentCreateOrConnectWithoutLogsInput
    connect?: IncidentWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutLogsInput = {
    create?: XOR<EmployeeCreateWithoutLogsInput, EmployeeUncheckedCreateWithoutLogsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLogsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type MountainCreateNestedOneWithoutIncidentLogsInput = {
    create?: XOR<MountainCreateWithoutIncidentLogsInput, MountainUncheckedCreateWithoutIncidentLogsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutIncidentLogsInput
    connect?: MountainWhereUniqueInput
  }

  export type IncidentLogEquipmentCreateNestedManyWithoutIncidentLogInput = {
    create?: XOR<IncidentLogEquipmentCreateWithoutIncidentLogInput, IncidentLogEquipmentUncheckedCreateWithoutIncidentLogInput> | IncidentLogEquipmentCreateWithoutIncidentLogInput[] | IncidentLogEquipmentUncheckedCreateWithoutIncidentLogInput[]
    connectOrCreate?: IncidentLogEquipmentCreateOrConnectWithoutIncidentLogInput | IncidentLogEquipmentCreateOrConnectWithoutIncidentLogInput[]
    createMany?: IncidentLogEquipmentCreateManyIncidentLogInputEnvelope
    connect?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
  }

  export type LiftCreateNestedOneWithoutIncidentLogsInput = {
    create?: XOR<LiftCreateWithoutIncidentLogsInput, LiftUncheckedCreateWithoutIncidentLogsInput>
    connectOrCreate?: LiftCreateOrConnectWithoutIncidentLogsInput
    connect?: LiftWhereUniqueInput
  }

  export type TrailCreateNestedOneWithoutIncidentLogsInput = {
    create?: XOR<TrailCreateWithoutIncidentLogsInput, TrailUncheckedCreateWithoutIncidentLogsInput>
    connectOrCreate?: TrailCreateOrConnectWithoutIncidentLogsInput
    connect?: TrailWhereUniqueInput
  }

  export type LodgeCreateNestedOneWithoutIncidentLogsInput = {
    create?: XOR<LodgeCreateWithoutIncidentLogsInput, LodgeUncheckedCreateWithoutIncidentLogsInput>
    connectOrCreate?: LodgeCreateOrConnectWithoutIncidentLogsInput
    connect?: LodgeWhereUniqueInput
  }

  export type HutCreateNestedOneWithoutIncidentLogsInput = {
    create?: XOR<HutCreateWithoutIncidentLogsInput, HutUncheckedCreateWithoutIncidentLogsInput>
    connectOrCreate?: HutCreateOrConnectWithoutIncidentLogsInput
    connect?: HutWhereUniqueInput
  }

  export type AidRoomCreateNestedOneWithoutIncidentLogsInput = {
    create?: XOR<AidRoomCreateWithoutIncidentLogsInput, AidRoomUncheckedCreateWithoutIncidentLogsInput>
    connectOrCreate?: AidRoomCreateOrConnectWithoutIncidentLogsInput
    connect?: AidRoomWhereUniqueInput
  }

  export type IncidentLogEquipmentUncheckedCreateNestedManyWithoutIncidentLogInput = {
    create?: XOR<IncidentLogEquipmentCreateWithoutIncidentLogInput, IncidentLogEquipmentUncheckedCreateWithoutIncidentLogInput> | IncidentLogEquipmentCreateWithoutIncidentLogInput[] | IncidentLogEquipmentUncheckedCreateWithoutIncidentLogInput[]
    connectOrCreate?: IncidentLogEquipmentCreateOrConnectWithoutIncidentLogInput | IncidentLogEquipmentCreateOrConnectWithoutIncidentLogInput[]
    createMany?: IncidentLogEquipmentCreateManyIncidentLogInputEnvelope
    connect?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
  }

  export type EnumLocationTypeFieldUpdateOperationsInput = {
    set?: $Enums.LocationType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IncidentUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<IncidentCreateWithoutLogsInput, IncidentUncheckedCreateWithoutLogsInput>
    connectOrCreate?: IncidentCreateOrConnectWithoutLogsInput
    upsert?: IncidentUpsertWithoutLogsInput
    connect?: IncidentWhereUniqueInput
    update?: XOR<XOR<IncidentUpdateToOneWithWhereWithoutLogsInput, IncidentUpdateWithoutLogsInput>, IncidentUncheckedUpdateWithoutLogsInput>
  }

  export type EmployeeUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<EmployeeCreateWithoutLogsInput, EmployeeUncheckedCreateWithoutLogsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLogsInput
    upsert?: EmployeeUpsertWithoutLogsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutLogsInput, EmployeeUpdateWithoutLogsInput>, EmployeeUncheckedUpdateWithoutLogsInput>
  }

  export type MountainUpdateOneRequiredWithoutIncidentLogsNestedInput = {
    create?: XOR<MountainCreateWithoutIncidentLogsInput, MountainUncheckedCreateWithoutIncidentLogsInput>
    connectOrCreate?: MountainCreateOrConnectWithoutIncidentLogsInput
    upsert?: MountainUpsertWithoutIncidentLogsInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutIncidentLogsInput, MountainUpdateWithoutIncidentLogsInput>, MountainUncheckedUpdateWithoutIncidentLogsInput>
  }

  export type IncidentLogEquipmentUpdateManyWithoutIncidentLogNestedInput = {
    create?: XOR<IncidentLogEquipmentCreateWithoutIncidentLogInput, IncidentLogEquipmentUncheckedCreateWithoutIncidentLogInput> | IncidentLogEquipmentCreateWithoutIncidentLogInput[] | IncidentLogEquipmentUncheckedCreateWithoutIncidentLogInput[]
    connectOrCreate?: IncidentLogEquipmentCreateOrConnectWithoutIncidentLogInput | IncidentLogEquipmentCreateOrConnectWithoutIncidentLogInput[]
    upsert?: IncidentLogEquipmentUpsertWithWhereUniqueWithoutIncidentLogInput | IncidentLogEquipmentUpsertWithWhereUniqueWithoutIncidentLogInput[]
    createMany?: IncidentLogEquipmentCreateManyIncidentLogInputEnvelope
    set?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    disconnect?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    delete?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    connect?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    update?: IncidentLogEquipmentUpdateWithWhereUniqueWithoutIncidentLogInput | IncidentLogEquipmentUpdateWithWhereUniqueWithoutIncidentLogInput[]
    updateMany?: IncidentLogEquipmentUpdateManyWithWhereWithoutIncidentLogInput | IncidentLogEquipmentUpdateManyWithWhereWithoutIncidentLogInput[]
    deleteMany?: IncidentLogEquipmentScalarWhereInput | IncidentLogEquipmentScalarWhereInput[]
  }

  export type LiftUpdateOneWithoutIncidentLogsNestedInput = {
    create?: XOR<LiftCreateWithoutIncidentLogsInput, LiftUncheckedCreateWithoutIncidentLogsInput>
    connectOrCreate?: LiftCreateOrConnectWithoutIncidentLogsInput
    upsert?: LiftUpsertWithoutIncidentLogsInput
    disconnect?: LiftWhereInput | boolean
    delete?: LiftWhereInput | boolean
    connect?: LiftWhereUniqueInput
    update?: XOR<XOR<LiftUpdateToOneWithWhereWithoutIncidentLogsInput, LiftUpdateWithoutIncidentLogsInput>, LiftUncheckedUpdateWithoutIncidentLogsInput>
  }

  export type TrailUpdateOneWithoutIncidentLogsNestedInput = {
    create?: XOR<TrailCreateWithoutIncidentLogsInput, TrailUncheckedCreateWithoutIncidentLogsInput>
    connectOrCreate?: TrailCreateOrConnectWithoutIncidentLogsInput
    upsert?: TrailUpsertWithoutIncidentLogsInput
    disconnect?: TrailWhereInput | boolean
    delete?: TrailWhereInput | boolean
    connect?: TrailWhereUniqueInput
    update?: XOR<XOR<TrailUpdateToOneWithWhereWithoutIncidentLogsInput, TrailUpdateWithoutIncidentLogsInput>, TrailUncheckedUpdateWithoutIncidentLogsInput>
  }

  export type LodgeUpdateOneWithoutIncidentLogsNestedInput = {
    create?: XOR<LodgeCreateWithoutIncidentLogsInput, LodgeUncheckedCreateWithoutIncidentLogsInput>
    connectOrCreate?: LodgeCreateOrConnectWithoutIncidentLogsInput
    upsert?: LodgeUpsertWithoutIncidentLogsInput
    disconnect?: LodgeWhereInput | boolean
    delete?: LodgeWhereInput | boolean
    connect?: LodgeWhereUniqueInput
    update?: XOR<XOR<LodgeUpdateToOneWithWhereWithoutIncidentLogsInput, LodgeUpdateWithoutIncidentLogsInput>, LodgeUncheckedUpdateWithoutIncidentLogsInput>
  }

  export type HutUpdateOneWithoutIncidentLogsNestedInput = {
    create?: XOR<HutCreateWithoutIncidentLogsInput, HutUncheckedCreateWithoutIncidentLogsInput>
    connectOrCreate?: HutCreateOrConnectWithoutIncidentLogsInput
    upsert?: HutUpsertWithoutIncidentLogsInput
    disconnect?: HutWhereInput | boolean
    delete?: HutWhereInput | boolean
    connect?: HutWhereUniqueInput
    update?: XOR<XOR<HutUpdateToOneWithWhereWithoutIncidentLogsInput, HutUpdateWithoutIncidentLogsInput>, HutUncheckedUpdateWithoutIncidentLogsInput>
  }

  export type AidRoomUpdateOneWithoutIncidentLogsNestedInput = {
    create?: XOR<AidRoomCreateWithoutIncidentLogsInput, AidRoomUncheckedCreateWithoutIncidentLogsInput>
    connectOrCreate?: AidRoomCreateOrConnectWithoutIncidentLogsInput
    upsert?: AidRoomUpsertWithoutIncidentLogsInput
    disconnect?: AidRoomWhereInput | boolean
    delete?: AidRoomWhereInput | boolean
    connect?: AidRoomWhereUniqueInput
    update?: XOR<XOR<AidRoomUpdateToOneWithWhereWithoutIncidentLogsInput, AidRoomUpdateWithoutIncidentLogsInput>, AidRoomUncheckedUpdateWithoutIncidentLogsInput>
  }

  export type IncidentLogEquipmentUncheckedUpdateManyWithoutIncidentLogNestedInput = {
    create?: XOR<IncidentLogEquipmentCreateWithoutIncidentLogInput, IncidentLogEquipmentUncheckedCreateWithoutIncidentLogInput> | IncidentLogEquipmentCreateWithoutIncidentLogInput[] | IncidentLogEquipmentUncheckedCreateWithoutIncidentLogInput[]
    connectOrCreate?: IncidentLogEquipmentCreateOrConnectWithoutIncidentLogInput | IncidentLogEquipmentCreateOrConnectWithoutIncidentLogInput[]
    upsert?: IncidentLogEquipmentUpsertWithWhereUniqueWithoutIncidentLogInput | IncidentLogEquipmentUpsertWithWhereUniqueWithoutIncidentLogInput[]
    createMany?: IncidentLogEquipmentCreateManyIncidentLogInputEnvelope
    set?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    disconnect?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    delete?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    connect?: IncidentLogEquipmentWhereUniqueInput | IncidentLogEquipmentWhereUniqueInput[]
    update?: IncidentLogEquipmentUpdateWithWhereUniqueWithoutIncidentLogInput | IncidentLogEquipmentUpdateWithWhereUniqueWithoutIncidentLogInput[]
    updateMany?: IncidentLogEquipmentUpdateManyWithWhereWithoutIncidentLogInput | IncidentLogEquipmentUpdateManyWithWhereWithoutIncidentLogInput[]
    deleteMany?: IncidentLogEquipmentScalarWhereInput | IncidentLogEquipmentScalarWhereInput[]
  }

  export type MountainCreateNestedOneWithoutIncidentLogEquipmentInput = {
    create?: XOR<MountainCreateWithoutIncidentLogEquipmentInput, MountainUncheckedCreateWithoutIncidentLogEquipmentInput>
    connectOrCreate?: MountainCreateOrConnectWithoutIncidentLogEquipmentInput
    connect?: MountainWhereUniqueInput
  }

  export type IncidentLogCreateNestedOneWithoutEquipmentUsedInput = {
    create?: XOR<IncidentLogCreateWithoutEquipmentUsedInput, IncidentLogUncheckedCreateWithoutEquipmentUsedInput>
    connectOrCreate?: IncidentLogCreateOrConnectWithoutEquipmentUsedInput
    connect?: IncidentLogWhereUniqueInput
  }

  export type EquipmentCreateNestedOneWithoutUsedInLogsInput = {
    create?: XOR<EquipmentCreateWithoutUsedInLogsInput, EquipmentUncheckedCreateWithoutUsedInLogsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutUsedInLogsInput
    connect?: EquipmentWhereUniqueInput
  }

  export type MountainUpdateOneRequiredWithoutIncidentLogEquipmentNestedInput = {
    create?: XOR<MountainCreateWithoutIncidentLogEquipmentInput, MountainUncheckedCreateWithoutIncidentLogEquipmentInput>
    connectOrCreate?: MountainCreateOrConnectWithoutIncidentLogEquipmentInput
    upsert?: MountainUpsertWithoutIncidentLogEquipmentInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutIncidentLogEquipmentInput, MountainUpdateWithoutIncidentLogEquipmentInput>, MountainUncheckedUpdateWithoutIncidentLogEquipmentInput>
  }

  export type IncidentLogUpdateOneRequiredWithoutEquipmentUsedNestedInput = {
    create?: XOR<IncidentLogCreateWithoutEquipmentUsedInput, IncidentLogUncheckedCreateWithoutEquipmentUsedInput>
    connectOrCreate?: IncidentLogCreateOrConnectWithoutEquipmentUsedInput
    upsert?: IncidentLogUpsertWithoutEquipmentUsedInput
    connect?: IncidentLogWhereUniqueInput
    update?: XOR<XOR<IncidentLogUpdateToOneWithWhereWithoutEquipmentUsedInput, IncidentLogUpdateWithoutEquipmentUsedInput>, IncidentLogUncheckedUpdateWithoutEquipmentUsedInput>
  }

  export type EquipmentUpdateOneRequiredWithoutUsedInLogsNestedInput = {
    create?: XOR<EquipmentCreateWithoutUsedInLogsInput, EquipmentUncheckedCreateWithoutUsedInLogsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutUsedInLogsInput
    upsert?: EquipmentUpsertWithoutUsedInLogsInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutUsedInLogsInput, EquipmentUpdateWithoutUsedInLogsInput>, EquipmentUncheckedUpdateWithoutUsedInLogsInput>
  }

  export type EmployeeCreateNestedOneWithoutLiftChecksInput = {
    create?: XOR<EmployeeCreateWithoutLiftChecksInput, EmployeeUncheckedCreateWithoutLiftChecksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLiftChecksInput
    connect?: EmployeeWhereUniqueInput
  }

  export type MountainCreateNestedOneWithoutLiftChecksInput = {
    create?: XOR<MountainCreateWithoutLiftChecksInput, MountainUncheckedCreateWithoutLiftChecksInput>
    connectOrCreate?: MountainCreateOrConnectWithoutLiftChecksInput
    connect?: MountainWhereUniqueInput
  }

  export type LiftCreateNestedOneWithoutLiftChecksInput = {
    create?: XOR<LiftCreateWithoutLiftChecksInput, LiftUncheckedCreateWithoutLiftChecksInput>
    connectOrCreate?: LiftCreateOrConnectWithoutLiftChecksInput
    connect?: LiftWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutLiftChecksNestedInput = {
    create?: XOR<EmployeeCreateWithoutLiftChecksInput, EmployeeUncheckedCreateWithoutLiftChecksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLiftChecksInput
    upsert?: EmployeeUpsertWithoutLiftChecksInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutLiftChecksInput, EmployeeUpdateWithoutLiftChecksInput>, EmployeeUncheckedUpdateWithoutLiftChecksInput>
  }

  export type MountainUpdateOneRequiredWithoutLiftChecksNestedInput = {
    create?: XOR<MountainCreateWithoutLiftChecksInput, MountainUncheckedCreateWithoutLiftChecksInput>
    connectOrCreate?: MountainCreateOrConnectWithoutLiftChecksInput
    upsert?: MountainUpsertWithoutLiftChecksInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutLiftChecksInput, MountainUpdateWithoutLiftChecksInput>, MountainUncheckedUpdateWithoutLiftChecksInput>
  }

  export type LiftUpdateOneRequiredWithoutLiftChecksNestedInput = {
    create?: XOR<LiftCreateWithoutLiftChecksInput, LiftUncheckedCreateWithoutLiftChecksInput>
    connectOrCreate?: LiftCreateOrConnectWithoutLiftChecksInput
    upsert?: LiftUpsertWithoutLiftChecksInput
    connect?: LiftWhereUniqueInput
    update?: XOR<XOR<LiftUpdateToOneWithWhereWithoutLiftChecksInput, LiftUpdateWithoutLiftChecksInput>, LiftUncheckedUpdateWithoutLiftChecksInput>
  }

  export type EmployeeCreateNestedOneWithoutTrailChecksInput = {
    create?: XOR<EmployeeCreateWithoutTrailChecksInput, EmployeeUncheckedCreateWithoutTrailChecksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutTrailChecksInput
    connect?: EmployeeWhereUniqueInput
  }

  export type MountainCreateNestedOneWithoutTrailChecksInput = {
    create?: XOR<MountainCreateWithoutTrailChecksInput, MountainUncheckedCreateWithoutTrailChecksInput>
    connectOrCreate?: MountainCreateOrConnectWithoutTrailChecksInput
    connect?: MountainWhereUniqueInput
  }

  export type TrailCreateNestedOneWithoutTrailChecksInput = {
    create?: XOR<TrailCreateWithoutTrailChecksInput, TrailUncheckedCreateWithoutTrailChecksInput>
    connectOrCreate?: TrailCreateOrConnectWithoutTrailChecksInput
    connect?: TrailWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutTrailChecksNestedInput = {
    create?: XOR<EmployeeCreateWithoutTrailChecksInput, EmployeeUncheckedCreateWithoutTrailChecksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutTrailChecksInput
    upsert?: EmployeeUpsertWithoutTrailChecksInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutTrailChecksInput, EmployeeUpdateWithoutTrailChecksInput>, EmployeeUncheckedUpdateWithoutTrailChecksInput>
  }

  export type MountainUpdateOneRequiredWithoutTrailChecksNestedInput = {
    create?: XOR<MountainCreateWithoutTrailChecksInput, MountainUncheckedCreateWithoutTrailChecksInput>
    connectOrCreate?: MountainCreateOrConnectWithoutTrailChecksInput
    upsert?: MountainUpsertWithoutTrailChecksInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutTrailChecksInput, MountainUpdateWithoutTrailChecksInput>, MountainUncheckedUpdateWithoutTrailChecksInput>
  }

  export type TrailUpdateOneRequiredWithoutTrailChecksNestedInput = {
    create?: XOR<TrailCreateWithoutTrailChecksInput, TrailUncheckedCreateWithoutTrailChecksInput>
    connectOrCreate?: TrailCreateOrConnectWithoutTrailChecksInput
    upsert?: TrailUpsertWithoutTrailChecksInput
    connect?: TrailWhereUniqueInput
    update?: XOR<XOR<TrailUpdateToOneWithWhereWithoutTrailChecksInput, TrailUpdateWithoutTrailChecksInput>, TrailUncheckedUpdateWithoutTrailChecksInput>
  }

  export type EmployeeCreateNestedOneWithoutHutChecksInput = {
    create?: XOR<EmployeeCreateWithoutHutChecksInput, EmployeeUncheckedCreateWithoutHutChecksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutHutChecksInput
    connect?: EmployeeWhereUniqueInput
  }

  export type MountainCreateNestedOneWithoutHutChecksInput = {
    create?: XOR<MountainCreateWithoutHutChecksInput, MountainUncheckedCreateWithoutHutChecksInput>
    connectOrCreate?: MountainCreateOrConnectWithoutHutChecksInput
    connect?: MountainWhereUniqueInput
  }

  export type HutCreateNestedOneWithoutHutChecksInput = {
    create?: XOR<HutCreateWithoutHutChecksInput, HutUncheckedCreateWithoutHutChecksInput>
    connectOrCreate?: HutCreateOrConnectWithoutHutChecksInput
    connect?: HutWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutHutChecksNestedInput = {
    create?: XOR<EmployeeCreateWithoutHutChecksInput, EmployeeUncheckedCreateWithoutHutChecksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutHutChecksInput
    upsert?: EmployeeUpsertWithoutHutChecksInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutHutChecksInput, EmployeeUpdateWithoutHutChecksInput>, EmployeeUncheckedUpdateWithoutHutChecksInput>
  }

  export type MountainUpdateOneRequiredWithoutHutChecksNestedInput = {
    create?: XOR<MountainCreateWithoutHutChecksInput, MountainUncheckedCreateWithoutHutChecksInput>
    connectOrCreate?: MountainCreateOrConnectWithoutHutChecksInput
    upsert?: MountainUpsertWithoutHutChecksInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutHutChecksInput, MountainUpdateWithoutHutChecksInput>, MountainUncheckedUpdateWithoutHutChecksInput>
  }

  export type HutUpdateOneRequiredWithoutHutChecksNestedInput = {
    create?: XOR<HutCreateWithoutHutChecksInput, HutUncheckedCreateWithoutHutChecksInput>
    connectOrCreate?: HutCreateOrConnectWithoutHutChecksInput
    upsert?: HutUpsertWithoutHutChecksInput
    connect?: HutWhereUniqueInput
    update?: XOR<XOR<HutUpdateToOneWithWhereWithoutHutChecksInput, HutUpdateWithoutHutChecksInput>, HutUncheckedUpdateWithoutHutChecksInput>
  }

  export type EmployeeCreateNestedOneWithoutAidRoomChecksInput = {
    create?: XOR<EmployeeCreateWithoutAidRoomChecksInput, EmployeeUncheckedCreateWithoutAidRoomChecksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAidRoomChecksInput
    connect?: EmployeeWhereUniqueInput
  }

  export type MountainCreateNestedOneWithoutAidRoomChecksInput = {
    create?: XOR<MountainCreateWithoutAidRoomChecksInput, MountainUncheckedCreateWithoutAidRoomChecksInput>
    connectOrCreate?: MountainCreateOrConnectWithoutAidRoomChecksInput
    connect?: MountainWhereUniqueInput
  }

  export type AidRoomCreateNestedOneWithoutAidRoomChecksInput = {
    create?: XOR<AidRoomCreateWithoutAidRoomChecksInput, AidRoomUncheckedCreateWithoutAidRoomChecksInput>
    connectOrCreate?: AidRoomCreateOrConnectWithoutAidRoomChecksInput
    connect?: AidRoomWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutAidRoomChecksNestedInput = {
    create?: XOR<EmployeeCreateWithoutAidRoomChecksInput, EmployeeUncheckedCreateWithoutAidRoomChecksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAidRoomChecksInput
    upsert?: EmployeeUpsertWithoutAidRoomChecksInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAidRoomChecksInput, EmployeeUpdateWithoutAidRoomChecksInput>, EmployeeUncheckedUpdateWithoutAidRoomChecksInput>
  }

  export type MountainUpdateOneRequiredWithoutAidRoomChecksNestedInput = {
    create?: XOR<MountainCreateWithoutAidRoomChecksInput, MountainUncheckedCreateWithoutAidRoomChecksInput>
    connectOrCreate?: MountainCreateOrConnectWithoutAidRoomChecksInput
    upsert?: MountainUpsertWithoutAidRoomChecksInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutAidRoomChecksInput, MountainUpdateWithoutAidRoomChecksInput>, MountainUncheckedUpdateWithoutAidRoomChecksInput>
  }

  export type AidRoomUpdateOneRequiredWithoutAidRoomChecksNestedInput = {
    create?: XOR<AidRoomCreateWithoutAidRoomChecksInput, AidRoomUncheckedCreateWithoutAidRoomChecksInput>
    connectOrCreate?: AidRoomCreateOrConnectWithoutAidRoomChecksInput
    upsert?: AidRoomUpsertWithoutAidRoomChecksInput
    connect?: AidRoomWhereUniqueInput
    update?: XOR<XOR<AidRoomUpdateToOneWithWhereWithoutAidRoomChecksInput, AidRoomUpdateWithoutAidRoomChecksInput>, AidRoomUncheckedUpdateWithoutAidRoomChecksInput>
  }

  export type EmployeeCreateNestedOneWithoutEquipmentChecksInput = {
    create?: XOR<EmployeeCreateWithoutEquipmentChecksInput, EmployeeUncheckedCreateWithoutEquipmentChecksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEquipmentChecksInput
    connect?: EmployeeWhereUniqueInput
  }

  export type MountainCreateNestedOneWithoutEquipmentChecksInput = {
    create?: XOR<MountainCreateWithoutEquipmentChecksInput, MountainUncheckedCreateWithoutEquipmentChecksInput>
    connectOrCreate?: MountainCreateOrConnectWithoutEquipmentChecksInput
    connect?: MountainWhereUniqueInput
  }

  export type EquipmentCreateNestedOneWithoutEquipmentChecksInput = {
    create?: XOR<EquipmentCreateWithoutEquipmentChecksInput, EquipmentUncheckedCreateWithoutEquipmentChecksInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutEquipmentChecksInput
    connect?: EquipmentWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutEquipmentChecksNestedInput = {
    create?: XOR<EmployeeCreateWithoutEquipmentChecksInput, EmployeeUncheckedCreateWithoutEquipmentChecksInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEquipmentChecksInput
    upsert?: EmployeeUpsertWithoutEquipmentChecksInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutEquipmentChecksInput, EmployeeUpdateWithoutEquipmentChecksInput>, EmployeeUncheckedUpdateWithoutEquipmentChecksInput>
  }

  export type MountainUpdateOneRequiredWithoutEquipmentChecksNestedInput = {
    create?: XOR<MountainCreateWithoutEquipmentChecksInput, MountainUncheckedCreateWithoutEquipmentChecksInput>
    connectOrCreate?: MountainCreateOrConnectWithoutEquipmentChecksInput
    upsert?: MountainUpsertWithoutEquipmentChecksInput
    connect?: MountainWhereUniqueInput
    update?: XOR<XOR<MountainUpdateToOneWithWhereWithoutEquipmentChecksInput, MountainUpdateWithoutEquipmentChecksInput>, MountainUncheckedUpdateWithoutEquipmentChecksInput>
  }

  export type EquipmentUpdateOneRequiredWithoutEquipmentChecksNestedInput = {
    create?: XOR<EquipmentCreateWithoutEquipmentChecksInput, EquipmentUncheckedCreateWithoutEquipmentChecksInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutEquipmentChecksInput
    upsert?: EquipmentUpsertWithoutEquipmentChecksInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutEquipmentChecksInput, EquipmentUpdateWithoutEquipmentChecksInput>, EquipmentUncheckedUpdateWithoutEquipmentChecksInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumDepartmentFilter<$PrismaModel = never> = {
    equals?: $Enums.Department | EnumDepartmentFieldRefInput<$PrismaModel>
    in?: $Enums.Department[] | ListEnumDepartmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.Department[] | ListEnumDepartmentFieldRefInput<$PrismaModel>
    not?: NestedEnumDepartmentFilter<$PrismaModel> | $Enums.Department
  }

  export type NestedEnumDepartmentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Department | EnumDepartmentFieldRefInput<$PrismaModel>
    in?: $Enums.Department[] | ListEnumDepartmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.Department[] | ListEnumDepartmentFieldRefInput<$PrismaModel>
    not?: NestedEnumDepartmentWithAggregatesFilter<$PrismaModel> | $Enums.Department
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDepartmentFilter<$PrismaModel>
    _max?: NestedEnumDepartmentFilter<$PrismaModel>
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedEnumTrailDifficultyFilter<$PrismaModel = never> = {
    equals?: $Enums.TrailDifficulty | EnumTrailDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.TrailDifficulty[] | ListEnumTrailDifficultyFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrailDifficulty[] | ListEnumTrailDifficultyFieldRefInput<$PrismaModel>
    not?: NestedEnumTrailDifficultyFilter<$PrismaModel> | $Enums.TrailDifficulty
  }

  export type NestedEnumTrailConditionFilter<$PrismaModel = never> = {
    equals?: $Enums.TrailCondition | EnumTrailConditionFieldRefInput<$PrismaModel>
    in?: $Enums.TrailCondition[] | ListEnumTrailConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrailCondition[] | ListEnumTrailConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumTrailConditionFilter<$PrismaModel> | $Enums.TrailCondition
  }

  export type NestedEnumTrailDifficultyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrailDifficulty | EnumTrailDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.TrailDifficulty[] | ListEnumTrailDifficultyFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrailDifficulty[] | ListEnumTrailDifficultyFieldRefInput<$PrismaModel>
    not?: NestedEnumTrailDifficultyWithAggregatesFilter<$PrismaModel> | $Enums.TrailDifficulty
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrailDifficultyFilter<$PrismaModel>
    _max?: NestedEnumTrailDifficultyFilter<$PrismaModel>
  }

  export type NestedEnumTrailConditionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrailCondition | EnumTrailConditionFieldRefInput<$PrismaModel>
    in?: $Enums.TrailCondition[] | ListEnumTrailConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrailCondition[] | ListEnumTrailConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumTrailConditionWithAggregatesFilter<$PrismaModel> | $Enums.TrailCondition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrailConditionFilter<$PrismaModel>
    _max?: NestedEnumTrailConditionFilter<$PrismaModel>
  }

  export type NestedEnumEquipmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusFilter<$PrismaModel> | $Enums.EquipmentStatus
  }

  export type NestedEnumEquipmentServiceFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentService | EnumEquipmentServiceFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentService[] | ListEnumEquipmentServiceFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentService[] | ListEnumEquipmentServiceFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentServiceFilter<$PrismaModel> | $Enums.EquipmentService
  }

  export type NestedEnumEquipmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentStatusFilter<$PrismaModel>
    _max?: NestedEnumEquipmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumEquipmentServiceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentService | EnumEquipmentServiceFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentService[] | ListEnumEquipmentServiceFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentService[] | ListEnumEquipmentServiceFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentServiceWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentService
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentServiceFilter<$PrismaModel>
    _max?: NestedEnumEquipmentServiceFilter<$PrismaModel>
  }

  export type NestedEnumLocationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLocationTypeFilter<$PrismaModel> | $Enums.LocationType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumLocationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLocationTypeWithAggregatesFilter<$PrismaModel> | $Enums.LocationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLocationTypeFilter<$PrismaModel>
    _max?: NestedEnumLocationTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type LiftCreateWithoutMountainInput = {
    id?: string
    name: string
    capacity: number
    status?: $Enums.Status
    incidentLogs?: IncidentLogCreateNestedManyWithoutLiftInput
    liftChecks?: LiftCheckCreateNestedManyWithoutLiftInput
  }

  export type LiftUncheckedCreateWithoutMountainInput = {
    id?: string
    name: string
    capacity: number
    status?: $Enums.Status
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutLiftInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutLiftInput
  }

  export type LiftCreateOrConnectWithoutMountainInput = {
    where: LiftWhereUniqueInput
    create: XOR<LiftCreateWithoutMountainInput, LiftUncheckedCreateWithoutMountainInput>
  }

  export type LiftCreateManyMountainInputEnvelope = {
    data: LiftCreateManyMountainInput | LiftCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type LiftCheckCreateWithoutMountainInput = {
    id?: string
    date?: Date | string
    notes?: string | null
    employee: EmployeeCreateNestedOneWithoutLiftChecksInput
    lift: LiftCreateNestedOneWithoutLiftChecksInput
  }

  export type LiftCheckUncheckedCreateWithoutMountainInput = {
    id?: string
    date?: Date | string
    employeeId: string
    liftId: string
    notes?: string | null
  }

  export type LiftCheckCreateOrConnectWithoutMountainInput = {
    where: LiftCheckWhereUniqueInput
    create: XOR<LiftCheckCreateWithoutMountainInput, LiftCheckUncheckedCreateWithoutMountainInput>
  }

  export type LiftCheckCreateManyMountainInputEnvelope = {
    data: LiftCheckCreateManyMountainInput | LiftCheckCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type TrailCreateWithoutMountainInput = {
    id?: string
    name: string
    status?: $Enums.Status
    difficulty: $Enums.TrailDifficulty
    length: number
    condition?: $Enums.TrailCondition
    incidentLogs?: IncidentLogCreateNestedManyWithoutTrailInput
    trailChecks?: TrailCheckCreateNestedManyWithoutTrailInput
  }

  export type TrailUncheckedCreateWithoutMountainInput = {
    id?: string
    name: string
    status?: $Enums.Status
    difficulty: $Enums.TrailDifficulty
    length: number
    condition?: $Enums.TrailCondition
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutTrailInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutTrailInput
  }

  export type TrailCreateOrConnectWithoutMountainInput = {
    where: TrailWhereUniqueInput
    create: XOR<TrailCreateWithoutMountainInput, TrailUncheckedCreateWithoutMountainInput>
  }

  export type TrailCreateManyMountainInputEnvelope = {
    data: TrailCreateManyMountainInput | TrailCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type TrailCheckCreateWithoutMountainInput = {
    id?: string
    date?: Date | string
    notes?: string | null
    employee: EmployeeCreateNestedOneWithoutTrailChecksInput
    trail: TrailCreateNestedOneWithoutTrailChecksInput
  }

  export type TrailCheckUncheckedCreateWithoutMountainInput = {
    id?: string
    date?: Date | string
    employeeId: string
    trailId: string
    notes?: string | null
  }

  export type TrailCheckCreateOrConnectWithoutMountainInput = {
    where: TrailCheckWhereUniqueInput
    create: XOR<TrailCheckCreateWithoutMountainInput, TrailCheckUncheckedCreateWithoutMountainInput>
  }

  export type TrailCheckCreateManyMountainInputEnvelope = {
    data: TrailCheckCreateManyMountainInput | TrailCheckCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutMountainInput = {
    id?: string
    name: string
    role: string
    department: $Enums.Department
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutEmployeeInput
    logs?: IncidentLogCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckCreateNestedManyWithoutEmployeeInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutMountainInput = {
    id?: string
    name: string
    role: string
    department: $Enums.Department
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    logs?: IncidentLogUncheckedCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutEmployeeInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutMountainInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutMountainInput, EmployeeUncheckedCreateWithoutMountainInput>
  }

  export type EmployeeCreateManyMountainInputEnvelope = {
    data: EmployeeCreateManyMountainInput | EmployeeCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type LodgeCreateWithoutMountainInput = {
    id?: string
    name: string
    capacity: number
    status?: $Enums.Status
    incidentLogs?: IncidentLogCreateNestedManyWithoutLodgeInput
  }

  export type LodgeUncheckedCreateWithoutMountainInput = {
    id?: string
    name: string
    capacity: number
    status?: $Enums.Status
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutLodgeInput
  }

  export type LodgeCreateOrConnectWithoutMountainInput = {
    where: LodgeWhereUniqueInput
    create: XOR<LodgeCreateWithoutMountainInput, LodgeUncheckedCreateWithoutMountainInput>
  }

  export type LodgeCreateManyMountainInputEnvelope = {
    data: LodgeCreateManyMountainInput | LodgeCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type HutCreateWithoutMountainInput = {
    id?: string
    name: string
    status?: $Enums.Status
    incidentLogs?: IncidentLogCreateNestedManyWithoutHutInput
    hutChecks?: HutCheckCreateNestedManyWithoutHutInput
  }

  export type HutUncheckedCreateWithoutMountainInput = {
    id?: string
    name: string
    status?: $Enums.Status
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutHutInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutHutInput
  }

  export type HutCreateOrConnectWithoutMountainInput = {
    where: HutWhereUniqueInput
    create: XOR<HutCreateWithoutMountainInput, HutUncheckedCreateWithoutMountainInput>
  }

  export type HutCreateManyMountainInputEnvelope = {
    data: HutCreateManyMountainInput | HutCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type HutCheckCreateWithoutMountainInput = {
    id?: string
    date?: Date | string
    notes?: string | null
    employee: EmployeeCreateNestedOneWithoutHutChecksInput
    hut: HutCreateNestedOneWithoutHutChecksInput
  }

  export type HutCheckUncheckedCreateWithoutMountainInput = {
    id?: string
    date?: Date | string
    employeeId: string
    hutId: string
    notes?: string | null
  }

  export type HutCheckCreateOrConnectWithoutMountainInput = {
    where: HutCheckWhereUniqueInput
    create: XOR<HutCheckCreateWithoutMountainInput, HutCheckUncheckedCreateWithoutMountainInput>
  }

  export type HutCheckCreateManyMountainInputEnvelope = {
    data: HutCheckCreateManyMountainInput | HutCheckCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type AidRoomCreateWithoutMountainInput = {
    id?: string
    name: string
    location: string
    status?: $Enums.Status
    incidentLogs?: IncidentLogCreateNestedManyWithoutAidRoomInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutAidRoomInput
  }

  export type AidRoomUncheckedCreateWithoutMountainInput = {
    id?: string
    name: string
    location: string
    status?: $Enums.Status
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutAidRoomInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutAidRoomInput
  }

  export type AidRoomCreateOrConnectWithoutMountainInput = {
    where: AidRoomWhereUniqueInput
    create: XOR<AidRoomCreateWithoutMountainInput, AidRoomUncheckedCreateWithoutMountainInput>
  }

  export type AidRoomCreateManyMountainInputEnvelope = {
    data: AidRoomCreateManyMountainInput | AidRoomCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type AidRoomCheckCreateWithoutMountainInput = {
    id?: string
    date?: Date | string
    notes?: string | null
    employee: EmployeeCreateNestedOneWithoutAidRoomChecksInput
    aidRoom: AidRoomCreateNestedOneWithoutAidRoomChecksInput
  }

  export type AidRoomCheckUncheckedCreateWithoutMountainInput = {
    id?: string
    date?: Date | string
    employeeId: string
    aidRoomId: string
    notes?: string | null
  }

  export type AidRoomCheckCreateOrConnectWithoutMountainInput = {
    where: AidRoomCheckWhereUniqueInput
    create: XOR<AidRoomCheckCreateWithoutMountainInput, AidRoomCheckUncheckedCreateWithoutMountainInput>
  }

  export type AidRoomCheckCreateManyMountainInputEnvelope = {
    data: AidRoomCheckCreateManyMountainInput | AidRoomCheckCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCreateWithoutMountainInput = {
    id?: string
    name: string
    type: string
    status: $Enums.EquipmentStatus
    service: $Enums.EquipmentService
    usedInLogs?: IncidentLogEquipmentCreateNestedManyWithoutEquipmentInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutMountainInput = {
    id?: string
    name: string
    type: string
    status: $Enums.EquipmentStatus
    service: $Enums.EquipmentService
    usedInLogs?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutEquipmentInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutMountainInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutMountainInput, EquipmentUncheckedCreateWithoutMountainInput>
  }

  export type EquipmentCreateManyMountainInputEnvelope = {
    data: EquipmentCreateManyMountainInput | EquipmentCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCheckCreateWithoutMountainInput = {
    id?: string
    date?: Date | string
    notes?: string | null
    employee: EmployeeCreateNestedOneWithoutEquipmentChecksInput
    equipment: EquipmentCreateNestedOneWithoutEquipmentChecksInput
  }

  export type EquipmentCheckUncheckedCreateWithoutMountainInput = {
    id?: string
    date?: Date | string
    employeeId: string
    equipmentId: string
    notes?: string | null
  }

  export type EquipmentCheckCreateOrConnectWithoutMountainInput = {
    where: EquipmentCheckWhereUniqueInput
    create: XOR<EquipmentCheckCreateWithoutMountainInput, EquipmentCheckUncheckedCreateWithoutMountainInput>
  }

  export type EquipmentCheckCreateManyMountainInputEnvelope = {
    data: EquipmentCheckCreateManyMountainInput | EquipmentCheckCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type IncidentCreateWithoutMountainInput = {
    id?: string
    description: string
    status?: $Enums.Status
    logs?: IncidentLogCreateNestedManyWithoutIncidentInput
  }

  export type IncidentUncheckedCreateWithoutMountainInput = {
    id?: string
    description: string
    status?: $Enums.Status
    logs?: IncidentLogUncheckedCreateNestedManyWithoutIncidentInput
  }

  export type IncidentCreateOrConnectWithoutMountainInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutMountainInput, IncidentUncheckedCreateWithoutMountainInput>
  }

  export type IncidentCreateManyMountainInputEnvelope = {
    data: IncidentCreateManyMountainInput | IncidentCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type IncidentLogCreateWithoutMountainInput = {
    id?: string
    locationType: $Enums.LocationType
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
    incident: IncidentCreateNestedOneWithoutLogsInput
    employee: EmployeeCreateNestedOneWithoutLogsInput
    equipmentUsed?: IncidentLogEquipmentCreateNestedManyWithoutIncidentLogInput
    lift?: LiftCreateNestedOneWithoutIncidentLogsInput
    trail?: TrailCreateNestedOneWithoutIncidentLogsInput
    lodge?: LodgeCreateNestedOneWithoutIncidentLogsInput
    hut?: HutCreateNestedOneWithoutIncidentLogsInput
    aidRoom?: AidRoomCreateNestedOneWithoutIncidentLogsInput
  }

  export type IncidentLogUncheckedCreateWithoutMountainInput = {
    id?: string
    incidentId: string
    employeeId: string
    locationType: $Enums.LocationType
    locationId: string
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
    equipmentUsed?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutIncidentLogInput
  }

  export type IncidentLogCreateOrConnectWithoutMountainInput = {
    where: IncidentLogWhereUniqueInput
    create: XOR<IncidentLogCreateWithoutMountainInput, IncidentLogUncheckedCreateWithoutMountainInput>
  }

  export type IncidentLogCreateManyMountainInputEnvelope = {
    data: IncidentLogCreateManyMountainInput | IncidentLogCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type DispatcherAssignmentCreateWithoutMountainInput = {
    id?: string
    assignedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutDispatcherAssignmentsInput
  }

  export type DispatcherAssignmentUncheckedCreateWithoutMountainInput = {
    id?: string
    employeeId: string
    assignedAt?: Date | string
  }

  export type DispatcherAssignmentCreateOrConnectWithoutMountainInput = {
    where: DispatcherAssignmentWhereUniqueInput
    create: XOR<DispatcherAssignmentCreateWithoutMountainInput, DispatcherAssignmentUncheckedCreateWithoutMountainInput>
  }

  export type DispatcherAssignmentCreateManyMountainInputEnvelope = {
    data: DispatcherAssignmentCreateManyMountainInput | DispatcherAssignmentCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type IncidentLogEquipmentCreateWithoutMountainInput = {
    id?: string
    usedAt?: Date | string
    notes?: string | null
    incidentLog: IncidentLogCreateNestedOneWithoutEquipmentUsedInput
    equipment: EquipmentCreateNestedOneWithoutUsedInLogsInput
  }

  export type IncidentLogEquipmentUncheckedCreateWithoutMountainInput = {
    id?: string
    incidentLogId: string
    equipmentId: string
    usedAt?: Date | string
    notes?: string | null
  }

  export type IncidentLogEquipmentCreateOrConnectWithoutMountainInput = {
    where: IncidentLogEquipmentWhereUniqueInput
    create: XOR<IncidentLogEquipmentCreateWithoutMountainInput, IncidentLogEquipmentUncheckedCreateWithoutMountainInput>
  }

  export type IncidentLogEquipmentCreateManyMountainInputEnvelope = {
    data: IncidentLogEquipmentCreateManyMountainInput | IncidentLogEquipmentCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type WeatherCreateWithoutMountainInput = {
    id?: string
    date?: Date | string
    temperature: number
    windSpeed: number
    windDirection?: string | null
    visibility?: number | null
    conditions: string
    snowfall24h?: number | null
    snowfall7d?: number | null
    updatedAt?: Date | string
  }

  export type WeatherUncheckedCreateWithoutMountainInput = {
    id?: string
    date?: Date | string
    temperature: number
    windSpeed: number
    windDirection?: string | null
    visibility?: number | null
    conditions: string
    snowfall24h?: number | null
    snowfall7d?: number | null
    updatedAt?: Date | string
  }

  export type WeatherCreateOrConnectWithoutMountainInput = {
    where: WeatherWhereUniqueInput
    create: XOR<WeatherCreateWithoutMountainInput, WeatherUncheckedCreateWithoutMountainInput>
  }

  export type WeatherCreateManyMountainInputEnvelope = {
    data: WeatherCreateManyMountainInput | WeatherCreateManyMountainInput[]
    skipDuplicates?: boolean
  }

  export type LiftUpsertWithWhereUniqueWithoutMountainInput = {
    where: LiftWhereUniqueInput
    update: XOR<LiftUpdateWithoutMountainInput, LiftUncheckedUpdateWithoutMountainInput>
    create: XOR<LiftCreateWithoutMountainInput, LiftUncheckedCreateWithoutMountainInput>
  }

  export type LiftUpdateWithWhereUniqueWithoutMountainInput = {
    where: LiftWhereUniqueInput
    data: XOR<LiftUpdateWithoutMountainInput, LiftUncheckedUpdateWithoutMountainInput>
  }

  export type LiftUpdateManyWithWhereWithoutMountainInput = {
    where: LiftScalarWhereInput
    data: XOR<LiftUpdateManyMutationInput, LiftUncheckedUpdateManyWithoutMountainInput>
  }

  export type LiftScalarWhereInput = {
    AND?: LiftScalarWhereInput | LiftScalarWhereInput[]
    OR?: LiftScalarWhereInput[]
    NOT?: LiftScalarWhereInput | LiftScalarWhereInput[]
    id?: StringFilter<"Lift"> | string
    name?: StringFilter<"Lift"> | string
    capacity?: IntFilter<"Lift"> | number
    status?: EnumStatusFilter<"Lift"> | $Enums.Status
    mountainId?: StringFilter<"Lift"> | string
  }

  export type LiftCheckUpsertWithWhereUniqueWithoutMountainInput = {
    where: LiftCheckWhereUniqueInput
    update: XOR<LiftCheckUpdateWithoutMountainInput, LiftCheckUncheckedUpdateWithoutMountainInput>
    create: XOR<LiftCheckCreateWithoutMountainInput, LiftCheckUncheckedCreateWithoutMountainInput>
  }

  export type LiftCheckUpdateWithWhereUniqueWithoutMountainInput = {
    where: LiftCheckWhereUniqueInput
    data: XOR<LiftCheckUpdateWithoutMountainInput, LiftCheckUncheckedUpdateWithoutMountainInput>
  }

  export type LiftCheckUpdateManyWithWhereWithoutMountainInput = {
    where: LiftCheckScalarWhereInput
    data: XOR<LiftCheckUpdateManyMutationInput, LiftCheckUncheckedUpdateManyWithoutMountainInput>
  }

  export type LiftCheckScalarWhereInput = {
    AND?: LiftCheckScalarWhereInput | LiftCheckScalarWhereInput[]
    OR?: LiftCheckScalarWhereInput[]
    NOT?: LiftCheckScalarWhereInput | LiftCheckScalarWhereInput[]
    id?: StringFilter<"LiftCheck"> | string
    date?: DateTimeFilter<"LiftCheck"> | Date | string
    employeeId?: StringFilter<"LiftCheck"> | string
    mountainId?: StringFilter<"LiftCheck"> | string
    liftId?: StringFilter<"LiftCheck"> | string
    notes?: StringNullableFilter<"LiftCheck"> | string | null
  }

  export type TrailUpsertWithWhereUniqueWithoutMountainInput = {
    where: TrailWhereUniqueInput
    update: XOR<TrailUpdateWithoutMountainInput, TrailUncheckedUpdateWithoutMountainInput>
    create: XOR<TrailCreateWithoutMountainInput, TrailUncheckedCreateWithoutMountainInput>
  }

  export type TrailUpdateWithWhereUniqueWithoutMountainInput = {
    where: TrailWhereUniqueInput
    data: XOR<TrailUpdateWithoutMountainInput, TrailUncheckedUpdateWithoutMountainInput>
  }

  export type TrailUpdateManyWithWhereWithoutMountainInput = {
    where: TrailScalarWhereInput
    data: XOR<TrailUpdateManyMutationInput, TrailUncheckedUpdateManyWithoutMountainInput>
  }

  export type TrailScalarWhereInput = {
    AND?: TrailScalarWhereInput | TrailScalarWhereInput[]
    OR?: TrailScalarWhereInput[]
    NOT?: TrailScalarWhereInput | TrailScalarWhereInput[]
    id?: StringFilter<"Trail"> | string
    name?: StringFilter<"Trail"> | string
    status?: EnumStatusFilter<"Trail"> | $Enums.Status
    difficulty?: EnumTrailDifficultyFilter<"Trail"> | $Enums.TrailDifficulty
    length?: FloatFilter<"Trail"> | number
    condition?: EnumTrailConditionFilter<"Trail"> | $Enums.TrailCondition
    mountainId?: StringFilter<"Trail"> | string
  }

  export type TrailCheckUpsertWithWhereUniqueWithoutMountainInput = {
    where: TrailCheckWhereUniqueInput
    update: XOR<TrailCheckUpdateWithoutMountainInput, TrailCheckUncheckedUpdateWithoutMountainInput>
    create: XOR<TrailCheckCreateWithoutMountainInput, TrailCheckUncheckedCreateWithoutMountainInput>
  }

  export type TrailCheckUpdateWithWhereUniqueWithoutMountainInput = {
    where: TrailCheckWhereUniqueInput
    data: XOR<TrailCheckUpdateWithoutMountainInput, TrailCheckUncheckedUpdateWithoutMountainInput>
  }

  export type TrailCheckUpdateManyWithWhereWithoutMountainInput = {
    where: TrailCheckScalarWhereInput
    data: XOR<TrailCheckUpdateManyMutationInput, TrailCheckUncheckedUpdateManyWithoutMountainInput>
  }

  export type TrailCheckScalarWhereInput = {
    AND?: TrailCheckScalarWhereInput | TrailCheckScalarWhereInput[]
    OR?: TrailCheckScalarWhereInput[]
    NOT?: TrailCheckScalarWhereInput | TrailCheckScalarWhereInput[]
    id?: StringFilter<"TrailCheck"> | string
    date?: DateTimeFilter<"TrailCheck"> | Date | string
    employeeId?: StringFilter<"TrailCheck"> | string
    mountainId?: StringFilter<"TrailCheck"> | string
    trailId?: StringFilter<"TrailCheck"> | string
    notes?: StringNullableFilter<"TrailCheck"> | string | null
  }

  export type EmployeeUpsertWithWhereUniqueWithoutMountainInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutMountainInput, EmployeeUncheckedUpdateWithoutMountainInput>
    create: XOR<EmployeeCreateWithoutMountainInput, EmployeeUncheckedCreateWithoutMountainInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutMountainInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutMountainInput, EmployeeUncheckedUpdateWithoutMountainInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutMountainInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutMountainInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: StringFilter<"Employee"> | string
    name?: StringFilter<"Employee"> | string
    role?: StringFilter<"Employee"> | string
    department?: EnumDepartmentFilter<"Employee"> | $Enums.Department
    mountainId?: StringFilter<"Employee"> | string
  }

  export type LodgeUpsertWithWhereUniqueWithoutMountainInput = {
    where: LodgeWhereUniqueInput
    update: XOR<LodgeUpdateWithoutMountainInput, LodgeUncheckedUpdateWithoutMountainInput>
    create: XOR<LodgeCreateWithoutMountainInput, LodgeUncheckedCreateWithoutMountainInput>
  }

  export type LodgeUpdateWithWhereUniqueWithoutMountainInput = {
    where: LodgeWhereUniqueInput
    data: XOR<LodgeUpdateWithoutMountainInput, LodgeUncheckedUpdateWithoutMountainInput>
  }

  export type LodgeUpdateManyWithWhereWithoutMountainInput = {
    where: LodgeScalarWhereInput
    data: XOR<LodgeUpdateManyMutationInput, LodgeUncheckedUpdateManyWithoutMountainInput>
  }

  export type LodgeScalarWhereInput = {
    AND?: LodgeScalarWhereInput | LodgeScalarWhereInput[]
    OR?: LodgeScalarWhereInput[]
    NOT?: LodgeScalarWhereInput | LodgeScalarWhereInput[]
    id?: StringFilter<"Lodge"> | string
    name?: StringFilter<"Lodge"> | string
    capacity?: IntFilter<"Lodge"> | number
    status?: EnumStatusFilter<"Lodge"> | $Enums.Status
    mountainId?: StringFilter<"Lodge"> | string
  }

  export type HutUpsertWithWhereUniqueWithoutMountainInput = {
    where: HutWhereUniqueInput
    update: XOR<HutUpdateWithoutMountainInput, HutUncheckedUpdateWithoutMountainInput>
    create: XOR<HutCreateWithoutMountainInput, HutUncheckedCreateWithoutMountainInput>
  }

  export type HutUpdateWithWhereUniqueWithoutMountainInput = {
    where: HutWhereUniqueInput
    data: XOR<HutUpdateWithoutMountainInput, HutUncheckedUpdateWithoutMountainInput>
  }

  export type HutUpdateManyWithWhereWithoutMountainInput = {
    where: HutScalarWhereInput
    data: XOR<HutUpdateManyMutationInput, HutUncheckedUpdateManyWithoutMountainInput>
  }

  export type HutScalarWhereInput = {
    AND?: HutScalarWhereInput | HutScalarWhereInput[]
    OR?: HutScalarWhereInput[]
    NOT?: HutScalarWhereInput | HutScalarWhereInput[]
    id?: StringFilter<"Hut"> | string
    name?: StringFilter<"Hut"> | string
    status?: EnumStatusFilter<"Hut"> | $Enums.Status
    mountainId?: StringFilter<"Hut"> | string
  }

  export type HutCheckUpsertWithWhereUniqueWithoutMountainInput = {
    where: HutCheckWhereUniqueInput
    update: XOR<HutCheckUpdateWithoutMountainInput, HutCheckUncheckedUpdateWithoutMountainInput>
    create: XOR<HutCheckCreateWithoutMountainInput, HutCheckUncheckedCreateWithoutMountainInput>
  }

  export type HutCheckUpdateWithWhereUniqueWithoutMountainInput = {
    where: HutCheckWhereUniqueInput
    data: XOR<HutCheckUpdateWithoutMountainInput, HutCheckUncheckedUpdateWithoutMountainInput>
  }

  export type HutCheckUpdateManyWithWhereWithoutMountainInput = {
    where: HutCheckScalarWhereInput
    data: XOR<HutCheckUpdateManyMutationInput, HutCheckUncheckedUpdateManyWithoutMountainInput>
  }

  export type HutCheckScalarWhereInput = {
    AND?: HutCheckScalarWhereInput | HutCheckScalarWhereInput[]
    OR?: HutCheckScalarWhereInput[]
    NOT?: HutCheckScalarWhereInput | HutCheckScalarWhereInput[]
    id?: StringFilter<"HutCheck"> | string
    date?: DateTimeFilter<"HutCheck"> | Date | string
    employeeId?: StringFilter<"HutCheck"> | string
    mountainId?: StringFilter<"HutCheck"> | string
    hutId?: StringFilter<"HutCheck"> | string
    notes?: StringNullableFilter<"HutCheck"> | string | null
  }

  export type AidRoomUpsertWithWhereUniqueWithoutMountainInput = {
    where: AidRoomWhereUniqueInput
    update: XOR<AidRoomUpdateWithoutMountainInput, AidRoomUncheckedUpdateWithoutMountainInput>
    create: XOR<AidRoomCreateWithoutMountainInput, AidRoomUncheckedCreateWithoutMountainInput>
  }

  export type AidRoomUpdateWithWhereUniqueWithoutMountainInput = {
    where: AidRoomWhereUniqueInput
    data: XOR<AidRoomUpdateWithoutMountainInput, AidRoomUncheckedUpdateWithoutMountainInput>
  }

  export type AidRoomUpdateManyWithWhereWithoutMountainInput = {
    where: AidRoomScalarWhereInput
    data: XOR<AidRoomUpdateManyMutationInput, AidRoomUncheckedUpdateManyWithoutMountainInput>
  }

  export type AidRoomScalarWhereInput = {
    AND?: AidRoomScalarWhereInput | AidRoomScalarWhereInput[]
    OR?: AidRoomScalarWhereInput[]
    NOT?: AidRoomScalarWhereInput | AidRoomScalarWhereInput[]
    id?: StringFilter<"AidRoom"> | string
    name?: StringFilter<"AidRoom"> | string
    location?: StringFilter<"AidRoom"> | string
    status?: EnumStatusFilter<"AidRoom"> | $Enums.Status
    mountainId?: StringFilter<"AidRoom"> | string
  }

  export type AidRoomCheckUpsertWithWhereUniqueWithoutMountainInput = {
    where: AidRoomCheckWhereUniqueInput
    update: XOR<AidRoomCheckUpdateWithoutMountainInput, AidRoomCheckUncheckedUpdateWithoutMountainInput>
    create: XOR<AidRoomCheckCreateWithoutMountainInput, AidRoomCheckUncheckedCreateWithoutMountainInput>
  }

  export type AidRoomCheckUpdateWithWhereUniqueWithoutMountainInput = {
    where: AidRoomCheckWhereUniqueInput
    data: XOR<AidRoomCheckUpdateWithoutMountainInput, AidRoomCheckUncheckedUpdateWithoutMountainInput>
  }

  export type AidRoomCheckUpdateManyWithWhereWithoutMountainInput = {
    where: AidRoomCheckScalarWhereInput
    data: XOR<AidRoomCheckUpdateManyMutationInput, AidRoomCheckUncheckedUpdateManyWithoutMountainInput>
  }

  export type AidRoomCheckScalarWhereInput = {
    AND?: AidRoomCheckScalarWhereInput | AidRoomCheckScalarWhereInput[]
    OR?: AidRoomCheckScalarWhereInput[]
    NOT?: AidRoomCheckScalarWhereInput | AidRoomCheckScalarWhereInput[]
    id?: StringFilter<"AidRoomCheck"> | string
    date?: DateTimeFilter<"AidRoomCheck"> | Date | string
    employeeId?: StringFilter<"AidRoomCheck"> | string
    mountainId?: StringFilter<"AidRoomCheck"> | string
    aidRoomId?: StringFilter<"AidRoomCheck"> | string
    notes?: StringNullableFilter<"AidRoomCheck"> | string | null
  }

  export type EquipmentUpsertWithWhereUniqueWithoutMountainInput = {
    where: EquipmentWhereUniqueInput
    update: XOR<EquipmentUpdateWithoutMountainInput, EquipmentUncheckedUpdateWithoutMountainInput>
    create: XOR<EquipmentCreateWithoutMountainInput, EquipmentUncheckedCreateWithoutMountainInput>
  }

  export type EquipmentUpdateWithWhereUniqueWithoutMountainInput = {
    where: EquipmentWhereUniqueInput
    data: XOR<EquipmentUpdateWithoutMountainInput, EquipmentUncheckedUpdateWithoutMountainInput>
  }

  export type EquipmentUpdateManyWithWhereWithoutMountainInput = {
    where: EquipmentScalarWhereInput
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyWithoutMountainInput>
  }

  export type EquipmentScalarWhereInput = {
    AND?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
    OR?: EquipmentScalarWhereInput[]
    NOT?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
    id?: StringFilter<"Equipment"> | string
    name?: StringFilter<"Equipment"> | string
    type?: StringFilter<"Equipment"> | string
    status?: EnumEquipmentStatusFilter<"Equipment"> | $Enums.EquipmentStatus
    service?: EnumEquipmentServiceFilter<"Equipment"> | $Enums.EquipmentService
    mountainId?: StringFilter<"Equipment"> | string
  }

  export type EquipmentCheckUpsertWithWhereUniqueWithoutMountainInput = {
    where: EquipmentCheckWhereUniqueInput
    update: XOR<EquipmentCheckUpdateWithoutMountainInput, EquipmentCheckUncheckedUpdateWithoutMountainInput>
    create: XOR<EquipmentCheckCreateWithoutMountainInput, EquipmentCheckUncheckedCreateWithoutMountainInput>
  }

  export type EquipmentCheckUpdateWithWhereUniqueWithoutMountainInput = {
    where: EquipmentCheckWhereUniqueInput
    data: XOR<EquipmentCheckUpdateWithoutMountainInput, EquipmentCheckUncheckedUpdateWithoutMountainInput>
  }

  export type EquipmentCheckUpdateManyWithWhereWithoutMountainInput = {
    where: EquipmentCheckScalarWhereInput
    data: XOR<EquipmentCheckUpdateManyMutationInput, EquipmentCheckUncheckedUpdateManyWithoutMountainInput>
  }

  export type EquipmentCheckScalarWhereInput = {
    AND?: EquipmentCheckScalarWhereInput | EquipmentCheckScalarWhereInput[]
    OR?: EquipmentCheckScalarWhereInput[]
    NOT?: EquipmentCheckScalarWhereInput | EquipmentCheckScalarWhereInput[]
    id?: StringFilter<"EquipmentCheck"> | string
    date?: DateTimeFilter<"EquipmentCheck"> | Date | string
    employeeId?: StringFilter<"EquipmentCheck"> | string
    mountainId?: StringFilter<"EquipmentCheck"> | string
    equipmentId?: StringFilter<"EquipmentCheck"> | string
    notes?: StringNullableFilter<"EquipmentCheck"> | string | null
  }

  export type IncidentUpsertWithWhereUniqueWithoutMountainInput = {
    where: IncidentWhereUniqueInput
    update: XOR<IncidentUpdateWithoutMountainInput, IncidentUncheckedUpdateWithoutMountainInput>
    create: XOR<IncidentCreateWithoutMountainInput, IncidentUncheckedCreateWithoutMountainInput>
  }

  export type IncidentUpdateWithWhereUniqueWithoutMountainInput = {
    where: IncidentWhereUniqueInput
    data: XOR<IncidentUpdateWithoutMountainInput, IncidentUncheckedUpdateWithoutMountainInput>
  }

  export type IncidentUpdateManyWithWhereWithoutMountainInput = {
    where: IncidentScalarWhereInput
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyWithoutMountainInput>
  }

  export type IncidentScalarWhereInput = {
    AND?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
    OR?: IncidentScalarWhereInput[]
    NOT?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
    id?: StringFilter<"Incident"> | string
    description?: StringFilter<"Incident"> | string
    status?: EnumStatusFilter<"Incident"> | $Enums.Status
    mountainId?: StringFilter<"Incident"> | string
  }

  export type IncidentLogUpsertWithWhereUniqueWithoutMountainInput = {
    where: IncidentLogWhereUniqueInput
    update: XOR<IncidentLogUpdateWithoutMountainInput, IncidentLogUncheckedUpdateWithoutMountainInput>
    create: XOR<IncidentLogCreateWithoutMountainInput, IncidentLogUncheckedCreateWithoutMountainInput>
  }

  export type IncidentLogUpdateWithWhereUniqueWithoutMountainInput = {
    where: IncidentLogWhereUniqueInput
    data: XOR<IncidentLogUpdateWithoutMountainInput, IncidentLogUncheckedUpdateWithoutMountainInput>
  }

  export type IncidentLogUpdateManyWithWhereWithoutMountainInput = {
    where: IncidentLogScalarWhereInput
    data: XOR<IncidentLogUpdateManyMutationInput, IncidentLogUncheckedUpdateManyWithoutMountainInput>
  }

  export type IncidentLogScalarWhereInput = {
    AND?: IncidentLogScalarWhereInput | IncidentLogScalarWhereInput[]
    OR?: IncidentLogScalarWhereInput[]
    NOT?: IncidentLogScalarWhereInput | IncidentLogScalarWhereInput[]
    id?: StringFilter<"IncidentLog"> | string
    incidentId?: StringFilter<"IncidentLog"> | string
    employeeId?: StringFilter<"IncidentLog"> | string
    mountainId?: StringFilter<"IncidentLog"> | string
    locationType?: EnumLocationTypeFilter<"IncidentLog"> | $Enums.LocationType
    locationId?: StringFilter<"IncidentLog"> | string
    locationStatus?: StringFilter<"IncidentLog"> | string
    startTime?: DateTimeFilter<"IncidentLog"> | Date | string
    endTime?: DateTimeFilter<"IncidentLog"> | Date | string
    onSceneTime?: DateTimeNullableFilter<"IncidentLog"> | Date | string | null
    stableTime?: DateTimeNullableFilter<"IncidentLog"> | Date | string | null
    transportTime?: DateTimeNullableFilter<"IncidentLog"> | Date | string | null
    dryRun?: BoolFilter<"IncidentLog"> | boolean
    dryRunTime?: DateTimeNullableFilter<"IncidentLog"> | Date | string | null
  }

  export type DispatcherAssignmentUpsertWithWhereUniqueWithoutMountainInput = {
    where: DispatcherAssignmentWhereUniqueInput
    update: XOR<DispatcherAssignmentUpdateWithoutMountainInput, DispatcherAssignmentUncheckedUpdateWithoutMountainInput>
    create: XOR<DispatcherAssignmentCreateWithoutMountainInput, DispatcherAssignmentUncheckedCreateWithoutMountainInput>
  }

  export type DispatcherAssignmentUpdateWithWhereUniqueWithoutMountainInput = {
    where: DispatcherAssignmentWhereUniqueInput
    data: XOR<DispatcherAssignmentUpdateWithoutMountainInput, DispatcherAssignmentUncheckedUpdateWithoutMountainInput>
  }

  export type DispatcherAssignmentUpdateManyWithWhereWithoutMountainInput = {
    where: DispatcherAssignmentScalarWhereInput
    data: XOR<DispatcherAssignmentUpdateManyMutationInput, DispatcherAssignmentUncheckedUpdateManyWithoutMountainInput>
  }

  export type DispatcherAssignmentScalarWhereInput = {
    AND?: DispatcherAssignmentScalarWhereInput | DispatcherAssignmentScalarWhereInput[]
    OR?: DispatcherAssignmentScalarWhereInput[]
    NOT?: DispatcherAssignmentScalarWhereInput | DispatcherAssignmentScalarWhereInput[]
    id?: StringFilter<"DispatcherAssignment"> | string
    employeeId?: StringFilter<"DispatcherAssignment"> | string
    assignedAt?: DateTimeFilter<"DispatcherAssignment"> | Date | string
    mountainId?: StringFilter<"DispatcherAssignment"> | string
  }

  export type IncidentLogEquipmentUpsertWithWhereUniqueWithoutMountainInput = {
    where: IncidentLogEquipmentWhereUniqueInput
    update: XOR<IncidentLogEquipmentUpdateWithoutMountainInput, IncidentLogEquipmentUncheckedUpdateWithoutMountainInput>
    create: XOR<IncidentLogEquipmentCreateWithoutMountainInput, IncidentLogEquipmentUncheckedCreateWithoutMountainInput>
  }

  export type IncidentLogEquipmentUpdateWithWhereUniqueWithoutMountainInput = {
    where: IncidentLogEquipmentWhereUniqueInput
    data: XOR<IncidentLogEquipmentUpdateWithoutMountainInput, IncidentLogEquipmentUncheckedUpdateWithoutMountainInput>
  }

  export type IncidentLogEquipmentUpdateManyWithWhereWithoutMountainInput = {
    where: IncidentLogEquipmentScalarWhereInput
    data: XOR<IncidentLogEquipmentUpdateManyMutationInput, IncidentLogEquipmentUncheckedUpdateManyWithoutMountainInput>
  }

  export type IncidentLogEquipmentScalarWhereInput = {
    AND?: IncidentLogEquipmentScalarWhereInput | IncidentLogEquipmentScalarWhereInput[]
    OR?: IncidentLogEquipmentScalarWhereInput[]
    NOT?: IncidentLogEquipmentScalarWhereInput | IncidentLogEquipmentScalarWhereInput[]
    id?: StringFilter<"IncidentLogEquipment"> | string
    incidentLogId?: StringFilter<"IncidentLogEquipment"> | string
    equipmentId?: StringFilter<"IncidentLogEquipment"> | string
    mountainId?: StringFilter<"IncidentLogEquipment"> | string
    usedAt?: DateTimeFilter<"IncidentLogEquipment"> | Date | string
    notes?: StringNullableFilter<"IncidentLogEquipment"> | string | null
  }

  export type WeatherUpsertWithWhereUniqueWithoutMountainInput = {
    where: WeatherWhereUniqueInput
    update: XOR<WeatherUpdateWithoutMountainInput, WeatherUncheckedUpdateWithoutMountainInput>
    create: XOR<WeatherCreateWithoutMountainInput, WeatherUncheckedCreateWithoutMountainInput>
  }

  export type WeatherUpdateWithWhereUniqueWithoutMountainInput = {
    where: WeatherWhereUniqueInput
    data: XOR<WeatherUpdateWithoutMountainInput, WeatherUncheckedUpdateWithoutMountainInput>
  }

  export type WeatherUpdateManyWithWhereWithoutMountainInput = {
    where: WeatherScalarWhereInput
    data: XOR<WeatherUpdateManyMutationInput, WeatherUncheckedUpdateManyWithoutMountainInput>
  }

  export type WeatherScalarWhereInput = {
    AND?: WeatherScalarWhereInput | WeatherScalarWhereInput[]
    OR?: WeatherScalarWhereInput[]
    NOT?: WeatherScalarWhereInput | WeatherScalarWhereInput[]
    id?: StringFilter<"Weather"> | string
    mountainId?: StringFilter<"Weather"> | string
    date?: DateTimeFilter<"Weather"> | Date | string
    temperature?: FloatFilter<"Weather"> | number
    windSpeed?: FloatFilter<"Weather"> | number
    windDirection?: StringNullableFilter<"Weather"> | string | null
    visibility?: FloatNullableFilter<"Weather"> | number | null
    conditions?: StringFilter<"Weather"> | string
    snowfall24h?: FloatNullableFilter<"Weather"> | number | null
    snowfall7d?: FloatNullableFilter<"Weather"> | number | null
    updatedAt?: DateTimeFilter<"Weather"> | Date | string
  }

  export type MountainCreateWithoutWeatherInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    employees?: EmployeeCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutWeatherInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutWeatherInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutWeatherInput, MountainUncheckedCreateWithoutWeatherInput>
  }

  export type MountainUpsertWithoutWeatherInput = {
    update: XOR<MountainUpdateWithoutWeatherInput, MountainUncheckedUpdateWithoutWeatherInput>
    create: XOR<MountainCreateWithoutWeatherInput, MountainUncheckedCreateWithoutWeatherInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutWeatherInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutWeatherInput, MountainUncheckedUpdateWithoutWeatherInput>
  }

  export type MountainUpdateWithoutWeatherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutWeatherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type MountainCreateWithoutEmployeesInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentCreateNestedManyWithoutMountainInput
    weather?: WeatherCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutEmployeesInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutMountainInput
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutEmployeesInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutEmployeesInput, MountainUncheckedCreateWithoutEmployeesInput>
  }

  export type DispatcherAssignmentCreateWithoutEmployeeInput = {
    id?: string
    assignedAt?: Date | string
    mountain: MountainCreateNestedOneWithoutDispatcherAssignmentsInput
  }

  export type DispatcherAssignmentUncheckedCreateWithoutEmployeeInput = {
    id?: string
    assignedAt?: Date | string
    mountainId: string
  }

  export type DispatcherAssignmentCreateOrConnectWithoutEmployeeInput = {
    where: DispatcherAssignmentWhereUniqueInput
    create: XOR<DispatcherAssignmentCreateWithoutEmployeeInput, DispatcherAssignmentUncheckedCreateWithoutEmployeeInput>
  }

  export type DispatcherAssignmentCreateManyEmployeeInputEnvelope = {
    data: DispatcherAssignmentCreateManyEmployeeInput | DispatcherAssignmentCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type IncidentLogCreateWithoutEmployeeInput = {
    id?: string
    locationType: $Enums.LocationType
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
    incident: IncidentCreateNestedOneWithoutLogsInput
    mountain: MountainCreateNestedOneWithoutIncidentLogsInput
    equipmentUsed?: IncidentLogEquipmentCreateNestedManyWithoutIncidentLogInput
    lift?: LiftCreateNestedOneWithoutIncidentLogsInput
    trail?: TrailCreateNestedOneWithoutIncidentLogsInput
    lodge?: LodgeCreateNestedOneWithoutIncidentLogsInput
    hut?: HutCreateNestedOneWithoutIncidentLogsInput
    aidRoom?: AidRoomCreateNestedOneWithoutIncidentLogsInput
  }

  export type IncidentLogUncheckedCreateWithoutEmployeeInput = {
    id?: string
    incidentId: string
    mountainId: string
    locationType: $Enums.LocationType
    locationId: string
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
    equipmentUsed?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutIncidentLogInput
  }

  export type IncidentLogCreateOrConnectWithoutEmployeeInput = {
    where: IncidentLogWhereUniqueInput
    create: XOR<IncidentLogCreateWithoutEmployeeInput, IncidentLogUncheckedCreateWithoutEmployeeInput>
  }

  export type IncidentLogCreateManyEmployeeInputEnvelope = {
    data: IncidentLogCreateManyEmployeeInput | IncidentLogCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type LiftCheckCreateWithoutEmployeeInput = {
    id?: string
    date?: Date | string
    notes?: string | null
    mountain: MountainCreateNestedOneWithoutLiftChecksInput
    lift: LiftCreateNestedOneWithoutLiftChecksInput
  }

  export type LiftCheckUncheckedCreateWithoutEmployeeInput = {
    id?: string
    date?: Date | string
    mountainId: string
    liftId: string
    notes?: string | null
  }

  export type LiftCheckCreateOrConnectWithoutEmployeeInput = {
    where: LiftCheckWhereUniqueInput
    create: XOR<LiftCheckCreateWithoutEmployeeInput, LiftCheckUncheckedCreateWithoutEmployeeInput>
  }

  export type LiftCheckCreateManyEmployeeInputEnvelope = {
    data: LiftCheckCreateManyEmployeeInput | LiftCheckCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type TrailCheckCreateWithoutEmployeeInput = {
    id?: string
    date?: Date | string
    notes?: string | null
    mountain: MountainCreateNestedOneWithoutTrailChecksInput
    trail: TrailCreateNestedOneWithoutTrailChecksInput
  }

  export type TrailCheckUncheckedCreateWithoutEmployeeInput = {
    id?: string
    date?: Date | string
    mountainId: string
    trailId: string
    notes?: string | null
  }

  export type TrailCheckCreateOrConnectWithoutEmployeeInput = {
    where: TrailCheckWhereUniqueInput
    create: XOR<TrailCheckCreateWithoutEmployeeInput, TrailCheckUncheckedCreateWithoutEmployeeInput>
  }

  export type TrailCheckCreateManyEmployeeInputEnvelope = {
    data: TrailCheckCreateManyEmployeeInput | TrailCheckCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type HutCheckCreateWithoutEmployeeInput = {
    id?: string
    date?: Date | string
    notes?: string | null
    mountain: MountainCreateNestedOneWithoutHutChecksInput
    hut: HutCreateNestedOneWithoutHutChecksInput
  }

  export type HutCheckUncheckedCreateWithoutEmployeeInput = {
    id?: string
    date?: Date | string
    mountainId: string
    hutId: string
    notes?: string | null
  }

  export type HutCheckCreateOrConnectWithoutEmployeeInput = {
    where: HutCheckWhereUniqueInput
    create: XOR<HutCheckCreateWithoutEmployeeInput, HutCheckUncheckedCreateWithoutEmployeeInput>
  }

  export type HutCheckCreateManyEmployeeInputEnvelope = {
    data: HutCheckCreateManyEmployeeInput | HutCheckCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type AidRoomCheckCreateWithoutEmployeeInput = {
    id?: string
    date?: Date | string
    notes?: string | null
    mountain: MountainCreateNestedOneWithoutAidRoomChecksInput
    aidRoom: AidRoomCreateNestedOneWithoutAidRoomChecksInput
  }

  export type AidRoomCheckUncheckedCreateWithoutEmployeeInput = {
    id?: string
    date?: Date | string
    mountainId: string
    aidRoomId: string
    notes?: string | null
  }

  export type AidRoomCheckCreateOrConnectWithoutEmployeeInput = {
    where: AidRoomCheckWhereUniqueInput
    create: XOR<AidRoomCheckCreateWithoutEmployeeInput, AidRoomCheckUncheckedCreateWithoutEmployeeInput>
  }

  export type AidRoomCheckCreateManyEmployeeInputEnvelope = {
    data: AidRoomCheckCreateManyEmployeeInput | AidRoomCheckCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCheckCreateWithoutEmployeeInput = {
    id?: string
    date?: Date | string
    notes?: string | null
    mountain: MountainCreateNestedOneWithoutEquipmentChecksInput
    equipment: EquipmentCreateNestedOneWithoutEquipmentChecksInput
  }

  export type EquipmentCheckUncheckedCreateWithoutEmployeeInput = {
    id?: string
    date?: Date | string
    mountainId: string
    equipmentId: string
    notes?: string | null
  }

  export type EquipmentCheckCreateOrConnectWithoutEmployeeInput = {
    where: EquipmentCheckWhereUniqueInput
    create: XOR<EquipmentCheckCreateWithoutEmployeeInput, EquipmentCheckUncheckedCreateWithoutEmployeeInput>
  }

  export type EquipmentCheckCreateManyEmployeeInputEnvelope = {
    data: EquipmentCheckCreateManyEmployeeInput | EquipmentCheckCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type MountainUpsertWithoutEmployeesInput = {
    update: XOR<MountainUpdateWithoutEmployeesInput, MountainUncheckedUpdateWithoutEmployeesInput>
    create: XOR<MountainCreateWithoutEmployeesInput, MountainUncheckedCreateWithoutEmployeesInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutEmployeesInput, MountainUncheckedUpdateWithoutEmployeesInput>
  }

  export type MountainUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUpdateManyWithoutMountainNestedInput
    weather?: WeatherUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedUpdateManyWithoutMountainNestedInput
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type DispatcherAssignmentUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: DispatcherAssignmentWhereUniqueInput
    update: XOR<DispatcherAssignmentUpdateWithoutEmployeeInput, DispatcherAssignmentUncheckedUpdateWithoutEmployeeInput>
    create: XOR<DispatcherAssignmentCreateWithoutEmployeeInput, DispatcherAssignmentUncheckedCreateWithoutEmployeeInput>
  }

  export type DispatcherAssignmentUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: DispatcherAssignmentWhereUniqueInput
    data: XOR<DispatcherAssignmentUpdateWithoutEmployeeInput, DispatcherAssignmentUncheckedUpdateWithoutEmployeeInput>
  }

  export type DispatcherAssignmentUpdateManyWithWhereWithoutEmployeeInput = {
    where: DispatcherAssignmentScalarWhereInput
    data: XOR<DispatcherAssignmentUpdateManyMutationInput, DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type IncidentLogUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: IncidentLogWhereUniqueInput
    update: XOR<IncidentLogUpdateWithoutEmployeeInput, IncidentLogUncheckedUpdateWithoutEmployeeInput>
    create: XOR<IncidentLogCreateWithoutEmployeeInput, IncidentLogUncheckedCreateWithoutEmployeeInput>
  }

  export type IncidentLogUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: IncidentLogWhereUniqueInput
    data: XOR<IncidentLogUpdateWithoutEmployeeInput, IncidentLogUncheckedUpdateWithoutEmployeeInput>
  }

  export type IncidentLogUpdateManyWithWhereWithoutEmployeeInput = {
    where: IncidentLogScalarWhereInput
    data: XOR<IncidentLogUpdateManyMutationInput, IncidentLogUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type LiftCheckUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: LiftCheckWhereUniqueInput
    update: XOR<LiftCheckUpdateWithoutEmployeeInput, LiftCheckUncheckedUpdateWithoutEmployeeInput>
    create: XOR<LiftCheckCreateWithoutEmployeeInput, LiftCheckUncheckedCreateWithoutEmployeeInput>
  }

  export type LiftCheckUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: LiftCheckWhereUniqueInput
    data: XOR<LiftCheckUpdateWithoutEmployeeInput, LiftCheckUncheckedUpdateWithoutEmployeeInput>
  }

  export type LiftCheckUpdateManyWithWhereWithoutEmployeeInput = {
    where: LiftCheckScalarWhereInput
    data: XOR<LiftCheckUpdateManyMutationInput, LiftCheckUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type TrailCheckUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: TrailCheckWhereUniqueInput
    update: XOR<TrailCheckUpdateWithoutEmployeeInput, TrailCheckUncheckedUpdateWithoutEmployeeInput>
    create: XOR<TrailCheckCreateWithoutEmployeeInput, TrailCheckUncheckedCreateWithoutEmployeeInput>
  }

  export type TrailCheckUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: TrailCheckWhereUniqueInput
    data: XOR<TrailCheckUpdateWithoutEmployeeInput, TrailCheckUncheckedUpdateWithoutEmployeeInput>
  }

  export type TrailCheckUpdateManyWithWhereWithoutEmployeeInput = {
    where: TrailCheckScalarWhereInput
    data: XOR<TrailCheckUpdateManyMutationInput, TrailCheckUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type HutCheckUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: HutCheckWhereUniqueInput
    update: XOR<HutCheckUpdateWithoutEmployeeInput, HutCheckUncheckedUpdateWithoutEmployeeInput>
    create: XOR<HutCheckCreateWithoutEmployeeInput, HutCheckUncheckedCreateWithoutEmployeeInput>
  }

  export type HutCheckUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: HutCheckWhereUniqueInput
    data: XOR<HutCheckUpdateWithoutEmployeeInput, HutCheckUncheckedUpdateWithoutEmployeeInput>
  }

  export type HutCheckUpdateManyWithWhereWithoutEmployeeInput = {
    where: HutCheckScalarWhereInput
    data: XOR<HutCheckUpdateManyMutationInput, HutCheckUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type AidRoomCheckUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AidRoomCheckWhereUniqueInput
    update: XOR<AidRoomCheckUpdateWithoutEmployeeInput, AidRoomCheckUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AidRoomCheckCreateWithoutEmployeeInput, AidRoomCheckUncheckedCreateWithoutEmployeeInput>
  }

  export type AidRoomCheckUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AidRoomCheckWhereUniqueInput
    data: XOR<AidRoomCheckUpdateWithoutEmployeeInput, AidRoomCheckUncheckedUpdateWithoutEmployeeInput>
  }

  export type AidRoomCheckUpdateManyWithWhereWithoutEmployeeInput = {
    where: AidRoomCheckScalarWhereInput
    data: XOR<AidRoomCheckUpdateManyMutationInput, AidRoomCheckUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EquipmentCheckUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EquipmentCheckWhereUniqueInput
    update: XOR<EquipmentCheckUpdateWithoutEmployeeInput, EquipmentCheckUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EquipmentCheckCreateWithoutEmployeeInput, EquipmentCheckUncheckedCreateWithoutEmployeeInput>
  }

  export type EquipmentCheckUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EquipmentCheckWhereUniqueInput
    data: XOR<EquipmentCheckUpdateWithoutEmployeeInput, EquipmentCheckUncheckedUpdateWithoutEmployeeInput>
  }

  export type EquipmentCheckUpdateManyWithWhereWithoutEmployeeInput = {
    where: EquipmentCheckScalarWhereInput
    data: XOR<EquipmentCheckUpdateManyMutationInput, EquipmentCheckUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeCreateWithoutDispatcherAssignmentsInput = {
    id?: string
    name: string
    role: string
    department: $Enums.Department
    mountain: MountainCreateNestedOneWithoutEmployeesInput
    logs?: IncidentLogCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckCreateNestedManyWithoutEmployeeInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutDispatcherAssignmentsInput = {
    id?: string
    name: string
    role: string
    department: $Enums.Department
    mountainId: string
    logs?: IncidentLogUncheckedCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutEmployeeInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutDispatcherAssignmentsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDispatcherAssignmentsInput, EmployeeUncheckedCreateWithoutDispatcherAssignmentsInput>
  }

  export type MountainCreateWithoutDispatcherAssignmentsInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    employees?: EmployeeCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentCreateNestedManyWithoutMountainInput
    weather?: WeatherCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutDispatcherAssignmentsInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutMountainInput
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutDispatcherAssignmentsInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutDispatcherAssignmentsInput, MountainUncheckedCreateWithoutDispatcherAssignmentsInput>
  }

  export type EmployeeUpsertWithoutDispatcherAssignmentsInput = {
    update: XOR<EmployeeUpdateWithoutDispatcherAssignmentsInput, EmployeeUncheckedUpdateWithoutDispatcherAssignmentsInput>
    create: XOR<EmployeeCreateWithoutDispatcherAssignmentsInput, EmployeeUncheckedCreateWithoutDispatcherAssignmentsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutDispatcherAssignmentsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutDispatcherAssignmentsInput, EmployeeUncheckedUpdateWithoutDispatcherAssignmentsInput>
  }

  export type EmployeeUpdateWithoutDispatcherAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: EnumDepartmentFieldUpdateOperationsInput | $Enums.Department
    mountain?: MountainUpdateOneRequiredWithoutEmployeesNestedInput
    logs?: IncidentLogUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUpdateManyWithoutEmployeeNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDispatcherAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: EnumDepartmentFieldUpdateOperationsInput | $Enums.Department
    mountainId?: StringFieldUpdateOperationsInput | string
    logs?: IncidentLogUncheckedUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type MountainUpsertWithoutDispatcherAssignmentsInput = {
    update: XOR<MountainUpdateWithoutDispatcherAssignmentsInput, MountainUncheckedUpdateWithoutDispatcherAssignmentsInput>
    create: XOR<MountainCreateWithoutDispatcherAssignmentsInput, MountainUncheckedCreateWithoutDispatcherAssignmentsInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutDispatcherAssignmentsInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutDispatcherAssignmentsInput, MountainUncheckedUpdateWithoutDispatcherAssignmentsInput>
  }

  export type MountainUpdateWithoutDispatcherAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUpdateManyWithoutMountainNestedInput
    weather?: WeatherUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutDispatcherAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedUpdateManyWithoutMountainNestedInput
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type MountainCreateWithoutLiftsInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    employees?: EmployeeCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentCreateNestedManyWithoutMountainInput
    weather?: WeatherCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutLiftsInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutMountainInput
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutLiftsInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutLiftsInput, MountainUncheckedCreateWithoutLiftsInput>
  }

  export type IncidentLogCreateWithoutLiftInput = {
    id?: string
    locationType: $Enums.LocationType
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
    incident: IncidentCreateNestedOneWithoutLogsInput
    employee: EmployeeCreateNestedOneWithoutLogsInput
    mountain: MountainCreateNestedOneWithoutIncidentLogsInput
    equipmentUsed?: IncidentLogEquipmentCreateNestedManyWithoutIncidentLogInput
    trail?: TrailCreateNestedOneWithoutIncidentLogsInput
    lodge?: LodgeCreateNestedOneWithoutIncidentLogsInput
    hut?: HutCreateNestedOneWithoutIncidentLogsInput
    aidRoom?: AidRoomCreateNestedOneWithoutIncidentLogsInput
  }

  export type IncidentLogUncheckedCreateWithoutLiftInput = {
    id?: string
    incidentId: string
    employeeId: string
    mountainId: string
    locationType: $Enums.LocationType
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
    equipmentUsed?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutIncidentLogInput
  }

  export type IncidentLogCreateOrConnectWithoutLiftInput = {
    where: IncidentLogWhereUniqueInput
    create: XOR<IncidentLogCreateWithoutLiftInput, IncidentLogUncheckedCreateWithoutLiftInput>
  }

  export type IncidentLogCreateManyLiftInputEnvelope = {
    data: IncidentLogCreateManyLiftInput | IncidentLogCreateManyLiftInput[]
    skipDuplicates?: boolean
  }

  export type LiftCheckCreateWithoutLiftInput = {
    id?: string
    date?: Date | string
    notes?: string | null
    employee: EmployeeCreateNestedOneWithoutLiftChecksInput
    mountain: MountainCreateNestedOneWithoutLiftChecksInput
  }

  export type LiftCheckUncheckedCreateWithoutLiftInput = {
    id?: string
    date?: Date | string
    employeeId: string
    mountainId: string
    notes?: string | null
  }

  export type LiftCheckCreateOrConnectWithoutLiftInput = {
    where: LiftCheckWhereUniqueInput
    create: XOR<LiftCheckCreateWithoutLiftInput, LiftCheckUncheckedCreateWithoutLiftInput>
  }

  export type LiftCheckCreateManyLiftInputEnvelope = {
    data: LiftCheckCreateManyLiftInput | LiftCheckCreateManyLiftInput[]
    skipDuplicates?: boolean
  }

  export type MountainUpsertWithoutLiftsInput = {
    update: XOR<MountainUpdateWithoutLiftsInput, MountainUncheckedUpdateWithoutLiftsInput>
    create: XOR<MountainCreateWithoutLiftsInput, MountainUncheckedCreateWithoutLiftsInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutLiftsInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutLiftsInput, MountainUncheckedUpdateWithoutLiftsInput>
  }

  export type MountainUpdateWithoutLiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUpdateManyWithoutMountainNestedInput
    weather?: WeatherUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutLiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedUpdateManyWithoutMountainNestedInput
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type IncidentLogUpsertWithWhereUniqueWithoutLiftInput = {
    where: IncidentLogWhereUniqueInput
    update: XOR<IncidentLogUpdateWithoutLiftInput, IncidentLogUncheckedUpdateWithoutLiftInput>
    create: XOR<IncidentLogCreateWithoutLiftInput, IncidentLogUncheckedCreateWithoutLiftInput>
  }

  export type IncidentLogUpdateWithWhereUniqueWithoutLiftInput = {
    where: IncidentLogWhereUniqueInput
    data: XOR<IncidentLogUpdateWithoutLiftInput, IncidentLogUncheckedUpdateWithoutLiftInput>
  }

  export type IncidentLogUpdateManyWithWhereWithoutLiftInput = {
    where: IncidentLogScalarWhereInput
    data: XOR<IncidentLogUpdateManyMutationInput, IncidentLogUncheckedUpdateManyWithoutLiftInput>
  }

  export type LiftCheckUpsertWithWhereUniqueWithoutLiftInput = {
    where: LiftCheckWhereUniqueInput
    update: XOR<LiftCheckUpdateWithoutLiftInput, LiftCheckUncheckedUpdateWithoutLiftInput>
    create: XOR<LiftCheckCreateWithoutLiftInput, LiftCheckUncheckedCreateWithoutLiftInput>
  }

  export type LiftCheckUpdateWithWhereUniqueWithoutLiftInput = {
    where: LiftCheckWhereUniqueInput
    data: XOR<LiftCheckUpdateWithoutLiftInput, LiftCheckUncheckedUpdateWithoutLiftInput>
  }

  export type LiftCheckUpdateManyWithWhereWithoutLiftInput = {
    where: LiftCheckScalarWhereInput
    data: XOR<LiftCheckUpdateManyMutationInput, LiftCheckUncheckedUpdateManyWithoutLiftInput>
  }

  export type MountainCreateWithoutTrailsInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    employees?: EmployeeCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentCreateNestedManyWithoutMountainInput
    weather?: WeatherCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutTrailsInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutMountainInput
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutTrailsInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutTrailsInput, MountainUncheckedCreateWithoutTrailsInput>
  }

  export type IncidentLogCreateWithoutTrailInput = {
    id?: string
    locationType: $Enums.LocationType
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
    incident: IncidentCreateNestedOneWithoutLogsInput
    employee: EmployeeCreateNestedOneWithoutLogsInput
    mountain: MountainCreateNestedOneWithoutIncidentLogsInput
    equipmentUsed?: IncidentLogEquipmentCreateNestedManyWithoutIncidentLogInput
    lift?: LiftCreateNestedOneWithoutIncidentLogsInput
    lodge?: LodgeCreateNestedOneWithoutIncidentLogsInput
    hut?: HutCreateNestedOneWithoutIncidentLogsInput
    aidRoom?: AidRoomCreateNestedOneWithoutIncidentLogsInput
  }

  export type IncidentLogUncheckedCreateWithoutTrailInput = {
    id?: string
    incidentId: string
    employeeId: string
    mountainId: string
    locationType: $Enums.LocationType
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
    equipmentUsed?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutIncidentLogInput
  }

  export type IncidentLogCreateOrConnectWithoutTrailInput = {
    where: IncidentLogWhereUniqueInput
    create: XOR<IncidentLogCreateWithoutTrailInput, IncidentLogUncheckedCreateWithoutTrailInput>
  }

  export type IncidentLogCreateManyTrailInputEnvelope = {
    data: IncidentLogCreateManyTrailInput | IncidentLogCreateManyTrailInput[]
    skipDuplicates?: boolean
  }

  export type TrailCheckCreateWithoutTrailInput = {
    id?: string
    date?: Date | string
    notes?: string | null
    employee: EmployeeCreateNestedOneWithoutTrailChecksInput
    mountain: MountainCreateNestedOneWithoutTrailChecksInput
  }

  export type TrailCheckUncheckedCreateWithoutTrailInput = {
    id?: string
    date?: Date | string
    employeeId: string
    mountainId: string
    notes?: string | null
  }

  export type TrailCheckCreateOrConnectWithoutTrailInput = {
    where: TrailCheckWhereUniqueInput
    create: XOR<TrailCheckCreateWithoutTrailInput, TrailCheckUncheckedCreateWithoutTrailInput>
  }

  export type TrailCheckCreateManyTrailInputEnvelope = {
    data: TrailCheckCreateManyTrailInput | TrailCheckCreateManyTrailInput[]
    skipDuplicates?: boolean
  }

  export type MountainUpsertWithoutTrailsInput = {
    update: XOR<MountainUpdateWithoutTrailsInput, MountainUncheckedUpdateWithoutTrailsInput>
    create: XOR<MountainCreateWithoutTrailsInput, MountainUncheckedCreateWithoutTrailsInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutTrailsInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutTrailsInput, MountainUncheckedUpdateWithoutTrailsInput>
  }

  export type MountainUpdateWithoutTrailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUpdateManyWithoutMountainNestedInput
    weather?: WeatherUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutTrailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedUpdateManyWithoutMountainNestedInput
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type IncidentLogUpsertWithWhereUniqueWithoutTrailInput = {
    where: IncidentLogWhereUniqueInput
    update: XOR<IncidentLogUpdateWithoutTrailInput, IncidentLogUncheckedUpdateWithoutTrailInput>
    create: XOR<IncidentLogCreateWithoutTrailInput, IncidentLogUncheckedCreateWithoutTrailInput>
  }

  export type IncidentLogUpdateWithWhereUniqueWithoutTrailInput = {
    where: IncidentLogWhereUniqueInput
    data: XOR<IncidentLogUpdateWithoutTrailInput, IncidentLogUncheckedUpdateWithoutTrailInput>
  }

  export type IncidentLogUpdateManyWithWhereWithoutTrailInput = {
    where: IncidentLogScalarWhereInput
    data: XOR<IncidentLogUpdateManyMutationInput, IncidentLogUncheckedUpdateManyWithoutTrailInput>
  }

  export type TrailCheckUpsertWithWhereUniqueWithoutTrailInput = {
    where: TrailCheckWhereUniqueInput
    update: XOR<TrailCheckUpdateWithoutTrailInput, TrailCheckUncheckedUpdateWithoutTrailInput>
    create: XOR<TrailCheckCreateWithoutTrailInput, TrailCheckUncheckedCreateWithoutTrailInput>
  }

  export type TrailCheckUpdateWithWhereUniqueWithoutTrailInput = {
    where: TrailCheckWhereUniqueInput
    data: XOR<TrailCheckUpdateWithoutTrailInput, TrailCheckUncheckedUpdateWithoutTrailInput>
  }

  export type TrailCheckUpdateManyWithWhereWithoutTrailInput = {
    where: TrailCheckScalarWhereInput
    data: XOR<TrailCheckUpdateManyMutationInput, TrailCheckUncheckedUpdateManyWithoutTrailInput>
  }

  export type MountainCreateWithoutLodgesInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    employees?: EmployeeCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentCreateNestedManyWithoutMountainInput
    weather?: WeatherCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutLodgesInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutMountainInput
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutLodgesInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutLodgesInput, MountainUncheckedCreateWithoutLodgesInput>
  }

  export type IncidentLogCreateWithoutLodgeInput = {
    id?: string
    locationType: $Enums.LocationType
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
    incident: IncidentCreateNestedOneWithoutLogsInput
    employee: EmployeeCreateNestedOneWithoutLogsInput
    mountain: MountainCreateNestedOneWithoutIncidentLogsInput
    equipmentUsed?: IncidentLogEquipmentCreateNestedManyWithoutIncidentLogInput
    lift?: LiftCreateNestedOneWithoutIncidentLogsInput
    trail?: TrailCreateNestedOneWithoutIncidentLogsInput
    hut?: HutCreateNestedOneWithoutIncidentLogsInput
    aidRoom?: AidRoomCreateNestedOneWithoutIncidentLogsInput
  }

  export type IncidentLogUncheckedCreateWithoutLodgeInput = {
    id?: string
    incidentId: string
    employeeId: string
    mountainId: string
    locationType: $Enums.LocationType
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
    equipmentUsed?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutIncidentLogInput
  }

  export type IncidentLogCreateOrConnectWithoutLodgeInput = {
    where: IncidentLogWhereUniqueInput
    create: XOR<IncidentLogCreateWithoutLodgeInput, IncidentLogUncheckedCreateWithoutLodgeInput>
  }

  export type IncidentLogCreateManyLodgeInputEnvelope = {
    data: IncidentLogCreateManyLodgeInput | IncidentLogCreateManyLodgeInput[]
    skipDuplicates?: boolean
  }

  export type MountainUpsertWithoutLodgesInput = {
    update: XOR<MountainUpdateWithoutLodgesInput, MountainUncheckedUpdateWithoutLodgesInput>
    create: XOR<MountainCreateWithoutLodgesInput, MountainUncheckedCreateWithoutLodgesInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutLodgesInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutLodgesInput, MountainUncheckedUpdateWithoutLodgesInput>
  }

  export type MountainUpdateWithoutLodgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUpdateManyWithoutMountainNestedInput
    weather?: WeatherUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutLodgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedUpdateManyWithoutMountainNestedInput
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type IncidentLogUpsertWithWhereUniqueWithoutLodgeInput = {
    where: IncidentLogWhereUniqueInput
    update: XOR<IncidentLogUpdateWithoutLodgeInput, IncidentLogUncheckedUpdateWithoutLodgeInput>
    create: XOR<IncidentLogCreateWithoutLodgeInput, IncidentLogUncheckedCreateWithoutLodgeInput>
  }

  export type IncidentLogUpdateWithWhereUniqueWithoutLodgeInput = {
    where: IncidentLogWhereUniqueInput
    data: XOR<IncidentLogUpdateWithoutLodgeInput, IncidentLogUncheckedUpdateWithoutLodgeInput>
  }

  export type IncidentLogUpdateManyWithWhereWithoutLodgeInput = {
    where: IncidentLogScalarWhereInput
    data: XOR<IncidentLogUpdateManyMutationInput, IncidentLogUncheckedUpdateManyWithoutLodgeInput>
  }

  export type MountainCreateWithoutHutsInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    employees?: EmployeeCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentCreateNestedManyWithoutMountainInput
    weather?: WeatherCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutHutsInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutMountainInput
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutHutsInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutHutsInput, MountainUncheckedCreateWithoutHutsInput>
  }

  export type IncidentLogCreateWithoutHutInput = {
    id?: string
    locationType: $Enums.LocationType
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
    incident: IncidentCreateNestedOneWithoutLogsInput
    employee: EmployeeCreateNestedOneWithoutLogsInput
    mountain: MountainCreateNestedOneWithoutIncidentLogsInput
    equipmentUsed?: IncidentLogEquipmentCreateNestedManyWithoutIncidentLogInput
    lift?: LiftCreateNestedOneWithoutIncidentLogsInput
    trail?: TrailCreateNestedOneWithoutIncidentLogsInput
    lodge?: LodgeCreateNestedOneWithoutIncidentLogsInput
    aidRoom?: AidRoomCreateNestedOneWithoutIncidentLogsInput
  }

  export type IncidentLogUncheckedCreateWithoutHutInput = {
    id?: string
    incidentId: string
    employeeId: string
    mountainId: string
    locationType: $Enums.LocationType
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
    equipmentUsed?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutIncidentLogInput
  }

  export type IncidentLogCreateOrConnectWithoutHutInput = {
    where: IncidentLogWhereUniqueInput
    create: XOR<IncidentLogCreateWithoutHutInput, IncidentLogUncheckedCreateWithoutHutInput>
  }

  export type IncidentLogCreateManyHutInputEnvelope = {
    data: IncidentLogCreateManyHutInput | IncidentLogCreateManyHutInput[]
    skipDuplicates?: boolean
  }

  export type HutCheckCreateWithoutHutInput = {
    id?: string
    date?: Date | string
    notes?: string | null
    employee: EmployeeCreateNestedOneWithoutHutChecksInput
    mountain: MountainCreateNestedOneWithoutHutChecksInput
  }

  export type HutCheckUncheckedCreateWithoutHutInput = {
    id?: string
    date?: Date | string
    employeeId: string
    mountainId: string
    notes?: string | null
  }

  export type HutCheckCreateOrConnectWithoutHutInput = {
    where: HutCheckWhereUniqueInput
    create: XOR<HutCheckCreateWithoutHutInput, HutCheckUncheckedCreateWithoutHutInput>
  }

  export type HutCheckCreateManyHutInputEnvelope = {
    data: HutCheckCreateManyHutInput | HutCheckCreateManyHutInput[]
    skipDuplicates?: boolean
  }

  export type MountainUpsertWithoutHutsInput = {
    update: XOR<MountainUpdateWithoutHutsInput, MountainUncheckedUpdateWithoutHutsInput>
    create: XOR<MountainCreateWithoutHutsInput, MountainUncheckedCreateWithoutHutsInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutHutsInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutHutsInput, MountainUncheckedUpdateWithoutHutsInput>
  }

  export type MountainUpdateWithoutHutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUpdateManyWithoutMountainNestedInput
    weather?: WeatherUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutHutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedUpdateManyWithoutMountainNestedInput
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type IncidentLogUpsertWithWhereUniqueWithoutHutInput = {
    where: IncidentLogWhereUniqueInput
    update: XOR<IncidentLogUpdateWithoutHutInput, IncidentLogUncheckedUpdateWithoutHutInput>
    create: XOR<IncidentLogCreateWithoutHutInput, IncidentLogUncheckedCreateWithoutHutInput>
  }

  export type IncidentLogUpdateWithWhereUniqueWithoutHutInput = {
    where: IncidentLogWhereUniqueInput
    data: XOR<IncidentLogUpdateWithoutHutInput, IncidentLogUncheckedUpdateWithoutHutInput>
  }

  export type IncidentLogUpdateManyWithWhereWithoutHutInput = {
    where: IncidentLogScalarWhereInput
    data: XOR<IncidentLogUpdateManyMutationInput, IncidentLogUncheckedUpdateManyWithoutHutInput>
  }

  export type HutCheckUpsertWithWhereUniqueWithoutHutInput = {
    where: HutCheckWhereUniqueInput
    update: XOR<HutCheckUpdateWithoutHutInput, HutCheckUncheckedUpdateWithoutHutInput>
    create: XOR<HutCheckCreateWithoutHutInput, HutCheckUncheckedCreateWithoutHutInput>
  }

  export type HutCheckUpdateWithWhereUniqueWithoutHutInput = {
    where: HutCheckWhereUniqueInput
    data: XOR<HutCheckUpdateWithoutHutInput, HutCheckUncheckedUpdateWithoutHutInput>
  }

  export type HutCheckUpdateManyWithWhereWithoutHutInput = {
    where: HutCheckScalarWhereInput
    data: XOR<HutCheckUpdateManyMutationInput, HutCheckUncheckedUpdateManyWithoutHutInput>
  }

  export type MountainCreateWithoutAidRoomsInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    employees?: EmployeeCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentCreateNestedManyWithoutMountainInput
    weather?: WeatherCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutAidRoomsInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutMountainInput
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutAidRoomsInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutAidRoomsInput, MountainUncheckedCreateWithoutAidRoomsInput>
  }

  export type IncidentLogCreateWithoutAidRoomInput = {
    id?: string
    locationType: $Enums.LocationType
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
    incident: IncidentCreateNestedOneWithoutLogsInput
    employee: EmployeeCreateNestedOneWithoutLogsInput
    mountain: MountainCreateNestedOneWithoutIncidentLogsInput
    equipmentUsed?: IncidentLogEquipmentCreateNestedManyWithoutIncidentLogInput
    lift?: LiftCreateNestedOneWithoutIncidentLogsInput
    trail?: TrailCreateNestedOneWithoutIncidentLogsInput
    lodge?: LodgeCreateNestedOneWithoutIncidentLogsInput
    hut?: HutCreateNestedOneWithoutIncidentLogsInput
  }

  export type IncidentLogUncheckedCreateWithoutAidRoomInput = {
    id?: string
    incidentId: string
    employeeId: string
    mountainId: string
    locationType: $Enums.LocationType
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
    equipmentUsed?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutIncidentLogInput
  }

  export type IncidentLogCreateOrConnectWithoutAidRoomInput = {
    where: IncidentLogWhereUniqueInput
    create: XOR<IncidentLogCreateWithoutAidRoomInput, IncidentLogUncheckedCreateWithoutAidRoomInput>
  }

  export type IncidentLogCreateManyAidRoomInputEnvelope = {
    data: IncidentLogCreateManyAidRoomInput | IncidentLogCreateManyAidRoomInput[]
    skipDuplicates?: boolean
  }

  export type AidRoomCheckCreateWithoutAidRoomInput = {
    id?: string
    date?: Date | string
    notes?: string | null
    employee: EmployeeCreateNestedOneWithoutAidRoomChecksInput
    mountain: MountainCreateNestedOneWithoutAidRoomChecksInput
  }

  export type AidRoomCheckUncheckedCreateWithoutAidRoomInput = {
    id?: string
    date?: Date | string
    employeeId: string
    mountainId: string
    notes?: string | null
  }

  export type AidRoomCheckCreateOrConnectWithoutAidRoomInput = {
    where: AidRoomCheckWhereUniqueInput
    create: XOR<AidRoomCheckCreateWithoutAidRoomInput, AidRoomCheckUncheckedCreateWithoutAidRoomInput>
  }

  export type AidRoomCheckCreateManyAidRoomInputEnvelope = {
    data: AidRoomCheckCreateManyAidRoomInput | AidRoomCheckCreateManyAidRoomInput[]
    skipDuplicates?: boolean
  }

  export type MountainUpsertWithoutAidRoomsInput = {
    update: XOR<MountainUpdateWithoutAidRoomsInput, MountainUncheckedUpdateWithoutAidRoomsInput>
    create: XOR<MountainCreateWithoutAidRoomsInput, MountainUncheckedCreateWithoutAidRoomsInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutAidRoomsInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutAidRoomsInput, MountainUncheckedUpdateWithoutAidRoomsInput>
  }

  export type MountainUpdateWithoutAidRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUpdateManyWithoutMountainNestedInput
    weather?: WeatherUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutAidRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedUpdateManyWithoutMountainNestedInput
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type IncidentLogUpsertWithWhereUniqueWithoutAidRoomInput = {
    where: IncidentLogWhereUniqueInput
    update: XOR<IncidentLogUpdateWithoutAidRoomInput, IncidentLogUncheckedUpdateWithoutAidRoomInput>
    create: XOR<IncidentLogCreateWithoutAidRoomInput, IncidentLogUncheckedCreateWithoutAidRoomInput>
  }

  export type IncidentLogUpdateWithWhereUniqueWithoutAidRoomInput = {
    where: IncidentLogWhereUniqueInput
    data: XOR<IncidentLogUpdateWithoutAidRoomInput, IncidentLogUncheckedUpdateWithoutAidRoomInput>
  }

  export type IncidentLogUpdateManyWithWhereWithoutAidRoomInput = {
    where: IncidentLogScalarWhereInput
    data: XOR<IncidentLogUpdateManyMutationInput, IncidentLogUncheckedUpdateManyWithoutAidRoomInput>
  }

  export type AidRoomCheckUpsertWithWhereUniqueWithoutAidRoomInput = {
    where: AidRoomCheckWhereUniqueInput
    update: XOR<AidRoomCheckUpdateWithoutAidRoomInput, AidRoomCheckUncheckedUpdateWithoutAidRoomInput>
    create: XOR<AidRoomCheckCreateWithoutAidRoomInput, AidRoomCheckUncheckedCreateWithoutAidRoomInput>
  }

  export type AidRoomCheckUpdateWithWhereUniqueWithoutAidRoomInput = {
    where: AidRoomCheckWhereUniqueInput
    data: XOR<AidRoomCheckUpdateWithoutAidRoomInput, AidRoomCheckUncheckedUpdateWithoutAidRoomInput>
  }

  export type AidRoomCheckUpdateManyWithWhereWithoutAidRoomInput = {
    where: AidRoomCheckScalarWhereInput
    data: XOR<AidRoomCheckUpdateManyMutationInput, AidRoomCheckUncheckedUpdateManyWithoutAidRoomInput>
  }

  export type MountainCreateWithoutEquipmentInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    employees?: EmployeeCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentCreateNestedManyWithoutMountainInput
    weather?: WeatherCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutEquipmentInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutMountainInput
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutEquipmentInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutEquipmentInput, MountainUncheckedCreateWithoutEquipmentInput>
  }

  export type IncidentLogEquipmentCreateWithoutEquipmentInput = {
    id?: string
    usedAt?: Date | string
    notes?: string | null
    mountain: MountainCreateNestedOneWithoutIncidentLogEquipmentInput
    incidentLog: IncidentLogCreateNestedOneWithoutEquipmentUsedInput
  }

  export type IncidentLogEquipmentUncheckedCreateWithoutEquipmentInput = {
    id?: string
    incidentLogId: string
    mountainId: string
    usedAt?: Date | string
    notes?: string | null
  }

  export type IncidentLogEquipmentCreateOrConnectWithoutEquipmentInput = {
    where: IncidentLogEquipmentWhereUniqueInput
    create: XOR<IncidentLogEquipmentCreateWithoutEquipmentInput, IncidentLogEquipmentUncheckedCreateWithoutEquipmentInput>
  }

  export type IncidentLogEquipmentCreateManyEquipmentInputEnvelope = {
    data: IncidentLogEquipmentCreateManyEquipmentInput | IncidentLogEquipmentCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCheckCreateWithoutEquipmentInput = {
    id?: string
    date?: Date | string
    notes?: string | null
    employee: EmployeeCreateNestedOneWithoutEquipmentChecksInput
    mountain: MountainCreateNestedOneWithoutEquipmentChecksInput
  }

  export type EquipmentCheckUncheckedCreateWithoutEquipmentInput = {
    id?: string
    date?: Date | string
    employeeId: string
    mountainId: string
    notes?: string | null
  }

  export type EquipmentCheckCreateOrConnectWithoutEquipmentInput = {
    where: EquipmentCheckWhereUniqueInput
    create: XOR<EquipmentCheckCreateWithoutEquipmentInput, EquipmentCheckUncheckedCreateWithoutEquipmentInput>
  }

  export type EquipmentCheckCreateManyEquipmentInputEnvelope = {
    data: EquipmentCheckCreateManyEquipmentInput | EquipmentCheckCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type MountainUpsertWithoutEquipmentInput = {
    update: XOR<MountainUpdateWithoutEquipmentInput, MountainUncheckedUpdateWithoutEquipmentInput>
    create: XOR<MountainCreateWithoutEquipmentInput, MountainUncheckedCreateWithoutEquipmentInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutEquipmentInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutEquipmentInput, MountainUncheckedUpdateWithoutEquipmentInput>
  }

  export type MountainUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUpdateManyWithoutMountainNestedInput
    weather?: WeatherUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedUpdateManyWithoutMountainNestedInput
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type IncidentLogEquipmentUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: IncidentLogEquipmentWhereUniqueInput
    update: XOR<IncidentLogEquipmentUpdateWithoutEquipmentInput, IncidentLogEquipmentUncheckedUpdateWithoutEquipmentInput>
    create: XOR<IncidentLogEquipmentCreateWithoutEquipmentInput, IncidentLogEquipmentUncheckedCreateWithoutEquipmentInput>
  }

  export type IncidentLogEquipmentUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: IncidentLogEquipmentWhereUniqueInput
    data: XOR<IncidentLogEquipmentUpdateWithoutEquipmentInput, IncidentLogEquipmentUncheckedUpdateWithoutEquipmentInput>
  }

  export type IncidentLogEquipmentUpdateManyWithWhereWithoutEquipmentInput = {
    where: IncidentLogEquipmentScalarWhereInput
    data: XOR<IncidentLogEquipmentUpdateManyMutationInput, IncidentLogEquipmentUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type EquipmentCheckUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: EquipmentCheckWhereUniqueInput
    update: XOR<EquipmentCheckUpdateWithoutEquipmentInput, EquipmentCheckUncheckedUpdateWithoutEquipmentInput>
    create: XOR<EquipmentCheckCreateWithoutEquipmentInput, EquipmentCheckUncheckedCreateWithoutEquipmentInput>
  }

  export type EquipmentCheckUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: EquipmentCheckWhereUniqueInput
    data: XOR<EquipmentCheckUpdateWithoutEquipmentInput, EquipmentCheckUncheckedUpdateWithoutEquipmentInput>
  }

  export type EquipmentCheckUpdateManyWithWhereWithoutEquipmentInput = {
    where: EquipmentCheckScalarWhereInput
    data: XOR<EquipmentCheckUpdateManyMutationInput, EquipmentCheckUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type MountainCreateWithoutIncidentsInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    employees?: EmployeeCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentCreateNestedManyWithoutMountainInput
    weather?: WeatherCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutIncidentsInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutMountainInput
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutIncidentsInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutIncidentsInput, MountainUncheckedCreateWithoutIncidentsInput>
  }

  export type IncidentLogCreateWithoutIncidentInput = {
    id?: string
    locationType: $Enums.LocationType
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutLogsInput
    mountain: MountainCreateNestedOneWithoutIncidentLogsInput
    equipmentUsed?: IncidentLogEquipmentCreateNestedManyWithoutIncidentLogInput
    lift?: LiftCreateNestedOneWithoutIncidentLogsInput
    trail?: TrailCreateNestedOneWithoutIncidentLogsInput
    lodge?: LodgeCreateNestedOneWithoutIncidentLogsInput
    hut?: HutCreateNestedOneWithoutIncidentLogsInput
    aidRoom?: AidRoomCreateNestedOneWithoutIncidentLogsInput
  }

  export type IncidentLogUncheckedCreateWithoutIncidentInput = {
    id?: string
    employeeId: string
    mountainId: string
    locationType: $Enums.LocationType
    locationId: string
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
    equipmentUsed?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutIncidentLogInput
  }

  export type IncidentLogCreateOrConnectWithoutIncidentInput = {
    where: IncidentLogWhereUniqueInput
    create: XOR<IncidentLogCreateWithoutIncidentInput, IncidentLogUncheckedCreateWithoutIncidentInput>
  }

  export type IncidentLogCreateManyIncidentInputEnvelope = {
    data: IncidentLogCreateManyIncidentInput | IncidentLogCreateManyIncidentInput[]
    skipDuplicates?: boolean
  }

  export type MountainUpsertWithoutIncidentsInput = {
    update: XOR<MountainUpdateWithoutIncidentsInput, MountainUncheckedUpdateWithoutIncidentsInput>
    create: XOR<MountainCreateWithoutIncidentsInput, MountainUncheckedCreateWithoutIncidentsInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutIncidentsInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutIncidentsInput, MountainUncheckedUpdateWithoutIncidentsInput>
  }

  export type MountainUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUpdateManyWithoutMountainNestedInput
    weather?: WeatherUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedUpdateManyWithoutMountainNestedInput
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type IncidentLogUpsertWithWhereUniqueWithoutIncidentInput = {
    where: IncidentLogWhereUniqueInput
    update: XOR<IncidentLogUpdateWithoutIncidentInput, IncidentLogUncheckedUpdateWithoutIncidentInput>
    create: XOR<IncidentLogCreateWithoutIncidentInput, IncidentLogUncheckedCreateWithoutIncidentInput>
  }

  export type IncidentLogUpdateWithWhereUniqueWithoutIncidentInput = {
    where: IncidentLogWhereUniqueInput
    data: XOR<IncidentLogUpdateWithoutIncidentInput, IncidentLogUncheckedUpdateWithoutIncidentInput>
  }

  export type IncidentLogUpdateManyWithWhereWithoutIncidentInput = {
    where: IncidentLogScalarWhereInput
    data: XOR<IncidentLogUpdateManyMutationInput, IncidentLogUncheckedUpdateManyWithoutIncidentInput>
  }

  export type IncidentCreateWithoutLogsInput = {
    id?: string
    description: string
    status?: $Enums.Status
    mountain: MountainCreateNestedOneWithoutIncidentsInput
  }

  export type IncidentUncheckedCreateWithoutLogsInput = {
    id?: string
    description: string
    status?: $Enums.Status
    mountainId: string
  }

  export type IncidentCreateOrConnectWithoutLogsInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutLogsInput, IncidentUncheckedCreateWithoutLogsInput>
  }

  export type EmployeeCreateWithoutLogsInput = {
    id?: string
    name: string
    role: string
    department: $Enums.Department
    mountain: MountainCreateNestedOneWithoutEmployeesInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckCreateNestedManyWithoutEmployeeInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutLogsInput = {
    id?: string
    name: string
    role: string
    department: $Enums.Department
    mountainId: string
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutEmployeeInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutLogsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutLogsInput, EmployeeUncheckedCreateWithoutLogsInput>
  }

  export type MountainCreateWithoutIncidentLogsInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    employees?: EmployeeCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentCreateNestedManyWithoutMountainInput
    weather?: WeatherCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutIncidentLogsInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutMountainInput
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutIncidentLogsInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutIncidentLogsInput, MountainUncheckedCreateWithoutIncidentLogsInput>
  }

  export type IncidentLogEquipmentCreateWithoutIncidentLogInput = {
    id?: string
    usedAt?: Date | string
    notes?: string | null
    mountain: MountainCreateNestedOneWithoutIncidentLogEquipmentInput
    equipment: EquipmentCreateNestedOneWithoutUsedInLogsInput
  }

  export type IncidentLogEquipmentUncheckedCreateWithoutIncidentLogInput = {
    id?: string
    equipmentId: string
    mountainId: string
    usedAt?: Date | string
    notes?: string | null
  }

  export type IncidentLogEquipmentCreateOrConnectWithoutIncidentLogInput = {
    where: IncidentLogEquipmentWhereUniqueInput
    create: XOR<IncidentLogEquipmentCreateWithoutIncidentLogInput, IncidentLogEquipmentUncheckedCreateWithoutIncidentLogInput>
  }

  export type IncidentLogEquipmentCreateManyIncidentLogInputEnvelope = {
    data: IncidentLogEquipmentCreateManyIncidentLogInput | IncidentLogEquipmentCreateManyIncidentLogInput[]
    skipDuplicates?: boolean
  }

  export type LiftCreateWithoutIncidentLogsInput = {
    id?: string
    name: string
    capacity: number
    status?: $Enums.Status
    mountain: MountainCreateNestedOneWithoutLiftsInput
    liftChecks?: LiftCheckCreateNestedManyWithoutLiftInput
  }

  export type LiftUncheckedCreateWithoutIncidentLogsInput = {
    id?: string
    name: string
    capacity: number
    status?: $Enums.Status
    mountainId: string
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutLiftInput
  }

  export type LiftCreateOrConnectWithoutIncidentLogsInput = {
    where: LiftWhereUniqueInput
    create: XOR<LiftCreateWithoutIncidentLogsInput, LiftUncheckedCreateWithoutIncidentLogsInput>
  }

  export type TrailCreateWithoutIncidentLogsInput = {
    id?: string
    name: string
    status?: $Enums.Status
    difficulty: $Enums.TrailDifficulty
    length: number
    condition?: $Enums.TrailCondition
    mountain: MountainCreateNestedOneWithoutTrailsInput
    trailChecks?: TrailCheckCreateNestedManyWithoutTrailInput
  }

  export type TrailUncheckedCreateWithoutIncidentLogsInput = {
    id?: string
    name: string
    status?: $Enums.Status
    difficulty: $Enums.TrailDifficulty
    length: number
    condition?: $Enums.TrailCondition
    mountainId: string
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutTrailInput
  }

  export type TrailCreateOrConnectWithoutIncidentLogsInput = {
    where: TrailWhereUniqueInput
    create: XOR<TrailCreateWithoutIncidentLogsInput, TrailUncheckedCreateWithoutIncidentLogsInput>
  }

  export type LodgeCreateWithoutIncidentLogsInput = {
    id?: string
    name: string
    capacity: number
    status?: $Enums.Status
    mountain: MountainCreateNestedOneWithoutLodgesInput
  }

  export type LodgeUncheckedCreateWithoutIncidentLogsInput = {
    id?: string
    name: string
    capacity: number
    status?: $Enums.Status
    mountainId: string
  }

  export type LodgeCreateOrConnectWithoutIncidentLogsInput = {
    where: LodgeWhereUniqueInput
    create: XOR<LodgeCreateWithoutIncidentLogsInput, LodgeUncheckedCreateWithoutIncidentLogsInput>
  }

  export type HutCreateWithoutIncidentLogsInput = {
    id?: string
    name: string
    status?: $Enums.Status
    mountain: MountainCreateNestedOneWithoutHutsInput
    hutChecks?: HutCheckCreateNestedManyWithoutHutInput
  }

  export type HutUncheckedCreateWithoutIncidentLogsInput = {
    id?: string
    name: string
    status?: $Enums.Status
    mountainId: string
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutHutInput
  }

  export type HutCreateOrConnectWithoutIncidentLogsInput = {
    where: HutWhereUniqueInput
    create: XOR<HutCreateWithoutIncidentLogsInput, HutUncheckedCreateWithoutIncidentLogsInput>
  }

  export type AidRoomCreateWithoutIncidentLogsInput = {
    id?: string
    name: string
    location: string
    status?: $Enums.Status
    mountain: MountainCreateNestedOneWithoutAidRoomsInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutAidRoomInput
  }

  export type AidRoomUncheckedCreateWithoutIncidentLogsInput = {
    id?: string
    name: string
    location: string
    status?: $Enums.Status
    mountainId: string
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutAidRoomInput
  }

  export type AidRoomCreateOrConnectWithoutIncidentLogsInput = {
    where: AidRoomWhereUniqueInput
    create: XOR<AidRoomCreateWithoutIncidentLogsInput, AidRoomUncheckedCreateWithoutIncidentLogsInput>
  }

  export type IncidentUpsertWithoutLogsInput = {
    update: XOR<IncidentUpdateWithoutLogsInput, IncidentUncheckedUpdateWithoutLogsInput>
    create: XOR<IncidentCreateWithoutLogsInput, IncidentUncheckedCreateWithoutLogsInput>
    where?: IncidentWhereInput
  }

  export type IncidentUpdateToOneWithWhereWithoutLogsInput = {
    where?: IncidentWhereInput
    data: XOR<IncidentUpdateWithoutLogsInput, IncidentUncheckedUpdateWithoutLogsInput>
  }

  export type IncidentUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountain?: MountainUpdateOneRequiredWithoutIncidentsNestedInput
  }

  export type IncidentUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountainId?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeUpsertWithoutLogsInput = {
    update: XOR<EmployeeUpdateWithoutLogsInput, EmployeeUncheckedUpdateWithoutLogsInput>
    create: XOR<EmployeeCreateWithoutLogsInput, EmployeeUncheckedCreateWithoutLogsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutLogsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutLogsInput, EmployeeUncheckedUpdateWithoutLogsInput>
  }

  export type EmployeeUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: EnumDepartmentFieldUpdateOperationsInput | $Enums.Department
    mountain?: MountainUpdateOneRequiredWithoutEmployeesNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUpdateManyWithoutEmployeeNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: EnumDepartmentFieldUpdateOperationsInput | $Enums.Department
    mountainId?: StringFieldUpdateOperationsInput | string
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type MountainUpsertWithoutIncidentLogsInput = {
    update: XOR<MountainUpdateWithoutIncidentLogsInput, MountainUncheckedUpdateWithoutIncidentLogsInput>
    create: XOR<MountainCreateWithoutIncidentLogsInput, MountainUncheckedCreateWithoutIncidentLogsInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutIncidentLogsInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutIncidentLogsInput, MountainUncheckedUpdateWithoutIncidentLogsInput>
  }

  export type MountainUpdateWithoutIncidentLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUpdateManyWithoutMountainNestedInput
    weather?: WeatherUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutIncidentLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedUpdateManyWithoutMountainNestedInput
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type IncidentLogEquipmentUpsertWithWhereUniqueWithoutIncidentLogInput = {
    where: IncidentLogEquipmentWhereUniqueInput
    update: XOR<IncidentLogEquipmentUpdateWithoutIncidentLogInput, IncidentLogEquipmentUncheckedUpdateWithoutIncidentLogInput>
    create: XOR<IncidentLogEquipmentCreateWithoutIncidentLogInput, IncidentLogEquipmentUncheckedCreateWithoutIncidentLogInput>
  }

  export type IncidentLogEquipmentUpdateWithWhereUniqueWithoutIncidentLogInput = {
    where: IncidentLogEquipmentWhereUniqueInput
    data: XOR<IncidentLogEquipmentUpdateWithoutIncidentLogInput, IncidentLogEquipmentUncheckedUpdateWithoutIncidentLogInput>
  }

  export type IncidentLogEquipmentUpdateManyWithWhereWithoutIncidentLogInput = {
    where: IncidentLogEquipmentScalarWhereInput
    data: XOR<IncidentLogEquipmentUpdateManyMutationInput, IncidentLogEquipmentUncheckedUpdateManyWithoutIncidentLogInput>
  }

  export type LiftUpsertWithoutIncidentLogsInput = {
    update: XOR<LiftUpdateWithoutIncidentLogsInput, LiftUncheckedUpdateWithoutIncidentLogsInput>
    create: XOR<LiftCreateWithoutIncidentLogsInput, LiftUncheckedCreateWithoutIncidentLogsInput>
    where?: LiftWhereInput
  }

  export type LiftUpdateToOneWithWhereWithoutIncidentLogsInput = {
    where?: LiftWhereInput
    data: XOR<LiftUpdateWithoutIncidentLogsInput, LiftUncheckedUpdateWithoutIncidentLogsInput>
  }

  export type LiftUpdateWithoutIncidentLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountain?: MountainUpdateOneRequiredWithoutLiftsNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutLiftNestedInput
  }

  export type LiftUncheckedUpdateWithoutIncidentLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountainId?: StringFieldUpdateOperationsInput | string
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutLiftNestedInput
  }

  export type TrailUpsertWithoutIncidentLogsInput = {
    update: XOR<TrailUpdateWithoutIncidentLogsInput, TrailUncheckedUpdateWithoutIncidentLogsInput>
    create: XOR<TrailCreateWithoutIncidentLogsInput, TrailUncheckedCreateWithoutIncidentLogsInput>
    where?: TrailWhereInput
  }

  export type TrailUpdateToOneWithWhereWithoutIncidentLogsInput = {
    where?: TrailWhereInput
    data: XOR<TrailUpdateWithoutIncidentLogsInput, TrailUncheckedUpdateWithoutIncidentLogsInput>
  }

  export type TrailUpdateWithoutIncidentLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    difficulty?: EnumTrailDifficultyFieldUpdateOperationsInput | $Enums.TrailDifficulty
    length?: FloatFieldUpdateOperationsInput | number
    condition?: EnumTrailConditionFieldUpdateOperationsInput | $Enums.TrailCondition
    mountain?: MountainUpdateOneRequiredWithoutTrailsNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutTrailNestedInput
  }

  export type TrailUncheckedUpdateWithoutIncidentLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    difficulty?: EnumTrailDifficultyFieldUpdateOperationsInput | $Enums.TrailDifficulty
    length?: FloatFieldUpdateOperationsInput | number
    condition?: EnumTrailConditionFieldUpdateOperationsInput | $Enums.TrailCondition
    mountainId?: StringFieldUpdateOperationsInput | string
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutTrailNestedInput
  }

  export type LodgeUpsertWithoutIncidentLogsInput = {
    update: XOR<LodgeUpdateWithoutIncidentLogsInput, LodgeUncheckedUpdateWithoutIncidentLogsInput>
    create: XOR<LodgeCreateWithoutIncidentLogsInput, LodgeUncheckedCreateWithoutIncidentLogsInput>
    where?: LodgeWhereInput
  }

  export type LodgeUpdateToOneWithWhereWithoutIncidentLogsInput = {
    where?: LodgeWhereInput
    data: XOR<LodgeUpdateWithoutIncidentLogsInput, LodgeUncheckedUpdateWithoutIncidentLogsInput>
  }

  export type LodgeUpdateWithoutIncidentLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountain?: MountainUpdateOneRequiredWithoutLodgesNestedInput
  }

  export type LodgeUncheckedUpdateWithoutIncidentLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountainId?: StringFieldUpdateOperationsInput | string
  }

  export type HutUpsertWithoutIncidentLogsInput = {
    update: XOR<HutUpdateWithoutIncidentLogsInput, HutUncheckedUpdateWithoutIncidentLogsInput>
    create: XOR<HutCreateWithoutIncidentLogsInput, HutUncheckedCreateWithoutIncidentLogsInput>
    where?: HutWhereInput
  }

  export type HutUpdateToOneWithWhereWithoutIncidentLogsInput = {
    where?: HutWhereInput
    data: XOR<HutUpdateWithoutIncidentLogsInput, HutUncheckedUpdateWithoutIncidentLogsInput>
  }

  export type HutUpdateWithoutIncidentLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountain?: MountainUpdateOneRequiredWithoutHutsNestedInput
    hutChecks?: HutCheckUpdateManyWithoutHutNestedInput
  }

  export type HutUncheckedUpdateWithoutIncidentLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountainId?: StringFieldUpdateOperationsInput | string
    hutChecks?: HutCheckUncheckedUpdateManyWithoutHutNestedInput
  }

  export type AidRoomUpsertWithoutIncidentLogsInput = {
    update: XOR<AidRoomUpdateWithoutIncidentLogsInput, AidRoomUncheckedUpdateWithoutIncidentLogsInput>
    create: XOR<AidRoomCreateWithoutIncidentLogsInput, AidRoomUncheckedCreateWithoutIncidentLogsInput>
    where?: AidRoomWhereInput
  }

  export type AidRoomUpdateToOneWithWhereWithoutIncidentLogsInput = {
    where?: AidRoomWhereInput
    data: XOR<AidRoomUpdateWithoutIncidentLogsInput, AidRoomUncheckedUpdateWithoutIncidentLogsInput>
  }

  export type AidRoomUpdateWithoutIncidentLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountain?: MountainUpdateOneRequiredWithoutAidRoomsNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutAidRoomNestedInput
  }

  export type AidRoomUncheckedUpdateWithoutIncidentLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountainId?: StringFieldUpdateOperationsInput | string
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutAidRoomNestedInput
  }

  export type MountainCreateWithoutIncidentLogEquipmentInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    employees?: EmployeeCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    weather?: WeatherCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutIncidentLogEquipmentInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutIncidentLogEquipmentInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutIncidentLogEquipmentInput, MountainUncheckedCreateWithoutIncidentLogEquipmentInput>
  }

  export type IncidentLogCreateWithoutEquipmentUsedInput = {
    id?: string
    locationType: $Enums.LocationType
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
    incident: IncidentCreateNestedOneWithoutLogsInput
    employee: EmployeeCreateNestedOneWithoutLogsInput
    mountain: MountainCreateNestedOneWithoutIncidentLogsInput
    lift?: LiftCreateNestedOneWithoutIncidentLogsInput
    trail?: TrailCreateNestedOneWithoutIncidentLogsInput
    lodge?: LodgeCreateNestedOneWithoutIncidentLogsInput
    hut?: HutCreateNestedOneWithoutIncidentLogsInput
    aidRoom?: AidRoomCreateNestedOneWithoutIncidentLogsInput
  }

  export type IncidentLogUncheckedCreateWithoutEquipmentUsedInput = {
    id?: string
    incidentId: string
    employeeId: string
    mountainId: string
    locationType: $Enums.LocationType
    locationId: string
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
  }

  export type IncidentLogCreateOrConnectWithoutEquipmentUsedInput = {
    where: IncidentLogWhereUniqueInput
    create: XOR<IncidentLogCreateWithoutEquipmentUsedInput, IncidentLogUncheckedCreateWithoutEquipmentUsedInput>
  }

  export type EquipmentCreateWithoutUsedInLogsInput = {
    id?: string
    name: string
    type: string
    status: $Enums.EquipmentStatus
    service: $Enums.EquipmentService
    mountain: MountainCreateNestedOneWithoutEquipmentInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutUsedInLogsInput = {
    id?: string
    name: string
    type: string
    status: $Enums.EquipmentStatus
    service: $Enums.EquipmentService
    mountainId: string
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutUsedInLogsInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutUsedInLogsInput, EquipmentUncheckedCreateWithoutUsedInLogsInput>
  }

  export type MountainUpsertWithoutIncidentLogEquipmentInput = {
    update: XOR<MountainUpdateWithoutIncidentLogEquipmentInput, MountainUncheckedUpdateWithoutIncidentLogEquipmentInput>
    create: XOR<MountainCreateWithoutIncidentLogEquipmentInput, MountainUncheckedCreateWithoutIncidentLogEquipmentInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutIncidentLogEquipmentInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutIncidentLogEquipmentInput, MountainUncheckedUpdateWithoutIncidentLogEquipmentInput>
  }

  export type MountainUpdateWithoutIncidentLogEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    weather?: WeatherUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutIncidentLogEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type IncidentLogUpsertWithoutEquipmentUsedInput = {
    update: XOR<IncidentLogUpdateWithoutEquipmentUsedInput, IncidentLogUncheckedUpdateWithoutEquipmentUsedInput>
    create: XOR<IncidentLogCreateWithoutEquipmentUsedInput, IncidentLogUncheckedCreateWithoutEquipmentUsedInput>
    where?: IncidentLogWhereInput
  }

  export type IncidentLogUpdateToOneWithWhereWithoutEquipmentUsedInput = {
    where?: IncidentLogWhereInput
    data: XOR<IncidentLogUpdateWithoutEquipmentUsedInput, IncidentLogUncheckedUpdateWithoutEquipmentUsedInput>
  }

  export type IncidentLogUpdateWithoutEquipmentUsedInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incident?: IncidentUpdateOneRequiredWithoutLogsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutLogsNestedInput
    mountain?: MountainUpdateOneRequiredWithoutIncidentLogsNestedInput
    lift?: LiftUpdateOneWithoutIncidentLogsNestedInput
    trail?: TrailUpdateOneWithoutIncidentLogsNestedInput
    lodge?: LodgeUpdateOneWithoutIncidentLogsNestedInput
    hut?: HutUpdateOneWithoutIncidentLogsNestedInput
    aidRoom?: AidRoomUpdateOneWithoutIncidentLogsNestedInput
  }

  export type IncidentLogUncheckedUpdateWithoutEquipmentUsedInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationId?: StringFieldUpdateOperationsInput | string
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EquipmentUpsertWithoutUsedInLogsInput = {
    update: XOR<EquipmentUpdateWithoutUsedInLogsInput, EquipmentUncheckedUpdateWithoutUsedInLogsInput>
    create: XOR<EquipmentCreateWithoutUsedInLogsInput, EquipmentUncheckedCreateWithoutUsedInLogsInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutUsedInLogsInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutUsedInLogsInput, EquipmentUncheckedUpdateWithoutUsedInLogsInput>
  }

  export type EquipmentUpdateWithoutUsedInLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    service?: EnumEquipmentServiceFieldUpdateOperationsInput | $Enums.EquipmentService
    mountain?: MountainUpdateOneRequiredWithoutEquipmentNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutUsedInLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    service?: EnumEquipmentServiceFieldUpdateOperationsInput | $Enums.EquipmentService
    mountainId?: StringFieldUpdateOperationsInput | string
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EmployeeCreateWithoutLiftChecksInput = {
    id?: string
    name: string
    role: string
    department: $Enums.Department
    mountain: MountainCreateNestedOneWithoutEmployeesInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutEmployeeInput
    logs?: IncidentLogCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckCreateNestedManyWithoutEmployeeInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutLiftChecksInput = {
    id?: string
    name: string
    role: string
    department: $Enums.Department
    mountainId: string
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    logs?: IncidentLogUncheckedCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutEmployeeInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutLiftChecksInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutLiftChecksInput, EmployeeUncheckedCreateWithoutLiftChecksInput>
  }

  export type MountainCreateWithoutLiftChecksInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    employees?: EmployeeCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentCreateNestedManyWithoutMountainInput
    weather?: WeatherCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutLiftChecksInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutMountainInput
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutLiftChecksInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutLiftChecksInput, MountainUncheckedCreateWithoutLiftChecksInput>
  }

  export type LiftCreateWithoutLiftChecksInput = {
    id?: string
    name: string
    capacity: number
    status?: $Enums.Status
    mountain: MountainCreateNestedOneWithoutLiftsInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutLiftInput
  }

  export type LiftUncheckedCreateWithoutLiftChecksInput = {
    id?: string
    name: string
    capacity: number
    status?: $Enums.Status
    mountainId: string
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutLiftInput
  }

  export type LiftCreateOrConnectWithoutLiftChecksInput = {
    where: LiftWhereUniqueInput
    create: XOR<LiftCreateWithoutLiftChecksInput, LiftUncheckedCreateWithoutLiftChecksInput>
  }

  export type EmployeeUpsertWithoutLiftChecksInput = {
    update: XOR<EmployeeUpdateWithoutLiftChecksInput, EmployeeUncheckedUpdateWithoutLiftChecksInput>
    create: XOR<EmployeeCreateWithoutLiftChecksInput, EmployeeUncheckedCreateWithoutLiftChecksInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutLiftChecksInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutLiftChecksInput, EmployeeUncheckedUpdateWithoutLiftChecksInput>
  }

  export type EmployeeUpdateWithoutLiftChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: EnumDepartmentFieldUpdateOperationsInput | $Enums.Department
    mountain?: MountainUpdateOneRequiredWithoutEmployeesNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutEmployeeNestedInput
    logs?: IncidentLogUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUpdateManyWithoutEmployeeNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutLiftChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: EnumDepartmentFieldUpdateOperationsInput | $Enums.Department
    mountainId?: StringFieldUpdateOperationsInput | string
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    logs?: IncidentLogUncheckedUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type MountainUpsertWithoutLiftChecksInput = {
    update: XOR<MountainUpdateWithoutLiftChecksInput, MountainUncheckedUpdateWithoutLiftChecksInput>
    create: XOR<MountainCreateWithoutLiftChecksInput, MountainUncheckedCreateWithoutLiftChecksInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutLiftChecksInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutLiftChecksInput, MountainUncheckedUpdateWithoutLiftChecksInput>
  }

  export type MountainUpdateWithoutLiftChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUpdateManyWithoutMountainNestedInput
    weather?: WeatherUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutLiftChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedUpdateManyWithoutMountainNestedInput
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type LiftUpsertWithoutLiftChecksInput = {
    update: XOR<LiftUpdateWithoutLiftChecksInput, LiftUncheckedUpdateWithoutLiftChecksInput>
    create: XOR<LiftCreateWithoutLiftChecksInput, LiftUncheckedCreateWithoutLiftChecksInput>
    where?: LiftWhereInput
  }

  export type LiftUpdateToOneWithWhereWithoutLiftChecksInput = {
    where?: LiftWhereInput
    data: XOR<LiftUpdateWithoutLiftChecksInput, LiftUncheckedUpdateWithoutLiftChecksInput>
  }

  export type LiftUpdateWithoutLiftChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountain?: MountainUpdateOneRequiredWithoutLiftsNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutLiftNestedInput
  }

  export type LiftUncheckedUpdateWithoutLiftChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountainId?: StringFieldUpdateOperationsInput | string
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutLiftNestedInput
  }

  export type EmployeeCreateWithoutTrailChecksInput = {
    id?: string
    name: string
    role: string
    department: $Enums.Department
    mountain: MountainCreateNestedOneWithoutEmployeesInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutEmployeeInput
    logs?: IncidentLogCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckCreateNestedManyWithoutEmployeeInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutTrailChecksInput = {
    id?: string
    name: string
    role: string
    department: $Enums.Department
    mountainId: string
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    logs?: IncidentLogUncheckedCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutEmployeeInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutTrailChecksInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutTrailChecksInput, EmployeeUncheckedCreateWithoutTrailChecksInput>
  }

  export type MountainCreateWithoutTrailChecksInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    employees?: EmployeeCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentCreateNestedManyWithoutMountainInput
    weather?: WeatherCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutTrailChecksInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutMountainInput
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutTrailChecksInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutTrailChecksInput, MountainUncheckedCreateWithoutTrailChecksInput>
  }

  export type TrailCreateWithoutTrailChecksInput = {
    id?: string
    name: string
    status?: $Enums.Status
    difficulty: $Enums.TrailDifficulty
    length: number
    condition?: $Enums.TrailCondition
    mountain: MountainCreateNestedOneWithoutTrailsInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutTrailInput
  }

  export type TrailUncheckedCreateWithoutTrailChecksInput = {
    id?: string
    name: string
    status?: $Enums.Status
    difficulty: $Enums.TrailDifficulty
    length: number
    condition?: $Enums.TrailCondition
    mountainId: string
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutTrailInput
  }

  export type TrailCreateOrConnectWithoutTrailChecksInput = {
    where: TrailWhereUniqueInput
    create: XOR<TrailCreateWithoutTrailChecksInput, TrailUncheckedCreateWithoutTrailChecksInput>
  }

  export type EmployeeUpsertWithoutTrailChecksInput = {
    update: XOR<EmployeeUpdateWithoutTrailChecksInput, EmployeeUncheckedUpdateWithoutTrailChecksInput>
    create: XOR<EmployeeCreateWithoutTrailChecksInput, EmployeeUncheckedCreateWithoutTrailChecksInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutTrailChecksInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutTrailChecksInput, EmployeeUncheckedUpdateWithoutTrailChecksInput>
  }

  export type EmployeeUpdateWithoutTrailChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: EnumDepartmentFieldUpdateOperationsInput | $Enums.Department
    mountain?: MountainUpdateOneRequiredWithoutEmployeesNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutEmployeeNestedInput
    logs?: IncidentLogUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUpdateManyWithoutEmployeeNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutTrailChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: EnumDepartmentFieldUpdateOperationsInput | $Enums.Department
    mountainId?: StringFieldUpdateOperationsInput | string
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    logs?: IncidentLogUncheckedUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type MountainUpsertWithoutTrailChecksInput = {
    update: XOR<MountainUpdateWithoutTrailChecksInput, MountainUncheckedUpdateWithoutTrailChecksInput>
    create: XOR<MountainCreateWithoutTrailChecksInput, MountainUncheckedCreateWithoutTrailChecksInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutTrailChecksInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutTrailChecksInput, MountainUncheckedUpdateWithoutTrailChecksInput>
  }

  export type MountainUpdateWithoutTrailChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUpdateManyWithoutMountainNestedInput
    weather?: WeatherUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutTrailChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedUpdateManyWithoutMountainNestedInput
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type TrailUpsertWithoutTrailChecksInput = {
    update: XOR<TrailUpdateWithoutTrailChecksInput, TrailUncheckedUpdateWithoutTrailChecksInput>
    create: XOR<TrailCreateWithoutTrailChecksInput, TrailUncheckedCreateWithoutTrailChecksInput>
    where?: TrailWhereInput
  }

  export type TrailUpdateToOneWithWhereWithoutTrailChecksInput = {
    where?: TrailWhereInput
    data: XOR<TrailUpdateWithoutTrailChecksInput, TrailUncheckedUpdateWithoutTrailChecksInput>
  }

  export type TrailUpdateWithoutTrailChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    difficulty?: EnumTrailDifficultyFieldUpdateOperationsInput | $Enums.TrailDifficulty
    length?: FloatFieldUpdateOperationsInput | number
    condition?: EnumTrailConditionFieldUpdateOperationsInput | $Enums.TrailCondition
    mountain?: MountainUpdateOneRequiredWithoutTrailsNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutTrailNestedInput
  }

  export type TrailUncheckedUpdateWithoutTrailChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    difficulty?: EnumTrailDifficultyFieldUpdateOperationsInput | $Enums.TrailDifficulty
    length?: FloatFieldUpdateOperationsInput | number
    condition?: EnumTrailConditionFieldUpdateOperationsInput | $Enums.TrailCondition
    mountainId?: StringFieldUpdateOperationsInput | string
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutTrailNestedInput
  }

  export type EmployeeCreateWithoutHutChecksInput = {
    id?: string
    name: string
    role: string
    department: $Enums.Department
    mountain: MountainCreateNestedOneWithoutEmployeesInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutEmployeeInput
    logs?: IncidentLogCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckCreateNestedManyWithoutEmployeeInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutHutChecksInput = {
    id?: string
    name: string
    role: string
    department: $Enums.Department
    mountainId: string
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    logs?: IncidentLogUncheckedCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutEmployeeInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutHutChecksInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutHutChecksInput, EmployeeUncheckedCreateWithoutHutChecksInput>
  }

  export type MountainCreateWithoutHutChecksInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    employees?: EmployeeCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentCreateNestedManyWithoutMountainInput
    weather?: WeatherCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutHutChecksInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutMountainInput
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutHutChecksInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutHutChecksInput, MountainUncheckedCreateWithoutHutChecksInput>
  }

  export type HutCreateWithoutHutChecksInput = {
    id?: string
    name: string
    status?: $Enums.Status
    mountain: MountainCreateNestedOneWithoutHutsInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutHutInput
  }

  export type HutUncheckedCreateWithoutHutChecksInput = {
    id?: string
    name: string
    status?: $Enums.Status
    mountainId: string
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutHutInput
  }

  export type HutCreateOrConnectWithoutHutChecksInput = {
    where: HutWhereUniqueInput
    create: XOR<HutCreateWithoutHutChecksInput, HutUncheckedCreateWithoutHutChecksInput>
  }

  export type EmployeeUpsertWithoutHutChecksInput = {
    update: XOR<EmployeeUpdateWithoutHutChecksInput, EmployeeUncheckedUpdateWithoutHutChecksInput>
    create: XOR<EmployeeCreateWithoutHutChecksInput, EmployeeUncheckedCreateWithoutHutChecksInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutHutChecksInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutHutChecksInput, EmployeeUncheckedUpdateWithoutHutChecksInput>
  }

  export type EmployeeUpdateWithoutHutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: EnumDepartmentFieldUpdateOperationsInput | $Enums.Department
    mountain?: MountainUpdateOneRequiredWithoutEmployeesNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutEmployeeNestedInput
    logs?: IncidentLogUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutEmployeeNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutHutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: EnumDepartmentFieldUpdateOperationsInput | $Enums.Department
    mountainId?: StringFieldUpdateOperationsInput | string
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    logs?: IncidentLogUncheckedUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type MountainUpsertWithoutHutChecksInput = {
    update: XOR<MountainUpdateWithoutHutChecksInput, MountainUncheckedUpdateWithoutHutChecksInput>
    create: XOR<MountainCreateWithoutHutChecksInput, MountainUncheckedCreateWithoutHutChecksInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutHutChecksInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutHutChecksInput, MountainUncheckedUpdateWithoutHutChecksInput>
  }

  export type MountainUpdateWithoutHutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUpdateManyWithoutMountainNestedInput
    weather?: WeatherUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutHutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedUpdateManyWithoutMountainNestedInput
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type HutUpsertWithoutHutChecksInput = {
    update: XOR<HutUpdateWithoutHutChecksInput, HutUncheckedUpdateWithoutHutChecksInput>
    create: XOR<HutCreateWithoutHutChecksInput, HutUncheckedCreateWithoutHutChecksInput>
    where?: HutWhereInput
  }

  export type HutUpdateToOneWithWhereWithoutHutChecksInput = {
    where?: HutWhereInput
    data: XOR<HutUpdateWithoutHutChecksInput, HutUncheckedUpdateWithoutHutChecksInput>
  }

  export type HutUpdateWithoutHutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountain?: MountainUpdateOneRequiredWithoutHutsNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutHutNestedInput
  }

  export type HutUncheckedUpdateWithoutHutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountainId?: StringFieldUpdateOperationsInput | string
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutHutNestedInput
  }

  export type EmployeeCreateWithoutAidRoomChecksInput = {
    id?: string
    name: string
    role: string
    department: $Enums.Department
    mountain: MountainCreateNestedOneWithoutEmployeesInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutEmployeeInput
    logs?: IncidentLogCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAidRoomChecksInput = {
    id?: string
    name: string
    role: string
    department: $Enums.Department
    mountainId: string
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    logs?: IncidentLogUncheckedCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutEmployeeInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAidRoomChecksInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAidRoomChecksInput, EmployeeUncheckedCreateWithoutAidRoomChecksInput>
  }

  export type MountainCreateWithoutAidRoomChecksInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    employees?: EmployeeCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentCreateNestedManyWithoutMountainInput
    weather?: WeatherCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutAidRoomChecksInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    equipmentChecks?: EquipmentCheckUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutMountainInput
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutAidRoomChecksInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutAidRoomChecksInput, MountainUncheckedCreateWithoutAidRoomChecksInput>
  }

  export type AidRoomCreateWithoutAidRoomChecksInput = {
    id?: string
    name: string
    location: string
    status?: $Enums.Status
    mountain: MountainCreateNestedOneWithoutAidRoomsInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutAidRoomInput
  }

  export type AidRoomUncheckedCreateWithoutAidRoomChecksInput = {
    id?: string
    name: string
    location: string
    status?: $Enums.Status
    mountainId: string
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutAidRoomInput
  }

  export type AidRoomCreateOrConnectWithoutAidRoomChecksInput = {
    where: AidRoomWhereUniqueInput
    create: XOR<AidRoomCreateWithoutAidRoomChecksInput, AidRoomUncheckedCreateWithoutAidRoomChecksInput>
  }

  export type EmployeeUpsertWithoutAidRoomChecksInput = {
    update: XOR<EmployeeUpdateWithoutAidRoomChecksInput, EmployeeUncheckedUpdateWithoutAidRoomChecksInput>
    create: XOR<EmployeeCreateWithoutAidRoomChecksInput, EmployeeUncheckedCreateWithoutAidRoomChecksInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAidRoomChecksInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAidRoomChecksInput, EmployeeUncheckedUpdateWithoutAidRoomChecksInput>
  }

  export type EmployeeUpdateWithoutAidRoomChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: EnumDepartmentFieldUpdateOperationsInput | $Enums.Department
    mountain?: MountainUpdateOneRequiredWithoutEmployeesNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutEmployeeNestedInput
    logs?: IncidentLogUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAidRoomChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: EnumDepartmentFieldUpdateOperationsInput | $Enums.Department
    mountainId?: StringFieldUpdateOperationsInput | string
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    logs?: IncidentLogUncheckedUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type MountainUpsertWithoutAidRoomChecksInput = {
    update: XOR<MountainUpdateWithoutAidRoomChecksInput, MountainUncheckedUpdateWithoutAidRoomChecksInput>
    create: XOR<MountainCreateWithoutAidRoomChecksInput, MountainUncheckedCreateWithoutAidRoomChecksInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutAidRoomChecksInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutAidRoomChecksInput, MountainUncheckedUpdateWithoutAidRoomChecksInput>
  }

  export type MountainUpdateWithoutAidRoomChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUpdateManyWithoutMountainNestedInput
    weather?: WeatherUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutAidRoomChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedUpdateManyWithoutMountainNestedInput
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type AidRoomUpsertWithoutAidRoomChecksInput = {
    update: XOR<AidRoomUpdateWithoutAidRoomChecksInput, AidRoomUncheckedUpdateWithoutAidRoomChecksInput>
    create: XOR<AidRoomCreateWithoutAidRoomChecksInput, AidRoomUncheckedCreateWithoutAidRoomChecksInput>
    where?: AidRoomWhereInput
  }

  export type AidRoomUpdateToOneWithWhereWithoutAidRoomChecksInput = {
    where?: AidRoomWhereInput
    data: XOR<AidRoomUpdateWithoutAidRoomChecksInput, AidRoomUncheckedUpdateWithoutAidRoomChecksInput>
  }

  export type AidRoomUpdateWithoutAidRoomChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountain?: MountainUpdateOneRequiredWithoutAidRoomsNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutAidRoomNestedInput
  }

  export type AidRoomUncheckedUpdateWithoutAidRoomChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    mountainId?: StringFieldUpdateOperationsInput | string
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutAidRoomNestedInput
  }

  export type EmployeeCreateWithoutEquipmentChecksInput = {
    id?: string
    name: string
    role: string
    department: $Enums.Department
    mountain: MountainCreateNestedOneWithoutEmployeesInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutEmployeeInput
    logs?: IncidentLogCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckCreateNestedManyWithoutEmployeeInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutEquipmentChecksInput = {
    id?: string
    name: string
    role: string
    department: $Enums.Department
    mountainId: string
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    logs?: IncidentLogUncheckedCreateNestedManyWithoutEmployeeInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutEmployeeInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutEmployeeInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutEmployeeInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutEquipmentChecksInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutEquipmentChecksInput, EmployeeUncheckedCreateWithoutEquipmentChecksInput>
  }

  export type MountainCreateWithoutEquipmentChecksInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckCreateNestedManyWithoutMountainInput
    trails?: TrailCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckCreateNestedManyWithoutMountainInput
    employees?: EmployeeCreateNestedManyWithoutMountainInput
    lodges?: LodgeCreateNestedManyWithoutMountainInput
    huts?: HutCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckCreateNestedManyWithoutMountainInput
    equipment?: EquipmentCreateNestedManyWithoutMountainInput
    incidents?: IncidentCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentCreateNestedManyWithoutMountainInput
    weather?: WeatherCreateNestedManyWithoutMountainInput
  }

  export type MountainUncheckedCreateWithoutEquipmentChecksInput = {
    id?: string
    name: string
    latitude: number
    longitude: number
    height: number
    hours: string
    phoneNumber: string
    address: string
    city: string
    state: string
    zipcode: string
    openingDate?: Date | string | null
    closingDate?: Date | string | null
    lifts?: LiftUncheckedCreateNestedManyWithoutMountainInput
    liftChecks?: LiftCheckUncheckedCreateNestedManyWithoutMountainInput
    trails?: TrailUncheckedCreateNestedManyWithoutMountainInput
    trailChecks?: TrailCheckUncheckedCreateNestedManyWithoutMountainInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutMountainInput
    lodges?: LodgeUncheckedCreateNestedManyWithoutMountainInput
    huts?: HutUncheckedCreateNestedManyWithoutMountainInput
    hutChecks?: HutCheckUncheckedCreateNestedManyWithoutMountainInput
    aidRooms?: AidRoomUncheckedCreateNestedManyWithoutMountainInput
    aidRoomChecks?: AidRoomCheckUncheckedCreateNestedManyWithoutMountainInput
    equipment?: EquipmentUncheckedCreateNestedManyWithoutMountainInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogs?: IncidentLogUncheckedCreateNestedManyWithoutMountainInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedCreateNestedManyWithoutMountainInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutMountainInput
    weather?: WeatherUncheckedCreateNestedManyWithoutMountainInput
  }

  export type MountainCreateOrConnectWithoutEquipmentChecksInput = {
    where: MountainWhereUniqueInput
    create: XOR<MountainCreateWithoutEquipmentChecksInput, MountainUncheckedCreateWithoutEquipmentChecksInput>
  }

  export type EquipmentCreateWithoutEquipmentChecksInput = {
    id?: string
    name: string
    type: string
    status: $Enums.EquipmentStatus
    service: $Enums.EquipmentService
    mountain: MountainCreateNestedOneWithoutEquipmentInput
    usedInLogs?: IncidentLogEquipmentCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutEquipmentChecksInput = {
    id?: string
    name: string
    type: string
    status: $Enums.EquipmentStatus
    service: $Enums.EquipmentService
    mountainId: string
    usedInLogs?: IncidentLogEquipmentUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutEquipmentChecksInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutEquipmentChecksInput, EquipmentUncheckedCreateWithoutEquipmentChecksInput>
  }

  export type EmployeeUpsertWithoutEquipmentChecksInput = {
    update: XOR<EmployeeUpdateWithoutEquipmentChecksInput, EmployeeUncheckedUpdateWithoutEquipmentChecksInput>
    create: XOR<EmployeeCreateWithoutEquipmentChecksInput, EmployeeUncheckedCreateWithoutEquipmentChecksInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutEquipmentChecksInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutEquipmentChecksInput, EmployeeUncheckedUpdateWithoutEquipmentChecksInput>
  }

  export type EmployeeUpdateWithoutEquipmentChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: EnumDepartmentFieldUpdateOperationsInput | $Enums.Department
    mountain?: MountainUpdateOneRequiredWithoutEmployeesNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutEmployeeNestedInput
    logs?: IncidentLogUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUpdateManyWithoutEmployeeNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutEquipmentChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: EnumDepartmentFieldUpdateOperationsInput | $Enums.Department
    mountainId?: StringFieldUpdateOperationsInput | string
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    logs?: IncidentLogUncheckedUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type MountainUpsertWithoutEquipmentChecksInput = {
    update: XOR<MountainUpdateWithoutEquipmentChecksInput, MountainUncheckedUpdateWithoutEquipmentChecksInput>
    create: XOR<MountainCreateWithoutEquipmentChecksInput, MountainUncheckedCreateWithoutEquipmentChecksInput>
    where?: MountainWhereInput
  }

  export type MountainUpdateToOneWithWhereWithoutEquipmentChecksInput = {
    where?: MountainWhereInput
    data: XOR<MountainUpdateWithoutEquipmentChecksInput, MountainUncheckedUpdateWithoutEquipmentChecksInput>
  }

  export type MountainUpdateWithoutEquipmentChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutMountainNestedInput
    trails?: TrailUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUpdateManyWithoutMountainNestedInput
    huts?: HutUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUpdateManyWithoutMountainNestedInput
    weather?: WeatherUpdateManyWithoutMountainNestedInput
  }

  export type MountainUncheckedUpdateWithoutEquipmentChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    hours?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    openingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lifts?: LiftUncheckedUpdateManyWithoutMountainNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutMountainNestedInput
    trails?: TrailUncheckedUpdateManyWithoutMountainNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutMountainNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutMountainNestedInput
    lodges?: LodgeUncheckedUpdateManyWithoutMountainNestedInput
    huts?: HutUncheckedUpdateManyWithoutMountainNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutMountainNestedInput
    aidRooms?: AidRoomUncheckedUpdateManyWithoutMountainNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutMountainNestedInput
    equipment?: EquipmentUncheckedUpdateManyWithoutMountainNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutMountainNestedInput
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutMountainNestedInput
    incidentLogEquipment?: IncidentLogEquipmentUncheckedUpdateManyWithoutMountainNestedInput
    weather?: WeatherUncheckedUpdateManyWithoutMountainNestedInput
  }

  export type EquipmentUpsertWithoutEquipmentChecksInput = {
    update: XOR<EquipmentUpdateWithoutEquipmentChecksInput, EquipmentUncheckedUpdateWithoutEquipmentChecksInput>
    create: XOR<EquipmentCreateWithoutEquipmentChecksInput, EquipmentUncheckedCreateWithoutEquipmentChecksInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutEquipmentChecksInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutEquipmentChecksInput, EquipmentUncheckedUpdateWithoutEquipmentChecksInput>
  }

  export type EquipmentUpdateWithoutEquipmentChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    service?: EnumEquipmentServiceFieldUpdateOperationsInput | $Enums.EquipmentService
    mountain?: MountainUpdateOneRequiredWithoutEquipmentNestedInput
    usedInLogs?: IncidentLogEquipmentUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutEquipmentChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    service?: EnumEquipmentServiceFieldUpdateOperationsInput | $Enums.EquipmentService
    mountainId?: StringFieldUpdateOperationsInput | string
    usedInLogs?: IncidentLogEquipmentUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type LiftCreateManyMountainInput = {
    id?: string
    name: string
    capacity: number
    status?: $Enums.Status
  }

  export type LiftCheckCreateManyMountainInput = {
    id?: string
    date?: Date | string
    employeeId: string
    liftId: string
    notes?: string | null
  }

  export type TrailCreateManyMountainInput = {
    id?: string
    name: string
    status?: $Enums.Status
    difficulty: $Enums.TrailDifficulty
    length: number
    condition?: $Enums.TrailCondition
  }

  export type TrailCheckCreateManyMountainInput = {
    id?: string
    date?: Date | string
    employeeId: string
    trailId: string
    notes?: string | null
  }

  export type EmployeeCreateManyMountainInput = {
    id?: string
    name: string
    role: string
    department: $Enums.Department
  }

  export type LodgeCreateManyMountainInput = {
    id?: string
    name: string
    capacity: number
    status?: $Enums.Status
  }

  export type HutCreateManyMountainInput = {
    id?: string
    name: string
    status?: $Enums.Status
  }

  export type HutCheckCreateManyMountainInput = {
    id?: string
    date?: Date | string
    employeeId: string
    hutId: string
    notes?: string | null
  }

  export type AidRoomCreateManyMountainInput = {
    id?: string
    name: string
    location: string
    status?: $Enums.Status
  }

  export type AidRoomCheckCreateManyMountainInput = {
    id?: string
    date?: Date | string
    employeeId: string
    aidRoomId: string
    notes?: string | null
  }

  export type EquipmentCreateManyMountainInput = {
    id?: string
    name: string
    type: string
    status: $Enums.EquipmentStatus
    service: $Enums.EquipmentService
  }

  export type EquipmentCheckCreateManyMountainInput = {
    id?: string
    date?: Date | string
    employeeId: string
    equipmentId: string
    notes?: string | null
  }

  export type IncidentCreateManyMountainInput = {
    id?: string
    description: string
    status?: $Enums.Status
  }

  export type IncidentLogCreateManyMountainInput = {
    id?: string
    incidentId: string
    employeeId: string
    locationType: $Enums.LocationType
    locationId: string
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
  }

  export type DispatcherAssignmentCreateManyMountainInput = {
    id?: string
    employeeId: string
    assignedAt?: Date | string
  }

  export type IncidentLogEquipmentCreateManyMountainInput = {
    id?: string
    incidentLogId: string
    equipmentId: string
    usedAt?: Date | string
    notes?: string | null
  }

  export type WeatherCreateManyMountainInput = {
    id?: string
    date?: Date | string
    temperature: number
    windSpeed: number
    windDirection?: string | null
    visibility?: number | null
    conditions: string
    snowfall24h?: number | null
    snowfall7d?: number | null
    updatedAt?: Date | string
  }

  export type LiftUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    incidentLogs?: IncidentLogUpdateManyWithoutLiftNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutLiftNestedInput
  }

  export type LiftUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutLiftNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutLiftNestedInput
  }

  export type LiftUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
  }

  export type LiftCheckUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutLiftChecksNestedInput
    lift?: LiftUpdateOneRequiredWithoutLiftChecksNestedInput
  }

  export type LiftCheckUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    liftId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LiftCheckUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    liftId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrailUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    difficulty?: EnumTrailDifficultyFieldUpdateOperationsInput | $Enums.TrailDifficulty
    length?: FloatFieldUpdateOperationsInput | number
    condition?: EnumTrailConditionFieldUpdateOperationsInput | $Enums.TrailCondition
    incidentLogs?: IncidentLogUpdateManyWithoutTrailNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutTrailNestedInput
  }

  export type TrailUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    difficulty?: EnumTrailDifficultyFieldUpdateOperationsInput | $Enums.TrailDifficulty
    length?: FloatFieldUpdateOperationsInput | number
    condition?: EnumTrailConditionFieldUpdateOperationsInput | $Enums.TrailCondition
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutTrailNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutTrailNestedInput
  }

  export type TrailUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    difficulty?: EnumTrailDifficultyFieldUpdateOperationsInput | $Enums.TrailDifficulty
    length?: FloatFieldUpdateOperationsInput | number
    condition?: EnumTrailConditionFieldUpdateOperationsInput | $Enums.TrailCondition
  }

  export type TrailCheckUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutTrailChecksNestedInput
    trail?: TrailUpdateOneRequiredWithoutTrailChecksNestedInput
  }

  export type TrailCheckUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    trailId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrailCheckUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    trailId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: EnumDepartmentFieldUpdateOperationsInput | $Enums.Department
    dispatcherAssignments?: DispatcherAssignmentUpdateManyWithoutEmployeeNestedInput
    logs?: IncidentLogUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUpdateManyWithoutEmployeeNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: EnumDepartmentFieldUpdateOperationsInput | $Enums.Department
    dispatcherAssignments?: DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    logs?: IncidentLogUncheckedUpdateManyWithoutEmployeeNestedInput
    liftChecks?: LiftCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    trailChecks?: TrailCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutEmployeeNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: EnumDepartmentFieldUpdateOperationsInput | $Enums.Department
  }

  export type LodgeUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    incidentLogs?: IncidentLogUpdateManyWithoutLodgeNestedInput
  }

  export type LodgeUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutLodgeNestedInput
  }

  export type LodgeUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
  }

  export type HutUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    incidentLogs?: IncidentLogUpdateManyWithoutHutNestedInput
    hutChecks?: HutCheckUpdateManyWithoutHutNestedInput
  }

  export type HutUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutHutNestedInput
    hutChecks?: HutCheckUncheckedUpdateManyWithoutHutNestedInput
  }

  export type HutUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
  }

  export type HutCheckUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutHutChecksNestedInput
    hut?: HutUpdateOneRequiredWithoutHutChecksNestedInput
  }

  export type HutCheckUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    hutId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HutCheckUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    hutId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AidRoomUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    incidentLogs?: IncidentLogUpdateManyWithoutAidRoomNestedInput
    aidRoomChecks?: AidRoomCheckUpdateManyWithoutAidRoomNestedInput
  }

  export type AidRoomUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    incidentLogs?: IncidentLogUncheckedUpdateManyWithoutAidRoomNestedInput
    aidRoomChecks?: AidRoomCheckUncheckedUpdateManyWithoutAidRoomNestedInput
  }

  export type AidRoomUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
  }

  export type AidRoomCheckUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutAidRoomChecksNestedInput
    aidRoom?: AidRoomUpdateOneRequiredWithoutAidRoomChecksNestedInput
  }

  export type AidRoomCheckUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aidRoomId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AidRoomCheckUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    aidRoomId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipmentUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    service?: EnumEquipmentServiceFieldUpdateOperationsInput | $Enums.EquipmentService
    usedInLogs?: IncidentLogEquipmentUpdateManyWithoutEquipmentNestedInput
    equipmentChecks?: EquipmentCheckUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    service?: EnumEquipmentServiceFieldUpdateOperationsInput | $Enums.EquipmentService
    usedInLogs?: IncidentLogEquipmentUncheckedUpdateManyWithoutEquipmentNestedInput
    equipmentChecks?: EquipmentCheckUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    service?: EnumEquipmentServiceFieldUpdateOperationsInput | $Enums.EquipmentService
  }

  export type EquipmentCheckUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutEquipmentChecksNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutEquipmentChecksNestedInput
  }

  export type EquipmentCheckUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipmentCheckUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IncidentUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    logs?: IncidentLogUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    logs?: IncidentLogUncheckedUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
  }

  export type IncidentLogUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incident?: IncidentUpdateOneRequiredWithoutLogsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutLogsNestedInput
    equipmentUsed?: IncidentLogEquipmentUpdateManyWithoutIncidentLogNestedInput
    lift?: LiftUpdateOneWithoutIncidentLogsNestedInput
    trail?: TrailUpdateOneWithoutIncidentLogsNestedInput
    lodge?: LodgeUpdateOneWithoutIncidentLogsNestedInput
    hut?: HutUpdateOneWithoutIncidentLogsNestedInput
    aidRoom?: AidRoomUpdateOneWithoutIncidentLogsNestedInput
  }

  export type IncidentLogUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationId?: StringFieldUpdateOperationsInput | string
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipmentUsed?: IncidentLogEquipmentUncheckedUpdateManyWithoutIncidentLogNestedInput
  }

  export type IncidentLogUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationId?: StringFieldUpdateOperationsInput | string
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DispatcherAssignmentUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutDispatcherAssignmentsNestedInput
  }

  export type DispatcherAssignmentUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatcherAssignmentUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentLogEquipmentUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    incidentLog?: IncidentLogUpdateOneRequiredWithoutEquipmentUsedNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutUsedInLogsNestedInput
  }

  export type IncidentLogEquipmentUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentLogId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IncidentLogEquipmentUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentLogId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeatherUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    windSpeed?: FloatFieldUpdateOperationsInput | number
    windDirection?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: NullableFloatFieldUpdateOperationsInput | number | null
    conditions?: StringFieldUpdateOperationsInput | string
    snowfall24h?: NullableFloatFieldUpdateOperationsInput | number | null
    snowfall7d?: NullableFloatFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherUncheckedUpdateWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    windSpeed?: FloatFieldUpdateOperationsInput | number
    windDirection?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: NullableFloatFieldUpdateOperationsInput | number | null
    conditions?: StringFieldUpdateOperationsInput | string
    snowfall24h?: NullableFloatFieldUpdateOperationsInput | number | null
    snowfall7d?: NullableFloatFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherUncheckedUpdateManyWithoutMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    windSpeed?: FloatFieldUpdateOperationsInput | number
    windDirection?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: NullableFloatFieldUpdateOperationsInput | number | null
    conditions?: StringFieldUpdateOperationsInput | string
    snowfall24h?: NullableFloatFieldUpdateOperationsInput | number | null
    snowfall7d?: NullableFloatFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatcherAssignmentCreateManyEmployeeInput = {
    id?: string
    assignedAt?: Date | string
    mountainId: string
  }

  export type IncidentLogCreateManyEmployeeInput = {
    id?: string
    incidentId: string
    mountainId: string
    locationType: $Enums.LocationType
    locationId: string
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
  }

  export type LiftCheckCreateManyEmployeeInput = {
    id?: string
    date?: Date | string
    mountainId: string
    liftId: string
    notes?: string | null
  }

  export type TrailCheckCreateManyEmployeeInput = {
    id?: string
    date?: Date | string
    mountainId: string
    trailId: string
    notes?: string | null
  }

  export type HutCheckCreateManyEmployeeInput = {
    id?: string
    date?: Date | string
    mountainId: string
    hutId: string
    notes?: string | null
  }

  export type AidRoomCheckCreateManyEmployeeInput = {
    id?: string
    date?: Date | string
    mountainId: string
    aidRoomId: string
    notes?: string | null
  }

  export type EquipmentCheckCreateManyEmployeeInput = {
    id?: string
    date?: Date | string
    mountainId: string
    equipmentId: string
    notes?: string | null
  }

  export type DispatcherAssignmentUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountain?: MountainUpdateOneRequiredWithoutDispatcherAssignmentsNestedInput
  }

  export type DispatcherAssignmentUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
  }

  export type DispatcherAssignmentUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
  }

  export type IncidentLogUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incident?: IncidentUpdateOneRequiredWithoutLogsNestedInput
    mountain?: MountainUpdateOneRequiredWithoutIncidentLogsNestedInput
    equipmentUsed?: IncidentLogEquipmentUpdateManyWithoutIncidentLogNestedInput
    lift?: LiftUpdateOneWithoutIncidentLogsNestedInput
    trail?: TrailUpdateOneWithoutIncidentLogsNestedInput
    lodge?: LodgeUpdateOneWithoutIncidentLogsNestedInput
    hut?: HutUpdateOneWithoutIncidentLogsNestedInput
    aidRoom?: AidRoomUpdateOneWithoutIncidentLogsNestedInput
  }

  export type IncidentLogUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationId?: StringFieldUpdateOperationsInput | string
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipmentUsed?: IncidentLogEquipmentUncheckedUpdateManyWithoutIncidentLogNestedInput
  }

  export type IncidentLogUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationId?: StringFieldUpdateOperationsInput | string
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LiftCheckUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mountain?: MountainUpdateOneRequiredWithoutLiftChecksNestedInput
    lift?: LiftUpdateOneRequiredWithoutLiftChecksNestedInput
  }

  export type LiftCheckUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
    liftId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LiftCheckUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
    liftId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrailCheckUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mountain?: MountainUpdateOneRequiredWithoutTrailChecksNestedInput
    trail?: TrailUpdateOneRequiredWithoutTrailChecksNestedInput
  }

  export type TrailCheckUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
    trailId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrailCheckUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
    trailId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HutCheckUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mountain?: MountainUpdateOneRequiredWithoutHutChecksNestedInput
    hut?: HutUpdateOneRequiredWithoutHutChecksNestedInput
  }

  export type HutCheckUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
    hutId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HutCheckUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
    hutId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AidRoomCheckUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mountain?: MountainUpdateOneRequiredWithoutAidRoomChecksNestedInput
    aidRoom?: AidRoomUpdateOneRequiredWithoutAidRoomChecksNestedInput
  }

  export type AidRoomCheckUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
    aidRoomId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AidRoomCheckUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
    aidRoomId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipmentCheckUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mountain?: MountainUpdateOneRequiredWithoutEquipmentChecksNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutEquipmentChecksNestedInput
  }

  export type EquipmentCheckUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipmentCheckUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mountainId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IncidentLogCreateManyLiftInput = {
    id?: string
    incidentId: string
    employeeId: string
    mountainId: string
    locationType: $Enums.LocationType
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
  }

  export type LiftCheckCreateManyLiftInput = {
    id?: string
    date?: Date | string
    employeeId: string
    mountainId: string
    notes?: string | null
  }

  export type IncidentLogUpdateWithoutLiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incident?: IncidentUpdateOneRequiredWithoutLogsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutLogsNestedInput
    mountain?: MountainUpdateOneRequiredWithoutIncidentLogsNestedInput
    equipmentUsed?: IncidentLogEquipmentUpdateManyWithoutIncidentLogNestedInput
    trail?: TrailUpdateOneWithoutIncidentLogsNestedInput
    lodge?: LodgeUpdateOneWithoutIncidentLogsNestedInput
    hut?: HutUpdateOneWithoutIncidentLogsNestedInput
    aidRoom?: AidRoomUpdateOneWithoutIncidentLogsNestedInput
  }

  export type IncidentLogUncheckedUpdateWithoutLiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipmentUsed?: IncidentLogEquipmentUncheckedUpdateManyWithoutIncidentLogNestedInput
  }

  export type IncidentLogUncheckedUpdateManyWithoutLiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LiftCheckUpdateWithoutLiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutLiftChecksNestedInput
    mountain?: MountainUpdateOneRequiredWithoutLiftChecksNestedInput
  }

  export type LiftCheckUncheckedUpdateWithoutLiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LiftCheckUncheckedUpdateManyWithoutLiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IncidentLogCreateManyTrailInput = {
    id?: string
    incidentId: string
    employeeId: string
    mountainId: string
    locationType: $Enums.LocationType
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
  }

  export type TrailCheckCreateManyTrailInput = {
    id?: string
    date?: Date | string
    employeeId: string
    mountainId: string
    notes?: string | null
  }

  export type IncidentLogUpdateWithoutTrailInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incident?: IncidentUpdateOneRequiredWithoutLogsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutLogsNestedInput
    mountain?: MountainUpdateOneRequiredWithoutIncidentLogsNestedInput
    equipmentUsed?: IncidentLogEquipmentUpdateManyWithoutIncidentLogNestedInput
    lift?: LiftUpdateOneWithoutIncidentLogsNestedInput
    lodge?: LodgeUpdateOneWithoutIncidentLogsNestedInput
    hut?: HutUpdateOneWithoutIncidentLogsNestedInput
    aidRoom?: AidRoomUpdateOneWithoutIncidentLogsNestedInput
  }

  export type IncidentLogUncheckedUpdateWithoutTrailInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipmentUsed?: IncidentLogEquipmentUncheckedUpdateManyWithoutIncidentLogNestedInput
  }

  export type IncidentLogUncheckedUpdateManyWithoutTrailInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrailCheckUpdateWithoutTrailInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutTrailChecksNestedInput
    mountain?: MountainUpdateOneRequiredWithoutTrailChecksNestedInput
  }

  export type TrailCheckUncheckedUpdateWithoutTrailInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrailCheckUncheckedUpdateManyWithoutTrailInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IncidentLogCreateManyLodgeInput = {
    id?: string
    incidentId: string
    employeeId: string
    mountainId: string
    locationType: $Enums.LocationType
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
  }

  export type IncidentLogUpdateWithoutLodgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incident?: IncidentUpdateOneRequiredWithoutLogsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutLogsNestedInput
    mountain?: MountainUpdateOneRequiredWithoutIncidentLogsNestedInput
    equipmentUsed?: IncidentLogEquipmentUpdateManyWithoutIncidentLogNestedInput
    lift?: LiftUpdateOneWithoutIncidentLogsNestedInput
    trail?: TrailUpdateOneWithoutIncidentLogsNestedInput
    hut?: HutUpdateOneWithoutIncidentLogsNestedInput
    aidRoom?: AidRoomUpdateOneWithoutIncidentLogsNestedInput
  }

  export type IncidentLogUncheckedUpdateWithoutLodgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipmentUsed?: IncidentLogEquipmentUncheckedUpdateManyWithoutIncidentLogNestedInput
  }

  export type IncidentLogUncheckedUpdateManyWithoutLodgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IncidentLogCreateManyHutInput = {
    id?: string
    incidentId: string
    employeeId: string
    mountainId: string
    locationType: $Enums.LocationType
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
  }

  export type HutCheckCreateManyHutInput = {
    id?: string
    date?: Date | string
    employeeId: string
    mountainId: string
    notes?: string | null
  }

  export type IncidentLogUpdateWithoutHutInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incident?: IncidentUpdateOneRequiredWithoutLogsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutLogsNestedInput
    mountain?: MountainUpdateOneRequiredWithoutIncidentLogsNestedInput
    equipmentUsed?: IncidentLogEquipmentUpdateManyWithoutIncidentLogNestedInput
    lift?: LiftUpdateOneWithoutIncidentLogsNestedInput
    trail?: TrailUpdateOneWithoutIncidentLogsNestedInput
    lodge?: LodgeUpdateOneWithoutIncidentLogsNestedInput
    aidRoom?: AidRoomUpdateOneWithoutIncidentLogsNestedInput
  }

  export type IncidentLogUncheckedUpdateWithoutHutInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipmentUsed?: IncidentLogEquipmentUncheckedUpdateManyWithoutIncidentLogNestedInput
  }

  export type IncidentLogUncheckedUpdateManyWithoutHutInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HutCheckUpdateWithoutHutInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutHutChecksNestedInput
    mountain?: MountainUpdateOneRequiredWithoutHutChecksNestedInput
  }

  export type HutCheckUncheckedUpdateWithoutHutInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HutCheckUncheckedUpdateManyWithoutHutInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IncidentLogCreateManyAidRoomInput = {
    id?: string
    incidentId: string
    employeeId: string
    mountainId: string
    locationType: $Enums.LocationType
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
  }

  export type AidRoomCheckCreateManyAidRoomInput = {
    id?: string
    date?: Date | string
    employeeId: string
    mountainId: string
    notes?: string | null
  }

  export type IncidentLogUpdateWithoutAidRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incident?: IncidentUpdateOneRequiredWithoutLogsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutLogsNestedInput
    mountain?: MountainUpdateOneRequiredWithoutIncidentLogsNestedInput
    equipmentUsed?: IncidentLogEquipmentUpdateManyWithoutIncidentLogNestedInput
    lift?: LiftUpdateOneWithoutIncidentLogsNestedInput
    trail?: TrailUpdateOneWithoutIncidentLogsNestedInput
    lodge?: LodgeUpdateOneWithoutIncidentLogsNestedInput
    hut?: HutUpdateOneWithoutIncidentLogsNestedInput
  }

  export type IncidentLogUncheckedUpdateWithoutAidRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipmentUsed?: IncidentLogEquipmentUncheckedUpdateManyWithoutIncidentLogNestedInput
  }

  export type IncidentLogUncheckedUpdateManyWithoutAidRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AidRoomCheckUpdateWithoutAidRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutAidRoomChecksNestedInput
    mountain?: MountainUpdateOneRequiredWithoutAidRoomChecksNestedInput
  }

  export type AidRoomCheckUncheckedUpdateWithoutAidRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AidRoomCheckUncheckedUpdateManyWithoutAidRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IncidentLogEquipmentCreateManyEquipmentInput = {
    id?: string
    incidentLogId: string
    mountainId: string
    usedAt?: Date | string
    notes?: string | null
  }

  export type EquipmentCheckCreateManyEquipmentInput = {
    id?: string
    date?: Date | string
    employeeId: string
    mountainId: string
    notes?: string | null
  }

  export type IncidentLogEquipmentUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mountain?: MountainUpdateOneRequiredWithoutIncidentLogEquipmentNestedInput
    incidentLog?: IncidentLogUpdateOneRequiredWithoutEquipmentUsedNestedInput
  }

  export type IncidentLogEquipmentUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentLogId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IncidentLogEquipmentUncheckedUpdateManyWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentLogId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipmentCheckUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutEquipmentChecksNestedInput
    mountain?: MountainUpdateOneRequiredWithoutEquipmentChecksNestedInput
  }

  export type EquipmentCheckUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipmentCheckUncheckedUpdateManyWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IncidentLogCreateManyIncidentInput = {
    id?: string
    employeeId: string
    mountainId: string
    locationType: $Enums.LocationType
    locationId: string
    locationStatus: string
    startTime: Date | string
    endTime: Date | string
    onSceneTime?: Date | string | null
    stableTime?: Date | string | null
    transportTime?: Date | string | null
    dryRun?: boolean
    dryRunTime?: Date | string | null
  }

  export type IncidentLogUpdateWithoutIncidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutLogsNestedInput
    mountain?: MountainUpdateOneRequiredWithoutIncidentLogsNestedInput
    equipmentUsed?: IncidentLogEquipmentUpdateManyWithoutIncidentLogNestedInput
    lift?: LiftUpdateOneWithoutIncidentLogsNestedInput
    trail?: TrailUpdateOneWithoutIncidentLogsNestedInput
    lodge?: LodgeUpdateOneWithoutIncidentLogsNestedInput
    hut?: HutUpdateOneWithoutIncidentLogsNestedInput
    aidRoom?: AidRoomUpdateOneWithoutIncidentLogsNestedInput
  }

  export type IncidentLogUncheckedUpdateWithoutIncidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationId?: StringFieldUpdateOperationsInput | string
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipmentUsed?: IncidentLogEquipmentUncheckedUpdateManyWithoutIncidentLogNestedInput
  }

  export type IncidentLogUncheckedUpdateManyWithoutIncidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    locationType?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    locationId?: StringFieldUpdateOperationsInput | string
    locationStatus?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    onSceneTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transportTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dryRun?: BoolFieldUpdateOperationsInput | boolean
    dryRunTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IncidentLogEquipmentCreateManyIncidentLogInput = {
    id?: string
    equipmentId: string
    mountainId: string
    usedAt?: Date | string
    notes?: string | null
  }

  export type IncidentLogEquipmentUpdateWithoutIncidentLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mountain?: MountainUpdateOneRequiredWithoutIncidentLogEquipmentNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutUsedInLogsNestedInput
  }

  export type IncidentLogEquipmentUncheckedUpdateWithoutIncidentLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IncidentLogEquipmentUncheckedUpdateManyWithoutIncidentLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    mountainId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}